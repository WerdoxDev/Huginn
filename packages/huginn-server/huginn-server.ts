// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = import.meta.require;

// ../../node_modules/consola/dist/chunks/prompt.mjs
var exports_prompt = {};
__export(exports_prompt, {
  prompt: () => prompt,
  kCancel: () => kCancel
});
import p, { stdin, stdout } from "process";
import f from "readline";
import { WriteStream } from "tty";
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function requireSrc() {
  if (hasRequiredSrc)
    return src;
  hasRequiredSrc = 1;
  const ESC = "\x1B";
  const CSI = `${ESC}[`;
  const beep = "\x07";
  const cursor = {
    to(x, y) {
      if (!y)
        return `${CSI}${x + 1}G`;
      return `${CSI}${y + 1};${x + 1}H`;
    },
    move(x, y) {
      let ret = "";
      if (x < 0)
        ret += `${CSI}${-x}D`;
      else if (x > 0)
        ret += `${CSI}${x}C`;
      if (y < 0)
        ret += `${CSI}${-y}A`;
      else if (y > 0)
        ret += `${CSI}${y}B`;
      return ret;
    },
    up: (count = 1) => `${CSI}${count}A`,
    down: (count = 1) => `${CSI}${count}B`,
    forward: (count = 1) => `${CSI}${count}C`,
    backward: (count = 1) => `${CSI}${count}D`,
    nextLine: (count = 1) => `${CSI}E`.repeat(count),
    prevLine: (count = 1) => `${CSI}F`.repeat(count),
    left: `${CSI}G`,
    hide: `${CSI}?25l`,
    show: `${CSI}?25h`,
    save: `${ESC}7`,
    restore: `${ESC}8`
  };
  const scroll = {
    up: (count = 1) => `${CSI}S`.repeat(count),
    down: (count = 1) => `${CSI}T`.repeat(count)
  };
  const erase = {
    screen: `${CSI}2J`,
    up: (count = 1) => `${CSI}1J`.repeat(count),
    down: (count = 1) => `${CSI}J`.repeat(count),
    line: `${CSI}2K`,
    lineEnd: `${CSI}K`,
    lineStart: `${CSI}1K`,
    lines(count) {
      let clear = "";
      for (let i = 0;i < count; i++)
        clear += this.line + (i < count - 1 ? cursor.up() : "");
      if (count)
        clear += cursor.left;
      return clear;
    }
  };
  src = { cursor, scroll, erase, beep };
  return src;
}
function requirePicocolors() {
  if (hasRequiredPicocolors)
    return picocolors.exports;
  hasRequiredPicocolors = 1;
  let p2 = process || {}, argv2 = p2.argv || [], env2 = p2.env || {};
  let isColorSupported2 = !(!!env2.NO_COLOR || argv2.includes("--no-color")) && (!!env2.FORCE_COLOR || argv2.includes("--color") || p2.platform === "win32" || (p2.stdout || {}).isTTY && env2.TERM !== "dumb" || !!env2.CI);
  let formatter = (open, close, replace = open) => (input) => {
    let string = "" + input, index = string.indexOf(close, open.length);
    return ~index ? open + replaceClose2(string, close, replace, index) + close : open + string + close;
  };
  let replaceClose2 = (string, close, replace, index) => {
    let result = "", cursor = 0;
    do {
      result += string.substring(cursor, index) + replace;
      cursor = index + close.length;
      index = string.indexOf(close, cursor);
    } while (~index);
    return result + string.substring(cursor);
  };
  let createColors2 = (enabled = isColorSupported2) => {
    let f2 = enabled ? formatter : () => String;
    return {
      isColorSupported: enabled,
      reset: f2("\x1B[0m", "\x1B[0m"),
      bold: f2("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
      dim: f2("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
      italic: f2("\x1B[3m", "\x1B[23m"),
      underline: f2("\x1B[4m", "\x1B[24m"),
      inverse: f2("\x1B[7m", "\x1B[27m"),
      hidden: f2("\x1B[8m", "\x1B[28m"),
      strikethrough: f2("\x1B[9m", "\x1B[29m"),
      black: f2("\x1B[30m", "\x1B[39m"),
      red: f2("\x1B[31m", "\x1B[39m"),
      green: f2("\x1B[32m", "\x1B[39m"),
      yellow: f2("\x1B[33m", "\x1B[39m"),
      blue: f2("\x1B[34m", "\x1B[39m"),
      magenta: f2("\x1B[35m", "\x1B[39m"),
      cyan: f2("\x1B[36m", "\x1B[39m"),
      white: f2("\x1B[37m", "\x1B[39m"),
      gray: f2("\x1B[90m", "\x1B[39m"),
      bgBlack: f2("\x1B[40m", "\x1B[49m"),
      bgRed: f2("\x1B[41m", "\x1B[49m"),
      bgGreen: f2("\x1B[42m", "\x1B[49m"),
      bgYellow: f2("\x1B[43m", "\x1B[49m"),
      bgBlue: f2("\x1B[44m", "\x1B[49m"),
      bgMagenta: f2("\x1B[45m", "\x1B[49m"),
      bgCyan: f2("\x1B[46m", "\x1B[49m"),
      bgWhite: f2("\x1B[47m", "\x1B[49m"),
      blackBright: f2("\x1B[90m", "\x1B[39m"),
      redBright: f2("\x1B[91m", "\x1B[39m"),
      greenBright: f2("\x1B[92m", "\x1B[39m"),
      yellowBright: f2("\x1B[93m", "\x1B[39m"),
      blueBright: f2("\x1B[94m", "\x1B[39m"),
      magentaBright: f2("\x1B[95m", "\x1B[39m"),
      cyanBright: f2("\x1B[96m", "\x1B[39m"),
      whiteBright: f2("\x1B[97m", "\x1B[39m"),
      bgBlackBright: f2("\x1B[100m", "\x1B[49m"),
      bgRedBright: f2("\x1B[101m", "\x1B[49m"),
      bgGreenBright: f2("\x1B[102m", "\x1B[49m"),
      bgYellowBright: f2("\x1B[103m", "\x1B[49m"),
      bgBlueBright: f2("\x1B[104m", "\x1B[49m"),
      bgMagentaBright: f2("\x1B[105m", "\x1B[49m"),
      bgCyanBright: f2("\x1B[106m", "\x1B[49m"),
      bgWhiteBright: f2("\x1B[107m", "\x1B[49m")
    };
  };
  picocolors.exports = createColors2();
  picocolors.exports.createColors = createColors2;
  return picocolors.exports;
}
function J({ onlyFirst: t = false } = {}) {
  const F = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|");
  return new RegExp(F, t ? undefined : "g");
}
function T(t) {
  if (typeof t != "string")
    throw new TypeError(`Expected a \`string\`, got \`${typeof t}\``);
  return t.replace(Q, "");
}
function O(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function A$1(t, u = {}) {
  if (typeof t != "string" || t.length === 0 || (u = { ambiguousIsNarrow: true, ...u }, t = T(t), t.length === 0))
    return 0;
  t = t.replace(FD(), "  ");
  const F = u.ambiguousIsNarrow ? 1 : 2;
  let e2 = 0;
  for (const s of t) {
    const i = s.codePointAt(0);
    if (i <= 31 || i >= 127 && i <= 159 || i >= 768 && i <= 879)
      continue;
    switch (DD.eastAsianWidth(s)) {
      case "F":
      case "W":
        e2 += 2;
        break;
      case "A":
        e2 += F;
        break;
      default:
        e2 += 1;
    }
  }
  return e2;
}
function sD() {
  const t = new Map;
  for (const [u, F] of Object.entries(r)) {
    for (const [e2, s] of Object.entries(F))
      r[e2] = { open: `\x1B[${s[0]}m`, close: `\x1B[${s[1]}m` }, F[e2] = r[e2], t.set(s[0], s[1]);
    Object.defineProperty(r, u, { value: F, enumerable: false });
  }
  return Object.defineProperty(r, "codes", { value: t, enumerable: false }), r.color.close = "\x1B[39m", r.bgColor.close = "\x1B[49m", r.color.ansi = L(), r.color.ansi256 = N(), r.color.ansi16m = I(), r.bgColor.ansi = L(m$1), r.bgColor.ansi256 = N(m$1), r.bgColor.ansi16m = I(m$1), Object.defineProperties(r, { rgbToAnsi256: { value: (u, F, e2) => u === F && F === e2 ? u < 8 ? 16 : u > 248 ? 231 : Math.round((u - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(u / 255 * 5) + 6 * Math.round(F / 255 * 5) + Math.round(e2 / 255 * 5), enumerable: false }, hexToRgb: { value: (u) => {
    const F = /[a-f\d]{6}|[a-f\d]{3}/i.exec(u.toString(16));
    if (!F)
      return [0, 0, 0];
    let [e2] = F;
    e2.length === 3 && (e2 = [...e2].map((i) => i + i).join(""));
    const s = Number.parseInt(e2, 16);
    return [s >> 16 & 255, s >> 8 & 255, s & 255];
  }, enumerable: false }, hexToAnsi256: { value: (u) => r.rgbToAnsi256(...r.hexToRgb(u)), enumerable: false }, ansi256ToAnsi: { value: (u) => {
    if (u < 8)
      return 30 + u;
    if (u < 16)
      return 90 + (u - 8);
    let F, e2, s;
    if (u >= 232)
      F = ((u - 232) * 10 + 8) / 255, e2 = F, s = F;
    else {
      u -= 16;
      const C = u % 36;
      F = Math.floor(u / 36) / 5, e2 = Math.floor(C / 6) / 5, s = C % 6 / 5;
    }
    const i = Math.max(F, e2, s) * 2;
    if (i === 0)
      return 30;
    let D = 30 + (Math.round(s) << 2 | Math.round(e2) << 1 | Math.round(F));
    return i === 2 && (D += 60), D;
  }, enumerable: false }, rgbToAnsi: { value: (u, F, e2) => r.ansi256ToAnsi(r.rgbToAnsi256(u, F, e2)), enumerable: false }, hexToAnsi: { value: (u) => r.ansi256ToAnsi(r.hexToAnsi256(u)), enumerable: false } }), r;
}
function G$1(t, u, F) {
  return String(t).normalize().replace(/\r\n/g, `
`).split(`
`).map((e2) => oD(e2, u, F)).join(`
`);
}
function k$1(t, u) {
  if (typeof t == "string")
    return c.aliases.get(t) === u;
  for (const F of t)
    if (F !== undefined && k$1(F, u))
      return true;
  return false;
}
function lD(t, u) {
  if (t === u)
    return;
  const F = t.split(`
`), e2 = u.split(`
`), s = [];
  for (let i = 0;i < Math.max(F.length, e2.length); i++)
    F[i] !== e2[i] && s.push(i);
  return s;
}
function d(t, u) {
  const F = t;
  F.isTTY && F.setRawMode(u);
}

class x {
  constructor(u, F = true) {
    h(this, "input"), h(this, "output"), h(this, "_abortSignal"), h(this, "rl"), h(this, "opts"), h(this, "_render"), h(this, "_track", false), h(this, "_prevFrame", ""), h(this, "_subscribers", new Map), h(this, "_cursor", 0), h(this, "state", "initial"), h(this, "error", ""), h(this, "value");
    const { input: e2 = stdin, output: s = stdout, render: i, signal: D, ...C } = u;
    this.opts = C, this.onKeypress = this.onKeypress.bind(this), this.close = this.close.bind(this), this.render = this.render.bind(this), this._render = i.bind(this), this._track = F, this._abortSignal = D, this.input = e2, this.output = s;
  }
  unsubscribe() {
    this._subscribers.clear();
  }
  setSubscriber(u, F) {
    const e2 = this._subscribers.get(u) ?? [];
    e2.push(F), this._subscribers.set(u, e2);
  }
  on(u, F) {
    this.setSubscriber(u, { cb: F });
  }
  once(u, F) {
    this.setSubscriber(u, { cb: F, once: true });
  }
  emit(u, ...F) {
    const e2 = this._subscribers.get(u) ?? [], s = [];
    for (const i of e2)
      i.cb(...F), i.once && s.push(() => e2.splice(e2.indexOf(i), 1));
    for (const i of s)
      i();
  }
  prompt() {
    return new Promise((u, F) => {
      if (this._abortSignal) {
        if (this._abortSignal.aborted)
          return this.state = "cancel", this.close(), u(S$1);
        this._abortSignal.addEventListener("abort", () => {
          this.state = "cancel", this.close();
        }, { once: true });
      }
      const e2 = new WriteStream(0);
      e2._write = (s, i, D) => {
        this._track && (this.value = this.rl?.line.replace(/\t/g, ""), this._cursor = this.rl?.cursor ?? 0, this.emit("value", this.value)), D();
      }, this.input.pipe(e2), this.rl = f.createInterface({ input: this.input, output: e2, tabSize: 2, prompt: "", escapeCodeTimeout: 50 }), f.emitKeypressEvents(this.input, this.rl), this.rl.prompt(), this.opts.initialValue !== undefined && this._track && this.rl.write(this.opts.initialValue), this.input.on("keypress", this.onKeypress), d(this.input, true), this.output.on("resize", this.render), this.render(), this.once("submit", () => {
        this.output.write(srcExports.cursor.show), this.output.off("resize", this.render), d(this.input, false), u(this.value);
      }), this.once("cancel", () => {
        this.output.write(srcExports.cursor.show), this.output.off("resize", this.render), d(this.input, false), u(S$1);
      });
    });
  }
  onKeypress(u, F) {
    if (this.state === "error" && (this.state = "active"), F?.name && (!this._track && c.aliases.has(F.name) && this.emit("cursor", c.aliases.get(F.name)), c.actions.has(F.name) && this.emit("cursor", F.name)), u && (u.toLowerCase() === "y" || u.toLowerCase() === "n") && this.emit("confirm", u.toLowerCase() === "y"), u === "\t" && this.opts.placeholder && (this.value || (this.rl?.write(this.opts.placeholder), this.emit("value", this.opts.placeholder))), u && this.emit("key", u.toLowerCase()), F?.name === "return") {
      if (this.opts.validate) {
        const e2 = this.opts.validate(this.value);
        e2 && (this.error = e2 instanceof Error ? e2.message : e2, this.state = "error", this.rl?.write(this.value));
      }
      this.state !== "error" && (this.state = "submit");
    }
    k$1([u, F?.name, F?.sequence], "cancel") && (this.state = "cancel"), (this.state === "submit" || this.state === "cancel") && this.emit("finalize"), this.render(), (this.state === "submit" || this.state === "cancel") && this.close();
  }
  close() {
    this.input.unpipe(), this.input.removeListener("keypress", this.onKeypress), this.output.write(`
`), d(this.input, false), this.rl?.close(), this.rl = undefined, this.emit(`${this.state}`, this.value), this.unsubscribe();
  }
  restoreCursor() {
    const u = G$1(this._prevFrame, process.stdout.columns, { hard: true }).split(`
`).length - 1;
    this.output.write(srcExports.cursor.move(-999, u * -1));
  }
  render() {
    const u = G$1(this._render(this) ?? "", process.stdout.columns, { hard: true });
    if (u !== this._prevFrame) {
      if (this.state === "initial")
        this.output.write(srcExports.cursor.hide);
      else {
        const F = lD(this._prevFrame, u);
        if (this.restoreCursor(), F && F?.length === 1) {
          const e2 = F[0];
          this.output.write(srcExports.cursor.move(0, e2)), this.output.write(srcExports.erase.lines(1));
          const s = u.split(`
`);
          this.output.write(s[e2]), this._prevFrame = u, this.output.write(srcExports.cursor.move(0, s.length - e2 - 1));
          return;
        }
        if (F && F?.length > 1) {
          const e2 = F[0];
          this.output.write(srcExports.cursor.move(0, e2)), this.output.write(srcExports.erase.down());
          const s = u.split(`
`).slice(e2);
          this.output.write(s.join(`
`)), this._prevFrame = u;
          return;
        }
        this.output.write(srcExports.erase.down());
      }
      this.output.write(u), this.state === "initial" && (this.state = "active"), this._prevFrame = u;
    }
  }
}
function X() {
  return p.platform !== "win32" ? p.env.TERM !== "linux" : !!p.env.CI || !!p.env.WT_SESSION || !!p.env.TERMINUS_SUBLIME || p.env.ConEmuTask === "{cmd::Cmder}" || p.env.TERM_PROGRAM === "Terminus-Sublime" || p.env.TERM_PROGRAM === "vscode" || p.env.TERM === "xterm-256color" || p.env.TERM === "alacritty" || p.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}
async function prompt(message, opts = {}) {
  const handleCancel = (value) => {
    if (typeof value !== "symbol" || value.toString() !== "Symbol(clack:cancel)") {
      return value;
    }
    switch (opts.cancel) {
      case "reject": {
        const error = new Error("Prompt cancelled.");
        error.name = "ConsolaPromptCancelledError";
        if (Error.captureStackTrace) {
          Error.captureStackTrace(error, prompt);
        }
        throw error;
      }
      case "undefined": {
        return;
      }
      case "null": {
        return null;
      }
      case "symbol": {
        return kCancel;
      }
      default:
      case "default": {
        return opts.default ?? opts.initial;
      }
    }
  };
  if (!opts.type || opts.type === "text") {
    return await ue({
      message,
      defaultValue: opts.default,
      placeholder: opts.placeholder,
      initialValue: opts.initial
    }).then(handleCancel);
  }
  if (opts.type === "confirm") {
    return await me({
      message,
      initialValue: opts.initial
    }).then(handleCancel);
  }
  if (opts.type === "select") {
    return await de({
      message,
      options: opts.options.map((o) => typeof o === "string" ? { value: o, label: o } : o),
      initialValue: opts.initial
    }).then(handleCancel);
  }
  if (opts.type === "multiselect") {
    return await pe({
      message,
      options: opts.options.map((o) => typeof o === "string" ? { value: o, label: o } : o),
      required: opts.required,
      initialValues: opts.initial
    }).then(handleCancel);
  }
  throw new Error(`Unknown prompt type: ${opts.type}`);
}
var src, hasRequiredSrc, srcExports, picocolors, hasRequiredPicocolors, picocolorsExports, e, Q, P, X$1, DD, uD = function() {
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
}, FD, m$1 = 10, L = (t = 0) => (u) => `\x1B[${u + t}m`, N = (t = 0) => (u) => `\x1B[${38 + t};5;${u}m`, I = (t = 0) => (u, F, e2) => `\x1B[${38 + t};2;${u};${F};${e2}m`, r, tD, eD, iD, v, CD = 39, w = "\x07", W = "[", rD = "]", R$1 = "m", y$1, V$1 = (t) => `${v.values().next().value}${W}${t}${R$1}`, z = (t) => `${v.values().next().value}${y$1}${t}${w}`, ED = (t) => t.split(" ").map((u) => A$1(u)), _ = (t, u, F) => {
  const e2 = [...u];
  let s = false, i = false, D = A$1(T(t[t.length - 1]));
  for (const [C, o] of e2.entries()) {
    const E = A$1(o);
    if (D + E <= F ? t[t.length - 1] += o : (t.push(o), D = 0), v.has(o) && (s = true, i = e2.slice(C + 1).join("").startsWith(y$1)), s) {
      i ? o === w && (s = false, i = false) : o === R$1 && (s = false);
      continue;
    }
    D += E, D === F && C < e2.length - 1 && (t.push(""), D = 0);
  }
  !D && t[t.length - 1].length > 0 && t.length > 1 && (t[t.length - 2] += t.pop());
}, nD = (t) => {
  const u = t.split(" ");
  let F = u.length;
  for (;F > 0 && !(A$1(u[F - 1]) > 0); )
    F--;
  return F === u.length ? t : u.slice(0, F).join(" ") + u.slice(F).join("");
}, oD = (t, u, F = {}) => {
  if (F.trim !== false && t.trim() === "")
    return "";
  let e2 = "", s, i;
  const D = ED(t);
  let C = [""];
  for (const [E, a] of t.split(" ").entries()) {
    F.trim !== false && (C[C.length - 1] = C[C.length - 1].trimStart());
    let n = A$1(C[C.length - 1]);
    if (E !== 0 && (n >= u && (F.wordWrap === false || F.trim === false) && (C.push(""), n = 0), (n > 0 || F.trim === false) && (C[C.length - 1] += " ", n++)), F.hard && D[E] > u) {
      const B = u - n, p2 = 1 + Math.floor((D[E] - B - 1) / u);
      Math.floor((D[E] - 1) / u) < p2 && C.push(""), _(C, a, u);
      continue;
    }
    if (n + D[E] > u && n > 0 && D[E] > 0) {
      if (F.wordWrap === false && n < u) {
        _(C, a, u);
        continue;
      }
      C.push("");
    }
    if (n + D[E] > u && F.wordWrap === false) {
      _(C, a, u);
      continue;
    }
    C[C.length - 1] += a;
  }
  F.trim !== false && (C = C.map((E) => nD(E)));
  const o = [...C.join(`
`)];
  for (const [E, a] of o.entries()) {
    if (e2 += a, v.has(a)) {
      const { groups: B } = new RegExp(`(?:\\${W}(?<code>\\d+)m|\\${y$1}(?<uri>.*)${w})`).exec(o.slice(E).join("")) || { groups: {} };
      if (B.code !== undefined) {
        const p2 = Number.parseFloat(B.code);
        s = p2 === CD ? undefined : p2;
      } else
        B.uri !== undefined && (i = B.uri.length === 0 ? undefined : B.uri);
    }
    const n = iD.codes.get(Number(s));
    o[E + 1] === `
` ? (i && (e2 += z("")), s && n && (e2 += V$1(n))) : a === `
` && (s && n && (e2 += V$1(s)), i && (e2 += z(i)));
  }
  return e2;
}, aD, c, S$1, AD, pD = (t, u, F) => (u in t) ? AD(t, u, { enumerable: true, configurable: true, writable: true, value: F }) : t[u] = F, h = (t, u, F) => (pD(t, typeof u != "symbol" ? u + "" : u, F), F), fD, bD, mD = (t, u, F) => (u in t) ? bD(t, u, { enumerable: true, configurable: true, writable: true, value: F }) : t[u] = F, Y = (t, u, F) => (mD(t, typeof u != "symbol" ? u + "" : u, F), F), wD, SD, $D = (t, u, F) => (u in t) ? SD(t, u, { enumerable: true, configurable: true, writable: true, value: F }) : t[u] = F, q = (t, u, F) => ($D(t, typeof u != "symbol" ? u + "" : u, F), F), jD, PD, E, u = (s, n) => E ? s : n, ee, A, B, S, a, m, j, R, V, M, G, y = (s) => {
  switch (s) {
    case "initial":
    case "active":
      return e.cyan(ee);
    case "cancel":
      return e.red(A);
    case "error":
      return e.yellow(B);
    case "submit":
      return e.green(S);
  }
}, k = (s) => {
  const { cursor: n, options: t, style: i } = s, r2 = s.maxItems ?? Number.POSITIVE_INFINITY, c2 = Math.max(process.stdout.rows - 4, 0), o = Math.min(c2, Math.max(r2, 5));
  let l = 0;
  n >= l + o - 3 ? l = Math.max(Math.min(n - o + 3, t.length - o), 0) : n < l + 2 && (l = Math.max(n - 2, 0));
  const $ = o < t.length && l > 0, d2 = o < t.length && l + o < t.length;
  return t.slice(l, l + o).map((w2, b, C) => {
    const I2 = b === 0 && $, x2 = b === C.length - 1 && d2;
    return I2 || x2 ? e.dim("...") : i(w2, b + l === n);
  });
}, ue = (s) => new PD({ validate: s.validate, placeholder: s.placeholder, defaultValue: s.defaultValue, initialValue: s.initialValue, render() {
  const n = `${e.gray(a)}
${y(this.state)} ${s.message}
`, t = s.placeholder ? e.inverse(s.placeholder[0]) + e.dim(s.placeholder.slice(1)) : e.inverse(e.hidden("_")), i = this.value ? this.valueWithCursor : t;
  switch (this.state) {
    case "error":
      return `${n.trim()}
${e.yellow(a)} ${i}
${e.yellow(m)} ${e.yellow(this.error)}
`;
    case "submit":
      return `${n}${e.gray(a)} ${e.dim(this.value || s.placeholder)}`;
    case "cancel":
      return `${n}${e.gray(a)} ${e.strikethrough(e.dim(this.value ?? ""))}${this.value?.trim() ? `
${e.gray(a)}` : ""}`;
    default:
      return `${n}${e.cyan(a)} ${i}
${e.cyan(m)}
`;
  }
} }).prompt(), me = (s) => {
  const n = s.active ?? "Yes", t = s.inactive ?? "No";
  return new fD({ active: n, inactive: t, initialValue: s.initialValue ?? true, render() {
    const i = `${e.gray(a)}
${y(this.state)} ${s.message}
`, r2 = this.value ? n : t;
    switch (this.state) {
      case "submit":
        return `${i}${e.gray(a)} ${e.dim(r2)}`;
      case "cancel":
        return `${i}${e.gray(a)} ${e.strikethrough(e.dim(r2))}
${e.gray(a)}`;
      default:
        return `${i}${e.cyan(a)} ${this.value ? `${e.green(j)} ${n}` : `${e.dim(R)} ${e.dim(n)}`} ${e.dim("/")} ${this.value ? `${e.dim(R)} ${e.dim(t)}` : `${e.green(j)} ${t}`}
${e.cyan(m)}
`;
    }
  } }).prompt();
}, de = (s) => {
  const n = (t, i) => {
    const r2 = t.label ?? String(t.value);
    switch (i) {
      case "selected":
        return `${e.dim(r2)}`;
      case "active":
        return `${e.green(j)} ${r2} ${t.hint ? e.dim(`(${t.hint})`) : ""}`;
      case "cancelled":
        return `${e.strikethrough(e.dim(r2))}`;
      default:
        return `${e.dim(R)} ${e.dim(r2)}`;
    }
  };
  return new jD({ options: s.options, initialValue: s.initialValue, render() {
    const t = `${e.gray(a)}
${y(this.state)} ${s.message}
`;
    switch (this.state) {
      case "submit":
        return `${t}${e.gray(a)} ${n(this.options[this.cursor], "selected")}`;
      case "cancel":
        return `${t}${e.gray(a)} ${n(this.options[this.cursor], "cancelled")}
${e.gray(a)}`;
      default:
        return `${t}${e.cyan(a)} ${k({ cursor: this.cursor, options: this.options, maxItems: s.maxItems, style: (i, r2) => n(i, r2 ? "active" : "inactive") }).join(`
${e.cyan(a)}  `)}
${e.cyan(m)}
`;
    }
  } }).prompt();
}, pe = (s) => {
  const n = (t, i) => {
    const r2 = t.label ?? String(t.value);
    return i === "active" ? `${e.cyan(V)} ${r2} ${t.hint ? e.dim(`(${t.hint})`) : ""}` : i === "selected" ? `${e.green(M)} ${e.dim(r2)}` : i === "cancelled" ? `${e.strikethrough(e.dim(r2))}` : i === "active-selected" ? `${e.green(M)} ${r2} ${t.hint ? e.dim(`(${t.hint})`) : ""}` : i === "submitted" ? `${e.dim(r2)}` : `${e.dim(G)} ${e.dim(r2)}`;
  };
  return new wD({ options: s.options, initialValues: s.initialValues, required: s.required ?? true, cursorAt: s.cursorAt, validate(t) {
    if (this.required && t.length === 0)
      return `Please select at least one option.
${e.reset(e.dim(`Press ${e.gray(e.bgWhite(e.inverse(" space ")))} to select, ${e.gray(e.bgWhite(e.inverse(" enter ")))} to submit`))}`;
  }, render() {
    const t = `${e.gray(a)}
${y(this.state)} ${s.message}
`, i = (r2, c2) => {
      const o = this.value.includes(r2.value);
      return c2 && o ? n(r2, "active-selected") : o ? n(r2, "selected") : n(r2, c2 ? "active" : "inactive");
    };
    switch (this.state) {
      case "submit":
        return `${t}${e.gray(a)} ${this.options.filter(({ value: r2 }) => this.value.includes(r2)).map((r2) => n(r2, "submitted")).join(e.dim(", ")) || e.dim("none")}`;
      case "cancel": {
        const r2 = this.options.filter(({ value: c2 }) => this.value.includes(c2)).map((c2) => n(c2, "cancelled")).join(e.dim(", "));
        return `${t}${e.gray(a)} ${r2.trim() ? `${r2}
${e.gray(a)}` : ""}`;
      }
      case "error": {
        const r2 = this.error.split(`
`).map((c2, o) => o === 0 ? `${e.yellow(m)} ${e.yellow(c2)}` : `   ${c2}`).join(`
`);
        return `${t + e.yellow(a)} ${k({ options: this.options, cursor: this.cursor, maxItems: s.maxItems, style: i }).join(`
${e.yellow(a)}  `)}
${r2}
`;
      }
      default:
        return `${t}${e.cyan(a)} ${k({ options: this.options, cursor: this.cursor, maxItems: s.maxItems, style: i }).join(`
${e.cyan(a)}  `)}
${e.cyan(m)}
`;
    }
  } }).prompt();
}, kCancel;
var init_prompt = __esm(() => {
  srcExports = requireSrc();
  picocolors = { exports: {} };
  picocolorsExports = /* @__PURE__ */ requirePicocolors();
  e = /* @__PURE__ */ getDefaultExportFromCjs(picocolorsExports);
  Q = J();
  P = { exports: {} };
  (function(t) {
    var u = {};
    t.exports = u, u.eastAsianWidth = function(e2) {
      var s = e2.charCodeAt(0), i = e2.length == 2 ? e2.charCodeAt(1) : 0, D = s;
      return 55296 <= s && s <= 56319 && 56320 <= i && i <= 57343 && (s &= 1023, i &= 1023, D = s << 10 | i, D += 65536), D == 12288 || 65281 <= D && D <= 65376 || 65504 <= D && D <= 65510 ? "F" : D == 8361 || 65377 <= D && D <= 65470 || 65474 <= D && D <= 65479 || 65482 <= D && D <= 65487 || 65490 <= D && D <= 65495 || 65498 <= D && D <= 65500 || 65512 <= D && D <= 65518 ? "H" : 4352 <= D && D <= 4447 || 4515 <= D && D <= 4519 || 4602 <= D && D <= 4607 || 9001 <= D && D <= 9002 || 11904 <= D && D <= 11929 || 11931 <= D && D <= 12019 || 12032 <= D && D <= 12245 || 12272 <= D && D <= 12283 || 12289 <= D && D <= 12350 || 12353 <= D && D <= 12438 || 12441 <= D && D <= 12543 || 12549 <= D && D <= 12589 || 12593 <= D && D <= 12686 || 12688 <= D && D <= 12730 || 12736 <= D && D <= 12771 || 12784 <= D && D <= 12830 || 12832 <= D && D <= 12871 || 12880 <= D && D <= 13054 || 13056 <= D && D <= 19903 || 19968 <= D && D <= 42124 || 42128 <= D && D <= 42182 || 43360 <= D && D <= 43388 || 44032 <= D && D <= 55203 || 55216 <= D && D <= 55238 || 55243 <= D && D <= 55291 || 63744 <= D && D <= 64255 || 65040 <= D && D <= 65049 || 65072 <= D && D <= 65106 || 65108 <= D && D <= 65126 || 65128 <= D && D <= 65131 || 110592 <= D && D <= 110593 || 127488 <= D && D <= 127490 || 127504 <= D && D <= 127546 || 127552 <= D && D <= 127560 || 127568 <= D && D <= 127569 || 131072 <= D && D <= 194367 || 177984 <= D && D <= 196605 || 196608 <= D && D <= 262141 ? "W" : 32 <= D && D <= 126 || 162 <= D && D <= 163 || 165 <= D && D <= 166 || D == 172 || D == 175 || 10214 <= D && D <= 10221 || 10629 <= D && D <= 10630 ? "Na" : D == 161 || D == 164 || 167 <= D && D <= 168 || D == 170 || 173 <= D && D <= 174 || 176 <= D && D <= 180 || 182 <= D && D <= 186 || 188 <= D && D <= 191 || D == 198 || D == 208 || 215 <= D && D <= 216 || 222 <= D && D <= 225 || D == 230 || 232 <= D && D <= 234 || 236 <= D && D <= 237 || D == 240 || 242 <= D && D <= 243 || 247 <= D && D <= 250 || D == 252 || D == 254 || D == 257 || D == 273 || D == 275 || D == 283 || 294 <= D && D <= 295 || D == 299 || 305 <= D && D <= 307 || D == 312 || 319 <= D && D <= 322 || D == 324 || 328 <= D && D <= 331 || D == 333 || 338 <= D && D <= 339 || 358 <= D && D <= 359 || D == 363 || D == 462 || D == 464 || D == 466 || D == 468 || D == 470 || D == 472 || D == 474 || D == 476 || D == 593 || D == 609 || D == 708 || D == 711 || 713 <= D && D <= 715 || D == 717 || D == 720 || 728 <= D && D <= 731 || D == 733 || D == 735 || 768 <= D && D <= 879 || 913 <= D && D <= 929 || 931 <= D && D <= 937 || 945 <= D && D <= 961 || 963 <= D && D <= 969 || D == 1025 || 1040 <= D && D <= 1103 || D == 1105 || D == 8208 || 8211 <= D && D <= 8214 || 8216 <= D && D <= 8217 || 8220 <= D && D <= 8221 || 8224 <= D && D <= 8226 || 8228 <= D && D <= 8231 || D == 8240 || 8242 <= D && D <= 8243 || D == 8245 || D == 8251 || D == 8254 || D == 8308 || D == 8319 || 8321 <= D && D <= 8324 || D == 8364 || D == 8451 || D == 8453 || D == 8457 || D == 8467 || D == 8470 || 8481 <= D && D <= 8482 || D == 8486 || D == 8491 || 8531 <= D && D <= 8532 || 8539 <= D && D <= 8542 || 8544 <= D && D <= 8555 || 8560 <= D && D <= 8569 || D == 8585 || 8592 <= D && D <= 8601 || 8632 <= D && D <= 8633 || D == 8658 || D == 8660 || D == 8679 || D == 8704 || 8706 <= D && D <= 8707 || 8711 <= D && D <= 8712 || D == 8715 || D == 8719 || D == 8721 || D == 8725 || D == 8730 || 8733 <= D && D <= 8736 || D == 8739 || D == 8741 || 8743 <= D && D <= 8748 || D == 8750 || 8756 <= D && D <= 8759 || 8764 <= D && D <= 8765 || D == 8776 || D == 8780 || D == 8786 || 8800 <= D && D <= 8801 || 8804 <= D && D <= 8807 || 8810 <= D && D <= 8811 || 8814 <= D && D <= 8815 || 8834 <= D && D <= 8835 || 8838 <= D && D <= 8839 || D == 8853 || D == 8857 || D == 8869 || D == 8895 || D == 8978 || 9312 <= D && D <= 9449 || 9451 <= D && D <= 9547 || 9552 <= D && D <= 9587 || 9600 <= D && D <= 9615 || 9618 <= D && D <= 9621 || 9632 <= D && D <= 9633 || 9635 <= D && D <= 9641 || 9650 <= D && D <= 9651 || 9654 <= D && D <= 9655 || 9660 <= D && D <= 9661 || 9664 <= D && D <= 9665 || 9670 <= D && D <= 9672 || D == 9675 || 9678 <= D && D <= 9681 || 9698 <= D && D <= 9701 || D == 9711 || 9733 <= D && D <= 9734 || D == 9737 || 9742 <= D && D <= 9743 || 9748 <= D && D <= 9749 || D == 9756 || D == 9758 || D == 9792 || D == 9794 || 9824 <= D && D <= 9825 || 9827 <= D && D <= 9829 || 9831 <= D && D <= 9834 || 9836 <= D && D <= 9837 || D == 9839 || 9886 <= D && D <= 9887 || 9918 <= D && D <= 9919 || 9924 <= D && D <= 9933 || 9935 <= D && D <= 9953 || D == 9955 || 9960 <= D && D <= 9983 || D == 10045 || D == 10071 || 10102 <= D && D <= 10111 || 11093 <= D && D <= 11097 || 12872 <= D && D <= 12879 || 57344 <= D && D <= 63743 || 65024 <= D && D <= 65039 || D == 65533 || 127232 <= D && D <= 127242 || 127248 <= D && D <= 127277 || 127280 <= D && D <= 127337 || 127344 <= D && D <= 127386 || 917760 <= D && D <= 917999 || 983040 <= D && D <= 1048573 || 1048576 <= D && D <= 1114109 ? "A" : "N";
    }, u.characterLength = function(e2) {
      var s = this.eastAsianWidth(e2);
      return s == "F" || s == "W" || s == "A" ? 2 : 1;
    };
    function F(e2) {
      return e2.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
    }
    u.length = function(e2) {
      for (var s = F(e2), i = 0, D = 0;D < s.length; D++)
        i = i + this.characterLength(s[D]);
      return i;
    }, u.slice = function(e2, s, i) {
      textLen = u.length(e2), s = s || 0, i = i || 1, s < 0 && (s = textLen + s), i < 0 && (i = textLen + i);
      for (var D = "", C = 0, o = F(e2), E = 0;E < o.length; E++) {
        var a = o[E], n = u.length(a);
        if (C >= s - (n == 2 ? 1 : 0))
          if (C + n <= i)
            D += a;
          else
            break;
        C += n;
      }
      return D;
    };
  })(P);
  X$1 = P.exports;
  DD = O(X$1);
  FD = O(uD);
  r = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], overline: [53, 55], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], gray: [90, 39], grey: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgGray: [100, 49], bgGrey: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
  Object.keys(r.modifier);
  tD = Object.keys(r.color);
  eD = Object.keys(r.bgColor);
  [...tD];
  iD = sD();
  v = new Set(["\x1B", "\x9B"]);
  y$1 = `${rD}8;;`;
  aD = ["up", "down", "left", "right", "space", "enter", "cancel"];
  c = { actions: new Set(aD), aliases: new Map([["k", "up"], ["j", "down"], ["h", "left"], ["l", "right"], ["\x03", "cancel"], ["escape", "cancel"]]) };
  globalThis.process.platform.startsWith("win");
  S$1 = Symbol("clack:cancel");
  AD = Object.defineProperty;
  fD = class fD extends x {
    get cursor() {
      return this.value ? 0 : 1;
    }
    get _value() {
      return this.cursor === 0;
    }
    constructor(u) {
      super(u, false), this.value = !!u.initialValue, this.on("value", () => {
        this.value = this._value;
      }), this.on("confirm", (F) => {
        this.output.write(srcExports.cursor.move(0, -1)), this.value = F, this.state = "submit", this.close();
      }), this.on("cursor", () => {
        this.value = !this.value;
      });
    }
  };
  bD = Object.defineProperty;
  wD = class extends x {
    constructor(u) {
      super(u, false), Y(this, "options"), Y(this, "cursor", 0), this.options = u.options, this.value = [...u.initialValues ?? []], this.cursor = Math.max(this.options.findIndex(({ value: F }) => F === u.cursorAt), 0), this.on("key", (F) => {
        F === "a" && this.toggleAll();
      }), this.on("cursor", (F) => {
        switch (F) {
          case "left":
          case "up":
            this.cursor = this.cursor === 0 ? this.options.length - 1 : this.cursor - 1;
            break;
          case "down":
          case "right":
            this.cursor = this.cursor === this.options.length - 1 ? 0 : this.cursor + 1;
            break;
          case "space":
            this.toggleValue();
            break;
        }
      });
    }
    get _value() {
      return this.options[this.cursor].value;
    }
    toggleAll() {
      const u = this.value.length === this.options.length;
      this.value = u ? [] : this.options.map((F) => F.value);
    }
    toggleValue() {
      const u = this.value.includes(this._value);
      this.value = u ? this.value.filter((F) => F !== this._value) : [...this.value, this._value];
    }
  };
  SD = Object.defineProperty;
  jD = class jD extends x {
    constructor(u) {
      super(u, false), q(this, "options"), q(this, "cursor", 0), this.options = u.options, this.cursor = this.options.findIndex(({ value: F }) => F === u.initialValue), this.cursor === -1 && (this.cursor = 0), this.changeValue(), this.on("cursor", (F) => {
        switch (F) {
          case "left":
          case "up":
            this.cursor = this.cursor === 0 ? this.options.length - 1 : this.cursor - 1;
            break;
          case "down":
          case "right":
            this.cursor = this.cursor === this.options.length - 1 ? 0 : this.cursor + 1;
            break;
        }
        this.changeValue();
      });
    }
    get _value() {
      return this.options[this.cursor];
    }
    changeValue() {
      this.value = this._value.value;
    }
  };
  PD = class PD extends x {
    get valueWithCursor() {
      if (this.state === "submit")
        return this.value;
      if (this.cursor >= this.value.length)
        return `${this.value}\u2588`;
      const u = this.value.slice(0, this.cursor), [F, ...e$1] = this.value.slice(this.cursor);
      return `${u}${e.inverse(F)}${e$1.join("")}`;
    }
    get cursor() {
      return this._cursor;
    }
    constructor(u) {
      super(u), this.on("finalize", () => {
        this.value || (this.value = u.defaultValue);
      });
    }
  };
  E = X();
  ee = u("\u276F", ">");
  A = u("\u25A0", "x");
  B = u("\u25B2", "x");
  S = u("\u2714", "\u221A");
  a = u("");
  m = u("");
  j = u("\u25CF", ">");
  R = u("\u25CB", " ");
  V = u("\u25FB", "[\u2022]");
  M = u("\u25FC", "[+]");
  G = u("\u25FB", "[ ]");
  kCancel = Symbol.for("cancel");
});

// ../../node_modules/@smithy/protocol-http/dist-es/extensions/httpExtensionConfiguration.js
var getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
  let httpHandler = runtimeConfig.httpHandler;
  return {
    setHttpHandler(handler) {
      httpHandler = handler;
    },
    httpHandler() {
      return httpHandler;
    },
    updateHttpClientConfig(key, value) {
      httpHandler.updateHttpClientConfig(key, value);
    },
    httpHandlerConfigs() {
      return httpHandler.httpHandlerConfigs();
    }
  };
}, resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
  return {
    httpHandler: httpHandlerExtensionConfiguration.httpHandler()
  };
};

// ../../node_modules/@smithy/protocol-http/dist-es/extensions/index.js
var init_extensions = () => {
};

// ../../node_modules/@smithy/types/dist-cjs/index.js
var require_dist_cjs = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    AlgorithmId: () => AlgorithmId,
    EndpointURLScheme: () => EndpointURLScheme,
    FieldPosition: () => FieldPosition,
    HttpApiKeyAuthLocation: () => HttpApiKeyAuthLocation,
    HttpAuthLocation: () => HttpAuthLocation,
    IniSectionType: () => IniSectionType,
    RequestHandlerProtocol: () => RequestHandlerProtocol,
    SMITHY_CONTEXT_KEY: () => SMITHY_CONTEXT_KEY,
    getDefaultClientConfiguration: () => getDefaultClientConfiguration,
    resolveDefaultRuntimeConfig: () => resolveDefaultRuntimeConfig
  });
  module.exports = __toCommonJS(src_exports);
  var HttpAuthLocation = /* @__PURE__ */ ((HttpAuthLocation2) => {
    HttpAuthLocation2["HEADER"] = "header";
    HttpAuthLocation2["QUERY"] = "query";
    return HttpAuthLocation2;
  })(HttpAuthLocation || {});
  var HttpApiKeyAuthLocation = /* @__PURE__ */ ((HttpApiKeyAuthLocation2) => {
    HttpApiKeyAuthLocation2["HEADER"] = "header";
    HttpApiKeyAuthLocation2["QUERY"] = "query";
    return HttpApiKeyAuthLocation2;
  })(HttpApiKeyAuthLocation || {});
  var EndpointURLScheme = /* @__PURE__ */ ((EndpointURLScheme2) => {
    EndpointURLScheme2["HTTP"] = "http";
    EndpointURLScheme2["HTTPS"] = "https";
    return EndpointURLScheme2;
  })(EndpointURLScheme || {});
  var AlgorithmId = /* @__PURE__ */ ((AlgorithmId2) => {
    AlgorithmId2["MD5"] = "md5";
    AlgorithmId2["CRC32"] = "crc32";
    AlgorithmId2["CRC32C"] = "crc32c";
    AlgorithmId2["SHA1"] = "sha1";
    AlgorithmId2["SHA256"] = "sha256";
    return AlgorithmId2;
  })(AlgorithmId || {});
  var getChecksumConfiguration = /* @__PURE__ */ __name2((runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
      checksumAlgorithms.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => runtimeConfig.sha256
      });
    }
    if (runtimeConfig.md5 != null) {
      checksumAlgorithms.push({
        algorithmId: () => "md5",
        checksumConstructor: () => runtimeConfig.md5
      });
    }
    return {
      _checksumAlgorithms: checksumAlgorithms,
      addChecksumAlgorithm(algo) {
        this._checksumAlgorithms.push(algo);
      },
      checksumAlgorithms() {
        return this._checksumAlgorithms;
      }
    };
  }, "getChecksumConfiguration");
  var resolveChecksumRuntimeConfig = /* @__PURE__ */ __name2((clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
      runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
  }, "resolveChecksumRuntimeConfig");
  var getDefaultClientConfiguration = /* @__PURE__ */ __name2((runtimeConfig) => {
    return {
      ...getChecksumConfiguration(runtimeConfig)
    };
  }, "getDefaultClientConfiguration");
  var resolveDefaultRuntimeConfig = /* @__PURE__ */ __name2((config2) => {
    return {
      ...resolveChecksumRuntimeConfig(config2)
    };
  }, "resolveDefaultRuntimeConfig");
  var FieldPosition = /* @__PURE__ */ ((FieldPosition2) => {
    FieldPosition2[FieldPosition2["HEADER"] = 0] = "HEADER";
    FieldPosition2[FieldPosition2["TRAILER"] = 1] = "TRAILER";
    return FieldPosition2;
  })(FieldPosition || {});
  var SMITHY_CONTEXT_KEY = "__smithy_context";
  var IniSectionType = /* @__PURE__ */ ((IniSectionType2) => {
    IniSectionType2["PROFILE"] = "profile";
    IniSectionType2["SSO_SESSION"] = "sso-session";
    IniSectionType2["SERVICES"] = "services";
    return IniSectionType2;
  })(IniSectionType || {});
  var RequestHandlerProtocol = /* @__PURE__ */ ((RequestHandlerProtocol2) => {
    RequestHandlerProtocol2["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol2["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol2["TDS_8_0"] = "tds/8.0";
    return RequestHandlerProtocol2;
  })(RequestHandlerProtocol || {});
});

// ../../node_modules/@smithy/protocol-http/dist-es/Field.js
var import_types2;
var init_Field = __esm(() => {
  import_types2 = __toESM(require_dist_cjs(), 1);
});
// ../../node_modules/@smithy/protocol-http/dist-es/httpHandler.js
var init_httpHandler = () => {
};

// ../../node_modules/@smithy/protocol-http/dist-es/httpRequest.js
class HttpRequest {
  constructor(options) {
    this.method = options.method || "GET";
    this.hostname = options.hostname || "localhost";
    this.port = options.port;
    this.query = options.query || {};
    this.headers = options.headers || {};
    this.body = options.body;
    this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
    this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
    this.username = options.username;
    this.password = options.password;
    this.fragment = options.fragment;
  }
  static clone(request) {
    const cloned = new HttpRequest({
      ...request,
      headers: { ...request.headers }
    });
    if (cloned.query) {
      cloned.query = cloneQuery(cloned.query);
    }
    return cloned;
  }
  static isInstance(request) {
    if (!request) {
      return false;
    }
    const req = request;
    return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
  }
  clone() {
    return HttpRequest.clone(this);
  }
}
function cloneQuery(query) {
  return Object.keys(query).reduce((carry, paramName) => {
    const param = query[paramName];
    return {
      ...carry,
      [paramName]: Array.isArray(param) ? [...param] : param
    };
  }, {});
}

// ../../node_modules/@smithy/protocol-http/dist-es/httpResponse.js
class HttpResponse {
  constructor(options) {
    this.statusCode = options.statusCode;
    this.reason = options.reason;
    this.headers = options.headers || {};
    this.body = options.body;
  }
  static isInstance(response) {
    if (!response)
      return false;
    const resp = response;
    return typeof resp.statusCode === "number" && typeof resp.headers === "object";
  }
}
// ../../node_modules/@smithy/protocol-http/dist-es/types.js
var init_types = () => {
};

// ../../node_modules/@smithy/protocol-http/dist-es/index.js
var init_dist_es = __esm(() => {
  init_extensions();
  init_Field();
  init_httpHandler();
  init_types();
});

// ../../node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  var __rewriteRelativeImportExtension;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v2) {
        return exports2[id] = previous ? previous(id, v2) : v2;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b) {
      d2.__proto__ = b;
    } || function(d2, b) {
      for (var p3 in b)
        if (Object.prototype.hasOwnProperty.call(b, p3))
          d2[p3] = b[p3];
    };
    __extends = function(d2, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d2, b);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t2) {
      for (var s2, i2 = 1, n2 = arguments.length;i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p3 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p3))
            t2[p3] = s2[p3];
      }
      return t2;
    };
    __rest = function(s2, e2) {
      var t2 = {};
      for (var p3 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
          t2[p3] = s2[p3];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2);i2 < p3.length; i2++) {
          if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
            t2[p3[i2]] = s2[p3[i2]];
        }
      return t2;
    };
    __decorate = function(decorators, target, key, desc) {
      var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r3 = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i2 = decorators.length - 1;i2 >= 0; i2--)
          if (d2 = decorators[i2])
            r3 = (c3 < 3 ? d2(r3) : c3 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
      return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f2) {
        if (f2 !== undefined && typeof f2 !== "function")
          throw new TypeError("Function expected");
        return f2;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _3, done = false;
      for (var i2 = decorators.length - 1;i2 >= 0; i2--) {
        var context = {};
        for (var p3 in contextIn)
          context[p3] = p3 === "access" ? {} : contextIn[p3];
        for (var p3 in contextIn.access)
          context.access[p3] = contextIn.access[p3];
        context.addInitializer = function(f2) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f2 || null));
        };
        var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_3 = accept(result.get))
            descriptor.get = _3;
          if (_3 = accept(result.set))
            descriptor.set = _3;
          if (_3 = accept(result.init))
            initializers.unshift(_3);
        } else if (_3 = accept(result)) {
          if (kind === "field")
            initializers.unshift(_3);
          else
            descriptor[key] = _3;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i2 = 0;i2 < initializers.length; i2++) {
        value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x2) {
      return typeof x2 === "symbol" ? x2 : "".concat(x2);
    };
    __setFunctionName = function(f2, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f2, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _3 = { label: 0, sent: function() {
        if (t2[0] & 1)
          throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f2, y3, t2, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n2) {
        return function(v2) {
          return step([n2, v2]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_3 = 0)), _3)
          try {
            if (f2 = 1, y3 && (t2 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t2 = y3["return"]) && t2.call(y3), 0) : y3.next) && !(t2 = t2.call(y3, op[1])).done)
              return t2;
            if (y3 = 0, t2)
              op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _3.label++;
                return { value: op[1], done: false };
              case 5:
                _3.label++;
                y3 = op[1];
                op = [0];
                continue;
              case 7:
                op = _3.ops.pop();
                _3.trys.pop();
                continue;
              default:
                if (!(t2 = _3.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _3 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _3.label = op[1];
                  break;
                }
                if (op[0] === 6 && _3.label < t2[1]) {
                  _3.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _3.label < t2[2]) {
                  _3.label = t2[2];
                  _3.ops.push(op);
                  break;
                }
                if (t2[2])
                  _3.ops.pop();
                _3.trys.pop();
                continue;
            }
            op = body.call(thisArg, _3);
          } catch (e2) {
            op = [6, e2];
            y3 = 0;
          } finally {
            f2 = t2 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m2, o) {
      for (var p3 in m2)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(o, p3))
          __createBinding(o, m2, p3);
    };
    __createBinding = Object.create ? function(o, m2, k2, k22) {
      if (k22 === undefined)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === undefined)
        k22 = k2;
      o[k22] = m2[k2];
    };
    __values = function(o) {
      var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i2 = 0;
      if (m2)
        return m2.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i2 >= o.length)
              o = undefined;
            return { value: o && o[i2++], done: !o };
          }
        };
      throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n2) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2)
        return o;
      var i2 = m2.call(o), r3, ar = [], e2;
      try {
        while ((n2 === undefined || n2-- > 0) && !(r3 = i2.next()).done)
          ar.push(r3.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r3 && !r3.done && (m2 = i2["return"]))
            m2.call(i2);
        } finally {
          if (e2)
            throw e2.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i2 = 0;i2 < arguments.length; i2++)
        ar = ar.concat(__read(arguments[i2]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s2 = 0, i2 = 0, il = arguments.length;i2 < il; i2++)
        s2 += arguments[i2].length;
      for (var r3 = Array(s2), k2 = 0, i2 = 0;i2 < il; i2++)
        for (var a3 = arguments[i2], j2 = 0, jl = a3.length;j2 < jl; j2++, k2++)
          r3[k2] = a3[j2];
      return r3;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from.length, ar;i2 < l2; i2++) {
          if (ar || !(i2 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i2);
            ar[i2] = from[i2];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v2) {
      return this instanceof __await ? (this.v = v2, this) : new __await(v2);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i2, q2 = [];
      return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2;
      function awaitReturn(f2) {
        return function(v2) {
          return Promise.resolve(v2).then(f2, reject);
        };
      }
      function verb(n2, f2) {
        if (g[n2]) {
          i2[n2] = function(v2) {
            return new Promise(function(a3, b) {
              q2.push([n2, v2, a3, b]) > 1 || resume(n2, v2);
            });
          };
          if (f2)
            i2[n2] = f2(i2[n2]);
        }
      }
      function resume(n2, v2) {
        try {
          step(g[n2](v2));
        } catch (e2) {
          settle(q2[0][3], e2);
        }
      }
      function step(r3) {
        r3.value instanceof __await ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q2[0][2], r3);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f2, v2) {
        if (f2(v2), q2.shift(), q2.length)
          resume(q2[0][0], q2[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i2, p3;
      return i2 = {}, verb("next"), verb("throw", function(e2) {
        throw e2;
      }), verb("return"), i2[Symbol.iterator] = function() {
        return this;
      }, i2;
      function verb(n2, f2) {
        i2[n2] = o[n2] ? function(v2) {
          return (p3 = !p3) ? { value: __await(o[n2](v2)), done: false } : f2 ? f2(v2) : v2;
        } : f2;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m2 = o[Symbol.asyncIterator], i2;
      return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2);
      function verb(n2) {
        i2[n2] = o[n2] && function(v2) {
          return new Promise(function(resolve2, reject) {
            v2 = o[n2](v2), settle(resolve2, reject, v2.done, v2.value);
          });
        };
      }
      function settle(resolve2, reject, d2, v2) {
        Promise.resolve(v2).then(function(v3) {
          resolve2({ value: v3, done: d2 });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw3) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw3 });
      } else {
        cooked.raw = raw3;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    };
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k2 in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k2))
            ar[ar.length] = k2;
        return ar;
      };
      return ownKeys(o);
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 = ownKeys(mod), i2 = 0;i2 < k2.length; i2++)
          if (k2[i2] !== "default")
            __createBinding(result, mod, k2[i2]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f2) {
      if (kind === "a" && !f2)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f2)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env2, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e2) {
              return Promise.reject(e2);
            }
          };
        env2.stack.push({ value, dispose, async });
      } else if (async) {
        env2.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e2 = new Error(message);
      return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
    };
    __disposeResources = function(env2) {
      function fail(e2) {
        env2.error = env2.hasError ? new _SuppressedError(e2, env2.error, "An error was suppressed during disposal.") : e2;
        env2.hasError = true;
      }
      var r3, s2 = 0;
      function next() {
        while (r3 = env2.stack.pop()) {
          try {
            if (!r3.async && s2 === 1)
              return s2 = 0, env2.stack.push(r3), Promise.resolve().then(next);
            if (r3.dispose) {
              var result = r3.dispose.call(r3.value);
              if (r3.async)
                return s2 |= 2, Promise.resolve(result).then(next, function(e2) {
                  fail(e2);
                  return next();
                });
            } else
              s2 |= 1;
          } catch (e2) {
            fail(e2);
          }
        }
        if (s2 === 1)
          return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
        if (env2.hasError)
          throw env2.error;
      }
      return next();
    };
    __rewriteRelativeImportExtension = function(path, preserveJsx) {
      if (typeof path === "string" && /^\.\.?\//.test(path)) {
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m2, tsx, d2, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d2 && (!ext || !cm) ? m2 : d2 + ext + "." + cm.toLowerCase() + "js";
        });
      }
      return path;
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
    exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);
  });
});

// ../../node_modules/@aws-sdk/core/dist-cjs/submodules/client/index.js
var require_client = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var client_exports = {};
  __export2(client_exports, {
    emitWarningIfUnsupportedVersion: () => emitWarningIfUnsupportedVersion,
    setCredentialFeature: () => setCredentialFeature,
    setFeature: () => setFeature,
    state: () => state
  });
  module.exports = __toCommonJS(client_exports);
  var state = {
    warningEmitted: false
  };
  var emitWarningIfUnsupportedVersion = /* @__PURE__ */ __name2((version) => {
    if (version && !state.warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 18) {
      state.warningEmitted = true;
      process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 16.x on January 6, 2025.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/74kJMmI`);
    }
  }, "emitWarningIfUnsupportedVersion");
  function setCredentialFeature(credentials, feature, value) {
    if (!credentials.$source) {
      credentials.$source = {};
    }
    credentials.$source[feature] = value;
    return credentials;
  }
  __name2(setCredentialFeature, "setCredentialFeature");
  function setFeature(context, feature, value) {
    if (!context.__aws_sdk_context) {
      context.__aws_sdk_context = {
        features: {}
      };
    } else if (!context.__aws_sdk_context.features) {
      context.__aws_sdk_context.features = {};
    }
    context.__aws_sdk_context.features[feature] = value;
  }
  __name2(setFeature, "setFeature");
});

// ../../node_modules/@smithy/protocol-http/dist-cjs/index.js
var require_dist_cjs2 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Field: () => Field2,
    Fields: () => Fields2,
    HttpRequest: () => HttpRequest2,
    HttpResponse: () => HttpResponse2,
    IHttpRequest: () => import_types3.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => getHttpHandlerExtensionConfiguration2,
    isValidHostname: () => isValidHostname2,
    resolveHttpHandlerRuntimeConfig: () => resolveHttpHandlerRuntimeConfig2
  });
  module.exports = __toCommonJS(src_exports);
  var getHttpHandlerExtensionConfiguration2 = /* @__PURE__ */ __name2((runtimeConfig) => {
    let httpHandler2 = runtimeConfig.httpHandler;
    return {
      setHttpHandler(handler) {
        httpHandler2 = handler;
      },
      httpHandler() {
        return httpHandler2;
      },
      updateHttpClientConfig(key, value) {
        httpHandler2.updateHttpClientConfig(key, value);
      },
      httpHandlerConfigs() {
        return httpHandler2.httpHandlerConfigs();
      }
    };
  }, "getHttpHandlerExtensionConfiguration");
  var resolveHttpHandlerRuntimeConfig2 = /* @__PURE__ */ __name2((httpHandlerExtensionConfiguration) => {
    return {
      httpHandler: httpHandlerExtensionConfiguration.httpHandler()
    };
  }, "resolveHttpHandlerRuntimeConfig");
  var import_types3 = require_dist_cjs();
  var Field2 = class {
    static {
      __name2(this, "Field");
    }
    constructor({ name, kind = import_types3.FieldPosition.HEADER, values = [] }) {
      this.name = name;
      this.kind = kind;
      this.values = values;
    }
    add(value) {
      this.values.push(value);
    }
    set(values) {
      this.values = values;
    }
    remove(value) {
      this.values = this.values.filter((v2) => v2 !== value);
    }
    toString() {
      return this.values.map((v2) => v2.includes(",") || v2.includes(" ") ? `"${v2}"` : v2).join(", ");
    }
    get() {
      return this.values;
    }
  };
  var Fields2 = class {
    constructor({ fields = [], encoding = "utf-8" }) {
      this.entries = {};
      fields.forEach(this.setField.bind(this));
      this.encoding = encoding;
    }
    static {
      __name2(this, "Fields");
    }
    setField(field) {
      this.entries[field.name.toLowerCase()] = field;
    }
    getField(name) {
      return this.entries[name.toLowerCase()];
    }
    removeField(name) {
      delete this.entries[name.toLowerCase()];
    }
    getByType(kind) {
      return Object.values(this.entries).filter((field) => field.kind === kind);
    }
  };
  var HttpRequest2 = class _HttpRequest {
    static {
      __name2(this, "HttpRequest");
    }
    constructor(options) {
      this.method = options.method || "GET";
      this.hostname = options.hostname || "localhost";
      this.port = options.port;
      this.query = options.query || {};
      this.headers = options.headers || {};
      this.body = options.body;
      this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
      this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
      this.username = options.username;
      this.password = options.password;
      this.fragment = options.fragment;
    }
    static clone(request) {
      const cloned = new _HttpRequest({
        ...request,
        headers: { ...request.headers }
      });
      if (cloned.query) {
        cloned.query = cloneQuery2(cloned.query);
      }
      return cloned;
    }
    static isInstance(request) {
      if (!request) {
        return false;
      }
      const req = request;
      return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
    }
    clone() {
      return _HttpRequest.clone(this);
    }
  };
  function cloneQuery2(query) {
    return Object.keys(query).reduce((carry, paramName) => {
      const param = query[paramName];
      return {
        ...carry,
        [paramName]: Array.isArray(param) ? [...param] : param
      };
    }, {});
  }
  __name2(cloneQuery2, "cloneQuery");
  var HttpResponse2 = class {
    static {
      __name2(this, "HttpResponse");
    }
    constructor(options) {
      this.statusCode = options.statusCode;
      this.reason = options.reason;
      this.headers = options.headers || {};
      this.body = options.body;
    }
    static isInstance(response) {
      if (!response)
        return false;
      const resp = response;
      return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
  };
  function isValidHostname2(hostname) {
    const hostPattern = /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/;
    return hostPattern.test(hostname);
  }
  __name2(isValidHostname2, "isValidHostname");
});

// ../../node_modules/@smithy/util-middleware/dist-cjs/index.js
var require_dist_cjs3 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    getSmithyContext: () => getSmithyContext,
    normalizeProvider: () => normalizeProvider
  });
  module.exports = __toCommonJS(src_exports);
  var import_types3 = require_dist_cjs();
  var getSmithyContext = /* @__PURE__ */ __name2((context) => context[import_types3.SMITHY_CONTEXT_KEY] || (context[import_types3.SMITHY_CONTEXT_KEY] = {}), "getSmithyContext");
  var normalizeProvider = /* @__PURE__ */ __name2((input) => {
    if (typeof input === "function")
      return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
  }, "normalizeProvider");
});

// ../../node_modules/@smithy/middleware-serde/dist-cjs/index.js
var require_dist_cjs4 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    deserializerMiddleware: () => deserializerMiddleware,
    deserializerMiddlewareOption: () => deserializerMiddlewareOption,
    getSerdePlugin: () => getSerdePlugin,
    serializerMiddleware: () => serializerMiddleware,
    serializerMiddlewareOption: () => serializerMiddlewareOption
  });
  module.exports = __toCommonJS(src_exports);
  var deserializerMiddleware = /* @__PURE__ */ __name2((options, deserializer) => (next) => async (args) => {
    const { response } = await next(args);
    try {
      const parsed = await deserializer(response, options);
      return {
        response,
        output: parsed
      };
    } catch (error) {
      Object.defineProperty(error, "$response", {
        value: response
      });
      if (!("$metadata" in error)) {
        const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
        error.message += `
  ` + hint;
        if (typeof error.$responseBodyText !== "undefined") {
          if (error.$response) {
            error.$response.body = error.$responseBodyText;
          }
        }
      }
      throw error;
    }
  }, "deserializerMiddleware");
  var serializerMiddleware = /* @__PURE__ */ __name2((options, serializer) => (next, context) => async (args) => {
    const endpoint = context.endpointV2?.url && options.urlParser ? async () => options.urlParser(context.endpointV2.url) : options.endpoint;
    if (!endpoint) {
      throw new Error("No valid endpoint provider available.");
    }
    const request = await serializer(args.input, { ...options, endpoint });
    return next({
      ...args,
      request
    });
  }, "serializerMiddleware");
  var deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true
  };
  var serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true
  };
  function getSerdePlugin(config2, serializer, deserializer) {
    return {
      applyToStack: (commandStack) => {
        commandStack.add(deserializerMiddleware(config2, deserializer), deserializerMiddlewareOption);
        commandStack.add(serializerMiddleware(config2, serializer), serializerMiddlewareOption);
      }
    };
  }
  __name2(getSerdePlugin, "getSerdePlugin");
});

// ../../node_modules/@smithy/is-array-buffer/dist-cjs/index.js
var require_dist_cjs5 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    isArrayBuffer: () => isArrayBuffer
  });
  module.exports = __toCommonJS(src_exports);
  var isArrayBuffer = /* @__PURE__ */ __name2((arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]", "isArrayBuffer");
});

// ../../node_modules/@smithy/util-buffer-from/dist-cjs/index.js
var require_dist_cjs6 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    fromArrayBuffer: () => fromArrayBuffer,
    fromString: () => fromString
  });
  module.exports = __toCommonJS(src_exports);
  var import_is_array_buffer = require_dist_cjs5();
  var import_buffer2 = __require("buffer");
  var fromArrayBuffer = /* @__PURE__ */ __name2((input, offset = 0, length = input.byteLength - offset) => {
    if (!(0, import_is_array_buffer.isArrayBuffer)(input)) {
      throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return import_buffer2.Buffer.from(input, offset, length);
  }, "fromArrayBuffer");
  var fromString = /* @__PURE__ */ __name2((input, encoding) => {
    if (typeof input !== "string") {
      throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? import_buffer2.Buffer.from(input, encoding) : import_buffer2.Buffer.from(input);
  }, "fromString");
});

// ../../node_modules/@smithy/util-base64/dist-cjs/fromBase64.js
var require_fromBase64 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromBase64 = undefined;
  var util_buffer_from_1 = require_dist_cjs6();
  var BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
  var fromBase643 = (input) => {
    if (input.length * 3 % 4 !== 0) {
      throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!BASE64_REGEX.exec(input)) {
      throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = (0, util_buffer_from_1.fromString)(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  };
  exports.fromBase64 = fromBase643;
});

// ../../node_modules/@smithy/util-utf8/dist-cjs/index.js
var require_dist_cjs7 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    fromUtf8: () => fromUtf8,
    toUint8Array: () => toUint8Array,
    toUtf8: () => toUtf8
  });
  module.exports = __toCommonJS(src_exports);
  var import_util_buffer_from = require_dist_cjs6();
  var fromUtf8 = /* @__PURE__ */ __name2((input) => {
    const buf = (0, import_util_buffer_from.fromString)(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }, "fromUtf8");
  var toUint8Array = /* @__PURE__ */ __name2((data) => {
    if (typeof data === "string") {
      return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
  }, "toUint8Array");
  var toUtf8 = /* @__PURE__ */ __name2((input) => {
    if (typeof input === "string") {
      return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
      throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return (0, import_util_buffer_from.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
  }, "toUtf8");
});

// ../../node_modules/@smithy/util-base64/dist-cjs/toBase64.js
var require_toBase64 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toBase64 = undefined;
  var util_buffer_from_1 = require_dist_cjs6();
  var util_utf8_1 = require_dist_cjs7();
  var toBase643 = (_input) => {
    let input;
    if (typeof _input === "string") {
      input = (0, util_utf8_1.fromUtf8)(_input);
    } else {
      input = _input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
      throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
    }
    return (0, util_buffer_from_1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("base64");
  };
  exports.toBase64 = toBase643;
});

// ../../node_modules/@smithy/util-base64/dist-cjs/index.js
var require_dist_cjs8 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  module.exports = __toCommonJS(src_exports);
  __reExport(src_exports, require_fromBase64(), module.exports);
  __reExport(src_exports, require_toBase64(), module.exports);
});

// ../../node_modules/@smithy/util-stream/dist-cjs/getAwsChunkedEncodingStream.js
var require_getAwsChunkedEncodingStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getAwsChunkedEncodingStream = undefined;
  var stream_1 = __require("stream");
  var getAwsChunkedEncodingStream2 = (readableStream, options) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined && checksumAlgorithmFn !== undefined && checksumLocationName !== undefined && streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const awsChunkedEncodingStream = new stream_1.Readable({ read: () => {
    } });
    readableStream.on("data", (data) => {
      const length = bodyLengthChecker(data) || 0;
      awsChunkedEncodingStream.push(`${length.toString(16)}\r
`);
      awsChunkedEncodingStream.push(data);
      awsChunkedEncodingStream.push(`\r
`);
    });
    readableStream.on("end", async () => {
      awsChunkedEncodingStream.push(`0\r
`);
      if (checksumRequired) {
        const checksum = base64Encoder(await digest);
        awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r
`);
        awsChunkedEncodingStream.push(`\r
`);
      }
      awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
  };
  exports.getAwsChunkedEncodingStream = getAwsChunkedEncodingStream2;
});

// ../../node_modules/@smithy/util-uri-escape/dist-cjs/index.js
var require_dist_cjs9 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    escapeUri: () => escapeUri,
    escapeUriPath: () => escapeUriPath
  });
  module.exports = __toCommonJS(src_exports);
  var escapeUri = /* @__PURE__ */ __name2((uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode), "escapeUri");
  var hexEncode = /* @__PURE__ */ __name2((c3) => `%${c3.charCodeAt(0).toString(16).toUpperCase()}`, "hexEncode");
  var escapeUriPath = /* @__PURE__ */ __name2((uri) => uri.split("/").map(escapeUri).join("/"), "escapeUriPath");
});

// ../../node_modules/@smithy/querystring-builder/dist-cjs/index.js
var require_dist_cjs10 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    buildQueryString: () => buildQueryString
  });
  module.exports = __toCommonJS(src_exports);
  var import_util_uri_escape = require_dist_cjs9();
  function buildQueryString(query) {
    const parts = [];
    for (let key of Object.keys(query).sort()) {
      const value = query[key];
      key = (0, import_util_uri_escape.escapeUri)(key);
      if (Array.isArray(value)) {
        for (let i2 = 0, iLen = value.length;i2 < iLen; i2++) {
          parts.push(`${key}=${(0, import_util_uri_escape.escapeUri)(value[i2])}`);
        }
      } else {
        let qsEntry = key;
        if (value || typeof value === "string") {
          qsEntry += `=${(0, import_util_uri_escape.escapeUri)(value)}`;
        }
        parts.push(qsEntry);
      }
    }
    return parts.join("&");
  }
  __name2(buildQueryString, "buildQueryString");
});

// ../../node_modules/@smithy/node-http-handler/dist-cjs/index.js
var require_dist_cjs11 = __commonJS((exports, module) => {
  var __create2 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp3(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    DEFAULT_REQUEST_TIMEOUT: () => DEFAULT_REQUEST_TIMEOUT,
    NodeHttp2Handler: () => NodeHttp2Handler,
    NodeHttpHandler: () => NodeHttpHandler,
    streamCollector: () => streamCollector
  });
  module.exports = __toCommonJS(src_exports);
  var import_protocol_http2 = require_dist_cjs2();
  var import_querystring_builder = require_dist_cjs10();
  var import_http = __require("http");
  var import_https = __require("https");
  var NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];
  var getTransformedHeaders = /* @__PURE__ */ __name2((headers) => {
    const transformedHeaders = {};
    for (const name of Object.keys(headers)) {
      const headerValues = headers[name];
      transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
    }
    return transformedHeaders;
  }, "getTransformedHeaders");
  var timing = {
    setTimeout: (cb, ms) => setTimeout(cb, ms),
    clearTimeout: (timeoutId) => clearTimeout(timeoutId)
  };
  var DEFER_EVENT_LISTENER_TIME = 1000;
  var setConnectionTimeout = /* @__PURE__ */ __name2((request, reject, timeoutInMs = 0) => {
    if (!timeoutInMs) {
      return -1;
    }
    const registerTimeout = /* @__PURE__ */ __name2((offset) => {
      const timeoutId = timing.setTimeout(() => {
        request.destroy();
        reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
          name: "TimeoutError"
        }));
      }, timeoutInMs - offset);
      const doWithSocket = /* @__PURE__ */ __name2((socket) => {
        if (socket?.connecting) {
          socket.on("connect", () => {
            timing.clearTimeout(timeoutId);
          });
        } else {
          timing.clearTimeout(timeoutId);
        }
      }, "doWithSocket");
      if (request.socket) {
        doWithSocket(request.socket);
      } else {
        request.on("socket", doWithSocket);
      }
    }, "registerTimeout");
    if (timeoutInMs < 2000) {
      registerTimeout(0);
      return 0;
    }
    return timing.setTimeout(registerTimeout.bind(null, DEFER_EVENT_LISTENER_TIME), DEFER_EVENT_LISTENER_TIME);
  }, "setConnectionTimeout");
  var DEFER_EVENT_LISTENER_TIME2 = 3000;
  var setSocketKeepAlive = /* @__PURE__ */ __name2((request, { keepAlive, keepAliveMsecs }, deferTimeMs = DEFER_EVENT_LISTENER_TIME2) => {
    if (keepAlive !== true) {
      return -1;
    }
    const registerListener = /* @__PURE__ */ __name2(() => {
      if (request.socket) {
        request.socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
      } else {
        request.on("socket", (socket) => {
          socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
        });
      }
    }, "registerListener");
    if (deferTimeMs === 0) {
      registerListener();
      return 0;
    }
    return timing.setTimeout(registerListener, deferTimeMs);
  }, "setSocketKeepAlive");
  var DEFER_EVENT_LISTENER_TIME3 = 3000;
  var setSocketTimeout = /* @__PURE__ */ __name2((request, reject, timeoutInMs = DEFAULT_REQUEST_TIMEOUT) => {
    const registerTimeout = /* @__PURE__ */ __name2((offset) => {
      const timeout = timeoutInMs - offset;
      const onTimeout = /* @__PURE__ */ __name2(() => {
        request.destroy();
        reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
      }, "onTimeout");
      if (request.socket) {
        request.socket.setTimeout(timeout, onTimeout);
      } else {
        request.setTimeout(timeout, onTimeout);
      }
    }, "registerTimeout");
    if (0 < timeoutInMs && timeoutInMs < 6000) {
      registerTimeout(0);
      return 0;
    }
    return timing.setTimeout(registerTimeout.bind(null, timeoutInMs === 0 ? 0 : DEFER_EVENT_LISTENER_TIME3), DEFER_EVENT_LISTENER_TIME3);
  }, "setSocketTimeout");
  var import_stream = __require("stream");
  var MIN_WAIT_TIME = 6000;
  async function writeRequestBody(httpRequest2, request, maxContinueTimeoutMs = MIN_WAIT_TIME) {
    const headers = request.headers ?? {};
    const expect = headers["Expect"] || headers["expect"];
    let timeoutId = -1;
    let sendBody = true;
    if (expect === "100-continue") {
      sendBody = await Promise.race([
        new Promise((resolve2) => {
          timeoutId = Number(timing.setTimeout(() => resolve2(true), Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
        }),
        new Promise((resolve2) => {
          httpRequest2.on("continue", () => {
            timing.clearTimeout(timeoutId);
            resolve2(true);
          });
          httpRequest2.on("response", () => {
            timing.clearTimeout(timeoutId);
            resolve2(false);
          });
          httpRequest2.on("error", () => {
            timing.clearTimeout(timeoutId);
            resolve2(false);
          });
        })
      ]);
    }
    if (sendBody) {
      writeBody(httpRequest2, request.body);
    }
  }
  __name2(writeRequestBody, "writeRequestBody");
  function writeBody(httpRequest2, body) {
    if (body instanceof import_stream.Readable) {
      body.pipe(httpRequest2);
      return;
    }
    if (body) {
      if (Buffer.isBuffer(body) || typeof body === "string") {
        httpRequest2.end(body);
        return;
      }
      const uint8 = body;
      if (typeof uint8 === "object" && uint8.buffer && typeof uint8.byteOffset === "number" && typeof uint8.byteLength === "number") {
        httpRequest2.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
        return;
      }
      httpRequest2.end(Buffer.from(body));
      return;
    }
    httpRequest2.end();
  }
  __name2(writeBody, "writeBody");
  var DEFAULT_REQUEST_TIMEOUT = 0;
  var NodeHttpHandler = class _NodeHttpHandler {
    constructor(options) {
      this.socketWarningTimestamp = 0;
      this.metadata = { handlerProtocol: "http/1.1" };
      this.configProvider = new Promise((resolve2, reject) => {
        if (typeof options === "function") {
          options().then((_options) => {
            resolve2(this.resolveDefaultConfig(_options));
          }).catch(reject);
        } else {
          resolve2(this.resolveDefaultConfig(options));
        }
      });
    }
    static {
      __name2(this, "NodeHttpHandler");
    }
    static create(instanceOrOptions) {
      if (typeof instanceOrOptions?.handle === "function") {
        return instanceOrOptions;
      }
      return new _NodeHttpHandler(instanceOrOptions);
    }
    static checkSocketUsage(agent, socketWarningTimestamp, logger = console) {
      const { sockets, requests, maxSockets } = agent;
      if (typeof maxSockets !== "number" || maxSockets === Infinity) {
        return socketWarningTimestamp;
      }
      const interval = 15000;
      if (Date.now() - interval < socketWarningTimestamp) {
        return socketWarningTimestamp;
      }
      if (sockets && requests) {
        for (const origin in sockets) {
          const socketsInUse = sockets[origin]?.length ?? 0;
          const requestsEnqueued = requests[origin]?.length ?? 0;
          if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
            logger?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`);
            return Date.now();
          }
        }
      }
      return socketWarningTimestamp;
    }
    resolveDefaultConfig(options) {
      const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
      const keepAlive = true;
      const maxSockets = 50;
      return {
        connectionTimeout,
        requestTimeout: requestTimeout ?? socketTimeout,
        httpAgent: (() => {
          if (httpAgent instanceof import_http.Agent || typeof httpAgent?.destroy === "function") {
            return httpAgent;
          }
          return new import_http.Agent({ keepAlive, maxSockets, ...httpAgent });
        })(),
        httpsAgent: (() => {
          if (httpsAgent instanceof import_https.Agent || typeof httpsAgent?.destroy === "function") {
            return httpsAgent;
          }
          return new import_https.Agent({ keepAlive, maxSockets, ...httpsAgent });
        })(),
        logger: console
      };
    }
    destroy() {
      this.config?.httpAgent?.destroy();
      this.config?.httpsAgent?.destroy();
    }
    async handle(request, { abortSignal } = {}) {
      if (!this.config) {
        this.config = await this.configProvider;
      }
      return new Promise((_resolve, _reject) => {
        let writeRequestBodyPromise = undefined;
        const timeouts = [];
        const resolve2 = /* @__PURE__ */ __name2(async (arg) => {
          await writeRequestBodyPromise;
          timeouts.forEach(timing.clearTimeout);
          _resolve(arg);
        }, "resolve");
        const reject = /* @__PURE__ */ __name2(async (arg) => {
          await writeRequestBodyPromise;
          timeouts.forEach(timing.clearTimeout);
          _reject(arg);
        }, "reject");
        if (!this.config) {
          throw new Error("Node HTTP request handler config is not resolved");
        }
        if (abortSignal?.aborted) {
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
          return;
        }
        const isSSL = request.protocol === "https:";
        const agent = isSSL ? this.config.httpsAgent : this.config.httpAgent;
        timeouts.push(timing.setTimeout(() => {
          this.socketWarningTimestamp = _NodeHttpHandler.checkSocketUsage(agent, this.socketWarningTimestamp, this.config.logger);
        }, this.config.socketAcquisitionWarningTimeout ?? (this.config.requestTimeout ?? 2000) + (this.config.connectionTimeout ?? 1000)));
        const queryString = (0, import_querystring_builder.buildQueryString)(request.query || {});
        let auth = undefined;
        if (request.username != null || request.password != null) {
          const username = request.username ?? "";
          const password = request.password ?? "";
          auth = `${username}:${password}`;
        }
        let path = request.path;
        if (queryString) {
          path += `?${queryString}`;
        }
        if (request.fragment) {
          path += `#${request.fragment}`;
        }
        let hostname = request.hostname ?? "";
        if (hostname[0] === "[" && hostname.endsWith("]")) {
          hostname = request.hostname.slice(1, -1);
        } else {
          hostname = request.hostname;
        }
        const nodeHttpsOptions = {
          headers: request.headers,
          host: hostname,
          method: request.method,
          path,
          port: request.port,
          agent,
          auth
        };
        const requestFunc = isSSL ? import_https.request : import_http.request;
        const req = requestFunc(nodeHttpsOptions, (res) => {
          const httpResponse2 = new import_protocol_http2.HttpResponse({
            statusCode: res.statusCode || -1,
            reason: res.statusMessage,
            headers: getTransformedHeaders(res.headers),
            body: res
          });
          resolve2({ response: httpResponse2 });
        });
        req.on("error", (err) => {
          if (NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
            reject(Object.assign(err, { name: "TimeoutError" }));
          } else {
            reject(err);
          }
        });
        if (abortSignal) {
          const onAbort = /* @__PURE__ */ __name2(() => {
            req.destroy();
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            reject(abortError);
          }, "onAbort");
          if (typeof abortSignal.addEventListener === "function") {
            const signal = abortSignal;
            signal.addEventListener("abort", onAbort, { once: true });
            req.once("close", () => signal.removeEventListener("abort", onAbort));
          } else {
            abortSignal.onabort = onAbort;
          }
        }
        timeouts.push(setConnectionTimeout(req, reject, this.config.connectionTimeout));
        timeouts.push(setSocketTimeout(req, reject, this.config.requestTimeout));
        const httpAgent = nodeHttpsOptions.agent;
        if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
          timeouts.push(setSocketKeepAlive(req, {
            keepAlive: httpAgent.keepAlive,
            keepAliveMsecs: httpAgent.keepAliveMsecs
          }));
        }
        writeRequestBodyPromise = writeRequestBody(req, request, this.config.requestTimeout).catch((e2) => {
          timeouts.forEach(timing.clearTimeout);
          return _reject(e2);
        });
      });
    }
    updateHttpClientConfig(key, value) {
      this.config = undefined;
      this.configProvider = this.configProvider.then((config2) => {
        return {
          ...config2,
          [key]: value
        };
      });
    }
    httpHandlerConfigs() {
      return this.config ?? {};
    }
  };
  var import_http22 = __require("http2");
  var import_http2 = __toESM2(__require("http2"));
  var NodeHttp2ConnectionPool = class {
    constructor(sessions) {
      this.sessions = [];
      this.sessions = sessions ?? [];
    }
    static {
      __name2(this, "NodeHttp2ConnectionPool");
    }
    poll() {
      if (this.sessions.length > 0) {
        return this.sessions.shift();
      }
    }
    offerLast(session) {
      this.sessions.push(session);
    }
    contains(session) {
      return this.sessions.includes(session);
    }
    remove(session) {
      this.sessions = this.sessions.filter((s2) => s2 !== session);
    }
    [Symbol.iterator]() {
      return this.sessions[Symbol.iterator]();
    }
    destroy(connection) {
      for (const session of this.sessions) {
        if (session === connection) {
          if (!session.destroyed) {
            session.destroy();
          }
        }
      }
    }
  };
  var NodeHttp2ConnectionManager = class {
    constructor(config2) {
      this.sessionCache = /* @__PURE__ */ new Map;
      this.config = config2;
      if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
        throw new RangeError("maxConcurrency must be greater than zero.");
      }
    }
    static {
      __name2(this, "NodeHttp2ConnectionManager");
    }
    lease(requestContext, connectionConfiguration) {
      const url = this.getUrlString(requestContext);
      const existingPool = this.sessionCache.get(url);
      if (existingPool) {
        const existingSession = existingPool.poll();
        if (existingSession && !this.config.disableConcurrency) {
          return existingSession;
        }
      }
      const session = import_http2.default.connect(url);
      if (this.config.maxConcurrency) {
        session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
          if (err) {
            throw new Error("Fail to set maxConcurrentStreams to " + this.config.maxConcurrency + "when creating new session for " + requestContext.destination.toString());
          }
        });
      }
      session.unref();
      const destroySessionCb = /* @__PURE__ */ __name2(() => {
        session.destroy();
        this.deleteSession(url, session);
      }, "destroySessionCb");
      session.on("goaway", destroySessionCb);
      session.on("error", destroySessionCb);
      session.on("frameError", destroySessionCb);
      session.on("close", () => this.deleteSession(url, session));
      if (connectionConfiguration.requestTimeout) {
        session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
      }
      const connectionPool = this.sessionCache.get(url) || new NodeHttp2ConnectionPool;
      connectionPool.offerLast(session);
      this.sessionCache.set(url, connectionPool);
      return session;
    }
    deleteSession(authority, session) {
      const existingConnectionPool = this.sessionCache.get(authority);
      if (!existingConnectionPool) {
        return;
      }
      if (!existingConnectionPool.contains(session)) {
        return;
      }
      existingConnectionPool.remove(session);
      this.sessionCache.set(authority, existingConnectionPool);
    }
    release(requestContext, session) {
      const cacheKey = this.getUrlString(requestContext);
      this.sessionCache.get(cacheKey)?.offerLast(session);
    }
    destroy() {
      for (const [key, connectionPool] of this.sessionCache) {
        for (const session of connectionPool) {
          if (!session.destroyed) {
            session.destroy();
          }
          connectionPool.remove(session);
        }
        this.sessionCache.delete(key);
      }
    }
    setMaxConcurrentStreams(maxConcurrentStreams) {
      if (maxConcurrentStreams && maxConcurrentStreams <= 0) {
        throw new RangeError("maxConcurrentStreams must be greater than zero.");
      }
      this.config.maxConcurrency = maxConcurrentStreams;
    }
    setDisableConcurrentStreams(disableConcurrentStreams) {
      this.config.disableConcurrency = disableConcurrentStreams;
    }
    getUrlString(request) {
      return request.destination.toString();
    }
  };
  var NodeHttp2Handler = class _NodeHttp2Handler {
    constructor(options) {
      this.metadata = { handlerProtocol: "h2" };
      this.connectionManager = new NodeHttp2ConnectionManager({});
      this.configProvider = new Promise((resolve2, reject) => {
        if (typeof options === "function") {
          options().then((opts) => {
            resolve2(opts || {});
          }).catch(reject);
        } else {
          resolve2(options || {});
        }
      });
    }
    static {
      __name2(this, "NodeHttp2Handler");
    }
    static create(instanceOrOptions) {
      if (typeof instanceOrOptions?.handle === "function") {
        return instanceOrOptions;
      }
      return new _NodeHttp2Handler(instanceOrOptions);
    }
    destroy() {
      this.connectionManager.destroy();
    }
    async handle(request, { abortSignal } = {}) {
      if (!this.config) {
        this.config = await this.configProvider;
        this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
        if (this.config.maxConcurrentStreams) {
          this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
        }
      }
      const { requestTimeout, disableConcurrentStreams } = this.config;
      return new Promise((_resolve, _reject) => {
        let fulfilled = false;
        let writeRequestBodyPromise = undefined;
        const resolve2 = /* @__PURE__ */ __name2(async (arg) => {
          await writeRequestBodyPromise;
          _resolve(arg);
        }, "resolve");
        const reject = /* @__PURE__ */ __name2(async (arg) => {
          await writeRequestBodyPromise;
          _reject(arg);
        }, "reject");
        if (abortSignal?.aborted) {
          fulfilled = true;
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
          return;
        }
        const { hostname, method, port, protocol, query } = request;
        let auth = "";
        if (request.username != null || request.password != null) {
          const username = request.username ?? "";
          const password = request.password ?? "";
          auth = `${username}:${password}@`;
        }
        const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
        const requestContext = { destination: new URL(authority) };
        const session = this.connectionManager.lease(requestContext, {
          requestTimeout: this.config?.sessionTimeout,
          disableConcurrentStreams: disableConcurrentStreams || false
        });
        const rejectWithDestroy = /* @__PURE__ */ __name2((err) => {
          if (disableConcurrentStreams) {
            this.destroySession(session);
          }
          fulfilled = true;
          reject(err);
        }, "rejectWithDestroy");
        const queryString = (0, import_querystring_builder.buildQueryString)(query || {});
        let path = request.path;
        if (queryString) {
          path += `?${queryString}`;
        }
        if (request.fragment) {
          path += `#${request.fragment}`;
        }
        const req = session.request({
          ...request.headers,
          [import_http22.constants.HTTP2_HEADER_PATH]: path,
          [import_http22.constants.HTTP2_HEADER_METHOD]: method
        });
        session.ref();
        req.on("response", (headers) => {
          const httpResponse2 = new import_protocol_http2.HttpResponse({
            statusCode: headers[":status"] || -1,
            headers: getTransformedHeaders(headers),
            body: req
          });
          fulfilled = true;
          resolve2({ response: httpResponse2 });
          if (disableConcurrentStreams) {
            session.close();
            this.connectionManager.deleteSession(authority, session);
          }
        });
        if (requestTimeout) {
          req.setTimeout(requestTimeout, () => {
            req.close();
            const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);
            timeoutError.name = "TimeoutError";
            rejectWithDestroy(timeoutError);
          });
        }
        if (abortSignal) {
          const onAbort = /* @__PURE__ */ __name2(() => {
            req.close();
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            rejectWithDestroy(abortError);
          }, "onAbort");
          if (typeof abortSignal.addEventListener === "function") {
            const signal = abortSignal;
            signal.addEventListener("abort", onAbort, { once: true });
            req.once("close", () => signal.removeEventListener("abort", onAbort));
          } else {
            abortSignal.onabort = onAbort;
          }
        }
        req.on("frameError", (type, code, id) => {
          rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
        });
        req.on("error", rejectWithDestroy);
        req.on("aborted", () => {
          rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
        });
        req.on("close", () => {
          session.unref();
          if (disableConcurrentStreams) {
            session.destroy();
          }
          if (!fulfilled) {
            rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
          }
        });
        writeRequestBodyPromise = writeRequestBody(req, request, requestTimeout);
      });
    }
    updateHttpClientConfig(key, value) {
      this.config = undefined;
      this.configProvider = this.configProvider.then((config2) => {
        return {
          ...config2,
          [key]: value
        };
      });
    }
    httpHandlerConfigs() {
      return this.config ?? {};
    }
    destroySession(session) {
      if (!session.destroyed) {
        session.destroy();
      }
    }
  };
  var Collector = class extends import_stream.Writable {
    constructor() {
      super(...arguments);
      this.bufferedBytes = [];
    }
    static {
      __name2(this, "Collector");
    }
    _write(chunk, encoding, callback) {
      this.bufferedBytes.push(chunk);
      callback();
    }
  };
  var streamCollector = /* @__PURE__ */ __name2((stream) => {
    if (isReadableStreamInstance(stream)) {
      return collectReadableStream(stream);
    }
    return new Promise((resolve2, reject) => {
      const collector = new Collector;
      stream.pipe(collector);
      stream.on("error", (err) => {
        collector.end();
        reject(err);
      });
      collector.on("error", reject);
      collector.on("finish", function() {
        const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
        resolve2(bytes);
      });
    });
  }, "streamCollector");
  var isReadableStreamInstance = /* @__PURE__ */ __name2((stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream, "isReadableStreamInstance");
  async function collectReadableStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
      const { done, value } = await reader.read();
      if (value) {
        chunks.push(value);
        length += value.length;
      }
      isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
      collected.set(chunk, offset);
      offset += chunk.length;
    }
    return collected;
  }
  __name2(collectReadableStream, "collectReadableStream");
});

// ../../node_modules/@smithy/fetch-http-handler/dist-cjs/index.js
var require_dist_cjs12 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    FetchHttpHandler: () => FetchHttpHandler,
    keepAliveSupport: () => keepAliveSupport,
    streamCollector: () => streamCollector
  });
  module.exports = __toCommonJS(src_exports);
  var import_protocol_http2 = require_dist_cjs2();
  var import_querystring_builder = require_dist_cjs10();
  function createRequest(url, requestOptions) {
    return new Request(url, requestOptions);
  }
  __name2(createRequest, "createRequest");
  function requestTimeout(timeoutInMs = 0) {
    return new Promise((resolve2, reject) => {
      if (timeoutInMs) {
        setTimeout(() => {
          const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
          timeoutError.name = "TimeoutError";
          reject(timeoutError);
        }, timeoutInMs);
      }
    });
  }
  __name2(requestTimeout, "requestTimeout");
  var keepAliveSupport = {
    supported: undefined
  };
  var FetchHttpHandler = class _FetchHttpHandler {
    static {
      __name2(this, "FetchHttpHandler");
    }
    static create(instanceOrOptions) {
      if (typeof instanceOrOptions?.handle === "function") {
        return instanceOrOptions;
      }
      return new _FetchHttpHandler(instanceOrOptions);
    }
    constructor(options) {
      if (typeof options === "function") {
        this.configProvider = options().then((opts) => opts || {});
      } else {
        this.config = options ?? {};
        this.configProvider = Promise.resolve(this.config);
      }
      if (keepAliveSupport.supported === undefined) {
        keepAliveSupport.supported = Boolean(typeof Request !== "undefined" && "keepalive" in createRequest("https://[::1]"));
      }
    }
    destroy() {
    }
    async handle(request, { abortSignal } = {}) {
      if (!this.config) {
        this.config = await this.configProvider;
      }
      const requestTimeoutInMs = this.config.requestTimeout;
      const keepAlive = this.config.keepAlive === true;
      const credentials = this.config.credentials;
      if (abortSignal?.aborted) {
        const abortError = new Error("Request aborted");
        abortError.name = "AbortError";
        return Promise.reject(abortError);
      }
      let path = request.path;
      const queryString = (0, import_querystring_builder.buildQueryString)(request.query || {});
      if (queryString) {
        path += `?${queryString}`;
      }
      if (request.fragment) {
        path += `#${request.fragment}`;
      }
      let auth = "";
      if (request.username != null || request.password != null) {
        const username = request.username ?? "";
        const password = request.password ?? "";
        auth = `${username}:${password}@`;
      }
      const { port, method } = request;
      const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
      const body = method === "GET" || method === "HEAD" ? undefined : request.body;
      const requestOptions = {
        body,
        headers: new Headers(request.headers),
        method,
        credentials
      };
      if (this.config?.cache) {
        requestOptions.cache = this.config.cache;
      }
      if (body) {
        requestOptions.duplex = "half";
      }
      if (typeof AbortController !== "undefined") {
        requestOptions.signal = abortSignal;
      }
      if (keepAliveSupport.supported) {
        requestOptions.keepalive = keepAlive;
      }
      if (typeof this.config.requestInit === "function") {
        Object.assign(requestOptions, this.config.requestInit(request));
      }
      let removeSignalEventListener = /* @__PURE__ */ __name2(() => {
      }, "removeSignalEventListener");
      const fetchRequest = createRequest(url, requestOptions);
      const raceOfPromises = [
        fetch(fetchRequest).then((response) => {
          const fetchHeaders = response.headers;
          const transformedHeaders = {};
          for (const pair of fetchHeaders.entries()) {
            transformedHeaders[pair[0]] = pair[1];
          }
          const hasReadableStream = response.body != null;
          if (!hasReadableStream) {
            return response.blob().then((body2) => ({
              response: new import_protocol_http2.HttpResponse({
                headers: transformedHeaders,
                reason: response.statusText,
                statusCode: response.status,
                body: body2
              })
            }));
          }
          return {
            response: new import_protocol_http2.HttpResponse({
              headers: transformedHeaders,
              reason: response.statusText,
              statusCode: response.status,
              body: response.body
            })
          };
        }),
        requestTimeout(requestTimeoutInMs)
      ];
      if (abortSignal) {
        raceOfPromises.push(new Promise((resolve2, reject) => {
          const onAbort = /* @__PURE__ */ __name2(() => {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            reject(abortError);
          }, "onAbort");
          if (typeof abortSignal.addEventListener === "function") {
            const signal = abortSignal;
            signal.addEventListener("abort", onAbort, { once: true });
            removeSignalEventListener = /* @__PURE__ */ __name2(() => signal.removeEventListener("abort", onAbort), "removeSignalEventListener");
          } else {
            abortSignal.onabort = onAbort;
          }
        }));
      }
      return Promise.race(raceOfPromises).finally(removeSignalEventListener);
    }
    updateHttpClientConfig(key, value) {
      this.config = undefined;
      this.configProvider = this.configProvider.then((config2) => {
        config2[key] = value;
        return config2;
      });
    }
    httpHandlerConfigs() {
      return this.config ?? {};
    }
  };
  var import_util_base64 = require_dist_cjs8();
  var streamCollector = /* @__PURE__ */ __name2(async (stream) => {
    if (typeof Blob === "function" && stream instanceof Blob || stream.constructor?.name === "Blob") {
      if (Blob.prototype.arrayBuffer !== undefined) {
        return new Uint8Array(await stream.arrayBuffer());
      }
      return collectBlob(stream);
    }
    return collectStream(stream);
  }, "streamCollector");
  async function collectBlob(blob) {
    const base642 = await readToBase64(blob);
    const arrayBuffer = (0, import_util_base64.fromBase64)(base642);
    return new Uint8Array(arrayBuffer);
  }
  __name2(collectBlob, "collectBlob");
  async function collectStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
      const { done, value } = await reader.read();
      if (value) {
        chunks.push(value);
        length += value.length;
      }
      isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
      collected.set(chunk, offset);
      offset += chunk.length;
    }
    return collected;
  }
  __name2(collectStream, "collectStream");
  function readToBase64(blob) {
    return new Promise((resolve2, reject) => {
      const reader = new FileReader;
      reader.onloadend = () => {
        if (reader.readyState !== 2) {
          return reject(new Error("Reader aborted too early"));
        }
        const result = reader.result ?? "";
        const commaIndex = result.indexOf(",");
        const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
        resolve2(result.substring(dataOffset));
      };
      reader.onabort = () => reject(new Error("Read aborted"));
      reader.onerror = () => reject(reader.error);
      reader.readAsDataURL(blob);
    });
  }
  __name2(readToBase64, "readToBase64");
});

// ../../node_modules/@smithy/util-hex-encoding/dist-cjs/index.js
var require_dist_cjs13 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    fromHex: () => fromHex,
    toHex: () => toHex
  });
  module.exports = __toCommonJS(src_exports);
  var SHORT_TO_HEX = {};
  var HEX_TO_SHORT = {};
  for (let i2 = 0;i2 < 256; i2++) {
    let encodedByte = i2.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
      encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i2] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i2;
  }
  function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
      throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i2 = 0;i2 < encoded.length; i2 += 2) {
      const encodedByte = encoded.slice(i2, i2 + 2).toLowerCase();
      if (encodedByte in HEX_TO_SHORT) {
        out[i2 / 2] = HEX_TO_SHORT[encodedByte];
      } else {
        throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
      }
    }
    return out;
  }
  __name2(fromHex, "fromHex");
  function toHex(bytes) {
    let out = "";
    for (let i2 = 0;i2 < bytes.byteLength; i2++) {
      out += SHORT_TO_HEX[bytes[i2]];
    }
    return out;
  }
  __name2(toHex, "toHex");
});

// ../../node_modules/@smithy/util-stream/dist-cjs/stream-type-check.js
var require_stream_type_check = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isBlob = exports.isReadableStream = undefined;
  var isReadableStream2 = (stream) => {
    var _a2;
    return typeof ReadableStream === "function" && (((_a2 = stream === null || stream === undefined ? undefined : stream.constructor) === null || _a2 === undefined ? undefined : _a2.name) === ReadableStream.name || stream instanceof ReadableStream);
  };
  exports.isReadableStream = isReadableStream2;
  var isBlob2 = (blob) => {
    var _a2;
    return typeof Blob === "function" && (((_a2 = blob === null || blob === undefined ? undefined : blob.constructor) === null || _a2 === undefined ? undefined : _a2.name) === Blob.name || blob instanceof Blob);
  };
  exports.isBlob = isBlob2;
});

// ../../node_modules/@smithy/util-stream/dist-cjs/sdk-stream-mixin.browser.js
var require_sdk_stream_mixin_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sdkStreamMixin = undefined;
  var fetch_http_handler_1 = require_dist_cjs12();
  var util_base64_1 = require_dist_cjs8();
  var util_hex_encoding_1 = require_dist_cjs13();
  var util_utf8_1 = require_dist_cjs7();
  var stream_type_check_1 = require_stream_type_check();
  var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
  var sdkStreamMixin2 = (stream) => {
    var _a2, _b2;
    if (!isBlobInstance(stream) && !(0, stream_type_check_1.isReadableStream)(stream)) {
      const name = ((_b2 = (_a2 = stream === null || stream === undefined ? undefined : stream.__proto__) === null || _a2 === undefined ? undefined : _a2.constructor) === null || _b2 === undefined ? undefined : _b2.name) || stream;
      throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async () => {
      if (transformed) {
        throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
      }
      transformed = true;
      return await (0, fetch_http_handler_1.streamCollector)(stream);
    };
    const blobToWebStream = (blob) => {
      if (typeof blob.stream !== "function") {
        throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
` + "If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
      }
      return blob.stream();
    };
    return Object.assign(stream, {
      transformToByteArray,
      transformToString: async (encoding) => {
        const buf = await transformToByteArray();
        if (encoding === "base64") {
          return (0, util_base64_1.toBase64)(buf);
        } else if (encoding === "hex") {
          return (0, util_hex_encoding_1.toHex)(buf);
        } else if (encoding === undefined || encoding === "utf8" || encoding === "utf-8") {
          return (0, util_utf8_1.toUtf8)(buf);
        } else if (typeof TextDecoder === "function") {
          return new TextDecoder(encoding).decode(buf);
        } else {
          throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
        }
      },
      transformToWebStream: () => {
        if (transformed) {
          throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        if (isBlobInstance(stream)) {
          return blobToWebStream(stream);
        } else if ((0, stream_type_check_1.isReadableStream)(stream)) {
          return stream;
        } else {
          throw new Error(`Cannot transform payload to web stream, got ${stream}`);
        }
      }
    });
  };
  exports.sdkStreamMixin = sdkStreamMixin2;
  var isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;
});

// ../../node_modules/@smithy/util-stream/dist-cjs/sdk-stream-mixin.js
var require_sdk_stream_mixin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sdkStreamMixin = undefined;
  var node_http_handler_1 = require_dist_cjs11();
  var util_buffer_from_1 = require_dist_cjs6();
  var stream_1 = __require("stream");
  var sdk_stream_mixin_browser_1 = require_sdk_stream_mixin_browser();
  var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
  var sdkStreamMixin2 = (stream) => {
    var _a2, _b2;
    if (!(stream instanceof stream_1.Readable)) {
      try {
        return (0, sdk_stream_mixin_browser_1.sdkStreamMixin)(stream);
      } catch (e2) {
        const name = ((_b2 = (_a2 = stream === null || stream === undefined ? undefined : stream.__proto__) === null || _a2 === undefined ? undefined : _a2.constructor) === null || _b2 === undefined ? undefined : _b2.name) || stream;
        throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
      }
    }
    let transformed = false;
    const transformToByteArray = async () => {
      if (transformed) {
        throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
      }
      transformed = true;
      return await (0, node_http_handler_1.streamCollector)(stream);
    };
    return Object.assign(stream, {
      transformToByteArray,
      transformToString: async (encoding) => {
        const buf = await transformToByteArray();
        if (encoding === undefined || Buffer.isEncoding(encoding)) {
          return (0, util_buffer_from_1.fromArrayBuffer)(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
        } else {
          const decoder = new TextDecoder(encoding);
          return decoder.decode(buf);
        }
      },
      transformToWebStream: () => {
        if (transformed) {
          throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        if (stream.readableFlowing !== null) {
          throw new Error("The stream has been consumed by other callbacks.");
        }
        if (typeof stream_1.Readable.toWeb !== "function") {
          throw new Error("Readable.toWeb() is not supported. Please ensure a polyfill is available.");
        }
        transformed = true;
        return stream_1.Readable.toWeb(stream);
      }
    });
  };
  exports.sdkStreamMixin = sdkStreamMixin2;
});

// ../../node_modules/@smithy/util-stream/dist-cjs/splitStream.browser.js
var require_splitStream_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.splitStream = undefined;
  async function splitStream2(stream) {
    if (typeof stream.stream === "function") {
      stream = stream.stream();
    }
    const readableStream = stream;
    return readableStream.tee();
  }
  exports.splitStream = splitStream2;
});

// ../../node_modules/@smithy/util-stream/dist-cjs/splitStream.js
var require_splitStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.splitStream = undefined;
  var stream_1 = __require("stream");
  var splitStream_browser_1 = require_splitStream_browser();
  var stream_type_check_1 = require_stream_type_check();
  async function splitStream2(stream) {
    if ((0, stream_type_check_1.isReadableStream)(stream) || (0, stream_type_check_1.isBlob)(stream)) {
      return (0, splitStream_browser_1.splitStream)(stream);
    }
    const stream1 = new stream_1.PassThrough;
    const stream2 = new stream_1.PassThrough;
    stream.pipe(stream1);
    stream.pipe(stream2);
    return [stream1, stream2];
  }
  exports.splitStream = splitStream2;
});

// ../../node_modules/@smithy/util-stream/dist-cjs/headStream.browser.js
var require_headStream_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.headStream = undefined;
  async function headStream2(stream, bytes) {
    var _a2;
    let byteLengthCounter = 0;
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    while (!isDone) {
      const { done, value } = await reader.read();
      if (value) {
        chunks.push(value);
        byteLengthCounter += (_a2 = value === null || value === undefined ? undefined : value.byteLength) !== null && _a2 !== undefined ? _a2 : 0;
      }
      if (byteLengthCounter >= bytes) {
        break;
      }
      isDone = done;
    }
    reader.releaseLock();
    const collected = new Uint8Array(Math.min(bytes, byteLengthCounter));
    let offset = 0;
    for (const chunk of chunks) {
      if (chunk.byteLength > collected.byteLength - offset) {
        collected.set(chunk.subarray(0, collected.byteLength - offset), offset);
        break;
      } else {
        collected.set(chunk, offset);
      }
      offset += chunk.length;
    }
    return collected;
  }
  exports.headStream = headStream2;
});

// ../../node_modules/@smithy/util-stream/dist-cjs/headStream.js
var require_headStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.headStream = undefined;
  var stream_1 = __require("stream");
  var headStream_browser_1 = require_headStream_browser();
  var stream_type_check_1 = require_stream_type_check();
  var headStream2 = (stream, bytes) => {
    if ((0, stream_type_check_1.isReadableStream)(stream)) {
      return (0, headStream_browser_1.headStream)(stream, bytes);
    }
    return new Promise((resolve2, reject) => {
      const collector = new Collector;
      collector.limit = bytes;
      stream.pipe(collector);
      stream.on("error", (err) => {
        collector.end();
        reject(err);
      });
      collector.on("error", reject);
      collector.on("finish", function() {
        const bytes2 = new Uint8Array(Buffer.concat(this.buffers));
        resolve2(bytes2);
      });
    });
  };
  exports.headStream = headStream2;

  class Collector extends stream_1.Writable {
    constructor() {
      super(...arguments);
      this.buffers = [];
      this.limit = Infinity;
      this.bytesBuffered = 0;
    }
    _write(chunk, encoding, callback) {
      var _a2;
      this.buffers.push(chunk);
      this.bytesBuffered += (_a2 = chunk.byteLength) !== null && _a2 !== undefined ? _a2 : 0;
      if (this.bytesBuffered >= this.limit) {
        const excess = this.bytesBuffered - this.limit;
        const tailBuffer = this.buffers[this.buffers.length - 1];
        this.buffers[this.buffers.length - 1] = tailBuffer.subarray(0, tailBuffer.byteLength - excess);
        this.emit("finish");
      }
      callback();
    }
  }
});

// ../../node_modules/@smithy/util-stream/dist-cjs/checksum/ChecksumStream.js
var require_ChecksumStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChecksumStream = undefined;
  var util_base64_1 = require_dist_cjs8();
  var stream_1 = __require("stream");

  class ChecksumStream2 extends stream_1.Duplex {
    constructor({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder }) {
      var _a2, _b2;
      super();
      if (typeof source.pipe === "function") {
        this.source = source;
      } else {
        throw new Error(`@smithy/util-stream: unsupported source type ${(_b2 = (_a2 = source === null || source === undefined ? undefined : source.constructor) === null || _a2 === undefined ? undefined : _a2.name) !== null && _b2 !== undefined ? _b2 : source} in ChecksumStream.`);
      }
      this.base64Encoder = base64Encoder !== null && base64Encoder !== undefined ? base64Encoder : util_base64_1.toBase64;
      this.expectedChecksum = expectedChecksum;
      this.checksum = checksum;
      this.checksumSourceLocation = checksumSourceLocation;
      this.source.pipe(this);
    }
    _read(size) {
    }
    _write(chunk, encoding, callback) {
      try {
        this.checksum.update(chunk);
        this.push(chunk);
      } catch (e2) {
        return callback(e2);
      }
      return callback();
    }
    async _final(callback) {
      try {
        const digest = await this.checksum.digest();
        const received = this.base64Encoder(digest);
        if (this.expectedChecksum !== received) {
          return callback(new Error(`Checksum mismatch: expected "${this.expectedChecksum}" but received "${received}"` + ` in response header "${this.checksumSourceLocation}".`));
        }
      } catch (e2) {
        return callback(e2);
      }
      this.push(null);
      return callback();
    }
  }
  exports.ChecksumStream = ChecksumStream2;
});

// ../../node_modules/@smithy/util-stream/dist-cjs/checksum/ChecksumStream.browser.js
var require_ChecksumStream_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChecksumStream = undefined;
  var ReadableStreamRef = typeof ReadableStream === "function" ? ReadableStream : function() {
  };

  class ChecksumStream2 extends ReadableStreamRef {
  }
  exports.ChecksumStream = ChecksumStream2;
});

// ../../node_modules/@smithy/util-stream/dist-cjs/checksum/createChecksumStream.browser.js
var require_createChecksumStream_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createChecksumStream = undefined;
  var util_base64_1 = require_dist_cjs8();
  var stream_type_check_1 = require_stream_type_check();
  var ChecksumStream_browser_1 = require_ChecksumStream_browser();
  var createChecksumStream2 = ({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder }) => {
    var _a2, _b2;
    if (!(0, stream_type_check_1.isReadableStream)(source)) {
      throw new Error(`@smithy/util-stream: unsupported source type ${(_b2 = (_a2 = source === null || source === undefined ? undefined : source.constructor) === null || _a2 === undefined ? undefined : _a2.name) !== null && _b2 !== undefined ? _b2 : source} in ChecksumStream.`);
    }
    const encoder2 = base64Encoder !== null && base64Encoder !== undefined ? base64Encoder : util_base64_1.toBase64;
    if (typeof TransformStream !== "function") {
      throw new Error("@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.");
    }
    const transform = new TransformStream({
      start() {
      },
      async transform(chunk, controller) {
        checksum.update(chunk);
        controller.enqueue(chunk);
      },
      async flush(controller) {
        const digest = await checksum.digest();
        const received = encoder2(digest);
        if (expectedChecksum !== received) {
          const error = new Error(`Checksum mismatch: expected "${expectedChecksum}" but received "${received}"` + ` in response header "${checksumSourceLocation}".`);
          controller.error(error);
        } else {
          controller.terminate();
        }
      }
    });
    source.pipeThrough(transform);
    const readable = transform.readable;
    Object.setPrototypeOf(readable, ChecksumStream_browser_1.ChecksumStream.prototype);
    return readable;
  };
  exports.createChecksumStream = createChecksumStream2;
});

// ../../node_modules/@smithy/util-stream/dist-cjs/checksum/createChecksumStream.js
var require_createChecksumStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createChecksumStream = undefined;
  var stream_type_check_1 = require_stream_type_check();
  var ChecksumStream_1 = require_ChecksumStream();
  var createChecksumStream_browser_1 = require_createChecksumStream_browser();
  function createChecksumStream2(init2) {
    if (typeof ReadableStream === "function" && (0, stream_type_check_1.isReadableStream)(init2.source)) {
      return (0, createChecksumStream_browser_1.createChecksumStream)(init2);
    }
    return new ChecksumStream_1.ChecksumStream(init2);
  }
  exports.createChecksumStream = createChecksumStream2;
});

// ../../node_modules/@smithy/util-stream/dist-cjs/index.js
var require_dist_cjs14 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Uint8ArrayBlobAdapter: () => Uint8ArrayBlobAdapter
  });
  module.exports = __toCommonJS(src_exports);
  var import_util_base64 = require_dist_cjs8();
  var import_util_utf8 = require_dist_cjs7();
  function transformToString(payload, encoding = "utf-8") {
    if (encoding === "base64") {
      return (0, import_util_base64.toBase64)(payload);
    }
    return (0, import_util_utf8.toUtf8)(payload);
  }
  __name2(transformToString, "transformToString");
  function transformFromString(str, encoding) {
    if (encoding === "base64") {
      return Uint8ArrayBlobAdapter.mutate((0, import_util_base64.fromBase64)(str));
    }
    return Uint8ArrayBlobAdapter.mutate((0, import_util_utf8.fromUtf8)(str));
  }
  __name2(transformFromString, "transformFromString");
  var Uint8ArrayBlobAdapter = class _Uint8ArrayBlobAdapter extends Uint8Array {
    static {
      __name2(this, "Uint8ArrayBlobAdapter");
    }
    static fromString(source, encoding = "utf-8") {
      switch (typeof source) {
        case "string":
          return transformFromString(source, encoding);
        default:
          throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
      }
    }
    static mutate(source) {
      Object.setPrototypeOf(source, _Uint8ArrayBlobAdapter.prototype);
      return source;
    }
    transformToString(encoding = "utf-8") {
      return transformToString(this, encoding);
    }
  };
  __reExport(src_exports, require_getAwsChunkedEncodingStream(), module.exports);
  __reExport(src_exports, require_sdk_stream_mixin(), module.exports);
  __reExport(src_exports, require_splitStream(), module.exports);
  __reExport(src_exports, require_headStream(), module.exports);
  __reExport(src_exports, require_stream_type_check(), module.exports);
  __reExport(src_exports, require_createChecksumStream(), module.exports);
  __reExport(src_exports, require_ChecksumStream(), module.exports);
});

// ../../node_modules/@smithy/core/dist-cjs/submodules/protocols/index.js
var require_protocols = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var protocols_exports = {};
  __export2(protocols_exports, {
    RequestBuilder: () => RequestBuilder,
    collectBody: () => collectBody2,
    extendedEncodeURIComponent: () => extendedEncodeURIComponent2,
    requestBuilder: () => requestBuilder2,
    resolvedPath: () => resolvedPath2
  });
  module.exports = __toCommonJS(protocols_exports);
  var import_util_stream = require_dist_cjs14();
  var collectBody2 = async (streamBody = new Uint8Array, context) => {
    if (streamBody instanceof Uint8Array) {
      return import_util_stream.Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
      return import_util_stream.Uint8ArrayBlobAdapter.mutate(new Uint8Array);
    }
    const fromContext = context.streamCollector(streamBody);
    return import_util_stream.Uint8ArrayBlobAdapter.mutate(await fromContext);
  };
  function extendedEncodeURIComponent2(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function(c3) {
      return "%" + c3.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  var import_protocol_http2 = require_dist_cjs2();
  var resolvedPath2 = (resolvedPath22, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
    if (input != null && input[memberName] !== undefined) {
      const labelValue = labelValueProvider();
      if (labelValue.length <= 0) {
        throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
      }
      resolvedPath22 = resolvedPath22.replace(uriLabel, isGreedyLabel ? labelValue.split("/").map((segment) => extendedEncodeURIComponent2(segment)).join("/") : extendedEncodeURIComponent2(labelValue));
    } else {
      throw new Error("No value provided for input HTTP label: " + memberName + ".");
    }
    return resolvedPath22;
  };
  function requestBuilder2(input, context) {
    return new RequestBuilder(input, context);
  }
  var RequestBuilder = class {
    constructor(input, context) {
      this.input = input;
      this.context = context;
      this.query = {};
      this.method = "";
      this.headers = {};
      this.path = "";
      this.body = null;
      this.hostname = "";
      this.resolvePathStack = [];
    }
    async build() {
      const { hostname, protocol = "https", port, path: basePath } = await this.context.endpoint();
      this.path = basePath;
      for (const resolvePath of this.resolvePathStack) {
        resolvePath(this.path);
      }
      return new import_protocol_http2.HttpRequest({
        protocol,
        hostname: this.hostname || hostname,
        port,
        method: this.method,
        path: this.path,
        query: this.query,
        body: this.body,
        headers: this.headers
      });
    }
    hn(hostname) {
      this.hostname = hostname;
      return this;
    }
    bp(uriLabel) {
      this.resolvePathStack.push((basePath) => {
        this.path = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + uriLabel;
      });
      return this;
    }
    p(memberName, labelValueProvider, uriLabel, isGreedyLabel) {
      this.resolvePathStack.push((path) => {
        this.path = resolvedPath2(path, this.input, memberName, labelValueProvider, uriLabel, isGreedyLabel);
      });
      return this;
    }
    h(headers) {
      this.headers = headers;
      return this;
    }
    q(query) {
      this.query = query;
      return this;
    }
    b(body) {
      this.body = body;
      return this;
    }
    m(method) {
      this.method = method;
      return this;
    }
  };
});

// ../../node_modules/@smithy/core/dist-cjs/index.js
var require_dist_cjs15 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    DefaultIdentityProviderConfig: () => DefaultIdentityProviderConfig,
    EXPIRATION_MS: () => EXPIRATION_MS,
    HttpApiKeyAuthSigner: () => HttpApiKeyAuthSigner,
    HttpBearerAuthSigner: () => HttpBearerAuthSigner,
    NoAuthSigner: () => NoAuthSigner,
    createIsIdentityExpiredFunction: () => createIsIdentityExpiredFunction,
    createPaginator: () => createPaginator,
    doesIdentityRequireRefresh: () => doesIdentityRequireRefresh,
    getHttpAuthSchemeEndpointRuleSetPlugin: () => getHttpAuthSchemeEndpointRuleSetPlugin,
    getHttpAuthSchemePlugin: () => getHttpAuthSchemePlugin,
    getHttpSigningPlugin: () => getHttpSigningPlugin,
    getSmithyContext: () => getSmithyContext,
    httpAuthSchemeEndpointRuleSetMiddlewareOptions: () => httpAuthSchemeEndpointRuleSetMiddlewareOptions,
    httpAuthSchemeMiddleware: () => httpAuthSchemeMiddleware,
    httpAuthSchemeMiddlewareOptions: () => httpAuthSchemeMiddlewareOptions,
    httpSigningMiddleware: () => httpSigningMiddleware,
    httpSigningMiddlewareOptions: () => httpSigningMiddlewareOptions,
    isIdentityExpired: () => isIdentityExpired,
    memoizeIdentityProvider: () => memoizeIdentityProvider,
    normalizeProvider: () => normalizeProvider,
    requestBuilder: () => import_protocols.requestBuilder,
    setFeature: () => setFeature
  });
  module.exports = __toCommonJS(src_exports);
  var import_types3 = require_dist_cjs();
  var getSmithyContext = /* @__PURE__ */ __name2((context) => context[import_types3.SMITHY_CONTEXT_KEY] || (context[import_types3.SMITHY_CONTEXT_KEY] = {}), "getSmithyContext");
  var import_util_middleware = require_dist_cjs3();
  function convertHttpAuthSchemesToMap(httpAuthSchemes) {
    const map = /* @__PURE__ */ new Map;
    for (const scheme of httpAuthSchemes) {
      map.set(scheme.schemeId, scheme);
    }
    return map;
  }
  __name2(convertHttpAuthSchemesToMap, "convertHttpAuthSchemesToMap");
  var httpAuthSchemeMiddleware = /* @__PURE__ */ __name2((config2, mwOptions) => (next, context) => async (args) => {
    const options = config2.httpAuthSchemeProvider(await mwOptions.httpAuthSchemeParametersProvider(config2, context, args.input));
    const authSchemes = convertHttpAuthSchemesToMap(config2.httpAuthSchemes);
    const smithyContext = (0, import_util_middleware.getSmithyContext)(context);
    const failureReasons = [];
    for (const option of options) {
      const scheme = authSchemes.get(option.schemeId);
      if (!scheme) {
        failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` was not enabled for this service.`);
        continue;
      }
      const identityProvider = scheme.identityProvider(await mwOptions.identityProviderConfigProvider(config2));
      if (!identityProvider) {
        failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` did not have an IdentityProvider configured.`);
        continue;
      }
      const { identityProperties = {}, signingProperties = {} } = option.propertiesExtractor?.(config2, context) || {};
      option.identityProperties = Object.assign(option.identityProperties || {}, identityProperties);
      option.signingProperties = Object.assign(option.signingProperties || {}, signingProperties);
      smithyContext.selectedHttpAuthScheme = {
        httpAuthOption: option,
        identity: await identityProvider(option.identityProperties),
        signer: scheme.signer
      };
      break;
    }
    if (!smithyContext.selectedHttpAuthScheme) {
      throw new Error(failureReasons.join(`
`));
    }
    return next(args);
  }, "httpAuthSchemeMiddleware");
  var httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: "endpointV2Middleware"
  };
  var getHttpAuthSchemeEndpointRuleSetPlugin = /* @__PURE__ */ __name2((config2, {
    httpAuthSchemeParametersProvider,
    identityProviderConfigProvider
  }) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(httpAuthSchemeMiddleware(config2, {
        httpAuthSchemeParametersProvider,
        identityProviderConfigProvider
      }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);
    }
  }), "getHttpAuthSchemeEndpointRuleSetPlugin");
  var import_middleware_serde = require_dist_cjs4();
  var httpAuthSchemeMiddlewareOptions = {
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: import_middleware_serde.serializerMiddlewareOption.name
  };
  var getHttpAuthSchemePlugin = /* @__PURE__ */ __name2((config2, {
    httpAuthSchemeParametersProvider,
    identityProviderConfigProvider
  }) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(httpAuthSchemeMiddleware(config2, {
        httpAuthSchemeParametersProvider,
        identityProviderConfigProvider
      }), httpAuthSchemeMiddlewareOptions);
    }
  }), "getHttpAuthSchemePlugin");
  var import_protocol_http2 = require_dist_cjs2();
  var defaultErrorHandler = /* @__PURE__ */ __name2((signingProperties) => (error) => {
    throw error;
  }, "defaultErrorHandler");
  var defaultSuccessHandler = /* @__PURE__ */ __name2((httpResponse2, signingProperties) => {
  }, "defaultSuccessHandler");
  var httpSigningMiddleware = /* @__PURE__ */ __name2((config2) => (next, context) => async (args) => {
    if (!import_protocol_http2.HttpRequest.isInstance(args.request)) {
      return next(args);
    }
    const smithyContext = (0, import_util_middleware.getSmithyContext)(context);
    const scheme = smithyContext.selectedHttpAuthScheme;
    if (!scheme) {
      throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
    }
    const {
      httpAuthOption: { signingProperties = {} },
      identity,
      signer
    } = scheme;
    const output = await next({
      ...args,
      request: await signer.sign(args.request, identity, signingProperties)
    }).catch((signer.errorHandler || defaultErrorHandler)(signingProperties));
    (signer.successHandler || defaultSuccessHandler)(output.response, signingProperties);
    return output;
  }, "httpSigningMiddleware");
  var httpSigningMiddlewareOptions = {
    step: "finalizeRequest",
    tags: ["HTTP_SIGNING"],
    name: "httpSigningMiddleware",
    aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
    override: true,
    relation: "after",
    toMiddleware: "retryMiddleware"
  };
  var getHttpSigningPlugin = /* @__PURE__ */ __name2((config2) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(httpSigningMiddleware(config2), httpSigningMiddlewareOptions);
    }
  }), "getHttpSigningPlugin");
  var normalizeProvider = /* @__PURE__ */ __name2((input) => {
    if (typeof input === "function")
      return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
  }, "normalizeProvider");
  var makePagedClientRequest = /* @__PURE__ */ __name2(async (CommandCtor, client, input, withCommand = (_3) => _3, ...args) => {
    let command = new CommandCtor(input);
    command = withCommand(command) ?? command;
    return await client.send(command, ...args);
  }, "makePagedClientRequest");
  function createPaginator(ClientCtor, CommandCtor, inputTokenName, outputTokenName, pageSizeTokenName) {
    return /* @__PURE__ */ __name2(async function* paginateOperation(config2, input, ...additionalArguments) {
      const _input = input;
      let token = config2.startingToken ?? _input[inputTokenName];
      let hasNext = true;
      let page;
      while (hasNext) {
        _input[inputTokenName] = token;
        if (pageSizeTokenName) {
          _input[pageSizeTokenName] = _input[pageSizeTokenName] ?? config2.pageSize;
        }
        if (config2.client instanceof ClientCtor) {
          page = await makePagedClientRequest(CommandCtor, config2.client, input, config2.withCommand, ...additionalArguments);
        } else {
          throw new Error(`Invalid client, expected instance of ${ClientCtor.name}`);
        }
        yield page;
        const prevToken = token;
        token = get(page, outputTokenName);
        hasNext = !!(token && (!config2.stopOnSameToken || token !== prevToken));
      }
      return;
    }, "paginateOperation");
  }
  __name2(createPaginator, "createPaginator");
  var get = /* @__PURE__ */ __name2((fromObject, path) => {
    let cursor = fromObject;
    const pathComponents = path.split(".");
    for (const step of pathComponents) {
      if (!cursor || typeof cursor !== "object") {
        return;
      }
      cursor = cursor[step];
    }
    return cursor;
  }, "get");
  var import_protocols = require_protocols();
  function setFeature(context, feature, value) {
    if (!context.__smithy_context) {
      context.__smithy_context = {
        features: {}
      };
    } else if (!context.__smithy_context.features) {
      context.__smithy_context.features = {};
    }
    context.__smithy_context.features[feature] = value;
  }
  __name2(setFeature, "setFeature");
  var DefaultIdentityProviderConfig = class {
    constructor(config2) {
      this.authSchemes = /* @__PURE__ */ new Map;
      for (const [key, value] of Object.entries(config2)) {
        if (value !== undefined) {
          this.authSchemes.set(key, value);
        }
      }
    }
    static {
      __name2(this, "DefaultIdentityProviderConfig");
    }
    getIdentityProvider(schemeId) {
      return this.authSchemes.get(schemeId);
    }
  };
  var HttpApiKeyAuthSigner = class {
    static {
      __name2(this, "HttpApiKeyAuthSigner");
    }
    async sign(httpRequest2, identity, signingProperties) {
      if (!signingProperties) {
        throw new Error("request could not be signed with `apiKey` since the `name` and `in` signer properties are missing");
      }
      if (!signingProperties.name) {
        throw new Error("request could not be signed with `apiKey` since the `name` signer property is missing");
      }
      if (!signingProperties.in) {
        throw new Error("request could not be signed with `apiKey` since the `in` signer property is missing");
      }
      if (!identity.apiKey) {
        throw new Error("request could not be signed with `apiKey` since the `apiKey` is not defined");
      }
      const clonedRequest = import_protocol_http2.HttpRequest.clone(httpRequest2);
      if (signingProperties.in === import_types3.HttpApiKeyAuthLocation.QUERY) {
        clonedRequest.query[signingProperties.name] = identity.apiKey;
      } else if (signingProperties.in === import_types3.HttpApiKeyAuthLocation.HEADER) {
        clonedRequest.headers[signingProperties.name] = signingProperties.scheme ? `${signingProperties.scheme} ${identity.apiKey}` : identity.apiKey;
      } else {
        throw new Error("request can only be signed with `apiKey` locations `query` or `header`, but found: `" + signingProperties.in + "`");
      }
      return clonedRequest;
    }
  };
  var HttpBearerAuthSigner = class {
    static {
      __name2(this, "HttpBearerAuthSigner");
    }
    async sign(httpRequest2, identity, signingProperties) {
      const clonedRequest = import_protocol_http2.HttpRequest.clone(httpRequest2);
      if (!identity.token) {
        throw new Error("request could not be signed with `token` since the `token` is not defined");
      }
      clonedRequest.headers["Authorization"] = `Bearer ${identity.token}`;
      return clonedRequest;
    }
  };
  var NoAuthSigner = class {
    static {
      __name2(this, "NoAuthSigner");
    }
    async sign(httpRequest2, identity, signingProperties) {
      return httpRequest2;
    }
  };
  var createIsIdentityExpiredFunction = /* @__PURE__ */ __name2((expirationMs) => (identity) => doesIdentityRequireRefresh(identity) && identity.expiration.getTime() - Date.now() < expirationMs, "createIsIdentityExpiredFunction");
  var EXPIRATION_MS = 300000;
  var isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);
  var doesIdentityRequireRefresh = /* @__PURE__ */ __name2((identity) => identity.expiration !== undefined, "doesIdentityRequireRefresh");
  var memoizeIdentityProvider = /* @__PURE__ */ __name2((provider, isExpired, requiresRefresh) => {
    if (provider === undefined) {
      return;
    }
    const normalizedProvider = typeof provider !== "function" ? async () => Promise.resolve(provider) : provider;
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = /* @__PURE__ */ __name2(async (options) => {
      if (!pending) {
        pending = normalizedProvider(options);
      }
      try {
        resolved = await pending;
        hasResult = true;
        isConstant = false;
      } finally {
        pending = undefined;
      }
      return resolved;
    }, "coalesceProvider");
    if (isExpired === undefined) {
      return async (options) => {
        if (!hasResult || options?.forceRefresh) {
          resolved = await coalesceProvider(options);
        }
        return resolved;
      };
    }
    return async (options) => {
      if (!hasResult || options?.forceRefresh) {
        resolved = await coalesceProvider(options);
      }
      if (isConstant) {
        return resolved;
      }
      if (!requiresRefresh(resolved)) {
        isConstant = true;
        return resolved;
      }
      if (isExpired(resolved)) {
        await coalesceProvider(options);
        return resolved;
      }
      return resolved;
    };
  }, "memoizeIdentityProvider");
});

// ../../node_modules/@smithy/property-provider/dist-cjs/index.js
var require_dist_cjs16 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    CredentialsProviderError: () => CredentialsProviderError,
    ProviderError: () => ProviderError,
    TokenProviderError: () => TokenProviderError,
    chain: () => chain,
    fromStatic: () => fromStatic,
    memoize: () => memoize
  });
  module.exports = __toCommonJS(src_exports);
  var ProviderError = class _ProviderError extends Error {
    constructor(message, options = true) {
      let logger;
      let tryNextLink = true;
      if (typeof options === "boolean") {
        logger = undefined;
        tryNextLink = options;
      } else if (options != null && typeof options === "object") {
        logger = options.logger;
        tryNextLink = options.tryNextLink ?? true;
      }
      super(message);
      this.name = "ProviderError";
      this.tryNextLink = tryNextLink;
      Object.setPrototypeOf(this, _ProviderError.prototype);
      logger?.debug?.(`@smithy/property-provider ${tryNextLink ? "->" : "(!)"} ${message}`);
    }
    static {
      __name2(this, "ProviderError");
    }
    static from(error, options = true) {
      return Object.assign(new this(error.message, options), error);
    }
  };
  var CredentialsProviderError = class _CredentialsProviderError extends ProviderError {
    constructor(message, options = true) {
      super(message, options);
      this.name = "CredentialsProviderError";
      Object.setPrototypeOf(this, _CredentialsProviderError.prototype);
    }
    static {
      __name2(this, "CredentialsProviderError");
    }
  };
  var TokenProviderError = class _TokenProviderError extends ProviderError {
    constructor(message, options = true) {
      super(message, options);
      this.name = "TokenProviderError";
      Object.setPrototypeOf(this, _TokenProviderError.prototype);
    }
    static {
      __name2(this, "TokenProviderError");
    }
  };
  var chain = /* @__PURE__ */ __name2((...providers) => async () => {
    if (providers.length === 0) {
      throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
      try {
        const credentials = await provider();
        return credentials;
      } catch (err) {
        lastProviderError = err;
        if (err?.tryNextLink) {
          continue;
        }
        throw err;
      }
    }
    throw lastProviderError;
  }, "chain");
  var fromStatic = /* @__PURE__ */ __name2((staticValue) => () => Promise.resolve(staticValue), "fromStatic");
  var memoize = /* @__PURE__ */ __name2((provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = /* @__PURE__ */ __name2(async () => {
      if (!pending) {
        pending = provider();
      }
      try {
        resolved = await pending;
        hasResult = true;
        isConstant = false;
      } finally {
        pending = undefined;
      }
      return resolved;
    }, "coalesceProvider");
    if (isExpired === undefined) {
      return async (options) => {
        if (!hasResult || options?.forceRefresh) {
          resolved = await coalesceProvider();
        }
        return resolved;
      };
    }
    return async (options) => {
      if (!hasResult || options?.forceRefresh) {
        resolved = await coalesceProvider();
      }
      if (isConstant) {
        return resolved;
      }
      if (requiresRefresh && !requiresRefresh(resolved)) {
        isConstant = true;
        return resolved;
      }
      if (isExpired(resolved)) {
        await coalesceProvider();
        return resolved;
      }
      return resolved;
    };
  }, "memoize");
});

// ../../node_modules/@smithy/signature-v4/dist-cjs/index.js
var require_dist_cjs17 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    SignatureV4: () => SignatureV4,
    clearCredentialCache: () => clearCredentialCache,
    createScope: () => createScope,
    getCanonicalHeaders: () => getCanonicalHeaders,
    getCanonicalQuery: () => getCanonicalQuery,
    getPayloadHash: () => getPayloadHash,
    getSigningKey: () => getSigningKey,
    moveHeadersToQuery: () => moveHeadersToQuery,
    prepareRequest: () => prepareRequest
  });
  module.exports = __toCommonJS(src_exports);
  var import_util_middleware = require_dist_cjs3();
  var import_util_utf84 = require_dist_cjs7();
  var ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
  var CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
  var AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
  var SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
  var EXPIRES_QUERY_PARAM = "X-Amz-Expires";
  var SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
  var TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
  var AUTH_HEADER = "authorization";
  var AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
  var DATE_HEADER = "date";
  var GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
  var SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
  var SHA256_HEADER = "x-amz-content-sha256";
  var TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
  var ALWAYS_UNSIGNABLE_HEADERS = {
    authorization: true,
    "cache-control": true,
    connection: true,
    expect: true,
    from: true,
    "keep-alive": true,
    "max-forwards": true,
    pragma: true,
    referer: true,
    te: true,
    trailer: true,
    "transfer-encoding": true,
    upgrade: true,
    "user-agent": true,
    "x-amzn-trace-id": true
  };
  var PROXY_HEADER_PATTERN = /^proxy-/;
  var SEC_HEADER_PATTERN = /^sec-/;
  var ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
  var EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
  var UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
  var MAX_CACHE_SIZE = 50;
  var KEY_TYPE_IDENTIFIER = "aws4_request";
  var MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;
  var import_util_hex_encoding = require_dist_cjs13();
  var import_util_utf8 = require_dist_cjs7();
  var signingKeyCache = {};
  var cacheQueue = [];
  var createScope = /* @__PURE__ */ __name2((shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`, "createScope");
  var getSigningKey = /* @__PURE__ */ __name2(async (sha256Constructor, credentials, shortDate, region, service) => {
    const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
    const cacheKey = `${shortDate}:${region}:${service}:${(0, import_util_hex_encoding.toHex)(credsHash)}:${credentials.sessionToken}`;
    if (cacheKey in signingKeyCache) {
      return signingKeyCache[cacheKey];
    }
    cacheQueue.push(cacheKey);
    while (cacheQueue.length > MAX_CACHE_SIZE) {
      delete signingKeyCache[cacheQueue.shift()];
    }
    let key = `AWS4${credentials.secretAccessKey}`;
    for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
      key = await hmac(sha256Constructor, key, signable);
    }
    return signingKeyCache[cacheKey] = key;
  }, "getSigningKey");
  var clearCredentialCache = /* @__PURE__ */ __name2(() => {
    cacheQueue.length = 0;
    Object.keys(signingKeyCache).forEach((cacheKey) => {
      delete signingKeyCache[cacheKey];
    });
  }, "clearCredentialCache");
  var hmac = /* @__PURE__ */ __name2((ctor, secret, data) => {
    const hash = new ctor(secret);
    hash.update((0, import_util_utf8.toUint8Array)(data));
    return hash.digest();
  }, "hmac");
  var getCanonicalHeaders = /* @__PURE__ */ __name2(({ headers }, unsignableHeaders, signableHeaders) => {
    const canonical = {};
    for (const headerName of Object.keys(headers).sort()) {
      if (headers[headerName] == undefined) {
        continue;
      }
      const canonicalHeaderName = headerName.toLowerCase();
      if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || unsignableHeaders?.has(canonicalHeaderName) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
        if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
          continue;
        }
      }
      canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
    }
    return canonical;
  }, "getCanonicalHeaders");
  var import_util_uri_escape = require_dist_cjs9();
  var getCanonicalQuery = /* @__PURE__ */ __name2(({ query = {} }) => {
    const keys = [];
    const serialized = {};
    for (const key of Object.keys(query)) {
      if (key.toLowerCase() === SIGNATURE_HEADER) {
        continue;
      }
      const encodedKey = (0, import_util_uri_escape.escapeUri)(key);
      keys.push(encodedKey);
      const value = query[key];
      if (typeof value === "string") {
        serialized[encodedKey] = `${encodedKey}=${(0, import_util_uri_escape.escapeUri)(value)}`;
      } else if (Array.isArray(value)) {
        serialized[encodedKey] = value.slice(0).reduce((encoded, value2) => encoded.concat([`${encodedKey}=${(0, import_util_uri_escape.escapeUri)(value2)}`]), []).sort().join("&");
      }
    }
    return keys.sort().map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
  }, "getCanonicalQuery");
  var import_is_array_buffer = require_dist_cjs5();
  var import_util_utf82 = require_dist_cjs7();
  var getPayloadHash = /* @__PURE__ */ __name2(async ({ headers, body }, hashConstructor) => {
    for (const headerName of Object.keys(headers)) {
      if (headerName.toLowerCase() === SHA256_HEADER) {
        return headers[headerName];
      }
    }
    if (body == undefined) {
      return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
    } else if (typeof body === "string" || ArrayBuffer.isView(body) || (0, import_is_array_buffer.isArrayBuffer)(body)) {
      const hashCtor = new hashConstructor;
      hashCtor.update((0, import_util_utf82.toUint8Array)(body));
      return (0, import_util_hex_encoding.toHex)(await hashCtor.digest());
    }
    return UNSIGNED_PAYLOAD;
  }, "getPayloadHash");
  var import_util_utf83 = require_dist_cjs7();
  var HeaderFormatter = class {
    static {
      __name2(this, "HeaderFormatter");
    }
    format(headers) {
      const chunks = [];
      for (const headerName of Object.keys(headers)) {
        const bytes = (0, import_util_utf83.fromUtf8)(headerName);
        chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
      }
      const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
      let position = 0;
      for (const chunk of chunks) {
        out.set(chunk, position);
        position += chunk.byteLength;
      }
      return out;
    }
    formatHeaderValue(header) {
      switch (header.type) {
        case "boolean":
          return Uint8Array.from([header.value ? 0 : 1]);
        case "byte":
          return Uint8Array.from([2, header.value]);
        case "short":
          const shortView = new DataView(new ArrayBuffer(3));
          shortView.setUint8(0, 3);
          shortView.setInt16(1, header.value, false);
          return new Uint8Array(shortView.buffer);
        case "integer":
          const intView = new DataView(new ArrayBuffer(5));
          intView.setUint8(0, 4);
          intView.setInt32(1, header.value, false);
          return new Uint8Array(intView.buffer);
        case "long":
          const longBytes = new Uint8Array(9);
          longBytes[0] = 5;
          longBytes.set(header.value.bytes, 1);
          return longBytes;
        case "binary":
          const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
          binView.setUint8(0, 6);
          binView.setUint16(1, header.value.byteLength, false);
          const binBytes = new Uint8Array(binView.buffer);
          binBytes.set(header.value, 3);
          return binBytes;
        case "string":
          const utf8Bytes = (0, import_util_utf83.fromUtf8)(header.value);
          const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
          strView.setUint8(0, 7);
          strView.setUint16(1, utf8Bytes.byteLength, false);
          const strBytes = new Uint8Array(strView.buffer);
          strBytes.set(utf8Bytes, 3);
          return strBytes;
        case "timestamp":
          const tsBytes = new Uint8Array(9);
          tsBytes[0] = 8;
          tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
          return tsBytes;
        case "uuid":
          if (!UUID_PATTERN.test(header.value)) {
            throw new Error(`Invalid UUID received: ${header.value}`);
          }
          const uuidBytes = new Uint8Array(17);
          uuidBytes[0] = 9;
          uuidBytes.set((0, import_util_hex_encoding.fromHex)(header.value.replace(/\-/g, "")), 1);
          return uuidBytes;
      }
    }
  };
  var UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
  var Int64 = class _Int64 {
    constructor(bytes) {
      this.bytes = bytes;
      if (bytes.byteLength !== 8) {
        throw new Error("Int64 buffers must be exactly 8 bytes");
      }
    }
    static {
      __name2(this, "Int64");
    }
    static fromNumber(number) {
      if (number > 9223372036854776000 || number < -9223372036854776000) {
        throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
      }
      const bytes = new Uint8Array(8);
      for (let i2 = 7, remaining = Math.abs(Math.round(number));i2 > -1 && remaining > 0; i2--, remaining /= 256) {
        bytes[i2] = remaining;
      }
      if (number < 0) {
        negate(bytes);
      }
      return new _Int64(bytes);
    }
    valueOf() {
      const bytes = this.bytes.slice(0);
      const negative = bytes[0] & 128;
      if (negative) {
        negate(bytes);
      }
      return parseInt((0, import_util_hex_encoding.toHex)(bytes), 16) * (negative ? -1 : 1);
    }
    toString() {
      return String(this.valueOf());
    }
  };
  function negate(bytes) {
    for (let i2 = 0;i2 < 8; i2++) {
      bytes[i2] ^= 255;
    }
    for (let i2 = 7;i2 > -1; i2--) {
      bytes[i2]++;
      if (bytes[i2] !== 0)
        break;
    }
  }
  __name2(negate, "negate");
  var hasHeader = /* @__PURE__ */ __name2((soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
      if (soughtHeader === headerName.toLowerCase()) {
        return true;
      }
    }
    return false;
  }, "hasHeader");
  var import_protocol_http2 = require_dist_cjs2();
  var moveHeadersToQuery = /* @__PURE__ */ __name2((request, options = {}) => {
    const { headers, query = {} } = import_protocol_http2.HttpRequest.clone(request);
    for (const name of Object.keys(headers)) {
      const lname = name.toLowerCase();
      if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname) || options.hoistableHeaders?.has(lname)) {
        query[name] = headers[name];
        delete headers[name];
      }
    }
    return {
      ...request,
      headers,
      query
    };
  }, "moveHeadersToQuery");
  var prepareRequest = /* @__PURE__ */ __name2((request) => {
    request = import_protocol_http2.HttpRequest.clone(request);
    for (const headerName of Object.keys(request.headers)) {
      if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
        delete request.headers[headerName];
      }
    }
    return request;
  }, "prepareRequest");
  var iso8601 = /* @__PURE__ */ __name2((time) => toDate(time).toISOString().replace(/\.\d{3}Z$/, "Z"), "iso8601");
  var toDate = /* @__PURE__ */ __name2((time) => {
    if (typeof time === "number") {
      return new Date(time * 1000);
    }
    if (typeof time === "string") {
      if (Number(time)) {
        return new Date(Number(time) * 1000);
      }
      return new Date(time);
    }
    return time;
  }, "toDate");
  var SignatureV4 = class {
    constructor({
      applyChecksum,
      credentials,
      region,
      service,
      sha256: sha2562,
      uriEscapePath = true
    }) {
      this.headerFormatter = new HeaderFormatter;
      this.service = service;
      this.sha256 = sha2562;
      this.uriEscapePath = uriEscapePath;
      this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
      this.regionProvider = (0, import_util_middleware.normalizeProvider)(region);
      this.credentialProvider = (0, import_util_middleware.normalizeProvider)(credentials);
    }
    static {
      __name2(this, "SignatureV4");
    }
    async presign(originalRequest, options = {}) {
      const {
        signingDate = /* @__PURE__ */ new Date,
        expiresIn = 3600,
        unsignableHeaders,
        unhoistableHeaders,
        signableHeaders,
        hoistableHeaders,
        signingRegion,
        signingService
      } = options;
      const credentials = await this.credentialProvider();
      this.validateResolvedCredentials(credentials);
      const region = signingRegion ?? await this.regionProvider();
      const { longDate, shortDate } = formatDate(signingDate);
      if (expiresIn > MAX_PRESIGNED_TTL) {
        return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
      }
      const scope = createScope(shortDate, region, signingService ?? this.service);
      const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders, hoistableHeaders });
      if (credentials.sessionToken) {
        request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
      }
      request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
      request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
      request.query[AMZ_DATE_QUERY_PARAM] = longDate;
      request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
      const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
      request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
      request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
      return request;
    }
    async sign(toSign, options) {
      if (typeof toSign === "string") {
        return this.signString(toSign, options);
      } else if (toSign.headers && toSign.payload) {
        return this.signEvent(toSign, options);
      } else if (toSign.message) {
        return this.signMessage(toSign, options);
      } else {
        return this.signRequest(toSign, options);
      }
    }
    async signEvent({ headers, payload }, { signingDate = /* @__PURE__ */ new Date, priorSignature, signingRegion, signingService }) {
      const region = signingRegion ?? await this.regionProvider();
      const { shortDate, longDate } = formatDate(signingDate);
      const scope = createScope(shortDate, region, signingService ?? this.service);
      const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
      const hash = new this.sha256;
      hash.update(headers);
      const hashedHeaders = (0, import_util_hex_encoding.toHex)(await hash.digest());
      const stringToSign = [
        EVENT_ALGORITHM_IDENTIFIER,
        longDate,
        scope,
        priorSignature,
        hashedHeaders,
        hashedPayload
      ].join(`
`);
      return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
    }
    async signMessage(signableMessage, { signingDate = /* @__PURE__ */ new Date, signingRegion, signingService }) {
      const promise = this.signEvent({
        headers: this.headerFormatter.format(signableMessage.message.headers),
        payload: signableMessage.message.body
      }, {
        signingDate,
        signingRegion,
        signingService,
        priorSignature: signableMessage.priorSignature
      });
      return promise.then((signature) => {
        return { message: signableMessage.message, signature };
      });
    }
    async signString(stringToSign, { signingDate = /* @__PURE__ */ new Date, signingRegion, signingService } = {}) {
      const credentials = await this.credentialProvider();
      this.validateResolvedCredentials(credentials);
      const region = signingRegion ?? await this.regionProvider();
      const { shortDate } = formatDate(signingDate);
      const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
      hash.update((0, import_util_utf84.toUint8Array)(stringToSign));
      return (0, import_util_hex_encoding.toHex)(await hash.digest());
    }
    async signRequest(requestToSign, {
      signingDate = /* @__PURE__ */ new Date,
      signableHeaders,
      unsignableHeaders,
      signingRegion,
      signingService
    } = {}) {
      const credentials = await this.credentialProvider();
      this.validateResolvedCredentials(credentials);
      const region = signingRegion ?? await this.regionProvider();
      const request = prepareRequest(requestToSign);
      const { longDate, shortDate } = formatDate(signingDate);
      const scope = createScope(shortDate, region, signingService ?? this.service);
      request.headers[AMZ_DATE_HEADER] = longDate;
      if (credentials.sessionToken) {
        request.headers[TOKEN_HEADER] = credentials.sessionToken;
      }
      const payloadHash = await getPayloadHash(request, this.sha256);
      if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
        request.headers[SHA256_HEADER] = payloadHash;
      }
      const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
      const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
      request.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} Credential=${credentials.accessKeyId}/${scope}, SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, Signature=${signature}`;
      return request;
    }
    createCanonicalRequest(request, canonicalHeaders, payloadHash) {
      const sortedHeaders = Object.keys(canonicalHeaders).sort();
      return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join(`
`)}

${sortedHeaders.join(";")}
${payloadHash}`;
    }
    async createStringToSign(longDate, credentialScope, canonicalRequest) {
      const hash = new this.sha256;
      hash.update((0, import_util_utf84.toUint8Array)(canonicalRequest));
      const hashedRequest = await hash.digest();
      return `${ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${(0, import_util_hex_encoding.toHex)(hashedRequest)}`;
    }
    getCanonicalPath({ path }) {
      if (this.uriEscapePath) {
        const normalizedPathSegments = [];
        for (const pathSegment of path.split("/")) {
          if (pathSegment?.length === 0)
            continue;
          if (pathSegment === ".")
            continue;
          if (pathSegment === "..") {
            normalizedPathSegments.pop();
          } else {
            normalizedPathSegments.push(pathSegment);
          }
        }
        const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
        const doubleEncoded = (0, import_util_uri_escape.escapeUri)(normalizedPath);
        return doubleEncoded.replace(/%2F/g, "/");
      }
      return path;
    }
    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
      const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
      const hash = new this.sha256(await keyPromise);
      hash.update((0, import_util_utf84.toUint8Array)(stringToSign));
      return (0, import_util_hex_encoding.toHex)(await hash.digest());
    }
    getSigningKey(credentials, region, shortDate, service) {
      return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
    }
    validateResolvedCredentials(credentials) {
      if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
        throw new Error("Resolved credential object is not valid");
      }
    }
  };
  var formatDate = /* @__PURE__ */ __name2((now) => {
    const longDate = iso8601(now).replace(/[\-:]/g, "");
    return {
      longDate,
      shortDate: longDate.slice(0, 8)
    };
  }, "formatDate");
  var getCanonicalHeaderList = /* @__PURE__ */ __name2((headers) => Object.keys(headers).sort().join(";"), "getCanonicalHeaderList");
});

// ../../node_modules/@aws-sdk/core/dist-cjs/submodules/httpAuthSchemes/index.js
var require_httpAuthSchemes = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var httpAuthSchemes_exports = {};
  __export2(httpAuthSchemes_exports, {
    AWSSDKSigV4Signer: () => AWSSDKSigV4Signer,
    AwsSdkSigV4ASigner: () => AwsSdkSigV4ASigner,
    AwsSdkSigV4Signer: () => AwsSdkSigV4Signer,
    NODE_SIGV4A_CONFIG_OPTIONS: () => NODE_SIGV4A_CONFIG_OPTIONS,
    resolveAWSSDKSigV4Config: () => resolveAWSSDKSigV4Config,
    resolveAwsSdkSigV4AConfig: () => resolveAwsSdkSigV4AConfig,
    resolveAwsSdkSigV4Config: () => resolveAwsSdkSigV4Config,
    validateSigningProperties: () => validateSigningProperties
  });
  module.exports = __toCommonJS(httpAuthSchemes_exports);
  var import_protocol_http2 = require_dist_cjs2();
  var import_protocol_http3 = require_dist_cjs2();
  var getDateHeader = /* @__PURE__ */ __name2((response) => import_protocol_http3.HttpResponse.isInstance(response) ? response.headers?.date ?? response.headers?.Date : undefined, "getDateHeader");
  var getSkewCorrectedDate = /* @__PURE__ */ __name2((systemClockOffset) => new Date(Date.now() + systemClockOffset), "getSkewCorrectedDate");
  var isClockSkewed = /* @__PURE__ */ __name2((clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 300000, "isClockSkewed");
  var getUpdatedSystemClockOffset = /* @__PURE__ */ __name2((clockTime, currentSystemClockOffset) => {
    const clockTimeInMs = Date.parse(clockTime);
    if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
      return clockTimeInMs - Date.now();
    }
    return currentSystemClockOffset;
  }, "getUpdatedSystemClockOffset");
  var throwSigningPropertyError = /* @__PURE__ */ __name2((name, property) => {
    if (!property) {
      throw new Error(`Property \`${name}\` is not resolved for AWS SDK SigV4Auth`);
    }
    return property;
  }, "throwSigningPropertyError");
  var validateSigningProperties = /* @__PURE__ */ __name2(async (signingProperties) => {
    const context = throwSigningPropertyError("context", signingProperties.context);
    const config2 = throwSigningPropertyError("config", signingProperties.config);
    const authScheme = context.endpointV2?.properties?.authSchemes?.[0];
    const signerFunction = throwSigningPropertyError("signer", config2.signer);
    const signer = await signerFunction(authScheme);
    const signingRegion = signingProperties?.signingRegion;
    const signingRegionSet = signingProperties?.signingRegionSet;
    const signingName = signingProperties?.signingName;
    return {
      config: config2,
      signer,
      signingRegion,
      signingRegionSet,
      signingName
    };
  }, "validateSigningProperties");
  var AwsSdkSigV4Signer = class {
    static {
      __name2(this, "AwsSdkSigV4Signer");
    }
    async sign(httpRequest2, identity, signingProperties) {
      if (!import_protocol_http2.HttpRequest.isInstance(httpRequest2)) {
        throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
      }
      const validatedProps = await validateSigningProperties(signingProperties);
      const { config: config2, signer } = validatedProps;
      let { signingRegion, signingName } = validatedProps;
      const handlerExecutionContext = signingProperties.context;
      if (handlerExecutionContext?.authSchemes?.length ?? 0 > 1) {
        const [first, second] = handlerExecutionContext.authSchemes;
        if (first?.name === "sigv4a" && second?.name === "sigv4") {
          signingRegion = second?.signingRegion ?? signingRegion;
          signingName = second?.signingName ?? signingName;
        }
      }
      const signedRequest = await signer.sign(httpRequest2, {
        signingDate: getSkewCorrectedDate(config2.systemClockOffset),
        signingRegion,
        signingService: signingName
      });
      return signedRequest;
    }
    errorHandler(signingProperties) {
      return (error) => {
        const serverTime = error.ServerTime ?? getDateHeader(error.$response);
        if (serverTime) {
          const config2 = throwSigningPropertyError("config", signingProperties.config);
          const initialSystemClockOffset = config2.systemClockOffset;
          config2.systemClockOffset = getUpdatedSystemClockOffset(serverTime, config2.systemClockOffset);
          const clockSkewCorrected = config2.systemClockOffset !== initialSystemClockOffset;
          if (clockSkewCorrected && error.$metadata) {
            error.$metadata.clockSkewCorrected = true;
          }
        }
        throw error;
      };
    }
    successHandler(httpResponse2, signingProperties) {
      const dateHeader = getDateHeader(httpResponse2);
      if (dateHeader) {
        const config2 = throwSigningPropertyError("config", signingProperties.config);
        config2.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, config2.systemClockOffset);
      }
    }
  };
  var AWSSDKSigV4Signer = AwsSdkSigV4Signer;
  var import_protocol_http32 = require_dist_cjs2();
  var AwsSdkSigV4ASigner = class extends AwsSdkSigV4Signer {
    static {
      __name2(this, "AwsSdkSigV4ASigner");
    }
    async sign(httpRequest2, identity, signingProperties) {
      if (!import_protocol_http32.HttpRequest.isInstance(httpRequest2)) {
        throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
      }
      const { config: config2, signer, signingRegion, signingRegionSet, signingName } = await validateSigningProperties(signingProperties);
      const configResolvedSigningRegionSet = await config2.sigv4aSigningRegionSet?.();
      const multiRegionOverride = (configResolvedSigningRegionSet ?? signingRegionSet ?? [signingRegion]).join(",");
      const signedRequest = await signer.sign(httpRequest2, {
        signingDate: getSkewCorrectedDate(config2.systemClockOffset),
        signingRegion: multiRegionOverride,
        signingService: signingName
      });
      return signedRequest;
    }
  };
  var import_core3 = require_dist_cjs15();
  var import_property_provider = require_dist_cjs16();
  var resolveAwsSdkSigV4AConfig = /* @__PURE__ */ __name2((config2) => {
    config2.sigv4aSigningRegionSet = (0, import_core3.normalizeProvider)(config2.sigv4aSigningRegionSet);
    return config2;
  }, "resolveAwsSdkSigV4AConfig");
  var NODE_SIGV4A_CONFIG_OPTIONS = {
    environmentVariableSelector(env2) {
      if (env2.AWS_SIGV4A_SIGNING_REGION_SET) {
        return env2.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((_3) => _3.trim());
      }
      throw new import_property_provider.ProviderError("AWS_SIGV4A_SIGNING_REGION_SET not set in env.", {
        tryNextLink: true
      });
    },
    configFileSelector(profile) {
      if (profile.sigv4a_signing_region_set) {
        return (profile.sigv4a_signing_region_set ?? "").split(",").map((_3) => _3.trim());
      }
      throw new import_property_provider.ProviderError("sigv4a_signing_region_set not set in profile.", {
        tryNextLink: true
      });
    },
    default: undefined
  };
  var import_client = require_client();
  var import_core22 = require_dist_cjs15();
  var import_signature_v4 = require_dist_cjs17();
  var resolveAwsSdkSigV4Config = /* @__PURE__ */ __name2((config2) => {
    let isUserSupplied = false;
    let credentialsProvider;
    if (config2.credentials) {
      isUserSupplied = true;
      credentialsProvider = (0, import_core22.memoizeIdentityProvider)(config2.credentials, import_core22.isIdentityExpired, import_core22.doesIdentityRequireRefresh);
    }
    if (!credentialsProvider) {
      if (config2.credentialDefaultProvider) {
        credentialsProvider = (0, import_core22.normalizeProvider)(config2.credentialDefaultProvider(Object.assign({}, config2, {
          parentClientConfig: config2
        })));
      } else {
        credentialsProvider = /* @__PURE__ */ __name2(async () => {
          throw new Error("`credentials` is missing");
        }, "credentialsProvider");
      }
    }
    const boundCredentialsProvider = /* @__PURE__ */ __name2(async () => credentialsProvider({ callerClientConfig: config2 }), "boundCredentialsProvider");
    const {
      signingEscapePath = true,
      systemClockOffset = config2.systemClockOffset || 0,
      sha256: sha2562
    } = config2;
    let signer;
    if (config2.signer) {
      signer = (0, import_core22.normalizeProvider)(config2.signer);
    } else if (config2.regionInfoProvider) {
      signer = /* @__PURE__ */ __name2(() => (0, import_core22.normalizeProvider)(config2.region)().then(async (region) => [
        await config2.regionInfoProvider(region, {
          useFipsEndpoint: await config2.useFipsEndpoint(),
          useDualstackEndpoint: await config2.useDualstackEndpoint()
        }) || {},
        region
      ]).then(([regionInfo, region]) => {
        const { signingRegion, signingService } = regionInfo;
        config2.signingRegion = config2.signingRegion || signingRegion || region;
        config2.signingName = config2.signingName || signingService || config2.serviceId;
        const params = {
          ...config2,
          credentials: boundCredentialsProvider,
          region: config2.signingRegion,
          service: config2.signingName,
          sha256: sha2562,
          uriEscapePath: signingEscapePath
        };
        const SignerCtor = config2.signerConstructor || import_signature_v4.SignatureV4;
        return new SignerCtor(params);
      }), "signer");
    } else {
      signer = /* @__PURE__ */ __name2(async (authScheme) => {
        authScheme = Object.assign({}, {
          name: "sigv4",
          signingName: config2.signingName || config2.defaultSigningName,
          signingRegion: await (0, import_core22.normalizeProvider)(config2.region)(),
          properties: {}
        }, authScheme);
        const signingRegion = authScheme.signingRegion;
        const signingService = authScheme.signingName;
        config2.signingRegion = config2.signingRegion || signingRegion;
        config2.signingName = config2.signingName || signingService || config2.serviceId;
        const params = {
          ...config2,
          credentials: boundCredentialsProvider,
          region: config2.signingRegion,
          service: config2.signingName,
          sha256: sha2562,
          uriEscapePath: signingEscapePath
        };
        const SignerCtor = config2.signerConstructor || import_signature_v4.SignatureV4;
        return new SignerCtor(params);
      }, "signer");
    }
    return {
      ...config2,
      systemClockOffset,
      signingEscapePath,
      credentials: isUserSupplied ? async () => boundCredentialsProvider().then((creds) => (0, import_client.setCredentialFeature)(creds, "CREDENTIALS_CODE", "e")) : boundCredentialsProvider,
      signer
    };
  }, "resolveAwsSdkSigV4Config");
  var resolveAWSSDKSigV4Config = resolveAwsSdkSigV4Config;
});

// ../../node_modules/@smithy/middleware-stack/dist-cjs/index.js
var require_dist_cjs18 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    constructStack: () => constructStack
  });
  module.exports = __toCommonJS(src_exports);
  var getAllAliases = /* @__PURE__ */ __name2((name, aliases) => {
    const _aliases = [];
    if (name) {
      _aliases.push(name);
    }
    if (aliases) {
      for (const alias of aliases) {
        _aliases.push(alias);
      }
    }
    return _aliases;
  }, "getAllAliases");
  var getMiddlewareNameWithAliases = /* @__PURE__ */ __name2((name, aliases) => {
    return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
  }, "getMiddlewareNameWithAliases");
  var constructStack = /* @__PURE__ */ __name2(() => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = /* @__PURE__ */ new Set;
    const sort = /* @__PURE__ */ __name2((entries) => entries.sort((a3, b) => stepWeights[b.step] - stepWeights[a3.step] || priorityWeights[b.priority || "normal"] - priorityWeights[a3.priority || "normal"]), "sort");
    const removeByName = /* @__PURE__ */ __name2((toRemove) => {
      let isRemoved = false;
      const filterCb = /* @__PURE__ */ __name2((entry) => {
        const aliases = getAllAliases(entry.name, entry.aliases);
        if (aliases.includes(toRemove)) {
          isRemoved = true;
          for (const alias of aliases) {
            entriesNameSet.delete(alias);
          }
          return false;
        }
        return true;
      }, "filterCb");
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    }, "removeByName");
    const removeByReference = /* @__PURE__ */ __name2((toRemove) => {
      let isRemoved = false;
      const filterCb = /* @__PURE__ */ __name2((entry) => {
        if (entry.middleware === toRemove) {
          isRemoved = true;
          for (const alias of getAllAliases(entry.name, entry.aliases)) {
            entriesNameSet.delete(alias);
          }
          return false;
        }
        return true;
      }, "filterCb");
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    }, "removeByReference");
    const cloneTo = /* @__PURE__ */ __name2((toStack) => {
      absoluteEntries.forEach((entry) => {
        toStack.add(entry.middleware, { ...entry });
      });
      relativeEntries.forEach((entry) => {
        toStack.addRelativeTo(entry.middleware, { ...entry });
      });
      toStack.identifyOnResolve?.(stack.identifyOnResolve());
      return toStack;
    }, "cloneTo");
    const expandRelativeMiddlewareList = /* @__PURE__ */ __name2((from) => {
      const expandedMiddlewareList = [];
      from.before.forEach((entry) => {
        if (entry.before.length === 0 && entry.after.length === 0) {
          expandedMiddlewareList.push(entry);
        } else {
          expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
        }
      });
      expandedMiddlewareList.push(from);
      from.after.reverse().forEach((entry) => {
        if (entry.before.length === 0 && entry.after.length === 0) {
          expandedMiddlewareList.push(entry);
        } else {
          expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
        }
      });
      return expandedMiddlewareList;
    }, "expandRelativeMiddlewareList");
    const getMiddlewareList = /* @__PURE__ */ __name2((debug = false) => {
      const normalizedAbsoluteEntries = [];
      const normalizedRelativeEntries = [];
      const normalizedEntriesNameMap = {};
      absoluteEntries.forEach((entry) => {
        const normalizedEntry = {
          ...entry,
          before: [],
          after: []
        };
        for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
          normalizedEntriesNameMap[alias] = normalizedEntry;
        }
        normalizedAbsoluteEntries.push(normalizedEntry);
      });
      relativeEntries.forEach((entry) => {
        const normalizedEntry = {
          ...entry,
          before: [],
          after: []
        };
        for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
          normalizedEntriesNameMap[alias] = normalizedEntry;
        }
        normalizedRelativeEntries.push(normalizedEntry);
      });
      normalizedRelativeEntries.forEach((entry) => {
        if (entry.toMiddleware) {
          const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
          if (toMiddleware === undefined) {
            if (debug) {
              return;
            }
            throw new Error(`${entry.toMiddleware} is not found when adding ${getMiddlewareNameWithAliases(entry.name, entry.aliases)} middleware ${entry.relation} ${entry.toMiddleware}`);
          }
          if (entry.relation === "after") {
            toMiddleware.after.push(entry);
          }
          if (entry.relation === "before") {
            toMiddleware.before.push(entry);
          }
        }
      });
      const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
        wholeList.push(...expandedMiddlewareList);
        return wholeList;
      }, []);
      return mainChain;
    }, "getMiddlewareList");
    const stack = {
      add: (middleware, options = {}) => {
        const { name, override, aliases: _aliases } = options;
        const entry = {
          step: "initialize",
          priority: "normal",
          middleware,
          ...options
        };
        const aliases = getAllAliases(name, _aliases);
        if (aliases.length > 0) {
          if (aliases.some((alias) => entriesNameSet.has(alias))) {
            if (!override)
              throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
            for (const alias of aliases) {
              const toOverrideIndex = absoluteEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a3) => a3 === alias));
              if (toOverrideIndex === -1) {
                continue;
              }
              const toOverride = absoluteEntries[toOverrideIndex];
              if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ${entry.priority} priority in ${entry.step} step.`);
              }
              absoluteEntries.splice(toOverrideIndex, 1);
            }
          }
          for (const alias of aliases) {
            entriesNameSet.add(alias);
          }
        }
        absoluteEntries.push(entry);
      },
      addRelativeTo: (middleware, options) => {
        const { name, override, aliases: _aliases } = options;
        const entry = {
          middleware,
          ...options
        };
        const aliases = getAllAliases(name, _aliases);
        if (aliases.length > 0) {
          if (aliases.some((alias) => entriesNameSet.has(alias))) {
            if (!override)
              throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
            for (const alias of aliases) {
              const toOverrideIndex = relativeEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a3) => a3 === alias));
              if (toOverrideIndex === -1) {
                continue;
              }
              const toOverride = relativeEntries[toOverrideIndex];
              if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
              }
              relativeEntries.splice(toOverrideIndex, 1);
            }
          }
          for (const alias of aliases) {
            entriesNameSet.add(alias);
          }
        }
        relativeEntries.push(entry);
      },
      clone: () => cloneTo(constructStack()),
      use: (plugin) => {
        plugin.applyToStack(stack);
      },
      remove: (toRemove) => {
        if (typeof toRemove === "string")
          return removeByName(toRemove);
        else
          return removeByReference(toRemove);
      },
      removeByTag: (toRemove) => {
        let isRemoved = false;
        const filterCb = /* @__PURE__ */ __name2((entry) => {
          const { tags, name, aliases: _aliases } = entry;
          if (tags && tags.includes(toRemove)) {
            const aliases = getAllAliases(name, _aliases);
            for (const alias of aliases) {
              entriesNameSet.delete(alias);
            }
            isRemoved = true;
            return false;
          }
          return true;
        }, "filterCb");
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
      },
      concat: (from) => {
        const cloned = cloneTo(constructStack());
        cloned.use(from);
        cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
        return cloned;
      },
      applyToStack: cloneTo,
      identify: () => {
        return getMiddlewareList(true).map((mw) => {
          const step = mw.step ?? mw.relation + " " + mw.toMiddleware;
          return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
        });
      },
      identifyOnResolve(toggle) {
        if (typeof toggle === "boolean")
          identifyOnResolve = toggle;
        return identifyOnResolve;
      },
      resolve: (handler, context) => {
        for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
          handler = middleware(handler, context);
        }
        if (identifyOnResolve) {
          console.log(stack.identify());
        }
        return handler;
      }
    };
    return stack;
  }, "constructStack");
  var stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1
  };
  var priorityWeights = {
    high: 3,
    normal: 2,
    low: 1
  };
});

// ../../node_modules/@smithy/smithy-client/dist-cjs/index.js
var require_dist_cjs19 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Client: () => Client,
    Command: () => Command,
    LazyJsonString: () => LazyJsonString,
    NoOpLogger: () => NoOpLogger,
    SENSITIVE_STRING: () => SENSITIVE_STRING,
    ServiceException: () => ServiceException,
    _json: () => _json,
    collectBody: () => import_protocols.collectBody,
    convertMap: () => convertMap,
    createAggregatedClient: () => createAggregatedClient,
    dateToUtcString: () => dateToUtcString,
    decorateServiceException: () => decorateServiceException,
    emitWarningIfUnsupportedVersion: () => emitWarningIfUnsupportedVersion,
    expectBoolean: () => expectBoolean,
    expectByte: () => expectByte,
    expectFloat32: () => expectFloat32,
    expectInt: () => expectInt,
    expectInt32: () => expectInt32,
    expectLong: () => expectLong,
    expectNonNull: () => expectNonNull,
    expectNumber: () => expectNumber,
    expectObject: () => expectObject,
    expectShort: () => expectShort,
    expectString: () => expectString,
    expectUnion: () => expectUnion,
    extendedEncodeURIComponent: () => import_protocols.extendedEncodeURIComponent,
    getArrayIfSingleItem: () => getArrayIfSingleItem,
    getDefaultClientConfiguration: () => getDefaultClientConfiguration,
    getDefaultExtensionConfiguration: () => getDefaultExtensionConfiguration,
    getValueFromTextNode: () => getValueFromTextNode,
    handleFloat: () => handleFloat,
    isSerializableHeaderValue: () => isSerializableHeaderValue,
    limitedParseDouble: () => limitedParseDouble,
    limitedParseFloat: () => limitedParseFloat,
    limitedParseFloat32: () => limitedParseFloat32,
    loadConfigsForDefaultMode: () => loadConfigsForDefaultMode,
    logger: () => logger,
    map: () => map,
    parseBoolean: () => parseBoolean,
    parseEpochTimestamp: () => parseEpochTimestamp,
    parseRfc3339DateTime: () => parseRfc3339DateTime,
    parseRfc3339DateTimeWithOffset: () => parseRfc3339DateTimeWithOffset,
    parseRfc7231DateTime: () => parseRfc7231DateTime,
    quoteHeader: () => quoteHeader,
    resolveDefaultRuntimeConfig: () => resolveDefaultRuntimeConfig,
    resolvedPath: () => import_protocols.resolvedPath,
    serializeDateTime: () => serializeDateTime,
    serializeFloat: () => serializeFloat,
    splitEvery: () => splitEvery,
    splitHeader: () => splitHeader,
    strictParseByte: () => strictParseByte,
    strictParseDouble: () => strictParseDouble,
    strictParseFloat: () => strictParseFloat,
    strictParseFloat32: () => strictParseFloat32,
    strictParseInt: () => strictParseInt,
    strictParseInt32: () => strictParseInt32,
    strictParseLong: () => strictParseLong,
    strictParseShort: () => strictParseShort,
    take: () => take,
    throwDefaultError: () => throwDefaultError,
    withBaseException: () => withBaseException
  });
  module.exports = __toCommonJS(src_exports);
  var import_middleware_stack = require_dist_cjs18();
  var Client = class {
    constructor(config2) {
      this.config = config2;
      this.middlewareStack = (0, import_middleware_stack.constructStack)();
    }
    static {
      __name2(this, "Client");
    }
    send(command, optionsOrCb, cb) {
      const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
      const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
      const useHandlerCache = options === undefined && this.config.cacheMiddleware === true;
      let handler;
      if (useHandlerCache) {
        if (!this.handlers) {
          this.handlers = /* @__PURE__ */ new WeakMap;
        }
        const handlers = this.handlers;
        if (handlers.has(command.constructor)) {
          handler = handlers.get(command.constructor);
        } else {
          handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
          handlers.set(command.constructor, handler);
        }
      } else {
        delete this.handlers;
        handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
      }
      if (callback) {
        handler(command).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {
        });
      } else {
        return handler(command).then((result) => result.output);
      }
    }
    destroy() {
      this.config?.requestHandler?.destroy?.();
      delete this.handlers;
    }
  };
  var import_protocols = require_protocols();
  var import_types3 = require_dist_cjs();
  var Command = class {
    constructor() {
      this.middlewareStack = (0, import_middleware_stack.constructStack)();
    }
    static {
      __name2(this, "Command");
    }
    static classBuilder() {
      return new ClassBuilder;
    }
    resolveMiddlewareWithContext(clientStack, configuration, options, {
      middlewareFn,
      clientName,
      commandName,
      inputFilterSensitiveLog,
      outputFilterSensitiveLog,
      smithyContext,
      additionalContext,
      CommandCtor
    }) {
      for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
        this.middlewareStack.use(mw);
      }
      const stack = clientStack.concat(this.middlewareStack);
      const { logger: logger2 } = configuration;
      const handlerExecutionContext = {
        logger: logger2,
        clientName,
        commandName,
        inputFilterSensitiveLog,
        outputFilterSensitiveLog,
        [import_types3.SMITHY_CONTEXT_KEY]: {
          commandInstance: this,
          ...smithyContext
        },
        ...additionalContext
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
  };
  var ClassBuilder = class {
    constructor() {
      this._init = () => {
      };
      this._ep = {};
      this._middlewareFn = () => [];
      this._commandName = "";
      this._clientName = "";
      this._additionalContext = {};
      this._smithyContext = {};
      this._inputFilterSensitiveLog = (_3) => _3;
      this._outputFilterSensitiveLog = (_3) => _3;
      this._serializer = null;
      this._deserializer = null;
    }
    static {
      __name2(this, "ClassBuilder");
    }
    init(cb) {
      this._init = cb;
    }
    ep(endpointParameterInstructions) {
      this._ep = endpointParameterInstructions;
      return this;
    }
    m(middlewareSupplier) {
      this._middlewareFn = middlewareSupplier;
      return this;
    }
    s(service, operation, smithyContext = {}) {
      this._smithyContext = {
        service,
        operation,
        ...smithyContext
      };
      return this;
    }
    c(additionalContext = {}) {
      this._additionalContext = additionalContext;
      return this;
    }
    n(clientName, commandName) {
      this._clientName = clientName;
      this._commandName = commandName;
      return this;
    }
    f(inputFilter = (_3) => _3, outputFilter = (_3) => _3) {
      this._inputFilterSensitiveLog = inputFilter;
      this._outputFilterSensitiveLog = outputFilter;
      return this;
    }
    ser(serializer) {
      this._serializer = serializer;
      return this;
    }
    de(deserializer) {
      this._deserializer = deserializer;
      return this;
    }
    build() {
      const closure = this;
      let CommandRef;
      return CommandRef = class extends Command {
        constructor(...[input]) {
          super();
          this.serialize = closure._serializer;
          this.deserialize = closure._deserializer;
          this.input = input ?? {};
          closure._init(this);
        }
        static {
          __name2(this, "CommandRef");
        }
        static getEndpointParameterInstructions() {
          return closure._ep;
        }
        resolveMiddleware(stack, configuration, options) {
          return this.resolveMiddlewareWithContext(stack, configuration, options, {
            CommandCtor: CommandRef,
            middlewareFn: closure._middlewareFn,
            clientName: closure._clientName,
            commandName: closure._commandName,
            inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
            outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
            smithyContext: closure._smithyContext,
            additionalContext: closure._additionalContext
          });
        }
      };
    }
  };
  var SENSITIVE_STRING = "***SensitiveInformation***";
  var createAggregatedClient = /* @__PURE__ */ __name2((commands, Client2) => {
    for (const command of Object.keys(commands)) {
      const CommandCtor = commands[command];
      const methodImpl = /* @__PURE__ */ __name2(async function(args, optionsOrCb, cb) {
        const command2 = new CommandCtor(args);
        if (typeof optionsOrCb === "function") {
          this.send(command2, optionsOrCb);
        } else if (typeof cb === "function") {
          if (typeof optionsOrCb !== "object")
            throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
          this.send(command2, optionsOrCb || {}, cb);
        } else {
          return this.send(command2, optionsOrCb);
        }
      }, "methodImpl");
      const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
      Client2.prototype[methodName] = methodImpl;
    }
  }, "createAggregatedClient");
  var parseBoolean = /* @__PURE__ */ __name2((value) => {
    switch (value) {
      case "true":
        return true;
      case "false":
        return false;
      default:
        throw new Error(`Unable to parse boolean value "${value}"`);
    }
  }, "parseBoolean");
  var expectBoolean = /* @__PURE__ */ __name2((value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value === "number") {
      if (value === 0 || value === 1) {
        logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
      }
      if (value === 0) {
        return false;
      }
      if (value === 1) {
        return true;
      }
    }
    if (typeof value === "string") {
      const lower = value.toLowerCase();
      if (lower === "false" || lower === "true") {
        logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
      }
      if (lower === "false") {
        return false;
      }
      if (lower === "true") {
        return true;
      }
    }
    if (typeof value === "boolean") {
      return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
  }, "expectBoolean");
  var expectNumber = /* @__PURE__ */ __name2((value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value === "string") {
      const parsed = parseFloat(value);
      if (!Number.isNaN(parsed)) {
        if (String(parsed) !== String(value)) {
          logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
        }
        return parsed;
      }
    }
    if (typeof value === "number") {
      return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
  }, "expectNumber");
  var MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
  var expectFloat32 = /* @__PURE__ */ __name2((value) => {
    const expected = expectNumber(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
      if (Math.abs(expected) > MAX_FLOAT) {
        throw new TypeError(`Expected 32-bit float, got ${value}`);
      }
    }
    return expected;
  }, "expectFloat32");
  var expectLong = /* @__PURE__ */ __name2((value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
      return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
  }, "expectLong");
  var expectInt = expectLong;
  var expectInt32 = /* @__PURE__ */ __name2((value) => expectSizedInt(value, 32), "expectInt32");
  var expectShort = /* @__PURE__ */ __name2((value) => expectSizedInt(value, 16), "expectShort");
  var expectByte = /* @__PURE__ */ __name2((value) => expectSizedInt(value, 8), "expectByte");
  var expectSizedInt = /* @__PURE__ */ __name2((value, size) => {
    const expected = expectLong(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
      throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
  }, "expectSizedInt");
  var castInt = /* @__PURE__ */ __name2((value, size) => {
    switch (size) {
      case 32:
        return Int32Array.of(value)[0];
      case 16:
        return Int16Array.of(value)[0];
      case 8:
        return Int8Array.of(value)[0];
    }
  }, "castInt");
  var expectNonNull = /* @__PURE__ */ __name2((value, location) => {
    if (value === null || value === undefined) {
      if (location) {
        throw new TypeError(`Expected a non-null value for ${location}`);
      }
      throw new TypeError("Expected a non-null value");
    }
    return value;
  }, "expectNonNull");
  var expectObject = /* @__PURE__ */ __name2((value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
      return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
  }, "expectObject");
  var expectString = /* @__PURE__ */ __name2((value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value === "string") {
      return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
      logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
      return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
  }, "expectString");
  var expectUnion = /* @__PURE__ */ __name2((value) => {
    if (value === null || value === undefined) {
      return;
    }
    const asObject = expectObject(value);
    const setKeys = Object.entries(asObject).filter(([, v2]) => v2 != null).map(([k2]) => k2);
    if (setKeys.length === 0) {
      throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
      throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
  }, "expectUnion");
  var strictParseDouble = /* @__PURE__ */ __name2((value) => {
    if (typeof value == "string") {
      return expectNumber(parseNumber(value));
    }
    return expectNumber(value);
  }, "strictParseDouble");
  var strictParseFloat = strictParseDouble;
  var strictParseFloat32 = /* @__PURE__ */ __name2((value) => {
    if (typeof value == "string") {
      return expectFloat32(parseNumber(value));
    }
    return expectFloat32(value);
  }, "strictParseFloat32");
  var NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
  var parseNumber = /* @__PURE__ */ __name2((value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
      throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
  }, "parseNumber");
  var limitedParseDouble = /* @__PURE__ */ __name2((value) => {
    if (typeof value == "string") {
      return parseFloatString(value);
    }
    return expectNumber(value);
  }, "limitedParseDouble");
  var handleFloat = limitedParseDouble;
  var limitedParseFloat = limitedParseDouble;
  var limitedParseFloat32 = /* @__PURE__ */ __name2((value) => {
    if (typeof value == "string") {
      return parseFloatString(value);
    }
    return expectFloat32(value);
  }, "limitedParseFloat32");
  var parseFloatString = /* @__PURE__ */ __name2((value) => {
    switch (value) {
      case "NaN":
        return NaN;
      case "Infinity":
        return Infinity;
      case "-Infinity":
        return -Infinity;
      default:
        throw new Error(`Unable to parse float value: ${value}`);
    }
  }, "parseFloatString");
  var strictParseLong = /* @__PURE__ */ __name2((value) => {
    if (typeof value === "string") {
      return expectLong(parseNumber(value));
    }
    return expectLong(value);
  }, "strictParseLong");
  var strictParseInt = strictParseLong;
  var strictParseInt32 = /* @__PURE__ */ __name2((value) => {
    if (typeof value === "string") {
      return expectInt32(parseNumber(value));
    }
    return expectInt32(value);
  }, "strictParseInt32");
  var strictParseShort = /* @__PURE__ */ __name2((value) => {
    if (typeof value === "string") {
      return expectShort(parseNumber(value));
    }
    return expectShort(value);
  }, "strictParseShort");
  var strictParseByte = /* @__PURE__ */ __name2((value) => {
    if (typeof value === "string") {
      return expectByte(parseNumber(value));
    }
    return expectByte(value);
  }, "strictParseByte");
  var stackTraceWarning = /* @__PURE__ */ __name2((message) => {
    return String(new TypeError(message).stack || message).split(`
`).slice(0, 5).filter((s2) => !s2.includes("stackTraceWarning")).join(`
`);
  }, "stackTraceWarning");
  var logger = {
    warn: console.warn
  };
  var DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  var MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  function dateToUtcString(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
  }
  __name2(dateToUtcString, "dateToUtcString");
  var RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
  var parseRfc3339DateTime = /* @__PURE__ */ __name2((value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value !== "string") {
      throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value);
    if (!match) {
      throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_3, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
  }, "parseRfc3339DateTime");
  var RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
  var parseRfc3339DateTimeWithOffset = /* @__PURE__ */ __name2((value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value !== "string") {
      throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339_WITH_OFFSET.exec(value);
    if (!match) {
      throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_3, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
      date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date;
  }, "parseRfc3339DateTimeWithOffset");
  var IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
  var RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
  var ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
  var parseRfc7231DateTime = /* @__PURE__ */ __name2((value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value !== "string") {
      throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = IMF_FIXDATE.exec(value);
    if (match) {
      const [_3, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
      return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = RFC_850_DATE.exec(value);
    if (match) {
      const [_3, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
      return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
        hours,
        minutes,
        seconds,
        fractionalMilliseconds
      }));
    }
    match = ASC_TIME.exec(value);
    if (match) {
      const [_3, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
      return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
  }, "parseRfc7231DateTime");
  var parseEpochTimestamp = /* @__PURE__ */ __name2((value) => {
    if (value === null || value === undefined) {
      return;
    }
    let valueAsDouble;
    if (typeof value === "number") {
      valueAsDouble = value;
    } else if (typeof value === "string") {
      valueAsDouble = strictParseDouble(value);
    } else if (typeof value === "object" && value.tag === 1) {
      valueAsDouble = value.value;
    } else {
      throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
      throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
  }, "parseEpochTimestamp");
  var buildDate = /* @__PURE__ */ __name2((year, month, day, time) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
  }, "buildDate");
  var parseTwoDigitYear = /* @__PURE__ */ __name2((value) => {
    const thisYear = (/* @__PURE__ */ new Date()).getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
      return valueInThisCentury + 100;
    }
    return valueInThisCentury;
  }, "parseTwoDigitYear");
  var FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1000;
  var adjustRfc850Year = /* @__PURE__ */ __name2((input) => {
    if (input.getTime() - (/* @__PURE__ */ new Date()).getTime() > FIFTY_YEARS_IN_MILLIS) {
      return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
  }, "adjustRfc850Year");
  var parseMonthByShortName = /* @__PURE__ */ __name2((value) => {
    const monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
      throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
  }, "parseMonthByShortName");
  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var validateDayOfMonth = /* @__PURE__ */ __name2((year, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
      maxDays = 29;
    }
    if (day > maxDays) {
      throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
  }, "validateDayOfMonth");
  var isLeapYear = /* @__PURE__ */ __name2((year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }, "isLeapYear");
  var parseDateValue = /* @__PURE__ */ __name2((value, type, lower, upper) => {
    const dateVal = strictParseByte(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
      throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
  }, "parseDateValue");
  var parseMilliseconds = /* @__PURE__ */ __name2((value) => {
    if (value === null || value === undefined) {
      return 0;
    }
    return strictParseFloat32("0." + value) * 1000;
  }, "parseMilliseconds");
  var parseOffsetToMilliseconds = /* @__PURE__ */ __name2((value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
      direction = 1;
    } else if (directionStr == "-") {
      direction = -1;
    } else {
      throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1000;
  }, "parseOffsetToMilliseconds");
  var stripLeadingZeroes = /* @__PURE__ */ __name2((value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
      idx++;
    }
    if (idx === 0) {
      return value;
    }
    return value.slice(idx);
  }, "stripLeadingZeroes");
  var ServiceException = class _ServiceException extends Error {
    static {
      __name2(this, "ServiceException");
    }
    constructor(options) {
      super(options.message);
      Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype);
      this.name = options.name;
      this.$fault = options.$fault;
      this.$metadata = options.$metadata;
    }
    static isInstance(value) {
      if (!value)
        return false;
      const candidate = value;
      return _ServiceException.prototype.isPrototypeOf(candidate) || Boolean(candidate.$fault) && Boolean(candidate.$metadata) && (candidate.$fault === "client" || candidate.$fault === "server");
    }
    static [Symbol.hasInstance](instance) {
      if (!instance)
        return false;
      const candidate = instance;
      if (this === _ServiceException) {
        return _ServiceException.isInstance(instance);
      }
      if (_ServiceException.isInstance(instance)) {
        if (candidate.name && this.name) {
          return this.prototype.isPrototypeOf(instance) || candidate.name === this.name;
        }
        return this.prototype.isPrototypeOf(instance);
      }
      return false;
    }
  };
  var decorateServiceException = /* @__PURE__ */ __name2((exception, additions = {}) => {
    Object.entries(additions).filter(([, v2]) => v2 !== undefined).forEach(([k2, v2]) => {
      if (exception[k2] == undefined || exception[k2] === "") {
        exception[k2] = v2;
      }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
  }, "decorateServiceException");
  var throwDefaultError = /* @__PURE__ */ __name2(({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response = new exceptionCtor({
      name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
      $fault: "client",
      $metadata
    });
    throw decorateServiceException(response, parsedBody);
  }, "throwDefaultError");
  var withBaseException = /* @__PURE__ */ __name2((ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
      throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
  }, "withBaseException");
  var deserializeMetadata = /* @__PURE__ */ __name2((output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"]
  }), "deserializeMetadata");
  var loadConfigsForDefaultMode = /* @__PURE__ */ __name2((mode) => {
    switch (mode) {
      case "standard":
        return {
          retryMode: "standard",
          connectionTimeout: 3100
        };
      case "in-region":
        return {
          retryMode: "standard",
          connectionTimeout: 1100
        };
      case "cross-region":
        return {
          retryMode: "standard",
          connectionTimeout: 3100
        };
      case "mobile":
        return {
          retryMode: "standard",
          connectionTimeout: 30000
        };
      default:
        return {};
    }
  }, "loadConfigsForDefaultMode");
  var warningEmitted = false;
  var emitWarningIfUnsupportedVersion = /* @__PURE__ */ __name2((version) => {
    if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 16) {
      warningEmitted = true;
    }
  }, "emitWarningIfUnsupportedVersion");
  var getChecksumConfiguration = /* @__PURE__ */ __name2((runtimeConfig) => {
    const checksumAlgorithms = [];
    for (const id in import_types3.AlgorithmId) {
      const algorithmId = import_types3.AlgorithmId[id];
      if (runtimeConfig[algorithmId] === undefined) {
        continue;
      }
      checksumAlgorithms.push({
        algorithmId: () => algorithmId,
        checksumConstructor: () => runtimeConfig[algorithmId]
      });
    }
    return {
      _checksumAlgorithms: checksumAlgorithms,
      addChecksumAlgorithm(algo) {
        this._checksumAlgorithms.push(algo);
      },
      checksumAlgorithms() {
        return this._checksumAlgorithms;
      }
    };
  }, "getChecksumConfiguration");
  var resolveChecksumRuntimeConfig = /* @__PURE__ */ __name2((clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
      runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
  }, "resolveChecksumRuntimeConfig");
  var getRetryConfiguration = /* @__PURE__ */ __name2((runtimeConfig) => {
    let _retryStrategy = runtimeConfig.retryStrategy;
    return {
      setRetryStrategy(retryStrategy) {
        _retryStrategy = retryStrategy;
      },
      retryStrategy() {
        return _retryStrategy;
      }
    };
  }, "getRetryConfiguration");
  var resolveRetryRuntimeConfig = /* @__PURE__ */ __name2((retryStrategyConfiguration) => {
    const runtimeConfig = {};
    runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
    return runtimeConfig;
  }, "resolveRetryRuntimeConfig");
  var getDefaultExtensionConfiguration = /* @__PURE__ */ __name2((runtimeConfig) => {
    return {
      ...getChecksumConfiguration(runtimeConfig),
      ...getRetryConfiguration(runtimeConfig)
    };
  }, "getDefaultExtensionConfiguration");
  var getDefaultClientConfiguration = getDefaultExtensionConfiguration;
  var resolveDefaultRuntimeConfig = /* @__PURE__ */ __name2((config2) => {
    return {
      ...resolveChecksumRuntimeConfig(config2),
      ...resolveRetryRuntimeConfig(config2)
    };
  }, "resolveDefaultRuntimeConfig");
  var getArrayIfSingleItem = /* @__PURE__ */ __name2((mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray], "getArrayIfSingleItem");
  var getValueFromTextNode = /* @__PURE__ */ __name2((obj) => {
    const textNodeName = "#text";
    for (const key in obj) {
      if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== undefined) {
        obj[key] = obj[key][textNodeName];
      } else if (typeof obj[key] === "object" && obj[key] !== null) {
        obj[key] = getValueFromTextNode(obj[key]);
      }
    }
    return obj;
  }, "getValueFromTextNode");
  var isSerializableHeaderValue = /* @__PURE__ */ __name2((value) => {
    return value != null;
  }, "isSerializableHeaderValue");
  var LazyJsonString = /* @__PURE__ */ __name2(function LazyJsonString2(val2) {
    const str = Object.assign(new String(val2), {
      deserializeJSON() {
        return JSON.parse(String(val2));
      },
      toString() {
        return String(val2);
      },
      toJSON() {
        return String(val2);
      }
    });
    return str;
  }, "LazyJsonString");
  LazyJsonString.from = (object) => {
    if (object && typeof object === "object" && (object instanceof LazyJsonString || ("deserializeJSON" in object))) {
      return object;
    } else if (typeof object === "string" || Object.getPrototypeOf(object) === String.prototype) {
      return LazyJsonString(String(object));
    }
    return LazyJsonString(JSON.stringify(object));
  };
  LazyJsonString.fromObject = LazyJsonString.from;
  var NoOpLogger = class {
    static {
      __name2(this, "NoOpLogger");
    }
    trace() {
    }
    debug() {
    }
    info() {
    }
    warn() {
    }
    error() {
    }
  };
  function map(arg0, arg1, arg2) {
    let target;
    let filter;
    let instructions;
    if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
      target = {};
      instructions = arg0;
    } else {
      target = arg0;
      if (typeof arg1 === "function") {
        filter = arg1;
        instructions = arg2;
        return mapWithFilter(target, filter, instructions);
      } else {
        instructions = arg1;
      }
    }
    for (const key of Object.keys(instructions)) {
      if (!Array.isArray(instructions[key])) {
        target[key] = instructions[key];
        continue;
      }
      applyInstruction(target, null, instructions, key);
    }
    return target;
  }
  __name2(map, "map");
  var convertMap = /* @__PURE__ */ __name2((target) => {
    const output = {};
    for (const [k2, v2] of Object.entries(target || {})) {
      output[k2] = [, v2];
    }
    return output;
  }, "convertMap");
  var take = /* @__PURE__ */ __name2((source, instructions) => {
    const out = {};
    for (const key in instructions) {
      applyInstruction(out, source, instructions, key);
    }
    return out;
  }, "take");
  var mapWithFilter = /* @__PURE__ */ __name2((target, filter, instructions) => {
    return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
      if (Array.isArray(value)) {
        _instructions[key] = value;
      } else {
        if (typeof value === "function") {
          _instructions[key] = [filter, value()];
        } else {
          _instructions[key] = [filter, value];
        }
      }
      return _instructions;
    }, {}));
  }, "mapWithFilter");
  var applyInstruction = /* @__PURE__ */ __name2((target, source, instructions, targetKey) => {
    if (source !== null) {
      let instruction = instructions[targetKey];
      if (typeof instruction === "function") {
        instruction = [, instruction];
      }
      const [filter2 = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
      if (typeof filter2 === "function" && filter2(source[sourceKey]) || typeof filter2 !== "function" && !!filter2) {
        target[targetKey] = valueFn(source[sourceKey]);
      }
      return;
    }
    let [filter, value] = instructions[targetKey];
    if (typeof value === "function") {
      let _value;
      const defaultFilterPassed = filter === undefined && (_value = value()) != null;
      const customFilterPassed = typeof filter === "function" && !!filter(undefined) || typeof filter !== "function" && !!filter;
      if (defaultFilterPassed) {
        target[targetKey] = _value;
      } else if (customFilterPassed) {
        target[targetKey] = value();
      }
    } else {
      const defaultFilterPassed = filter === undefined && value != null;
      const customFilterPassed = typeof filter === "function" && !!filter(value) || typeof filter !== "function" && !!filter;
      if (defaultFilterPassed || customFilterPassed) {
        target[targetKey] = value;
      }
    }
  }, "applyInstruction");
  var nonNullish = /* @__PURE__ */ __name2((_3) => _3 != null, "nonNullish");
  var pass = /* @__PURE__ */ __name2((_3) => _3, "pass");
  function quoteHeader(part) {
    if (part.includes(",") || part.includes('"')) {
      part = `"${part.replace(/"/g, "\\\"")}"`;
    }
    return part;
  }
  __name2(quoteHeader, "quoteHeader");
  var serializeFloat = /* @__PURE__ */ __name2((value) => {
    if (value !== value) {
      return "NaN";
    }
    switch (value) {
      case Infinity:
        return "Infinity";
      case -Infinity:
        return "-Infinity";
      default:
        return value;
    }
  }, "serializeFloat");
  var serializeDateTime = /* @__PURE__ */ __name2((date) => date.toISOString().replace(".000Z", "Z"), "serializeDateTime");
  var _json = /* @__PURE__ */ __name2((obj) => {
    if (obj == null) {
      return {};
    }
    if (Array.isArray(obj)) {
      return obj.filter((_3) => _3 != null).map(_json);
    }
    if (typeof obj === "object") {
      const target = {};
      for (const key of Object.keys(obj)) {
        if (obj[key] == null) {
          continue;
        }
        target[key] = _json(obj[key]);
      }
      return target;
    }
    return obj;
  }, "_json");
  function splitEvery(value, delimiter, numDelimiters) {
    if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) {
      throw new Error("Invalid number of delimiters (" + numDelimiters + ") for splitEvery.");
    }
    const segments = value.split(delimiter);
    if (numDelimiters === 1) {
      return segments;
    }
    const compoundSegments = [];
    let currentSegment = "";
    for (let i2 = 0;i2 < segments.length; i2++) {
      if (currentSegment === "") {
        currentSegment = segments[i2];
      } else {
        currentSegment += delimiter + segments[i2];
      }
      if ((i2 + 1) % numDelimiters === 0) {
        compoundSegments.push(currentSegment);
        currentSegment = "";
      }
    }
    if (currentSegment !== "") {
      compoundSegments.push(currentSegment);
    }
    return compoundSegments;
  }
  __name2(splitEvery, "splitEvery");
  var splitHeader = /* @__PURE__ */ __name2((value) => {
    const z2 = value.length;
    const values = [];
    let withinQuotes = false;
    let prevChar = undefined;
    let anchor = 0;
    for (let i2 = 0;i2 < z2; ++i2) {
      const char = value[i2];
      switch (char) {
        case `"`:
          if (prevChar !== "\\") {
            withinQuotes = !withinQuotes;
          }
          break;
        case ",":
          if (!withinQuotes) {
            values.push(value.slice(anchor, i2));
            anchor = i2 + 1;
          }
          break;
        default:
      }
      prevChar = char;
    }
    values.push(value.slice(anchor));
    return values.map((v2) => {
      v2 = v2.trim();
      const z22 = v2.length;
      if (z22 < 2) {
        return v2;
      }
      if (v2[0] === `"` && v2[z22 - 1] === `"`) {
        v2 = v2.slice(1, z22 - 1);
      }
      return v2.replace(/\\"/g, '"');
    });
  }, "splitHeader");
});

// ../../node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS((exports) => {
  var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
  var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
  var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
  var regexName = new RegExp("^" + nameRegexp + "$");
  var getAllMatches = function(string, regex2) {
    const matches = [];
    let match = regex2.exec(string);
    while (match) {
      const allmatches = [];
      allmatches.startIndex = regex2.lastIndex - match[0].length;
      const len = match.length;
      for (let index = 0;index < len; index++) {
        allmatches.push(match[index]);
      }
      matches.push(allmatches);
      match = regex2.exec(string);
    }
    return matches;
  };
  var isName = function(string) {
    const match = regexName.exec(string);
    return !(match === null || typeof match === "undefined");
  };
  exports.isExist = function(v2) {
    return typeof v2 !== "undefined";
  };
  exports.isEmptyObject = function(obj) {
    return Object.keys(obj).length === 0;
  };
  exports.merge = function(target, a3, arrayMode) {
    if (a3) {
      const keys = Object.keys(a3);
      const len = keys.length;
      for (let i2 = 0;i2 < len; i2++) {
        if (arrayMode === "strict") {
          target[keys[i2]] = [a3[keys[i2]]];
        } else {
          target[keys[i2]] = a3[keys[i2]];
        }
      }
    }
  };
  exports.getValue = function(v2) {
    if (exports.isExist(v2)) {
      return v2;
    } else {
      return "";
    }
  };
  exports.isName = isName;
  exports.getAllMatches = getAllMatches;
  exports.nameRegexp = nameRegexp;
});

// ../../node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS((exports) => {
  var util = require_util();
  var defaultOptions = {
    allowBooleanAttributes: false,
    unpairedTags: []
  };
  exports.validate = function(xmlData, options) {
    options = Object.assign({}, defaultOptions, options);
    const tags = [];
    let tagFound = false;
    let reachedRoot = false;
    if (xmlData[0] === "\uFEFF") {
      xmlData = xmlData.substr(1);
    }
    for (let i2 = 0;i2 < xmlData.length; i2++) {
      if (xmlData[i2] === "<" && xmlData[i2 + 1] === "?") {
        i2 += 2;
        i2 = readPI(xmlData, i2);
        if (i2.err)
          return i2;
      } else if (xmlData[i2] === "<") {
        let tagStartPos = i2;
        i2++;
        if (xmlData[i2] === "!") {
          i2 = readCommentAndCDATA(xmlData, i2);
          continue;
        } else {
          let closingTag = false;
          if (xmlData[i2] === "/") {
            closingTag = true;
            i2++;
          }
          let tagName = "";
          for (;i2 < xmlData.length && xmlData[i2] !== ">" && xmlData[i2] !== " " && xmlData[i2] !== "\t" && xmlData[i2] !== `
` && xmlData[i2] !== "\r"; i2++) {
            tagName += xmlData[i2];
          }
          tagName = tagName.trim();
          if (tagName[tagName.length - 1] === "/") {
            tagName = tagName.substring(0, tagName.length - 1);
            i2--;
          }
          if (!validateTagName(tagName)) {
            let msg;
            if (tagName.trim().length === 0) {
              msg = "Invalid space after '<'.";
            } else {
              msg = "Tag '" + tagName + "' is an invalid name.";
            }
            return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i2));
          }
          const result = readAttributeStr(xmlData, i2);
          if (result === false) {
            return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i2));
          }
          let attrStr = result.value;
          i2 = result.index;
          if (attrStr[attrStr.length - 1] === "/") {
            const attrStrStart = i2 - attrStr.length;
            attrStr = attrStr.substring(0, attrStr.length - 1);
            const isValid = validateAttributeString(attrStr, options);
            if (isValid === true) {
              tagFound = true;
            } else {
              return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
            }
          } else if (closingTag) {
            if (!result.tagClosed) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i2));
            } else if (attrStr.trim().length > 0) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
            } else if (tags.length === 0) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
            } else {
              const otg = tags.pop();
              if (tagName !== otg.tagName) {
                let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                return getErrorObject("InvalidTag", "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.", getLineNumberForPosition(xmlData, tagStartPos));
              }
              if (tags.length == 0) {
                reachedRoot = true;
              }
            }
          } else {
            const isValid = validateAttributeString(attrStr, options);
            if (isValid !== true) {
              return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i2 - attrStr.length + isValid.err.line));
            }
            if (reachedRoot === true) {
              return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i2));
            } else if (options.unpairedTags.indexOf(tagName) !== -1) {
            } else {
              tags.push({ tagName, tagStartPos });
            }
            tagFound = true;
          }
          for (i2++;i2 < xmlData.length; i2++) {
            if (xmlData[i2] === "<") {
              if (xmlData[i2 + 1] === "!") {
                i2++;
                i2 = readCommentAndCDATA(xmlData, i2);
                continue;
              } else if (xmlData[i2 + 1] === "?") {
                i2 = readPI(xmlData, ++i2);
                if (i2.err)
                  return i2;
              } else {
                break;
              }
            } else if (xmlData[i2] === "&") {
              const afterAmp = validateAmpersand(xmlData, i2);
              if (afterAmp == -1)
                return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i2));
              i2 = afterAmp;
            } else {
              if (reachedRoot === true && !isWhiteSpace(xmlData[i2])) {
                return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i2));
              }
            }
          }
          if (xmlData[i2] === "<") {
            i2--;
          }
        }
      } else {
        if (isWhiteSpace(xmlData[i2])) {
          continue;
        }
        return getErrorObject("InvalidChar", "char '" + xmlData[i2] + "' is not expected.", getLineNumberForPosition(xmlData, i2));
      }
    }
    if (!tagFound) {
      return getErrorObject("InvalidXml", "Start tag expected.", 1);
    } else if (tags.length == 1) {
      return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
    } else if (tags.length > 0) {
      return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t2) => t2.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
    }
    return true;
  };
  function isWhiteSpace(char) {
    return char === " " || char === "\t" || char === `
` || char === "\r";
  }
  function readPI(xmlData, i2) {
    const start = i2;
    for (;i2 < xmlData.length; i2++) {
      if (xmlData[i2] == "?" || xmlData[i2] == " ") {
        const tagname = xmlData.substr(start, i2 - start);
        if (i2 > 5 && tagname === "xml") {
          return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i2));
        } else if (xmlData[i2] == "?" && xmlData[i2 + 1] == ">") {
          i2++;
          break;
        } else {
          continue;
        }
      }
    }
    return i2;
  }
  function readCommentAndCDATA(xmlData, i2) {
    if (xmlData.length > i2 + 5 && xmlData[i2 + 1] === "-" && xmlData[i2 + 2] === "-") {
      for (i2 += 3;i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "-" && xmlData[i2 + 1] === "-" && xmlData[i2 + 2] === ">") {
          i2 += 2;
          break;
        }
      }
    } else if (xmlData.length > i2 + 8 && xmlData[i2 + 1] === "D" && xmlData[i2 + 2] === "O" && xmlData[i2 + 3] === "C" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "Y" && xmlData[i2 + 6] === "P" && xmlData[i2 + 7] === "E") {
      let angleBracketsCount = 1;
      for (i2 += 8;i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "<") {
          angleBracketsCount++;
        } else if (xmlData[i2] === ">") {
          angleBracketsCount--;
          if (angleBracketsCount === 0) {
            break;
          }
        }
      }
    } else if (xmlData.length > i2 + 9 && xmlData[i2 + 1] === "[" && xmlData[i2 + 2] === "C" && xmlData[i2 + 3] === "D" && xmlData[i2 + 4] === "A" && xmlData[i2 + 5] === "T" && xmlData[i2 + 6] === "A" && xmlData[i2 + 7] === "[") {
      for (i2 += 8;i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "]" && xmlData[i2 + 1] === "]" && xmlData[i2 + 2] === ">") {
          i2 += 2;
          break;
        }
      }
    }
    return i2;
  }
  var doubleQuote = '"';
  var singleQuote = "'";
  function readAttributeStr(xmlData, i2) {
    let attrStr = "";
    let startChar = "";
    let tagClosed = false;
    for (;i2 < xmlData.length; i2++) {
      if (xmlData[i2] === doubleQuote || xmlData[i2] === singleQuote) {
        if (startChar === "") {
          startChar = xmlData[i2];
        } else if (startChar !== xmlData[i2]) {
        } else {
          startChar = "";
        }
      } else if (xmlData[i2] === ">") {
        if (startChar === "") {
          tagClosed = true;
          break;
        }
      }
      attrStr += xmlData[i2];
    }
    if (startChar !== "") {
      return false;
    }
    return {
      value: attrStr,
      index: i2,
      tagClosed
    };
  }
  var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
  function validateAttributeString(attrStr, options) {
    const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
    const attrNames = {};
    for (let i2 = 0;i2 < matches.length; i2++) {
      if (matches[i2][1].length === 0) {
        return getErrorObject("InvalidAttr", "Attribute '" + matches[i2][2] + "' has no space in starting.", getPositionFromMatch(matches[i2]));
      } else if (matches[i2][3] !== undefined && matches[i2][4] === undefined) {
        return getErrorObject("InvalidAttr", "Attribute '" + matches[i2][2] + "' is without value.", getPositionFromMatch(matches[i2]));
      } else if (matches[i2][3] === undefined && !options.allowBooleanAttributes) {
        return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i2][2] + "' is not allowed.", getPositionFromMatch(matches[i2]));
      }
      const attrName = matches[i2][2];
      if (!validateAttrName(attrName)) {
        return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i2]));
      }
      if (!attrNames.hasOwnProperty(attrName)) {
        attrNames[attrName] = 1;
      } else {
        return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i2]));
      }
    }
    return true;
  }
  function validateNumberAmpersand(xmlData, i2) {
    let re = /\d/;
    if (xmlData[i2] === "x") {
      i2++;
      re = /[\da-fA-F]/;
    }
    for (;i2 < xmlData.length; i2++) {
      if (xmlData[i2] === ";")
        return i2;
      if (!xmlData[i2].match(re))
        break;
    }
    return -1;
  }
  function validateAmpersand(xmlData, i2) {
    i2++;
    if (xmlData[i2] === ";")
      return -1;
    if (xmlData[i2] === "#") {
      i2++;
      return validateNumberAmpersand(xmlData, i2);
    }
    let count = 0;
    for (;i2 < xmlData.length; i2++, count++) {
      if (xmlData[i2].match(/\w/) && count < 20)
        continue;
      if (xmlData[i2] === ";")
        break;
      return -1;
    }
    return i2;
  }
  function getErrorObject(code, message, lineNumber) {
    return {
      err: {
        code,
        msg: message,
        line: lineNumber.line || lineNumber,
        col: lineNumber.col
      }
    };
  }
  function validateAttrName(attrName) {
    return util.isName(attrName);
  }
  function validateTagName(tagname) {
    return util.isName(tagname);
  }
  function getLineNumberForPosition(xmlData, index) {
    const lines = xmlData.substring(0, index).split(/\r?\n/);
    return {
      line: lines.length,
      col: lines[lines.length - 1].length + 1
    };
  }
  function getPositionFromMatch(match) {
    return match.startIndex + match[1].length;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS((exports) => {
  var defaultOptions = {
    preserveOrder: false,
    attributeNamePrefix: "@_",
    attributesGroupName: false,
    textNodeName: "#text",
    ignoreAttributes: true,
    removeNSPrefix: false,
    allowBooleanAttributes: false,
    parseTagValue: true,
    parseAttributeValue: false,
    trimValues: true,
    cdataPropName: false,
    numberParseOptions: {
      hex: true,
      leadingZeros: true,
      eNotation: true
    },
    tagValueProcessor: function(tagName, val2) {
      return val2;
    },
    attributeValueProcessor: function(attrName, val2) {
      return val2;
    },
    stopNodes: [],
    alwaysCreateTextNode: false,
    isArray: () => false,
    commentPropName: false,
    unpairedTags: [],
    processEntities: true,
    htmlEntities: false,
    ignoreDeclaration: false,
    ignorePiTags: false,
    transformTagName: false,
    transformAttributeName: false,
    updateTag: function(tagName, jPath, attrs) {
      return tagName;
    }
  };
  var buildOptions = function(options) {
    return Object.assign({}, defaultOptions, options);
  };
  exports.buildOptions = buildOptions;
  exports.defaultOptions = defaultOptions;
});

// ../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS((exports, module) => {
  class XmlNode {
    constructor(tagname) {
      this.tagname = tagname;
      this.child = [];
      this[":@"] = {};
    }
    add(key, val2) {
      if (key === "__proto__")
        key = "#__proto__";
      this.child.push({ [key]: val2 });
    }
    addChild(node) {
      if (node.tagname === "__proto__")
        node.tagname = "#__proto__";
      if (node[":@"] && Object.keys(node[":@"]).length > 0) {
        this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
      } else {
        this.child.push({ [node.tagname]: node.child });
      }
    }
  }
  module.exports = XmlNode;
});

// ../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS((exports, module) => {
  var util = require_util();
  function readDocType(xmlData, i2) {
    const entities = {};
    if (xmlData[i2 + 3] === "O" && xmlData[i2 + 4] === "C" && xmlData[i2 + 5] === "T" && xmlData[i2 + 6] === "Y" && xmlData[i2 + 7] === "P" && xmlData[i2 + 8] === "E") {
      i2 = i2 + 9;
      let angleBracketsCount = 1;
      let hasBody = false, comment = false;
      let exp = "";
      for (;i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "<" && !comment) {
          if (hasBody && isEntity(xmlData, i2)) {
            i2 += 7;
            [entityName, val, i2] = readEntityExp(xmlData, i2 + 1);
            if (val.indexOf("&") === -1)
              entities[validateEntityName(entityName)] = {
                regx: RegExp(`&${entityName};`, "g"),
                val
              };
          } else if (hasBody && isElement(xmlData, i2))
            i2 += 8;
          else if (hasBody && isAttlist(xmlData, i2))
            i2 += 8;
          else if (hasBody && isNotation(xmlData, i2))
            i2 += 9;
          else if (isComment)
            comment = true;
          else
            throw new Error("Invalid DOCTYPE");
          angleBracketsCount++;
          exp = "";
        } else if (xmlData[i2] === ">") {
          if (comment) {
            if (xmlData[i2 - 1] === "-" && xmlData[i2 - 2] === "-") {
              comment = false;
              angleBracketsCount--;
            }
          } else {
            angleBracketsCount--;
          }
          if (angleBracketsCount === 0) {
            break;
          }
        } else if (xmlData[i2] === "[") {
          hasBody = true;
        } else {
          exp += xmlData[i2];
        }
      }
      if (angleBracketsCount !== 0) {
        throw new Error(`Unclosed DOCTYPE`);
      }
    } else {
      throw new Error(`Invalid Tag instead of DOCTYPE`);
    }
    return { entities, i: i2 };
  }
  function readEntityExp(xmlData, i2) {
    let entityName2 = "";
    for (;i2 < xmlData.length && (xmlData[i2] !== "'" && xmlData[i2] !== '"'); i2++) {
      entityName2 += xmlData[i2];
    }
    entityName2 = entityName2.trim();
    if (entityName2.indexOf(" ") !== -1)
      throw new Error("External entites are not supported");
    const startChar = xmlData[i2++];
    let val2 = "";
    for (;i2 < xmlData.length && xmlData[i2] !== startChar; i2++) {
      val2 += xmlData[i2];
    }
    return [entityName2, val2, i2];
  }
  function isComment(xmlData, i2) {
    if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "-" && xmlData[i2 + 3] === "-")
      return true;
    return false;
  }
  function isEntity(xmlData, i2) {
    if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "E" && xmlData[i2 + 3] === "N" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "I" && xmlData[i2 + 6] === "T" && xmlData[i2 + 7] === "Y")
      return true;
    return false;
  }
  function isElement(xmlData, i2) {
    if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "E" && xmlData[i2 + 3] === "L" && xmlData[i2 + 4] === "E" && xmlData[i2 + 5] === "M" && xmlData[i2 + 6] === "E" && xmlData[i2 + 7] === "N" && xmlData[i2 + 8] === "T")
      return true;
    return false;
  }
  function isAttlist(xmlData, i2) {
    if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "A" && xmlData[i2 + 3] === "T" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "L" && xmlData[i2 + 6] === "I" && xmlData[i2 + 7] === "S" && xmlData[i2 + 8] === "T")
      return true;
    return false;
  }
  function isNotation(xmlData, i2) {
    if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "N" && xmlData[i2 + 3] === "O" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "A" && xmlData[i2 + 6] === "T" && xmlData[i2 + 7] === "I" && xmlData[i2 + 8] === "O" && xmlData[i2 + 9] === "N")
      return true;
    return false;
  }
  function validateEntityName(name) {
    if (util.isName(name))
      return name;
    else
      throw new Error(`Invalid entity name ${name}`);
  }
  module.exports = readDocType;
});

// ../../node_modules/strnum/strnum.js
var require_strnum = __commonJS((exports, module) => {
  var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
  var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
  if (!Number.parseInt && window.parseInt) {
    Number.parseInt = window.parseInt;
  }
  if (!Number.parseFloat && window.parseFloat) {
    Number.parseFloat = window.parseFloat;
  }
  var consider = {
    hex: true,
    leadingZeros: true,
    decimalPoint: ".",
    eNotation: true
  };
  function toNumber(str, options = {}) {
    options = Object.assign({}, consider, options);
    if (!str || typeof str !== "string")
      return str;
    let trimmedStr = str.trim();
    if (options.skipLike !== undefined && options.skipLike.test(trimmedStr))
      return str;
    else if (options.hex && hexRegex.test(trimmedStr)) {
      return Number.parseInt(trimmedStr, 16);
    } else {
      const match = numRegex.exec(trimmedStr);
      if (match) {
        const sign = match[1];
        const leadingZeros = match[2];
        let numTrimmedByZeros = trimZeros(match[3]);
        const eNotation = match[4] || match[6];
        if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
          return str;
        else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
          return str;
        else {
          const num = Number(trimmedStr);
          const numStr = "" + num;
          if (numStr.search(/[eE]/) !== -1) {
            if (options.eNotation)
              return num;
            else
              return str;
          } else if (eNotation) {
            if (options.eNotation)
              return num;
            else
              return str;
          } else if (trimmedStr.indexOf(".") !== -1) {
            if (numStr === "0" && numTrimmedByZeros === "")
              return num;
            else if (numStr === numTrimmedByZeros)
              return num;
            else if (sign && numStr === "-" + numTrimmedByZeros)
              return num;
            else
              return str;
          }
          if (leadingZeros) {
            if (numTrimmedByZeros === numStr)
              return num;
            else if (sign + numTrimmedByZeros === numStr)
              return num;
            else
              return str;
          }
          if (trimmedStr === numStr)
            return num;
          else if (trimmedStr === sign + numStr)
            return num;
          return str;
        }
      } else {
        return str;
      }
    }
  }
  function trimZeros(numStr) {
    if (numStr && numStr.indexOf(".") !== -1) {
      numStr = numStr.replace(/0+$/, "");
      if (numStr === ".")
        numStr = "0";
      else if (numStr[0] === ".")
        numStr = "0" + numStr;
      else if (numStr[numStr.length - 1] === ".")
        numStr = numStr.substr(0, numStr.length - 1);
      return numStr;
    }
    return numStr;
  }
  module.exports = toNumber;
});

// ../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS((exports, module) => {
  var util = require_util();
  var xmlNode = require_xmlNode();
  var readDocType = require_DocTypeReader();
  var toNumber = require_strnum();

  class OrderedObjParser {
    constructor(options) {
      this.options = options;
      this.currentNode = null;
      this.tagsNodeStack = [];
      this.docTypeEntities = {};
      this.lastEntities = {
        apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
        gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
        lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
        quot: { regex: /&(quot|#34|#x22);/g, val: '"' }
      };
      this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
      this.htmlEntities = {
        space: { regex: /&(nbsp|#160);/g, val: " " },
        cent: { regex: /&(cent|#162);/g, val: "\xA2" },
        pound: { regex: /&(pound|#163);/g, val: "\xA3" },
        yen: { regex: /&(yen|#165);/g, val: "\xA5" },
        euro: { regex: /&(euro|#8364);/g, val: "\u20AC" },
        copyright: { regex: /&(copy|#169);/g, val: "\xA9" },
        reg: { regex: /&(reg|#174);/g, val: "\xAE" },
        inr: { regex: /&(inr|#8377);/g, val: "\u20B9" },
        num_dec: { regex: /&#([0-9]{1,7});/g, val: (_3, str) => String.fromCharCode(Number.parseInt(str, 10)) },
        num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_3, str) => String.fromCharCode(Number.parseInt(str, 16)) }
      };
      this.addExternalEntities = addExternalEntities;
      this.parseXml = parseXml;
      this.parseTextData = parseTextData;
      this.resolveNameSpace = resolveNameSpace;
      this.buildAttributesMap = buildAttributesMap;
      this.isItStopNode = isItStopNode;
      this.replaceEntitiesValue = replaceEntitiesValue;
      this.readStopNodeData = readStopNodeData;
      this.saveTextToParentTag = saveTextToParentTag;
      this.addChild = addChild;
    }
  }
  function addExternalEntities(externalEntities) {
    const entKeys = Object.keys(externalEntities);
    for (let i2 = 0;i2 < entKeys.length; i2++) {
      const ent = entKeys[i2];
      this.lastEntities[ent] = {
        regex: new RegExp("&" + ent + ";", "g"),
        val: externalEntities[ent]
      };
    }
  }
  function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
    if (val2 !== undefined) {
      if (this.options.trimValues && !dontTrim) {
        val2 = val2.trim();
      }
      if (val2.length > 0) {
        if (!escapeEntities)
          val2 = this.replaceEntitiesValue(val2);
        const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
        if (newval === null || newval === undefined) {
          return val2;
        } else if (typeof newval !== typeof val2 || newval !== val2) {
          return newval;
        } else if (this.options.trimValues) {
          return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
        } else {
          const trimmedVal = val2.trim();
          if (trimmedVal === val2) {
            return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            return val2;
          }
        }
      }
    }
  }
  function resolveNameSpace(tagname) {
    if (this.options.removeNSPrefix) {
      const tags = tagname.split(":");
      const prefix = tagname.charAt(0) === "/" ? "/" : "";
      if (tags[0] === "xmlns") {
        return "";
      }
      if (tags.length === 2) {
        tagname = prefix + tags[1];
      }
    }
    return tagname;
  }
  var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
  function buildAttributesMap(attrStr, jPath, tagName) {
    if (!this.options.ignoreAttributes && typeof attrStr === "string") {
      const matches = util.getAllMatches(attrStr, attrsRegx);
      const len = matches.length;
      const attrs = {};
      for (let i2 = 0;i2 < len; i2++) {
        const attrName = this.resolveNameSpace(matches[i2][1]);
        let oldVal = matches[i2][4];
        let aName = this.options.attributeNamePrefix + attrName;
        if (attrName.length) {
          if (this.options.transformAttributeName) {
            aName = this.options.transformAttributeName(aName);
          }
          if (aName === "__proto__")
            aName = "#__proto__";
          if (oldVal !== undefined) {
            if (this.options.trimValues) {
              oldVal = oldVal.trim();
            }
            oldVal = this.replaceEntitiesValue(oldVal);
            const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
            if (newVal === null || newVal === undefined) {
              attrs[aName] = oldVal;
            } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
              attrs[aName] = newVal;
            } else {
              attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);
            }
          } else if (this.options.allowBooleanAttributes) {
            attrs[aName] = true;
          }
        }
      }
      if (!Object.keys(attrs).length) {
        return;
      }
      if (this.options.attributesGroupName) {
        const attrCollection = {};
        attrCollection[this.options.attributesGroupName] = attrs;
        return attrCollection;
      }
      return attrs;
    }
  }
  var parseXml = function(xmlData) {
    xmlData = xmlData.replace(/\r\n?/g, `
`);
    const xmlObj = new xmlNode("!xml");
    let currentNode = xmlObj;
    let textData = "";
    let jPath = "";
    for (let i2 = 0;i2 < xmlData.length; i2++) {
      const ch = xmlData[i2];
      if (ch === "<") {
        if (xmlData[i2 + 1] === "/") {
          const closeIndex = findClosingIndex(xmlData, ">", i2, "Closing Tag is not closed.");
          let tagName = xmlData.substring(i2 + 2, closeIndex).trim();
          if (this.options.removeNSPrefix) {
            const colonIndex = tagName.indexOf(":");
            if (colonIndex !== -1) {
              tagName = tagName.substr(colonIndex + 1);
            }
          }
          if (this.options.transformTagName) {
            tagName = this.options.transformTagName(tagName);
          }
          if (currentNode) {
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
          }
          const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
          if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
            throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
          }
          let propIndex = 0;
          if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
            propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
            this.tagsNodeStack.pop();
          } else {
            propIndex = jPath.lastIndexOf(".");
          }
          jPath = jPath.substring(0, propIndex);
          currentNode = this.tagsNodeStack.pop();
          textData = "";
          i2 = closeIndex;
        } else if (xmlData[i2 + 1] === "?") {
          let tagData = readTagExp(xmlData, i2, false, "?>");
          if (!tagData)
            throw new Error("Pi Tag is not closed.");
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
          } else {
            const childNode = new xmlNode(tagData.tagName);
            childNode.add(this.options.textNodeName, "");
            if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
            }
            this.addChild(currentNode, childNode, jPath);
          }
          i2 = tagData.closeIndex + 1;
        } else if (xmlData.substr(i2 + 1, 3) === "!--") {
          const endIndex = findClosingIndex(xmlData, "-->", i2 + 4, "Comment is not closed.");
          if (this.options.commentPropName) {
            const comment = xmlData.substring(i2 + 4, endIndex - 2);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
          }
          i2 = endIndex;
        } else if (xmlData.substr(i2 + 1, 2) === "!D") {
          const result = readDocType(xmlData, i2);
          this.docTypeEntities = result.entities;
          i2 = result.i;
        } else if (xmlData.substr(i2 + 1, 2) === "![") {
          const closeIndex = findClosingIndex(xmlData, "]]>", i2, "CDATA is not closed.") - 2;
          const tagExp = xmlData.substring(i2 + 9, closeIndex);
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
          if (val2 == undefined)
            val2 = "";
          if (this.options.cdataPropName) {
            currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
          } else {
            currentNode.add(this.options.textNodeName, val2);
          }
          i2 = closeIndex + 2;
        } else {
          let result = readTagExp(xmlData, i2, this.options.removeNSPrefix);
          let tagName = result.tagName;
          const rawTagName = result.rawTagName;
          let tagExp = result.tagExp;
          let attrExpPresent = result.attrExpPresent;
          let closeIndex = result.closeIndex;
          if (this.options.transformTagName) {
            tagName = this.options.transformTagName(tagName);
          }
          if (currentNode && textData) {
            if (currentNode.tagname !== "!xml") {
              textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
            }
          }
          const lastTag = currentNode;
          if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
            currentNode = this.tagsNodeStack.pop();
            jPath = jPath.substring(0, jPath.lastIndexOf("."));
          }
          if (tagName !== xmlObj.tagname) {
            jPath += jPath ? "." + tagName : tagName;
          }
          if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
            let tagContent = "";
            if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substr(0, tagName.length - 1);
                jPath = jPath.substr(0, jPath.length - 1);
                tagExp = tagName;
              } else {
                tagExp = tagExp.substr(0, tagExp.length - 1);
              }
              i2 = result.closeIndex;
            } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
              i2 = result.closeIndex;
            } else {
              const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
              if (!result2)
                throw new Error(`Unexpected end of ${rawTagName}`);
              i2 = result2.i;
              tagContent = result2.tagContent;
            }
            const childNode = new xmlNode(tagName);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            if (tagContent) {
              tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
            }
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
            childNode.add(this.options.textNodeName, tagContent);
            this.addChild(currentNode, childNode, jPath);
          } else {
            if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substr(0, tagName.length - 1);
                jPath = jPath.substr(0, jPath.length - 1);
                tagExp = tagName;
              } else {
                tagExp = tagExp.substr(0, tagExp.length - 1);
              }
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              this.addChild(currentNode, childNode, jPath);
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
            } else {
              const childNode = new xmlNode(tagName);
              this.tagsNodeStack.push(currentNode);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              this.addChild(currentNode, childNode, jPath);
              currentNode = childNode;
            }
            textData = "";
            i2 = closeIndex;
          }
        }
      } else {
        textData += xmlData[i2];
      }
    }
    return xmlObj.child;
  };
  function addChild(currentNode, childNode, jPath) {
    const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
    if (result === false) {
    } else if (typeof result === "string") {
      childNode.tagname = result;
      currentNode.addChild(childNode);
    } else {
      currentNode.addChild(childNode);
    }
  }
  var replaceEntitiesValue = function(val2) {
    if (this.options.processEntities) {
      for (let entityName2 in this.docTypeEntities) {
        const entity = this.docTypeEntities[entityName2];
        val2 = val2.replace(entity.regx, entity.val);
      }
      for (let entityName2 in this.lastEntities) {
        const entity = this.lastEntities[entityName2];
        val2 = val2.replace(entity.regex, entity.val);
      }
      if (this.options.htmlEntities) {
        for (let entityName2 in this.htmlEntities) {
          const entity = this.htmlEntities[entityName2];
          val2 = val2.replace(entity.regex, entity.val);
        }
      }
      val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
    }
    return val2;
  };
  function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
    if (textData) {
      if (isLeafNode === undefined)
        isLeafNode = Object.keys(currentNode.child).length === 0;
      textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false, isLeafNode);
      if (textData !== undefined && textData !== "")
        currentNode.add(this.options.textNodeName, textData);
      textData = "";
    }
    return textData;
  }
  function isItStopNode(stopNodes, jPath, currentTagName) {
    const allNodesExp = "*." + currentTagName;
    for (const stopNodePath in stopNodes) {
      const stopNodeExp = stopNodes[stopNodePath];
      if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
        return true;
    }
    return false;
  }
  function tagExpWithClosingIndex(xmlData, i2, closingChar = ">") {
    let attrBoundary;
    let tagExp = "";
    for (let index = i2;index < xmlData.length; index++) {
      let ch = xmlData[index];
      if (attrBoundary) {
        if (ch === attrBoundary)
          attrBoundary = "";
      } else if (ch === '"' || ch === "'") {
        attrBoundary = ch;
      } else if (ch === closingChar[0]) {
        if (closingChar[1]) {
          if (xmlData[index + 1] === closingChar[1]) {
            return {
              data: tagExp,
              index
            };
          }
        } else {
          return {
            data: tagExp,
            index
          };
        }
      } else if (ch === "\t") {
        ch = " ";
      }
      tagExp += ch;
    }
  }
  function findClosingIndex(xmlData, str, i2, errMsg) {
    const closingIndex = xmlData.indexOf(str, i2);
    if (closingIndex === -1) {
      throw new Error(errMsg);
    } else {
      return closingIndex + str.length - 1;
    }
  }
  function readTagExp(xmlData, i2, removeNSPrefix, closingChar = ">") {
    const result = tagExpWithClosingIndex(xmlData, i2 + 1, closingChar);
    if (!result)
      return;
    let tagExp = result.data;
    const closeIndex = result.index;
    const separatorIndex = tagExp.search(/\s/);
    let tagName = tagExp;
    let attrExpPresent = true;
    if (separatorIndex !== -1) {
      tagName = tagExp.substring(0, separatorIndex);
      tagExp = tagExp.substring(separatorIndex + 1).trimStart();
    }
    const rawTagName = tagName;
    if (removeNSPrefix) {
      const colonIndex = tagName.indexOf(":");
      if (colonIndex !== -1) {
        tagName = tagName.substr(colonIndex + 1);
        attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
      }
    }
    return {
      tagName,
      tagExp,
      closeIndex,
      attrExpPresent,
      rawTagName
    };
  }
  function readStopNodeData(xmlData, tagName, i2) {
    const startIndex = i2;
    let openTagCount = 1;
    for (;i2 < xmlData.length; i2++) {
      if (xmlData[i2] === "<") {
        if (xmlData[i2 + 1] === "/") {
          const closeIndex = findClosingIndex(xmlData, ">", i2, `${tagName} is not closed`);
          let closeTagName = xmlData.substring(i2 + 2, closeIndex).trim();
          if (closeTagName === tagName) {
            openTagCount--;
            if (openTagCount === 0) {
              return {
                tagContent: xmlData.substring(startIndex, i2),
                i: closeIndex
              };
            }
          }
          i2 = closeIndex;
        } else if (xmlData[i2 + 1] === "?") {
          const closeIndex = findClosingIndex(xmlData, "?>", i2 + 1, "StopNode is not closed.");
          i2 = closeIndex;
        } else if (xmlData.substr(i2 + 1, 3) === "!--") {
          const closeIndex = findClosingIndex(xmlData, "-->", i2 + 3, "StopNode is not closed.");
          i2 = closeIndex;
        } else if (xmlData.substr(i2 + 1, 2) === "![") {
          const closeIndex = findClosingIndex(xmlData, "]]>", i2, "StopNode is not closed.") - 2;
          i2 = closeIndex;
        } else {
          const tagData = readTagExp(xmlData, i2, ">");
          if (tagData) {
            const openTagName = tagData && tagData.tagName;
            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
              openTagCount++;
            }
            i2 = tagData.closeIndex;
          }
        }
      }
    }
  }
  function parseValue(val2, shouldParse, options) {
    if (shouldParse && typeof val2 === "string") {
      const newval = val2.trim();
      if (newval === "true")
        return true;
      else if (newval === "false")
        return false;
      else
        return toNumber(val2, options);
    } else {
      if (util.isExist(val2)) {
        return val2;
      } else {
        return "";
      }
    }
  }
  module.exports = OrderedObjParser;
});

// ../../node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS((exports) => {
  function prettify(node, options) {
    return compress(node, options);
  }
  function compress(arr, options, jPath) {
    let text;
    const compressedObj = {};
    for (let i2 = 0;i2 < arr.length; i2++) {
      const tagObj = arr[i2];
      const property = propName(tagObj);
      let newJpath = "";
      if (jPath === undefined)
        newJpath = property;
      else
        newJpath = jPath + "." + property;
      if (property === options.textNodeName) {
        if (text === undefined)
          text = tagObj[property];
        else
          text += "" + tagObj[property];
      } else if (property === undefined) {
        continue;
      } else if (tagObj[property]) {
        let val2 = compress(tagObj[property], options, newJpath);
        const isLeaf = isLeafTag(val2, options);
        if (tagObj[":@"]) {
          assignAttributes(val2, tagObj[":@"], newJpath, options);
        } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== undefined && !options.alwaysCreateTextNode) {
          val2 = val2[options.textNodeName];
        } else if (Object.keys(val2).length === 0) {
          if (options.alwaysCreateTextNode)
            val2[options.textNodeName] = "";
          else
            val2 = "";
        }
        if (compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
          if (!Array.isArray(compressedObj[property])) {
            compressedObj[property] = [compressedObj[property]];
          }
          compressedObj[property].push(val2);
        } else {
          if (options.isArray(property, newJpath, isLeaf)) {
            compressedObj[property] = [val2];
          } else {
            compressedObj[property] = val2;
          }
        }
      }
    }
    if (typeof text === "string") {
      if (text.length > 0)
        compressedObj[options.textNodeName] = text;
    } else if (text !== undefined)
      compressedObj[options.textNodeName] = text;
    return compressedObj;
  }
  function propName(obj) {
    const keys = Object.keys(obj);
    for (let i2 = 0;i2 < keys.length; i2++) {
      const key = keys[i2];
      if (key !== ":@")
        return key;
    }
  }
  function assignAttributes(obj, attrMap, jpath, options) {
    if (attrMap) {
      const keys = Object.keys(attrMap);
      const len = keys.length;
      for (let i2 = 0;i2 < len; i2++) {
        const atrrName = keys[i2];
        if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
          obj[atrrName] = [attrMap[atrrName]];
        } else {
          obj[atrrName] = attrMap[atrrName];
        }
      }
    }
  }
  function isLeafTag(obj, options) {
    const { textNodeName } = options;
    const propCount = Object.keys(obj).length;
    if (propCount === 0) {
      return true;
    }
    if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
      return true;
    }
    return false;
  }
  exports.prettify = prettify;
});

// ../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS((exports, module) => {
  var { buildOptions } = require_OptionsBuilder();
  var OrderedObjParser = require_OrderedObjParser();
  var { prettify } = require_node2json();
  var validator2 = require_validator();

  class XMLParser {
    constructor(options) {
      this.externalEntities = {};
      this.options = buildOptions(options);
    }
    parse(xmlData, validationOption) {
      if (typeof xmlData === "string") {
      } else if (xmlData.toString) {
        xmlData = xmlData.toString();
      } else {
        throw new Error("XML data is accepted in String or Bytes[] form.");
      }
      if (validationOption) {
        if (validationOption === true)
          validationOption = {};
        const result = validator2.validate(xmlData, validationOption);
        if (result !== true) {
          throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
        }
      }
      const orderedObjParser = new OrderedObjParser(this.options);
      orderedObjParser.addExternalEntities(this.externalEntities);
      const orderedResult = orderedObjParser.parseXml(xmlData);
      if (this.options.preserveOrder || orderedResult === undefined)
        return orderedResult;
      else
        return prettify(orderedResult, this.options);
    }
    addEntity(key, value) {
      if (value.indexOf("&") !== -1) {
        throw new Error("Entity value can't have '&'");
      } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
        throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
      } else if (value === "&") {
        throw new Error("An entity with value '&' is not permitted");
      } else {
        this.externalEntities[key] = value;
      }
    }
  }
  module.exports = XMLParser;
});

// ../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS((exports, module) => {
  var EOL = `
`;
  function toXml(jArray, options) {
    let indentation = "";
    if (options.format && options.indentBy.length > 0) {
      indentation = EOL;
    }
    return arrToStr(jArray, options, "", indentation);
  }
  function arrToStr(arr, options, jPath, indentation) {
    let xmlStr = "";
    let isPreviousElementTag = false;
    for (let i2 = 0;i2 < arr.length; i2++) {
      const tagObj = arr[i2];
      const tagName = propName(tagObj);
      if (tagName === undefined)
        continue;
      let newJPath = "";
      if (jPath.length === 0)
        newJPath = tagName;
      else
        newJPath = `${jPath}.${tagName}`;
      if (tagName === options.textNodeName) {
        let tagText = tagObj[tagName];
        if (!isStopNode(newJPath, options)) {
          tagText = options.tagValueProcessor(tagName, tagText);
          tagText = replaceEntitiesValue(tagText, options);
        }
        if (isPreviousElementTag) {
          xmlStr += indentation;
        }
        xmlStr += tagText;
        isPreviousElementTag = false;
        continue;
      } else if (tagName === options.cdataPropName) {
        if (isPreviousElementTag) {
          xmlStr += indentation;
        }
        xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
        isPreviousElementTag = false;
        continue;
      } else if (tagName === options.commentPropName) {
        xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
        isPreviousElementTag = true;
        continue;
      } else if (tagName[0] === "?") {
        const attStr2 = attr_to_str(tagObj[":@"], options);
        const tempInd = tagName === "?xml" ? "" : indentation;
        let piTextNodeName = tagObj[tagName][0][options.textNodeName];
        piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
        xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
        isPreviousElementTag = true;
        continue;
      }
      let newIdentation = indentation;
      if (newIdentation !== "") {
        newIdentation += options.indentBy;
      }
      const attStr = attr_to_str(tagObj[":@"], options);
      const tagStart = indentation + `<${tagName}${attStr}`;
      const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
      if (options.unpairedTags.indexOf(tagName) !== -1) {
        if (options.suppressUnpairedNode)
          xmlStr += tagStart + ">";
        else
          xmlStr += tagStart + "/>";
      } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
        xmlStr += tagStart + "/>";
      } else if (tagValue && tagValue.endsWith(">")) {
        xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
      } else {
        xmlStr += tagStart + ">";
        if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
          xmlStr += indentation + options.indentBy + tagValue + indentation;
        } else {
          xmlStr += tagValue;
        }
        xmlStr += `</${tagName}>`;
      }
      isPreviousElementTag = true;
    }
    return xmlStr;
  }
  function propName(obj) {
    const keys = Object.keys(obj);
    for (let i2 = 0;i2 < keys.length; i2++) {
      const key = keys[i2];
      if (!obj.hasOwnProperty(key))
        continue;
      if (key !== ":@")
        return key;
    }
  }
  function attr_to_str(attrMap, options) {
    let attrStr = "";
    if (attrMap && !options.ignoreAttributes) {
      for (let attr in attrMap) {
        if (!attrMap.hasOwnProperty(attr))
          continue;
        let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
        attrVal = replaceEntitiesValue(attrVal, options);
        if (attrVal === true && options.suppressBooleanAttributes) {
          attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
        } else {
          attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
        }
      }
    }
    return attrStr;
  }
  function isStopNode(jPath, options) {
    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
    for (let index in options.stopNodes) {
      if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
        return true;
    }
    return false;
  }
  function replaceEntitiesValue(textValue, options) {
    if (textValue && textValue.length > 0 && options.processEntities) {
      for (let i2 = 0;i2 < options.entities.length; i2++) {
        const entity = options.entities[i2];
        textValue = textValue.replace(entity.regex, entity.val);
      }
    }
    return textValue;
  }
  module.exports = toXml;
});

// ../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS((exports, module) => {
  var buildFromOrderedJs = require_orderedJs2Xml();
  var defaultOptions = {
    attributeNamePrefix: "@_",
    attributesGroupName: false,
    textNodeName: "#text",
    ignoreAttributes: true,
    cdataPropName: false,
    format: false,
    indentBy: "  ",
    suppressEmptyNode: false,
    suppressUnpairedNode: true,
    suppressBooleanAttributes: true,
    tagValueProcessor: function(key, a3) {
      return a3;
    },
    attributeValueProcessor: function(attrName, a3) {
      return a3;
    },
    preserveOrder: false,
    commentPropName: false,
    unpairedTags: [],
    entities: [
      { regex: new RegExp("&", "g"), val: "&amp;" },
      { regex: new RegExp(">", "g"), val: "&gt;" },
      { regex: new RegExp("<", "g"), val: "&lt;" },
      { regex: new RegExp("'", "g"), val: "&apos;" },
      { regex: new RegExp('"', "g"), val: "&quot;" }
    ],
    processEntities: true,
    stopNodes: [],
    oneListGroup: false
  };
  function Builder(options) {
    this.options = Object.assign({}, defaultOptions, options);
    if (this.options.ignoreAttributes || this.options.attributesGroupName) {
      this.isAttribute = function() {
        return false;
      };
    } else {
      this.attrPrefixLen = this.options.attributeNamePrefix.length;
      this.isAttribute = isAttribute;
    }
    this.processTextOrObjNode = processTextOrObjNode;
    if (this.options.format) {
      this.indentate = indentate;
      this.tagEndChar = `>
`;
      this.newLine = `
`;
    } else {
      this.indentate = function() {
        return "";
      };
      this.tagEndChar = ">";
      this.newLine = "";
    }
  }
  Builder.prototype.build = function(jObj) {
    if (this.options.preserveOrder) {
      return buildFromOrderedJs(jObj, this.options);
    } else {
      if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
        jObj = {
          [this.options.arrayNodeName]: jObj
        };
      }
      return this.j2x(jObj, 0).val;
    }
  };
  Builder.prototype.j2x = function(jObj, level) {
    let attrStr = "";
    let val2 = "";
    for (let key in jObj) {
      if (!Object.prototype.hasOwnProperty.call(jObj, key))
        continue;
      if (typeof jObj[key] === "undefined") {
        if (this.isAttribute(key)) {
          val2 += "";
        }
      } else if (jObj[key] === null) {
        if (this.isAttribute(key)) {
          val2 += "";
        } else if (key[0] === "?") {
          val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
        } else {
          val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        }
      } else if (jObj[key] instanceof Date) {
        val2 += this.buildTextValNode(jObj[key], key, "", level);
      } else if (typeof jObj[key] !== "object") {
        const attr = this.isAttribute(key);
        if (attr) {
          attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
        } else {
          if (key === this.options.textNodeName) {
            let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
            val2 += this.replaceEntitiesValue(newval);
          } else {
            val2 += this.buildTextValNode(jObj[key], key, "", level);
          }
        }
      } else if (Array.isArray(jObj[key])) {
        const arrLen = jObj[key].length;
        let listTagVal = "";
        let listTagAttr = "";
        for (let j2 = 0;j2 < arrLen; j2++) {
          const item = jObj[key][j2];
          if (typeof item === "undefined") {
          } else if (item === null) {
            if (key[0] === "?")
              val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
            else
              val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          } else if (typeof item === "object") {
            if (this.options.oneListGroup) {
              const result = this.j2x(item, level + 1);
              listTagVal += result.val;
              if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
                listTagAttr += result.attrStr;
              }
            } else {
              listTagVal += this.processTextOrObjNode(item, key, level);
            }
          } else {
            if (this.options.oneListGroup) {
              let textValue = this.options.tagValueProcessor(key, item);
              textValue = this.replaceEntitiesValue(textValue);
              listTagVal += textValue;
            } else {
              listTagVal += this.buildTextValNode(item, key, "", level);
            }
          }
        }
        if (this.options.oneListGroup) {
          listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
        }
        val2 += listTagVal;
      } else {
        if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
          const Ks = Object.keys(jObj[key]);
          const L3 = Ks.length;
          for (let j2 = 0;j2 < L3; j2++) {
            attrStr += this.buildAttrPairStr(Ks[j2], "" + jObj[key][Ks[j2]]);
          }
        } else {
          val2 += this.processTextOrObjNode(jObj[key], key, level);
        }
      }
    }
    return { attrStr, val: val2 };
  };
  Builder.prototype.buildAttrPairStr = function(attrName, val2) {
    val2 = this.options.attributeValueProcessor(attrName, "" + val2);
    val2 = this.replaceEntitiesValue(val2);
    if (this.options.suppressBooleanAttributes && val2 === "true") {
      return " " + attrName;
    } else
      return " " + attrName + '="' + val2 + '"';
  };
  function processTextOrObjNode(object, key, level) {
    const result = this.j2x(object, level + 1);
    if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
      return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
    } else {
      return this.buildObjectNode(result.val, key, result.attrStr, level);
    }
  }
  Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
    if (val2 === "") {
      if (key[0] === "?")
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      else {
        return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
      }
    } else {
      let tagEndExp = "</" + key + this.tagEndChar;
      let piClosingChar = "";
      if (key[0] === "?") {
        piClosingChar = "?";
        tagEndExp = "";
      }
      if ((attrStr || attrStr === "") && val2.indexOf("<") === -1) {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
        return this.indentate(level) + `<!--${val2}-->` + this.newLine;
      } else {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
      }
    }
  };
  Builder.prototype.closeTag = function(key) {
    let closeTag = "";
    if (this.options.unpairedTags.indexOf(key) !== -1) {
      if (!this.options.suppressUnpairedNode)
        closeTag = "/";
    } else if (this.options.suppressEmptyNode) {
      closeTag = "/";
    } else {
      closeTag = `></${key}`;
    }
    return closeTag;
  };
  Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
    if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
      return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
      return this.indentate(level) + `<!--${val2}-->` + this.newLine;
    } else if (key[0] === "?") {
      return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
    } else {
      let textValue = this.options.tagValueProcessor(key, val2);
      textValue = this.replaceEntitiesValue(textValue);
      if (textValue === "") {
        return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
      } else {
        return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
      }
    }
  };
  Builder.prototype.replaceEntitiesValue = function(textValue) {
    if (textValue && textValue.length > 0 && this.options.processEntities) {
      for (let i2 = 0;i2 < this.options.entities.length; i2++) {
        const entity = this.options.entities[i2];
        textValue = textValue.replace(entity.regex, entity.val);
      }
    }
    return textValue;
  };
  function indentate(level) {
    return this.options.indentBy.repeat(level);
  }
  function isAttribute(name) {
    if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
      return name.substr(this.attrPrefixLen);
    } else {
      return false;
    }
  }
  module.exports = Builder;
});

// ../../node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS((exports, module) => {
  var validator2 = require_validator();
  var XMLParser = require_XMLParser();
  var XMLBuilder = require_json2xml();
  module.exports = {
    XMLParser,
    XMLValidator: validator2,
    XMLBuilder
  };
});

// ../../node_modules/@aws-sdk/core/dist-cjs/submodules/protocols/index.js
var require_protocols2 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var protocols_exports = {};
  __export2(protocols_exports, {
    _toBool: () => _toBool,
    _toNum: () => _toNum,
    _toStr: () => _toStr,
    awsExpectUnion: () => awsExpectUnion,
    loadRestJsonErrorCode: () => loadRestJsonErrorCode,
    loadRestXmlErrorCode: () => loadRestXmlErrorCode,
    parseJsonBody: () => parseJsonBody,
    parseJsonErrorBody: () => parseJsonErrorBody,
    parseXmlBody: () => parseXmlBody,
    parseXmlErrorBody: () => parseXmlErrorBody
  });
  module.exports = __toCommonJS(protocols_exports);
  var _toStr = /* @__PURE__ */ __name2((val2) => {
    if (val2 == null) {
      return val2;
    }
    if (typeof val2 === "number" || typeof val2 === "bigint") {
      const warning = new Error(`Received number ${val2} where a string was expected.`);
      warning.name = "Warning";
      console.warn(warning);
      return String(val2);
    }
    if (typeof val2 === "boolean") {
      const warning = new Error(`Received boolean ${val2} where a string was expected.`);
      warning.name = "Warning";
      console.warn(warning);
      return String(val2);
    }
    return val2;
  }, "_toStr");
  var _toBool = /* @__PURE__ */ __name2((val2) => {
    if (val2 == null) {
      return val2;
    }
    if (typeof val2 === "number") {
    }
    if (typeof val2 === "string") {
      const lowercase = val2.toLowerCase();
      if (val2 !== "" && lowercase !== "false" && lowercase !== "true") {
        const warning = new Error(`Received string "${val2}" where a boolean was expected.`);
        warning.name = "Warning";
        console.warn(warning);
      }
      return val2 !== "" && lowercase !== "false";
    }
    return val2;
  }, "_toBool");
  var _toNum = /* @__PURE__ */ __name2((val2) => {
    if (val2 == null) {
      return val2;
    }
    if (typeof val2 === "boolean") {
    }
    if (typeof val2 === "string") {
      const num = Number(val2);
      if (num.toString() !== val2) {
        const warning = new Error(`Received string "${val2}" where a number was expected.`);
        warning.name = "Warning";
        console.warn(warning);
        return val2;
      }
      return num;
    }
    return val2;
  }, "_toNum");
  var import_smithy_client = require_dist_cjs19();
  var awsExpectUnion = /* @__PURE__ */ __name2((value) => {
    if (value == null) {
      return;
    }
    if (typeof value === "object" && "__type" in value) {
      delete value.__type;
    }
    return (0, import_smithy_client.expectUnion)(value);
  }, "awsExpectUnion");
  var import_smithy_client2 = require_dist_cjs19();
  var collectBodyString = /* @__PURE__ */ __name2((streamBody, context) => (0, import_smithy_client2.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body)), "collectBodyString");
  var parseJsonBody = /* @__PURE__ */ __name2((streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      try {
        return JSON.parse(encoded);
      } catch (e2) {
        if (e2?.name === "SyntaxError") {
          Object.defineProperty(e2, "$responseBodyText", {
            value: encoded
          });
        }
        throw e2;
      }
    }
    return {};
  }), "parseJsonBody");
  var parseJsonErrorBody = /* @__PURE__ */ __name2(async (errorBody, context) => {
    const value = await parseJsonBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
  }, "parseJsonErrorBody");
  var loadRestJsonErrorCode = /* @__PURE__ */ __name2((output, data) => {
    const findKey = /* @__PURE__ */ __name2((object, key) => Object.keys(object).find((k2) => k2.toLowerCase() === key.toLowerCase()), "findKey");
    const sanitizeErrorCode = /* @__PURE__ */ __name2((rawValue) => {
      let cleanValue = rawValue;
      if (typeof cleanValue === "number") {
        cleanValue = cleanValue.toString();
      }
      if (cleanValue.indexOf(",") >= 0) {
        cleanValue = cleanValue.split(",")[0];
      }
      if (cleanValue.indexOf(":") >= 0) {
        cleanValue = cleanValue.split(":")[0];
      }
      if (cleanValue.indexOf("#") >= 0) {
        cleanValue = cleanValue.split("#")[1];
      }
      return cleanValue;
    }, "sanitizeErrorCode");
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
      return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
      return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
      return sanitizeErrorCode(data["__type"]);
    }
  }, "loadRestJsonErrorCode");
  var import_smithy_client3 = require_dist_cjs19();
  var import_fast_xml_parser = require_fxp();
  var parseXmlBody = /* @__PURE__ */ __name2((streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      const parser = new import_fast_xml_parser.XMLParser({
        attributeNamePrefix: "",
        htmlEntities: true,
        ignoreAttributes: false,
        ignoreDeclaration: true,
        parseTagValue: false,
        trimValues: false,
        tagValueProcessor: (_3, val2) => val2.trim() === "" && val2.includes(`
`) ? "" : undefined
      });
      parser.addEntity("#xD", "\r");
      parser.addEntity("#10", `
`);
      let parsedObj;
      try {
        parsedObj = parser.parse(encoded, true);
      } catch (e2) {
        if (e2 && typeof e2 === "object") {
          Object.defineProperty(e2, "$responseBodyText", {
            value: encoded
          });
        }
        throw e2;
      }
      const textNodeName = "#text";
      const key = Object.keys(parsedObj)[0];
      const parsedObjToReturn = parsedObj[key];
      if (parsedObjToReturn[textNodeName]) {
        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
        delete parsedObjToReturn[textNodeName];
      }
      return (0, import_smithy_client3.getValueFromTextNode)(parsedObjToReturn);
    }
    return {};
  }), "parseXmlBody");
  var parseXmlErrorBody = /* @__PURE__ */ __name2(async (errorBody, context) => {
    const value = await parseXmlBody(errorBody, context);
    if (value.Error) {
      value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
  }, "parseXmlErrorBody");
  var loadRestXmlErrorCode = /* @__PURE__ */ __name2((output, data) => {
    if (data?.Error?.Code !== undefined) {
      return data.Error.Code;
    }
    if (data?.Code !== undefined) {
      return data.Code;
    }
    if (output.statusCode == 404) {
      return "NotFound";
    }
  }, "loadRestXmlErrorCode");
});

// ../../node_modules/@aws-sdk/core/dist-cjs/index.js
var require_dist_cjs20 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_client(), exports);
  tslib_1.__exportStar(require_httpAuthSchemes(), exports);
  tslib_1.__exportStar(require_protocols2(), exports);
});

// ../../node_modules/@smithy/is-array-buffer/dist-es/index.js
var isArrayBuffer = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

// ../../node_modules/@smithy/util-buffer-from/dist-es/index.js
import { Buffer as Buffer3 } from "buffer";
var fromArrayBuffer2 = (input, offset = 0, length = input.byteLength - offset) => {
  if (!isArrayBuffer(input)) {
    throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
  }
  return Buffer3.from(input, offset, length);
}, fromString2 = (input, encoding) => {
  if (typeof input !== "string") {
    throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
  }
  return encoding ? Buffer3.from(input, encoding) : Buffer3.from(input);
};
var init_dist_es2 = () => {
};

// ../../node_modules/@smithy/util-utf8/dist-es/fromUtf8.js
var fromUtf84 = (input) => {
  const buf = fromString2(input, "utf8");
  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};
var init_fromUtf8 = __esm(() => {
  init_dist_es2();
});

// ../../node_modules/@smithy/util-utf8/dist-es/toUint8Array.js
var toUint8Array2 = (data) => {
  if (typeof data === "string") {
    return fromUtf84(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
};
var init_toUint8Array = __esm(() => {
  init_fromUtf8();
});

// ../../node_modules/@smithy/util-utf8/dist-es/toUtf8.js
var toUtf82 = (input) => {
  if (typeof input === "string") {
    return input;
  }
  if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
    throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
  }
  return fromArrayBuffer2(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
};
var init_toUtf8 = __esm(() => {
  init_dist_es2();
});

// ../../node_modules/@smithy/util-utf8/dist-es/index.js
var init_dist_es3 = __esm(() => {
  init_fromUtf8();
  init_toUint8Array();
  init_toUtf8();
});

// ../../node_modules/@smithy/util-base64/dist-es/fromBase64.js
var BASE64_REGEX, fromBase643 = (input) => {
  if (input.length * 3 % 4 !== 0) {
    throw new TypeError(`Incorrect padding on base64 string.`);
  }
  if (!BASE64_REGEX.exec(input)) {
    throw new TypeError(`Invalid base64 string.`);
  }
  const buffer = fromString2(input, "base64");
  return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};
var init_fromBase64 = __esm(() => {
  init_dist_es2();
  BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
});

// ../../node_modules/@smithy/util-base64/dist-es/toBase64.js
var toBase643 = (_input) => {
  let input;
  if (typeof _input === "string") {
    input = fromUtf84(_input);
  } else {
    input = _input;
  }
  if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
    throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
  }
  return fromArrayBuffer2(input.buffer, input.byteOffset, input.byteLength).toString("base64");
};
var init_toBase64 = __esm(() => {
  init_dist_es2();
  init_dist_es3();
});

// ../../node_modules/@smithy/util-base64/dist-es/index.js
var init_dist_es4 = __esm(() => {
  init_fromBase64();
  init_toBase64();
});

// ../../node_modules/@smithy/util-stream/dist-es/blob/transforms.js
var init_transforms = __esm(() => {
  init_dist_es4();
  init_dist_es3();
  init_Uint8ArrayBlobAdapter();
});

// ../../node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js
var init_Uint8ArrayBlobAdapter = __esm(() => {
  init_transforms();
});

// ../../node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.js
import { Readable } from "stream";
var getAwsChunkedEncodingStream2 = (readableStream, options) => {
  const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
  const checksumRequired = base64Encoder !== undefined && checksumAlgorithmFn !== undefined && checksumLocationName !== undefined && streamHasher !== undefined;
  const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
  const awsChunkedEncodingStream = new Readable({ read: () => {
  } });
  readableStream.on("data", (data) => {
    const length = bodyLengthChecker(data) || 0;
    awsChunkedEncodingStream.push(`${length.toString(16)}\r
`);
    awsChunkedEncodingStream.push(data);
    awsChunkedEncodingStream.push(`\r
`);
  });
  readableStream.on("end", async () => {
    awsChunkedEncodingStream.push(`0\r
`);
    if (checksumRequired) {
      const checksum = base64Encoder(await digest);
      awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r
`);
      awsChunkedEncodingStream.push(`\r
`);
    }
    awsChunkedEncodingStream.push(null);
  });
  return awsChunkedEncodingStream;
};
var init_getAwsChunkedEncodingStream = () => {
};

// ../../node_modules/@smithy/querystring-builder/dist-es/index.js
function buildQueryString(query) {
  const parts = [];
  for (let key of Object.keys(query).sort()) {
    const value = query[key];
    key = import_util_uri_escape.escapeUri(key);
    if (Array.isArray(value)) {
      for (let i2 = 0, iLen = value.length;i2 < iLen; i2++) {
        parts.push(`${key}=${import_util_uri_escape.escapeUri(value[i2])}`);
      }
    } else {
      let qsEntry = key;
      if (value || typeof value === "string") {
        qsEntry += `=${import_util_uri_escape.escapeUri(value)}`;
      }
      parts.push(qsEntry);
    }
  }
  return parts.join("&");
}
var import_util_uri_escape;
var init_dist_es5 = __esm(() => {
  import_util_uri_escape = __toESM(require_dist_cjs9(), 1);
});

// ../../node_modules/@smithy/node-http-handler/dist-es/constants.js
var NODEJS_TIMEOUT_ERROR_CODES;
var init_constants = __esm(() => {
  NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];
});

// ../../node_modules/@smithy/node-http-handler/dist-es/get-transformed-headers.js
var getTransformedHeaders = (headers) => {
  const transformedHeaders = {};
  for (const name of Object.keys(headers)) {
    const headerValues = headers[name];
    transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
  }
  return transformedHeaders;
};
var init_get_transformed_headers = () => {
};

// ../../node_modules/@smithy/node-http-handler/dist-es/timing.js
var timing;
var init_timing = __esm(() => {
  timing = {
    setTimeout: (cb, ms) => setTimeout(cb, ms),
    clearTimeout: (timeoutId) => clearTimeout(timeoutId)
  };
});

// ../../node_modules/@smithy/node-http-handler/dist-es/set-connection-timeout.js
var DEFER_EVENT_LISTENER_TIME = 1000, setConnectionTimeout = (request, reject, timeoutInMs = 0) => {
  if (!timeoutInMs) {
    return -1;
  }
  const registerTimeout = (offset) => {
    const timeoutId = timing.setTimeout(() => {
      request.destroy();
      reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
        name: "TimeoutError"
      }));
    }, timeoutInMs - offset);
    const doWithSocket = (socket) => {
      if (socket?.connecting) {
        socket.on("connect", () => {
          timing.clearTimeout(timeoutId);
        });
      } else {
        timing.clearTimeout(timeoutId);
      }
    };
    if (request.socket) {
      doWithSocket(request.socket);
    } else {
      request.on("socket", doWithSocket);
    }
  };
  if (timeoutInMs < 2000) {
    registerTimeout(0);
    return 0;
  }
  return timing.setTimeout(registerTimeout.bind(null, DEFER_EVENT_LISTENER_TIME), DEFER_EVENT_LISTENER_TIME);
};
var init_set_connection_timeout = __esm(() => {
  init_timing();
});

// ../../node_modules/@smithy/node-http-handler/dist-es/set-socket-keep-alive.js
var DEFER_EVENT_LISTENER_TIME2 = 3000, setSocketKeepAlive = (request, { keepAlive, keepAliveMsecs }, deferTimeMs = DEFER_EVENT_LISTENER_TIME2) => {
  if (keepAlive !== true) {
    return -1;
  }
  const registerListener = () => {
    if (request.socket) {
      request.socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
    } else {
      request.on("socket", (socket) => {
        socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
      });
    }
  };
  if (deferTimeMs === 0) {
    registerListener();
    return 0;
  }
  return timing.setTimeout(registerListener, deferTimeMs);
};
var init_set_socket_keep_alive = __esm(() => {
  init_timing();
});

// ../../node_modules/@smithy/node-http-handler/dist-es/set-socket-timeout.js
var DEFER_EVENT_LISTENER_TIME3 = 3000, setSocketTimeout = (request, reject, timeoutInMs = DEFAULT_REQUEST_TIMEOUT) => {
  const registerTimeout = (offset) => {
    const timeout = timeoutInMs - offset;
    const onTimeout = () => {
      request.destroy();
      reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
    };
    if (request.socket) {
      request.socket.setTimeout(timeout, onTimeout);
    } else {
      request.setTimeout(timeout, onTimeout);
    }
  };
  if (0 < timeoutInMs && timeoutInMs < 6000) {
    registerTimeout(0);
    return 0;
  }
  return timing.setTimeout(registerTimeout.bind(null, timeoutInMs === 0 ? 0 : DEFER_EVENT_LISTENER_TIME3), DEFER_EVENT_LISTENER_TIME3);
};
var init_set_socket_timeout = __esm(() => {
  init_node_http_handler();
  init_timing();
});

// ../../node_modules/@smithy/node-http-handler/dist-es/write-request-body.js
import { Readable as Readable2 } from "stream";
async function writeRequestBody(httpRequest2, request, maxContinueTimeoutMs = MIN_WAIT_TIME) {
  const headers = request.headers ?? {};
  const expect = headers["Expect"] || headers["expect"];
  let timeoutId = -1;
  let sendBody = true;
  if (expect === "100-continue") {
    sendBody = await Promise.race([
      new Promise((resolve2) => {
        timeoutId = Number(timing.setTimeout(() => resolve2(true), Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
      }),
      new Promise((resolve2) => {
        httpRequest2.on("continue", () => {
          timing.clearTimeout(timeoutId);
          resolve2(true);
        });
        httpRequest2.on("response", () => {
          timing.clearTimeout(timeoutId);
          resolve2(false);
        });
        httpRequest2.on("error", () => {
          timing.clearTimeout(timeoutId);
          resolve2(false);
        });
      })
    ]);
  }
  if (sendBody) {
    writeBody(httpRequest2, request.body);
  }
}
function writeBody(httpRequest2, body) {
  if (body instanceof Readable2) {
    body.pipe(httpRequest2);
    return;
  }
  if (body) {
    if (Buffer.isBuffer(body) || typeof body === "string") {
      httpRequest2.end(body);
      return;
    }
    const uint8 = body;
    if (typeof uint8 === "object" && uint8.buffer && typeof uint8.byteOffset === "number" && typeof uint8.byteLength === "number") {
      httpRequest2.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
      return;
    }
    httpRequest2.end(Buffer.from(body));
    return;
  }
  httpRequest2.end();
}
var MIN_WAIT_TIME = 6000;
var init_write_request_body = __esm(() => {
  init_timing();
});

// ../../node_modules/@smithy/node-http-handler/dist-es/node-http-handler.js
import { Agent as hAgent, request as hRequest } from "http";
import { Agent as hsAgent, request as hsRequest } from "https";

class NodeHttpHandler {
  static create(instanceOrOptions) {
    if (typeof instanceOrOptions?.handle === "function") {
      return instanceOrOptions;
    }
    return new NodeHttpHandler(instanceOrOptions);
  }
  static checkSocketUsage(agent, socketWarningTimestamp, logger = console) {
    const { sockets, requests, maxSockets } = agent;
    if (typeof maxSockets !== "number" || maxSockets === Infinity) {
      return socketWarningTimestamp;
    }
    const interval = 15000;
    if (Date.now() - interval < socketWarningTimestamp) {
      return socketWarningTimestamp;
    }
    if (sockets && requests) {
      for (const origin in sockets) {
        const socketsInUse = sockets[origin]?.length ?? 0;
        const requestsEnqueued = requests[origin]?.length ?? 0;
        if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
          logger?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`);
          return Date.now();
        }
      }
    }
    return socketWarningTimestamp;
  }
  constructor(options) {
    this.socketWarningTimestamp = 0;
    this.metadata = { handlerProtocol: "http/1.1" };
    this.configProvider = new Promise((resolve2, reject) => {
      if (typeof options === "function") {
        options().then((_options) => {
          resolve2(this.resolveDefaultConfig(_options));
        }).catch(reject);
      } else {
        resolve2(this.resolveDefaultConfig(options));
      }
    });
  }
  resolveDefaultConfig(options) {
    const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
    const keepAlive = true;
    const maxSockets = 50;
    return {
      connectionTimeout,
      requestTimeout: requestTimeout ?? socketTimeout,
      httpAgent: (() => {
        if (httpAgent instanceof hAgent || typeof httpAgent?.destroy === "function") {
          return httpAgent;
        }
        return new hAgent({ keepAlive, maxSockets, ...httpAgent });
      })(),
      httpsAgent: (() => {
        if (httpsAgent instanceof hsAgent || typeof httpsAgent?.destroy === "function") {
          return httpsAgent;
        }
        return new hsAgent({ keepAlive, maxSockets, ...httpsAgent });
      })(),
      logger: console
    };
  }
  destroy() {
    this.config?.httpAgent?.destroy();
    this.config?.httpsAgent?.destroy();
  }
  async handle(request, { abortSignal } = {}) {
    if (!this.config) {
      this.config = await this.configProvider;
    }
    return new Promise((_resolve, _reject) => {
      let writeRequestBodyPromise = undefined;
      const timeouts = [];
      const resolve2 = async (arg) => {
        await writeRequestBodyPromise;
        timeouts.forEach(timing.clearTimeout);
        _resolve(arg);
      };
      const reject = async (arg) => {
        await writeRequestBodyPromise;
        timeouts.forEach(timing.clearTimeout);
        _reject(arg);
      };
      if (!this.config) {
        throw new Error("Node HTTP request handler config is not resolved");
      }
      if (abortSignal?.aborted) {
        const abortError = new Error("Request aborted");
        abortError.name = "AbortError";
        reject(abortError);
        return;
      }
      const isSSL = request.protocol === "https:";
      const agent = isSSL ? this.config.httpsAgent : this.config.httpAgent;
      timeouts.push(timing.setTimeout(() => {
        this.socketWarningTimestamp = NodeHttpHandler.checkSocketUsage(agent, this.socketWarningTimestamp, this.config.logger);
      }, this.config.socketAcquisitionWarningTimeout ?? (this.config.requestTimeout ?? 2000) + (this.config.connectionTimeout ?? 1000)));
      const queryString = buildQueryString(request.query || {});
      let auth = undefined;
      if (request.username != null || request.password != null) {
        const username = request.username ?? "";
        const password = request.password ?? "";
        auth = `${username}:${password}`;
      }
      let path = request.path;
      if (queryString) {
        path += `?${queryString}`;
      }
      if (request.fragment) {
        path += `#${request.fragment}`;
      }
      let hostname = request.hostname ?? "";
      if (hostname[0] === "[" && hostname.endsWith("]")) {
        hostname = request.hostname.slice(1, -1);
      } else {
        hostname = request.hostname;
      }
      const nodeHttpsOptions = {
        headers: request.headers,
        host: hostname,
        method: request.method,
        path,
        port: request.port,
        agent,
        auth
      };
      const requestFunc = isSSL ? hsRequest : hRequest;
      const req = requestFunc(nodeHttpsOptions, (res) => {
        const httpResponse2 = new HttpResponse({
          statusCode: res.statusCode || -1,
          reason: res.statusMessage,
          headers: getTransformedHeaders(res.headers),
          body: res
        });
        resolve2({ response: httpResponse2 });
      });
      req.on("error", (err) => {
        if (NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
          reject(Object.assign(err, { name: "TimeoutError" }));
        } else {
          reject(err);
        }
      });
      if (abortSignal) {
        const onAbort = () => {
          req.destroy();
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
        };
        if (typeof abortSignal.addEventListener === "function") {
          const signal = abortSignal;
          signal.addEventListener("abort", onAbort, { once: true });
          req.once("close", () => signal.removeEventListener("abort", onAbort));
        } else {
          abortSignal.onabort = onAbort;
        }
      }
      timeouts.push(setConnectionTimeout(req, reject, this.config.connectionTimeout));
      timeouts.push(setSocketTimeout(req, reject, this.config.requestTimeout));
      const httpAgent = nodeHttpsOptions.agent;
      if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
        timeouts.push(setSocketKeepAlive(req, {
          keepAlive: httpAgent.keepAlive,
          keepAliveMsecs: httpAgent.keepAliveMsecs
        }));
      }
      writeRequestBodyPromise = writeRequestBody(req, request, this.config.requestTimeout).catch((e2) => {
        timeouts.forEach(timing.clearTimeout);
        return _reject(e2);
      });
    });
  }
  updateHttpClientConfig(key, value) {
    this.config = undefined;
    this.configProvider = this.configProvider.then((config2) => {
      return {
        ...config2,
        [key]: value
      };
    });
  }
  httpHandlerConfigs() {
    return this.config ?? {};
  }
}
var DEFAULT_REQUEST_TIMEOUT = 0;
var init_node_http_handler = __esm(() => {
  init_dist_es();
  init_dist_es5();
  init_constants();
  init_get_transformed_headers();
  init_set_connection_timeout();
  init_set_socket_keep_alive();
  init_set_socket_timeout();
  init_timing();
  init_write_request_body();
});

// ../../node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-pool.js
var init_node_http2_connection_pool = () => {
};

// ../../node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-manager.js
var init_node_http2_connection_manager = __esm(() => {
  init_node_http2_connection_pool();
});

// ../../node_modules/@smithy/node-http-handler/dist-es/node-http2-handler.js
var init_node_http2_handler = __esm(() => {
  init_dist_es();
  init_dist_es5();
  init_get_transformed_headers();
  init_node_http2_connection_manager();
  init_write_request_body();
});

// ../../node_modules/@smithy/node-http-handler/dist-es/stream-collector/collector.js
import { Writable } from "stream";
var Collector;
var init_collector = __esm(() => {
  Collector = class Collector extends Writable {
    constructor() {
      super(...arguments);
      this.bufferedBytes = [];
    }
    _write(chunk, encoding, callback) {
      this.bufferedBytes.push(chunk);
      callback();
    }
  };
});

// ../../node_modules/@smithy/node-http-handler/dist-es/stream-collector/index.js
async function collectReadableStream(stream) {
  const chunks = [];
  const reader = stream.getReader();
  let isDone = false;
  let length = 0;
  while (!isDone) {
    const { done, value } = await reader.read();
    if (value) {
      chunks.push(value);
      length += value.length;
    }
    isDone = done;
  }
  const collected = new Uint8Array(length);
  let offset = 0;
  for (const chunk of chunks) {
    collected.set(chunk, offset);
    offset += chunk.length;
  }
  return collected;
}
var streamCollector = (stream) => {
  if (isReadableStreamInstance(stream)) {
    return collectReadableStream(stream);
  }
  return new Promise((resolve2, reject) => {
    const collector = new Collector;
    stream.pipe(collector);
    stream.on("error", (err) => {
      collector.end();
      reject(err);
    });
    collector.on("error", reject);
    collector.on("finish", function() {
      const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
      resolve2(bytes);
    });
  });
}, isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;
var init_stream_collector = __esm(() => {
  init_collector();
});

// ../../node_modules/@smithy/node-http-handler/dist-es/index.js
var init_dist_es6 = __esm(() => {
  init_node_http_handler();
  init_node_http2_handler();
  init_stream_collector();
});
// ../../node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js
var init_fetch_http_handler = __esm(() => {
  init_dist_es();
  init_dist_es5();
});

// ../../node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js
async function collectBlob(blob) {
  const base642 = await readToBase64(blob);
  const arrayBuffer = fromBase643(base642);
  return new Uint8Array(arrayBuffer);
}
async function collectStream(stream) {
  const chunks = [];
  const reader = stream.getReader();
  let isDone = false;
  let length = 0;
  while (!isDone) {
    const { done, value } = await reader.read();
    if (value) {
      chunks.push(value);
      length += value.length;
    }
    isDone = done;
  }
  const collected = new Uint8Array(length);
  let offset = 0;
  for (const chunk of chunks) {
    collected.set(chunk, offset);
    offset += chunk.length;
  }
  return collected;
}
function readToBase64(blob) {
  return new Promise((resolve2, reject) => {
    const reader = new FileReader;
    reader.onloadend = () => {
      if (reader.readyState !== 2) {
        return reject(new Error("Reader aborted too early"));
      }
      const result = reader.result ?? "";
      const commaIndex = result.indexOf(",");
      const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
      resolve2(result.substring(dataOffset));
    };
    reader.onabort = () => reject(new Error("Read aborted"));
    reader.onerror = () => reject(reader.error);
    reader.readAsDataURL(blob);
  });
}
var streamCollector2 = async (stream) => {
  if (typeof Blob === "function" && stream instanceof Blob || stream.constructor?.name === "Blob") {
    if (Blob.prototype.arrayBuffer !== undefined) {
      return new Uint8Array(await stream.arrayBuffer());
    }
    return collectBlob(stream);
  }
  return collectStream(stream);
};
var init_stream_collector2 = __esm(() => {
  init_dist_es4();
});

// ../../node_modules/@smithy/fetch-http-handler/dist-es/index.js
var init_dist_es7 = __esm(() => {
  init_fetch_http_handler();
  init_stream_collector2();
});

// ../../node_modules/@smithy/util-stream/dist-es/stream-type-check.js
var isReadableStream2 = (stream) => typeof ReadableStream === "function" && (stream?.constructor?.name === ReadableStream.name || stream instanceof ReadableStream), isBlob2 = (blob) => {
  return typeof Blob === "function" && (blob?.constructor?.name === Blob.name || blob instanceof Blob);
};

// ../../node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js
var import_util_hex_encoding, ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.", sdkStreamMixin2 = (stream) => {
  if (!isBlobInstance(stream) && !isReadableStream2(stream)) {
    const name = stream?.__proto__?.constructor?.name || stream;
    throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
  }
  let transformed = false;
  const transformToByteArray = async () => {
    if (transformed) {
      throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
    }
    transformed = true;
    return await streamCollector2(stream);
  };
  const blobToWebStream = (blob) => {
    if (typeof blob.stream !== "function") {
      throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
` + "If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
    }
    return blob.stream();
  };
  return Object.assign(stream, {
    transformToByteArray,
    transformToString: async (encoding) => {
      const buf = await transformToByteArray();
      if (encoding === "base64") {
        return toBase643(buf);
      } else if (encoding === "hex") {
        return import_util_hex_encoding.toHex(buf);
      } else if (encoding === undefined || encoding === "utf8" || encoding === "utf-8") {
        return toUtf82(buf);
      } else if (typeof TextDecoder === "function") {
        return new TextDecoder(encoding).decode(buf);
      } else {
        throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
      }
    },
    transformToWebStream: () => {
      if (transformed) {
        throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
      }
      transformed = true;
      if (isBlobInstance(stream)) {
        return blobToWebStream(stream);
      } else if (isReadableStream2(stream)) {
        return stream;
      } else {
        throw new Error(`Cannot transform payload to web stream, got ${stream}`);
      }
    }
  });
}, isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;
var init_sdk_stream_mixin_browser = __esm(() => {
  init_dist_es7();
  init_dist_es4();
  import_util_hex_encoding = __toESM(require_dist_cjs13(), 1);
  init_dist_es3();
});

// ../../node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.js
import { Readable as Readable3 } from "stream";
var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED2 = "The stream has already been transformed.", sdkStreamMixin3 = (stream) => {
  if (!(stream instanceof Readable3)) {
    try {
      return sdkStreamMixin2(stream);
    } catch (e2) {
      const name = stream?.__proto__?.constructor?.name || stream;
      throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
    }
  }
  let transformed = false;
  const transformToByteArray = async () => {
    if (transformed) {
      throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED2);
    }
    transformed = true;
    return await streamCollector(stream);
  };
  return Object.assign(stream, {
    transformToByteArray,
    transformToString: async (encoding) => {
      const buf = await transformToByteArray();
      if (encoding === undefined || Buffer.isEncoding(encoding)) {
        return fromArrayBuffer2(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
      } else {
        const decoder = new TextDecoder(encoding);
        return decoder.decode(buf);
      }
    },
    transformToWebStream: () => {
      if (transformed) {
        throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED2);
      }
      if (stream.readableFlowing !== null) {
        throw new Error("The stream has been consumed by other callbacks.");
      }
      if (typeof Readable3.toWeb !== "function") {
        throw new Error("Readable.toWeb() is not supported. Please ensure a polyfill is available.");
      }
      transformed = true;
      return Readable3.toWeb(stream);
    }
  });
};
var init_sdk_stream_mixin = __esm(() => {
  init_dist_es6();
  init_dist_es2();
  init_sdk_stream_mixin_browser();
});

// ../../node_modules/@smithy/util-stream/dist-es/splitStream.browser.js
async function splitStream2(stream) {
  if (typeof stream.stream === "function") {
    stream = stream.stream();
  }
  const readableStream = stream;
  return readableStream.tee();
}

// ../../node_modules/@smithy/util-stream/dist-es/splitStream.js
import { PassThrough } from "stream";
async function splitStream3(stream) {
  if (isReadableStream2(stream) || isBlob2(stream)) {
    return splitStream2(stream);
  }
  const stream1 = new PassThrough;
  const stream2 = new PassThrough;
  stream.pipe(stream1);
  stream.pipe(stream2);
  return [stream1, stream2];
}
var init_splitStream = () => {
};

// ../../node_modules/@smithy/util-stream/dist-es/headStream.browser.js
async function headStream2(stream, bytes) {
  let byteLengthCounter = 0;
  const chunks = [];
  const reader = stream.getReader();
  let isDone = false;
  while (!isDone) {
    const { done, value } = await reader.read();
    if (value) {
      chunks.push(value);
      byteLengthCounter += value?.byteLength ?? 0;
    }
    if (byteLengthCounter >= bytes) {
      break;
    }
    isDone = done;
  }
  reader.releaseLock();
  const collected = new Uint8Array(Math.min(bytes, byteLengthCounter));
  let offset = 0;
  for (const chunk of chunks) {
    if (chunk.byteLength > collected.byteLength - offset) {
      collected.set(chunk.subarray(0, collected.byteLength - offset), offset);
      break;
    } else {
      collected.set(chunk, offset);
    }
    offset += chunk.length;
  }
  return collected;
}

// ../../node_modules/@smithy/util-stream/dist-es/headStream.js
import { Writable as Writable2 } from "stream";
var headStream3 = (stream, bytes) => {
  if (isReadableStream2(stream)) {
    return headStream2(stream, bytes);
  }
  return new Promise((resolve2, reject) => {
    const collector = new Collector2;
    collector.limit = bytes;
    stream.pipe(collector);
    stream.on("error", (err) => {
      collector.end();
      reject(err);
    });
    collector.on("error", reject);
    collector.on("finish", function() {
      const bytes2 = new Uint8Array(Buffer.concat(this.buffers));
      resolve2(bytes2);
    });
  });
}, Collector2;
var init_headStream = __esm(() => {
  Collector2 = class Collector2 extends Writable2 {
    constructor() {
      super(...arguments);
      this.buffers = [];
      this.limit = Infinity;
      this.bytesBuffered = 0;
    }
    _write(chunk, encoding, callback) {
      this.buffers.push(chunk);
      this.bytesBuffered += chunk.byteLength ?? 0;
      if (this.bytesBuffered >= this.limit) {
        const excess = this.bytesBuffered - this.limit;
        const tailBuffer = this.buffers[this.buffers.length - 1];
        this.buffers[this.buffers.length - 1] = tailBuffer.subarray(0, tailBuffer.byteLength - excess);
        this.emit("finish");
      }
      callback();
    }
  };
});

// ../../node_modules/@smithy/util-stream/dist-es/checksum/ChecksumStream.js
var init_ChecksumStream = __esm(() => {
  init_dist_es4();
});

// ../../node_modules/@smithy/util-stream/dist-es/checksum/ChecksumStream.browser.js
var init_ChecksumStream_browser = () => {
};

// ../../node_modules/@smithy/util-stream/dist-es/checksum/createChecksumStream.browser.js
var init_createChecksumStream_browser = __esm(() => {
  init_dist_es4();
  init_ChecksumStream_browser();
});

// ../../node_modules/@smithy/util-stream/dist-es/checksum/createChecksumStream.js
var init_createChecksumStream = __esm(() => {
  init_ChecksumStream();
  init_createChecksumStream_browser();
});

// ../../node_modules/@smithy/util-stream/dist-es/index.js
var init_dist_es8 = __esm(() => {
  init_Uint8ArrayBlobAdapter();
  init_getAwsChunkedEncodingStream();
  init_sdk_stream_mixin();
  init_splitStream();
  init_headStream();
  init_createChecksumStream();
  init_ChecksumStream();
});

// ../../node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js
var import_types5, getSmithyContext = (context) => context[import_types5.SMITHY_CONTEXT_KEY] || (context[import_types5.SMITHY_CONTEXT_KEY] = {});
var init_getSmithyContext = __esm(() => {
  import_types5 = __toESM(require_dist_cjs(), 1);
});

// ../../node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js
var normalizeProvider = (input) => {
  if (typeof input === "function")
    return input;
  const promisified = Promise.resolve(input);
  return () => promisified;
};

// ../../node_modules/@smithy/util-middleware/dist-es/index.js
var init_dist_es9 = __esm(() => {
  init_getSmithyContext();
});

// ../../node_modules/@aws-sdk/middleware-host-header/dist-es/index.js
function resolveHostHeaderConfig(input) {
  return input;
}
var hostHeaderMiddleware = (options) => (next) => async (args) => {
  if (!HttpRequest.isInstance(args.request))
    return next(args);
  const { request } = args;
  const { handlerProtocol = "" } = options.requestHandler.metadata || {};
  if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
    delete request.headers["host"];
    request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
  } else if (!request.headers["host"]) {
    let host = request.hostname;
    if (request.port != null)
      host += `:${request.port}`;
    request.headers["host"] = host;
  }
  return next(args);
}, hostHeaderMiddlewareOptions, getHostHeaderPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
  }
});
var init_dist_es10 = __esm(() => {
  init_dist_es();
  hostHeaderMiddlewareOptions = {
    name: "hostHeaderMiddleware",
    step: "build",
    priority: "low",
    tags: ["HOST"],
    override: true
  };
});

// ../../node_modules/@aws-sdk/middleware-logger/dist-es/loggerMiddleware.js
var loggerMiddleware = () => (next, context) => async (args) => {
  try {
    const response = await next(args);
    const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
    const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
    const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
    const { $metadata, ...outputWithoutMetadata } = response.output;
    logger?.info?.({
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      output: outputFilterSensitiveLog(outputWithoutMetadata),
      metadata: $metadata
    });
    return response;
  } catch (error) {
    const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
    const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
    logger?.error?.({
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      error,
      metadata: error.$metadata
    });
    throw error;
  }
}, loggerMiddlewareOptions, getLoggerPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
  }
});
var init_loggerMiddleware = __esm(() => {
  loggerMiddlewareOptions = {
    name: "loggerMiddleware",
    tags: ["LOGGER"],
    step: "initialize",
    override: true
  };
});

// ../../node_modules/@aws-sdk/middleware-logger/dist-es/index.js
var init_dist_es11 = __esm(() => {
  init_loggerMiddleware();
});

// ../../node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js
var TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id", ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME", ENV_TRACE_ID = "_X_AMZN_TRACE_ID", recursionDetectionMiddleware = (options) => (next) => async (args) => {
  const { request } = args;
  if (!HttpRequest.isInstance(request) || options.runtime !== "node" || request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
    return next(args);
  }
  const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
  const traceId = process.env[ENV_TRACE_ID];
  const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
  if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
    request.headers[TRACE_ID_HEADER_NAME] = traceId;
  }
  return next({
    ...args,
    request
  });
}, addRecursionDetectionMiddlewareOptions, getRecursionDetectionPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(recursionDetectionMiddleware(options), addRecursionDetectionMiddlewareOptions);
  }
});
var init_dist_es12 = __esm(() => {
  init_dist_es();
  addRecursionDetectionMiddlewareOptions = {
    step: "build",
    tags: ["RECURSION_DETECTION"],
    name: "recursionDetectionMiddleware",
    override: true,
    priority: "low"
  };
});

// ../../node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
var getAllAliases = (name, aliases) => {
  const _aliases = [];
  if (name) {
    _aliases.push(name);
  }
  if (aliases) {
    for (const alias of aliases) {
      _aliases.push(alias);
    }
  }
  return _aliases;
}, getMiddlewareNameWithAliases = (name, aliases) => {
  return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
}, constructStack = () => {
  let absoluteEntries = [];
  let relativeEntries = [];
  let identifyOnResolve = false;
  const entriesNameSet = new Set;
  const sort = (entries) => entries.sort((a3, b) => stepWeights[b.step] - stepWeights[a3.step] || priorityWeights[b.priority || "normal"] - priorityWeights[a3.priority || "normal"]);
  const removeByName = (toRemove) => {
    let isRemoved = false;
    const filterCb = (entry) => {
      const aliases = getAllAliases(entry.name, entry.aliases);
      if (aliases.includes(toRemove)) {
        isRemoved = true;
        for (const alias of aliases) {
          entriesNameSet.delete(alias);
        }
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  const removeByReference = (toRemove) => {
    let isRemoved = false;
    const filterCb = (entry) => {
      if (entry.middleware === toRemove) {
        isRemoved = true;
        for (const alias of getAllAliases(entry.name, entry.aliases)) {
          entriesNameSet.delete(alias);
        }
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  const cloneTo = (toStack) => {
    absoluteEntries.forEach((entry) => {
      toStack.add(entry.middleware, { ...entry });
    });
    relativeEntries.forEach((entry) => {
      toStack.addRelativeTo(entry.middleware, { ...entry });
    });
    toStack.identifyOnResolve?.(stack.identifyOnResolve());
    return toStack;
  };
  const expandRelativeMiddlewareList = (from) => {
    const expandedMiddlewareList = [];
    from.before.forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    expandedMiddlewareList.push(from);
    from.after.reverse().forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    return expandedMiddlewareList;
  };
  const getMiddlewareList = (debug = false) => {
    const normalizedAbsoluteEntries = [];
    const normalizedRelativeEntries = [];
    const normalizedEntriesNameMap = {};
    absoluteEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
        normalizedEntriesNameMap[alias] = normalizedEntry;
      }
      normalizedAbsoluteEntries.push(normalizedEntry);
    });
    relativeEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
        normalizedEntriesNameMap[alias] = normalizedEntry;
      }
      normalizedRelativeEntries.push(normalizedEntry);
    });
    normalizedRelativeEntries.forEach((entry) => {
      if (entry.toMiddleware) {
        const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
        if (toMiddleware === undefined) {
          if (debug) {
            return;
          }
          throw new Error(`${entry.toMiddleware} is not found when adding ` + `${getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` + `middleware ${entry.relation} ${entry.toMiddleware}`);
        }
        if (entry.relation === "after") {
          toMiddleware.after.push(entry);
        }
        if (entry.relation === "before") {
          toMiddleware.before.push(entry);
        }
      }
    });
    const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
      wholeList.push(...expandedMiddlewareList);
      return wholeList;
    }, []);
    return mainChain;
  };
  const stack = {
    add: (middleware, options = {}) => {
      const { name, override, aliases: _aliases } = options;
      const entry = {
        step: "initialize",
        priority: "normal",
        middleware,
        ...options
      };
      const aliases = getAllAliases(name, _aliases);
      if (aliases.length > 0) {
        if (aliases.some((alias) => entriesNameSet.has(alias))) {
          if (!override)
            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
          for (const alias of aliases) {
            const toOverrideIndex = absoluteEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a3) => a3 === alias));
            if (toOverrideIndex === -1) {
              continue;
            }
            const toOverride = absoluteEntries[toOverrideIndex];
            if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
              throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ` + `${toOverride.priority} priority in ${toOverride.step} step cannot ` + `be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ` + `${entry.priority} priority in ${entry.step} step.`);
            }
            absoluteEntries.splice(toOverrideIndex, 1);
          }
        }
        for (const alias of aliases) {
          entriesNameSet.add(alias);
        }
      }
      absoluteEntries.push(entry);
    },
    addRelativeTo: (middleware, options) => {
      const { name, override, aliases: _aliases } = options;
      const entry = {
        middleware,
        ...options
      };
      const aliases = getAllAliases(name, _aliases);
      if (aliases.length > 0) {
        if (aliases.some((alias) => entriesNameSet.has(alias))) {
          if (!override)
            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
          for (const alias of aliases) {
            const toOverrideIndex = relativeEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a3) => a3 === alias));
            if (toOverrideIndex === -1) {
              continue;
            }
            const toOverride = relativeEntries[toOverrideIndex];
            if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
              throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ` + `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` + `by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} ` + `"${entry.toMiddleware}" middleware.`);
            }
            relativeEntries.splice(toOverrideIndex, 1);
          }
        }
        for (const alias of aliases) {
          entriesNameSet.add(alias);
        }
      }
      relativeEntries.push(entry);
    },
    clone: () => cloneTo(constructStack()),
    use: (plugin) => {
      plugin.applyToStack(stack);
    },
    remove: (toRemove) => {
      if (typeof toRemove === "string")
        return removeByName(toRemove);
      else
        return removeByReference(toRemove);
    },
    removeByTag: (toRemove) => {
      let isRemoved = false;
      const filterCb = (entry) => {
        const { tags, name, aliases: _aliases } = entry;
        if (tags && tags.includes(toRemove)) {
          const aliases = getAllAliases(name, _aliases);
          for (const alias of aliases) {
            entriesNameSet.delete(alias);
          }
          isRemoved = true;
          return false;
        }
        return true;
      };
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    },
    concat: (from) => {
      const cloned = cloneTo(constructStack());
      cloned.use(from);
      cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
      return cloned;
    },
    applyToStack: cloneTo,
    identify: () => {
      return getMiddlewareList(true).map((mw) => {
        const step = mw.step ?? mw.relation + " " + mw.toMiddleware;
        return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
      });
    },
    identifyOnResolve(toggle) {
      if (typeof toggle === "boolean")
        identifyOnResolve = toggle;
      return identifyOnResolve;
    },
    resolve: (handler, context) => {
      for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
        handler = middleware(handler, context);
      }
      if (identifyOnResolve) {
        console.log(stack.identify());
      }
      return handler;
    }
  };
  return stack;
}, stepWeights, priorityWeights;
var init_MiddlewareStack = __esm(() => {
  stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1
  };
  priorityWeights = {
    high: 3,
    normal: 2,
    low: 1
  };
});

// ../../node_modules/@smithy/middleware-stack/dist-es/index.js
var init_dist_es13 = __esm(() => {
  init_MiddlewareStack();
});

// ../../node_modules/@smithy/smithy-client/dist-es/client.js
class Client {
  constructor(config2) {
    this.config = config2;
    this.middlewareStack = constructStack();
  }
  send(command, optionsOrCb, cb) {
    const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
    const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
    const useHandlerCache = options === undefined && this.config.cacheMiddleware === true;
    let handler;
    if (useHandlerCache) {
      if (!this.handlers) {
        this.handlers = new WeakMap;
      }
      const handlers = this.handlers;
      if (handlers.has(command.constructor)) {
        handler = handlers.get(command.constructor);
      } else {
        handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        handlers.set(command.constructor, handler);
      }
    } else {
      delete this.handlers;
      handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
    }
    if (callback) {
      handler(command).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {
      });
    } else {
      return handler(command).then((result) => result.output);
    }
  }
  destroy() {
    this.config?.requestHandler?.destroy?.();
    delete this.handlers;
  }
}
var init_client = __esm(() => {
  init_dist_es13();
});

// ../../node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js
var import_protocols;
var init_collect_stream_body = __esm(() => {
  import_protocols = __toESM(require_protocols(), 1);
});

// ../../node_modules/@smithy/smithy-client/dist-es/command.js
class Command {
  constructor() {
    this.middlewareStack = constructStack();
  }
  static classBuilder() {
    return new ClassBuilder;
  }
  resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor }) {
    for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
      this.middlewareStack.use(mw);
    }
    const stack = clientStack.concat(this.middlewareStack);
    const { logger } = configuration;
    const handlerExecutionContext = {
      logger,
      clientName,
      commandName,
      inputFilterSensitiveLog,
      outputFilterSensitiveLog,
      [import_types6.SMITHY_CONTEXT_KEY]: {
        commandInstance: this,
        ...smithyContext
      },
      ...additionalContext
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
}

class ClassBuilder {
  constructor() {
    this._init = () => {
    };
    this._ep = {};
    this._middlewareFn = () => [];
    this._commandName = "";
    this._clientName = "";
    this._additionalContext = {};
    this._smithyContext = {};
    this._inputFilterSensitiveLog = (_3) => _3;
    this._outputFilterSensitiveLog = (_3) => _3;
    this._serializer = null;
    this._deserializer = null;
  }
  init(cb) {
    this._init = cb;
  }
  ep(endpointParameterInstructions) {
    this._ep = endpointParameterInstructions;
    return this;
  }
  m(middlewareSupplier) {
    this._middlewareFn = middlewareSupplier;
    return this;
  }
  s(service, operation, smithyContext = {}) {
    this._smithyContext = {
      service,
      operation,
      ...smithyContext
    };
    return this;
  }
  c(additionalContext = {}) {
    this._additionalContext = additionalContext;
    return this;
  }
  n(clientName, commandName) {
    this._clientName = clientName;
    this._commandName = commandName;
    return this;
  }
  f(inputFilter = (_3) => _3, outputFilter = (_3) => _3) {
    this._inputFilterSensitiveLog = inputFilter;
    this._outputFilterSensitiveLog = outputFilter;
    return this;
  }
  ser(serializer) {
    this._serializer = serializer;
    return this;
  }
  de(deserializer) {
    this._deserializer = deserializer;
    return this;
  }
  build() {
    const closure = this;
    let CommandRef;
    return CommandRef = class extends Command {
      static getEndpointParameterInstructions() {
        return closure._ep;
      }
      constructor(...[input]) {
        super();
        this.serialize = closure._serializer;
        this.deserialize = closure._deserializer;
        this.input = input ?? {};
        closure._init(this);
      }
      resolveMiddleware(stack, configuration, options) {
        return this.resolveMiddlewareWithContext(stack, configuration, options, {
          CommandCtor: CommandRef,
          middlewareFn: closure._middlewareFn,
          clientName: closure._clientName,
          commandName: closure._commandName,
          inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
          outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
          smithyContext: closure._smithyContext,
          additionalContext: closure._additionalContext
        });
      }
    };
  }
}
var import_types6;
var init_command = __esm(() => {
  init_dist_es13();
  import_types6 = __toESM(require_dist_cjs(), 1);
});

// ../../node_modules/@smithy/smithy-client/dist-es/constants.js
var SENSITIVE_STRING = "***SensitiveInformation***";

// ../../node_modules/@smithy/smithy-client/dist-es/create-aggregated-client.js
var createAggregatedClient = (commands, Client2) => {
  for (const command of Object.keys(commands)) {
    const CommandCtor = commands[command];
    const methodImpl = async function(args, optionsOrCb, cb) {
      const command2 = new CommandCtor(args);
      if (typeof optionsOrCb === "function") {
        this.send(command2, optionsOrCb);
      } else if (typeof cb === "function") {
        if (typeof optionsOrCb !== "object")
          throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
        this.send(command2, optionsOrCb || {}, cb);
      } else {
        return this.send(command2, optionsOrCb);
      }
    };
    const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
    Client2.prototype[methodName] = methodImpl;
  }
};

// ../../node_modules/@smithy/smithy-client/dist-es/parse-utils.js
var parseBoolean = (value) => {
  switch (value) {
    case "true":
      return true;
    case "false":
      return false;
    default:
      throw new Error(`Unable to parse boolean value "${value}"`);
  }
}, expectNumber = (value) => {
  if (value === null || value === undefined) {
    return;
  }
  if (typeof value === "string") {
    const parsed = parseFloat(value);
    if (!Number.isNaN(parsed)) {
      if (String(parsed) !== String(value)) {
        logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
      }
      return parsed;
    }
  }
  if (typeof value === "number") {
    return value;
  }
  throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
}, MAX_FLOAT, expectFloat32 = (value) => {
  const expected = expectNumber(value);
  if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
    if (Math.abs(expected) > MAX_FLOAT) {
      throw new TypeError(`Expected 32-bit float, got ${value}`);
    }
  }
  return expected;
}, expectLong = (value) => {
  if (value === null || value === undefined) {
    return;
  }
  if (Number.isInteger(value) && !Number.isNaN(value)) {
    return value;
  }
  throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
}, expectShort = (value) => expectSizedInt(value, 16), expectByte = (value) => expectSizedInt(value, 8), expectSizedInt = (value, size) => {
  const expected = expectLong(value);
  if (expected !== undefined && castInt(expected, size) !== expected) {
    throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
  }
  return expected;
}, castInt = (value, size) => {
  switch (size) {
    case 32:
      return Int32Array.of(value)[0];
    case 16:
      return Int16Array.of(value)[0];
    case 8:
      return Int8Array.of(value)[0];
  }
}, expectNonNull = (value, location) => {
  if (value === null || value === undefined) {
    if (location) {
      throw new TypeError(`Expected a non-null value for ${location}`);
    }
    throw new TypeError("Expected a non-null value");
  }
  return value;
}, expectObject = (value) => {
  if (value === null || value === undefined) {
    return;
  }
  if (typeof value === "object" && !Array.isArray(value)) {
    return value;
  }
  const receivedType = Array.isArray(value) ? "array" : typeof value;
  throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
}, expectString = (value) => {
  if (value === null || value === undefined) {
    return;
  }
  if (typeof value === "string") {
    return value;
  }
  if (["boolean", "number", "bigint"].includes(typeof value)) {
    logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
    return String(value);
  }
  throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
}, strictParseFloat32 = (value) => {
  if (typeof value == "string") {
    return expectFloat32(parseNumber(value));
  }
  return expectFloat32(value);
}, NUMBER_REGEX, parseNumber = (value) => {
  const matches = value.match(NUMBER_REGEX);
  if (matches === null || matches[0].length !== value.length) {
    throw new TypeError(`Expected real number, got implicit NaN`);
  }
  return parseFloat(value);
}, strictParseShort = (value) => {
  if (typeof value === "string") {
    return expectShort(parseNumber(value));
  }
  return expectShort(value);
}, strictParseByte = (value) => {
  if (typeof value === "string") {
    return expectByte(parseNumber(value));
  }
  return expectByte(value);
}, stackTraceWarning = (message) => {
  return String(new TypeError(message).stack || message).split(`
`).slice(0, 5).filter((s2) => !s2.includes("stackTraceWarning")).join(`
`);
}, logger;
var init_parse_utils = __esm(() => {
  MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
  NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
  logger = {
    warn: console.warn
  };
});

// ../../node_modules/@smithy/smithy-client/dist-es/date-utils.js
var MONTHS, RFC3339, parseRfc3339DateTime = (value) => {
  if (value === null || value === undefined) {
    return;
  }
  if (typeof value !== "string") {
    throw new TypeError("RFC-3339 date-times must be expressed as strings");
  }
  const match = RFC3339.exec(value);
  if (!match) {
    throw new TypeError("Invalid RFC-3339 date-time value");
  }
  const [_3, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
  const year = strictParseShort(stripLeadingZeroes(yearStr));
  const month = parseDateValue(monthStr, "month", 1, 12);
  const day = parseDateValue(dayStr, "day", 1, 31);
  return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
}, RFC3339_WITH_OFFSET, parseRfc3339DateTimeWithOffset = (value) => {
  if (value === null || value === undefined) {
    return;
  }
  if (typeof value !== "string") {
    throw new TypeError("RFC-3339 date-times must be expressed as strings");
  }
  const match = RFC3339_WITH_OFFSET.exec(value);
  if (!match) {
    throw new TypeError("Invalid RFC-3339 date-time value");
  }
  const [_3, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
  const year = strictParseShort(stripLeadingZeroes(yearStr));
  const month = parseDateValue(monthStr, "month", 1, 12);
  const day = parseDateValue(dayStr, "day", 1, 31);
  const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
  if (offsetStr.toUpperCase() != "Z") {
    date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
  }
  return date;
}, IMF_FIXDATE, RFC_850_DATE, ASC_TIME, buildDate = (year, month, day, time) => {
  const adjustedMonth = month - 1;
  validateDayOfMonth(year, adjustedMonth, day);
  return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
}, FIFTY_YEARS_IN_MILLIS, DAYS_IN_MONTH, validateDayOfMonth = (year, month, day) => {
  let maxDays = DAYS_IN_MONTH[month];
  if (month === 1 && isLeapYear(year)) {
    maxDays = 29;
  }
  if (day > maxDays) {
    throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
  }
}, isLeapYear = (year) => {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}, parseDateValue = (value, type, lower, upper) => {
  const dateVal = strictParseByte(stripLeadingZeroes(value));
  if (dateVal < lower || dateVal > upper) {
    throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
  }
  return dateVal;
}, parseMilliseconds = (value) => {
  if (value === null || value === undefined) {
    return 0;
  }
  return strictParseFloat32("0." + value) * 1000;
}, parseOffsetToMilliseconds = (value) => {
  const directionStr = value[0];
  let direction = 1;
  if (directionStr == "+") {
    direction = 1;
  } else if (directionStr == "-") {
    direction = -1;
  } else {
    throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
  }
  const hour = Number(value.substring(1, 3));
  const minute = Number(value.substring(4, 6));
  return direction * (hour * 60 + minute) * 60 * 1000;
}, stripLeadingZeroes = (value) => {
  let idx = 0;
  while (idx < value.length - 1 && value.charAt(idx) === "0") {
    idx++;
  }
  if (idx === 0) {
    return value;
  }
  return value.slice(idx);
};
var init_date_utils = __esm(() => {
  init_parse_utils();
  MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
  RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
  IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
  RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
  ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
  FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1000;
  DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
});

// ../../node_modules/@smithy/smithy-client/dist-es/exceptions.js
var ServiceException, decorateServiceException = (exception, additions = {}) => {
  Object.entries(additions).filter(([, v2]) => v2 !== undefined).forEach(([k2, v2]) => {
    if (exception[k2] == undefined || exception[k2] === "") {
      exception[k2] = v2;
    }
  });
  const message = exception.message || exception.Message || "UnknownError";
  exception.message = message;
  delete exception.Message;
  return exception;
};
var init_exceptions = __esm(() => {
  ServiceException = class ServiceException extends Error {
    constructor(options) {
      super(options.message);
      Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype);
      this.name = options.name;
      this.$fault = options.$fault;
      this.$metadata = options.$metadata;
    }
    static isInstance(value) {
      if (!value)
        return false;
      const candidate = value;
      return ServiceException.prototype.isPrototypeOf(candidate) || Boolean(candidate.$fault) && Boolean(candidate.$metadata) && (candidate.$fault === "client" || candidate.$fault === "server");
    }
    static [Symbol.hasInstance](instance) {
      if (!instance)
        return false;
      const candidate = instance;
      if (this === ServiceException) {
        return ServiceException.isInstance(instance);
      }
      if (ServiceException.isInstance(instance)) {
        if (candidate.name && this.name) {
          return this.prototype.isPrototypeOf(instance) || candidate.name === this.name;
        }
        return this.prototype.isPrototypeOf(instance);
      }
      return false;
    }
  };
});

// ../../node_modules/@smithy/smithy-client/dist-es/default-error-handler.js
var throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
  const $metadata = deserializeMetadata(output);
  const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
  const response = new exceptionCtor({
    name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
    $fault: "client",
    $metadata
  });
  throw decorateServiceException(response, parsedBody);
}, withBaseException = (ExceptionCtor) => {
  return ({ output, parsedBody, errorCode }) => {
    throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
  };
}, deserializeMetadata = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var init_default_error_handler = __esm(() => {
  init_exceptions();
});

// ../../node_modules/@smithy/smithy-client/dist-es/defaults-mode.js
var loadConfigsForDefaultMode = (mode) => {
  switch (mode) {
    case "standard":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "in-region":
      return {
        retryMode: "standard",
        connectionTimeout: 1100
      };
    case "cross-region":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "mobile":
      return {
        retryMode: "standard",
        connectionTimeout: 30000
      };
    default:
      return {};
  }
};

// ../../node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js
var warningEmitted = false, emitWarningIfUnsupportedVersion = (version) => {
  if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 16) {
    warningEmitted = true;
  }
};

// ../../node_modules/@smithy/smithy-client/dist-es/extended-encode-uri-component.js
var import_protocols2;
var init_extended_encode_uri_component = __esm(() => {
  import_protocols2 = __toESM(require_protocols(), 1);
});

// ../../node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js
var import_types7, getChecksumConfiguration = (runtimeConfig) => {
  const checksumAlgorithms = [];
  for (const id in import_types7.AlgorithmId) {
    const algorithmId = import_types7.AlgorithmId[id];
    if (runtimeConfig[algorithmId] === undefined) {
      continue;
    }
    checksumAlgorithms.push({
      algorithmId: () => algorithmId,
      checksumConstructor: () => runtimeConfig[algorithmId]
    });
  }
  return {
    _checksumAlgorithms: checksumAlgorithms,
    addChecksumAlgorithm(algo) {
      this._checksumAlgorithms.push(algo);
    },
    checksumAlgorithms() {
      return this._checksumAlgorithms;
    }
  };
}, resolveChecksumRuntimeConfig = (clientConfig) => {
  const runtimeConfig = {};
  clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
    runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
  });
  return runtimeConfig;
};
var init_checksum = __esm(() => {
  import_types7 = __toESM(require_dist_cjs(), 1);
});

// ../../node_modules/@smithy/smithy-client/dist-es/extensions/retry.js
var getRetryConfiguration = (runtimeConfig) => {
  let _retryStrategy = runtimeConfig.retryStrategy;
  return {
    setRetryStrategy(retryStrategy) {
      _retryStrategy = retryStrategy;
    },
    retryStrategy() {
      return _retryStrategy;
    }
  };
}, resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
  const runtimeConfig = {};
  runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
  return runtimeConfig;
};

// ../../node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js
var getDefaultExtensionConfiguration = (runtimeConfig) => {
  return {
    ...getChecksumConfiguration(runtimeConfig),
    ...getRetryConfiguration(runtimeConfig)
  };
}, resolveDefaultRuntimeConfig = (config2) => {
  return {
    ...resolveChecksumRuntimeConfig(config2),
    ...resolveRetryRuntimeConfig(config2)
  };
};
var init_defaultExtensionConfiguration = __esm(() => {
  init_checksum();
});

// ../../node_modules/@smithy/smithy-client/dist-es/extensions/index.js
var init_extensions2 = __esm(() => {
  init_defaultExtensionConfiguration();
});
// ../../node_modules/@smithy/smithy-client/dist-es/is-serializable-header-value.js
var isSerializableHeaderValue = (value) => {
  return value != null;
};

// ../../node_modules/@smithy/smithy-client/dist-es/lazy-json.js
var LazyJsonString = function LazyJsonString2(val2) {
  const str = Object.assign(new String(val2), {
    deserializeJSON() {
      return JSON.parse(String(val2));
    },
    toString() {
      return String(val2);
    },
    toJSON() {
      return String(val2);
    }
  });
  return str;
};
var init_lazy_json = __esm(() => {
  LazyJsonString.from = (object) => {
    if (object && typeof object === "object" && (object instanceof LazyJsonString || ("deserializeJSON" in object))) {
      return object;
    } else if (typeof object === "string" || Object.getPrototypeOf(object) === String.prototype) {
      return LazyJsonString(String(object));
    }
    return LazyJsonString(JSON.stringify(object));
  };
  LazyJsonString.fromObject = LazyJsonString.from;
});

// ../../node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js
class NoOpLogger {
  trace() {
  }
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
}

// ../../node_modules/@smithy/smithy-client/dist-es/object-mapping.js
function map(arg0, arg1, arg2) {
  let target;
  let filter;
  let instructions;
  if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
    target = {};
    instructions = arg0;
  } else {
    target = arg0;
    if (typeof arg1 === "function") {
      filter = arg1;
      instructions = arg2;
      return mapWithFilter(target, filter, instructions);
    } else {
      instructions = arg1;
    }
  }
  for (const key of Object.keys(instructions)) {
    if (!Array.isArray(instructions[key])) {
      target[key] = instructions[key];
      continue;
    }
    applyInstruction(target, null, instructions, key);
  }
  return target;
}
var take = (source, instructions) => {
  const out = {};
  for (const key in instructions) {
    applyInstruction(out, source, instructions, key);
  }
  return out;
}, mapWithFilter = (target, filter, instructions) => {
  return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
    if (Array.isArray(value)) {
      _instructions[key] = value;
    } else {
      if (typeof value === "function") {
        _instructions[key] = [filter, value()];
      } else {
        _instructions[key] = [filter, value];
      }
    }
    return _instructions;
  }, {}));
}, applyInstruction = (target, source, instructions, targetKey) => {
  if (source !== null) {
    let instruction = instructions[targetKey];
    if (typeof instruction === "function") {
      instruction = [, instruction];
    }
    const [filter2 = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
    if (typeof filter2 === "function" && filter2(source[sourceKey]) || typeof filter2 !== "function" && !!filter2) {
      target[targetKey] = valueFn(source[sourceKey]);
    }
    return;
  }
  let [filter, value] = instructions[targetKey];
  if (typeof value === "function") {
    let _value;
    const defaultFilterPassed = filter === undefined && (_value = value()) != null;
    const customFilterPassed = typeof filter === "function" && !!filter(undefined) || typeof filter !== "function" && !!filter;
    if (defaultFilterPassed) {
      target[targetKey] = _value;
    } else if (customFilterPassed) {
      target[targetKey] = value();
    }
  } else {
    const defaultFilterPassed = filter === undefined && value != null;
    const customFilterPassed = typeof filter === "function" && !!filter(value) || typeof filter !== "function" && !!filter;
    if (defaultFilterPassed || customFilterPassed) {
      target[targetKey] = value;
    }
  }
}, nonNullish = (_3) => _3 != null, pass = (_3) => _3;
// ../../node_modules/@smithy/smithy-client/dist-es/resolve-path.js
var import_protocols3;
var init_resolve_path = __esm(() => {
  import_protocols3 = __toESM(require_protocols(), 1);
});
// ../../node_modules/@smithy/smithy-client/dist-es/serde-json.js
var _json = (obj) => {
  if (obj == null) {
    return {};
  }
  if (Array.isArray(obj)) {
    return obj.filter((_3) => _3 != null).map(_json);
  }
  if (typeof obj === "object") {
    const target = {};
    for (const key of Object.keys(obj)) {
      if (obj[key] == null) {
        continue;
      }
      target[key] = _json(obj[key]);
    }
    return target;
  }
  return obj;
};
// ../../node_modules/@smithy/smithy-client/dist-es/index.js
var init_dist_es14 = __esm(() => {
  init_client();
  init_collect_stream_body();
  init_command();
  init_date_utils();
  init_default_error_handler();
  init_exceptions();
  init_extended_encode_uri_component();
  init_extensions2();
  init_lazy_json();
  init_parse_utils();
  init_resolve_path();
});

// ../../node_modules/@smithy/util-config-provider/dist-es/booleanSelector.js
var booleanSelector = (obj, key, type) => {
  if (!(key in obj))
    return;
  if (obj[key] === "true")
    return true;
  if (obj[key] === "false")
    return false;
  throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
};
// ../../node_modules/@smithy/util-config-provider/dist-es/types.js
var SelectorType2;
var init_types2 = __esm(() => {
  (function(SelectorType3) {
    SelectorType3["ENV"] = "env";
    SelectorType3["CONFIG"] = "shared config entry";
  })(SelectorType2 || (SelectorType2 = {}));
});

// ../../node_modules/@smithy/util-config-provider/dist-es/index.js
var init_dist_es15 = __esm(() => {
  init_types2();
});

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/configurations.js
function isValidUserAgentAppId(appId) {
  if (appId === undefined) {
    return true;
  }
  return typeof appId === "string" && appId.length <= 50;
}
function resolveUserAgentConfig(input) {
  const normalizedAppIdProvider = import_core5.normalizeProvider(input.userAgentAppId ?? DEFAULT_UA_APP_ID);
  return {
    ...input,
    customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent,
    userAgentAppId: async () => {
      const appId = await normalizedAppIdProvider();
      if (!isValidUserAgentAppId(appId)) {
        const logger2 = input.logger?.constructor?.name === "NoOpLogger" || !input.logger ? console : input.logger;
        if (typeof appId !== "string") {
          logger2?.warn("userAgentAppId must be a string or undefined.");
        } else if (appId.length > 50) {
          logger2?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.");
        }
      }
      return appId;
    }
  };
}
var import_core5, DEFAULT_UA_APP_ID = undefined;
var init_configurations = __esm(() => {
  import_core5 = __toESM(require_dist_cjs15(), 1);
});

// ../../node_modules/@smithy/util-endpoints/dist-es/cache/EndpointCache.js
class EndpointCache {
  constructor({ size, params }) {
    this.data = new Map;
    this.parameters = [];
    this.capacity = size ?? 50;
    if (params) {
      this.parameters = params;
    }
  }
  get(endpointParams, resolver) {
    const key = this.hash(endpointParams);
    if (key === false) {
      return resolver();
    }
    if (!this.data.has(key)) {
      if (this.data.size > this.capacity + 10) {
        const keys = this.data.keys();
        let i2 = 0;
        while (true) {
          const { value, done } = keys.next();
          this.data.delete(value);
          if (done || ++i2 > 10) {
            break;
          }
        }
      }
      this.data.set(key, resolver());
    }
    return this.data.get(key);
  }
  size() {
    return this.data.size;
  }
  hash(endpointParams) {
    let buffer = "";
    const { parameters } = this;
    if (parameters.length === 0) {
      return false;
    }
    for (const param of parameters) {
      const val2 = String(endpointParams[param] ?? "");
      if (val2.includes("|;")) {
        return false;
      }
      buffer += val2 + "|;";
    }
    return buffer;
  }
}

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/isIpAddress.js
var IP_V4_REGEX, isIpAddress2 = (value) => IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]");
var init_isIpAddress = __esm(() => {
  IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
});

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/isValidHostLabel.js
var VALID_HOST_LABEL_REGEX, isValidHostLabel = (value, allowSubDomains = false) => {
  if (!allowSubDomains) {
    return VALID_HOST_LABEL_REGEX.test(value);
  }
  const labels = value.split(".");
  for (const label of labels) {
    if (!isValidHostLabel(label)) {
      return false;
    }
  }
  return true;
};
var init_isValidHostLabel = __esm(() => {
  VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
});

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/customEndpointFunctions.js
var customEndpointFunctions;
var init_customEndpointFunctions = __esm(() => {
  customEndpointFunctions = {};
});

// ../../node_modules/@smithy/util-endpoints/dist-es/debug/debugId.js
var debugId = "endpoints";

// ../../node_modules/@smithy/util-endpoints/dist-es/debug/toDebugString.js
function toDebugString(input) {
  if (typeof input !== "object" || input == null) {
    return input;
  }
  if ("ref" in input) {
    return `$${toDebugString(input.ref)}`;
  }
  if ("fn" in input) {
    return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
  }
  return JSON.stringify(input, null, 2);
}

// ../../node_modules/@smithy/util-endpoints/dist-es/debug/index.js
var init_debug = () => {
};

// ../../node_modules/@smithy/util-endpoints/dist-es/types/EndpointError.js
var EndpointError2;
var init_EndpointError = __esm(() => {
  EndpointError2 = class EndpointError2 extends Error {
    constructor(message) {
      super(message);
      this.name = "EndpointError";
    }
  };
});

// ../../node_modules/@smithy/util-endpoints/dist-es/types/EndpointFunctions.js
var init_EndpointFunctions = () => {
};

// ../../node_modules/@smithy/util-endpoints/dist-es/types/EndpointRuleObject.js
var init_EndpointRuleObject = () => {
};

// ../../node_modules/@smithy/util-endpoints/dist-es/types/ErrorRuleObject.js
var init_ErrorRuleObject = () => {
};

// ../../node_modules/@smithy/util-endpoints/dist-es/types/RuleSetObject.js
var init_RuleSetObject = () => {
};

// ../../node_modules/@smithy/util-endpoints/dist-es/types/TreeRuleObject.js
var init_TreeRuleObject = () => {
};

// ../../node_modules/@smithy/util-endpoints/dist-es/types/shared.js
var init_shared = () => {
};

// ../../node_modules/@smithy/util-endpoints/dist-es/types/index.js
var init_types3 = __esm(() => {
  init_EndpointError();
  init_EndpointFunctions();
  init_EndpointRuleObject();
  init_ErrorRuleObject();
  init_RuleSetObject();
  init_TreeRuleObject();
  init_shared();
});

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/booleanEquals.js
var booleanEquals = (value1, value2) => value1 === value2;

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/getAttrPathList.js
var getAttrPathList = (path) => {
  const parts = path.split(".");
  const pathList = [];
  for (const part of parts) {
    const squareBracketIndex = part.indexOf("[");
    if (squareBracketIndex !== -1) {
      if (part.indexOf("]") !== part.length - 1) {
        throw new EndpointError2(`Path: '${path}' does not end with ']'`);
      }
      const arrayIndex = part.slice(squareBracketIndex + 1, -1);
      if (Number.isNaN(parseInt(arrayIndex))) {
        throw new EndpointError2(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
      }
      if (squareBracketIndex !== 0) {
        pathList.push(part.slice(0, squareBracketIndex));
      }
      pathList.push(arrayIndex);
    } else {
      pathList.push(part);
    }
  }
  return pathList;
};
var init_getAttrPathList = __esm(() => {
  init_types3();
});

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/getAttr.js
var getAttr = (value, path) => getAttrPathList(path).reduce((acc, index) => {
  if (typeof acc !== "object") {
    throw new EndpointError2(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
  } else if (Array.isArray(acc)) {
    return acc[parseInt(index)];
  }
  return acc[index];
}, value);
var init_getAttr = __esm(() => {
  init_types3();
  init_getAttrPathList();
});

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/isSet.js
var isSet = (value) => value != null;

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/not.js
var not = (value) => !value;

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/parseURL.js
var import_types11, DEFAULT_PORTS, parseURL = (value) => {
  const whatwgURL = (() => {
    try {
      if (value instanceof URL) {
        return value;
      }
      if (typeof value === "object" && "hostname" in value) {
        const { hostname: hostname2, port, protocol: protocol2 = "", path = "", query = {} } = value;
        const url = new URL(`${protocol2}//${hostname2}${port ? `:${port}` : ""}${path}`);
        url.search = Object.entries(query).map(([k2, v2]) => `${k2}=${v2}`).join("&");
        return url;
      }
      return new URL(value);
    } catch (error) {
      return null;
    }
  })();
  if (!whatwgURL) {
    console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
    return null;
  }
  const urlString = whatwgURL.href;
  const { host, hostname, pathname, protocol, search } = whatwgURL;
  if (search) {
    return null;
  }
  const scheme = protocol.slice(0, -1);
  if (!Object.values(import_types11.EndpointURLScheme).includes(scheme)) {
    return null;
  }
  const isIp = isIpAddress2(hostname);
  const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
  const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
  return {
    scheme,
    authority,
    path: pathname,
    normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
    isIp
  };
};
var init_parseURL = __esm(() => {
  import_types11 = __toESM(require_dist_cjs(), 1);
  init_isIpAddress();
  DEFAULT_PORTS = {
    [import_types11.EndpointURLScheme.HTTP]: 80,
    [import_types11.EndpointURLScheme.HTTPS]: 443
  };
});

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/stringEquals.js
var stringEquals = (value1, value2) => value1 === value2;

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/substring.js
var substring = (input, start, stop, reverse) => {
  if (start >= stop || input.length < stop) {
    return null;
  }
  if (!reverse) {
    return input.substring(start, stop);
  }
  return input.substring(input.length - stop, input.length - start);
};

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/uriEncode.js
var uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c3) => `%${c3.charCodeAt(0).toString(16).toUpperCase()}`);

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/index.js
var init_lib = __esm(() => {
  init_getAttr();
  init_isValidHostLabel();
  init_parseURL();
});

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/endpointFunctions.js
var endpointFunctions;
var init_endpointFunctions = __esm(() => {
  init_lib();
  endpointFunctions = {
    booleanEquals,
    getAttr,
    isSet,
    isValidHostLabel,
    not,
    parseURL,
    stringEquals,
    substring,
    uriEncode
  };
});

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTemplate.js
var evaluateTemplate = (template, options) => {
  const evaluatedTemplateArr = [];
  const templateContext = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  let currentIndex = 0;
  while (currentIndex < template.length) {
    const openingBraceIndex = template.indexOf("{", currentIndex);
    if (openingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(currentIndex));
      break;
    }
    evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
    const closingBraceIndex = template.indexOf("}", openingBraceIndex);
    if (closingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex));
      break;
    }
    if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
      currentIndex = closingBraceIndex + 2;
    }
    const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
    if (parameterName.includes("#")) {
      const [refName, attrName] = parameterName.split("#");
      evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
    } else {
      evaluatedTemplateArr.push(templateContext[parameterName]);
    }
    currentIndex = closingBraceIndex + 1;
  }
  return evaluatedTemplateArr.join("");
};
var init_evaluateTemplate = __esm(() => {
  init_lib();
});

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/getReferenceValue.js
var getReferenceValue = ({ ref }, options) => {
  const referenceRecord = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  return referenceRecord[ref];
};

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateExpression.js
var evaluateExpression = (obj, keyName, options) => {
  if (typeof obj === "string") {
    return evaluateTemplate(obj, options);
  } else if (obj["fn"]) {
    return callFunction(obj, options);
  } else if (obj["ref"]) {
    return getReferenceValue(obj, options);
  }
  throw new EndpointError2(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
};
var init_evaluateExpression = __esm(() => {
  init_types3();
  init_callFunction();
  init_evaluateTemplate();
});

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/callFunction.js
var callFunction = ({ fn, argv: argv2 }, options) => {
  const evaluatedArgs = argv2.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression(arg, "arg", options));
  const fnSegments = fn.split(".");
  if (fnSegments[0] in customEndpointFunctions && fnSegments[1] != null) {
    return customEndpointFunctions[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
  }
  return endpointFunctions[fn](...evaluatedArgs);
};
var init_callFunction = __esm(() => {
  init_customEndpointFunctions();
  init_endpointFunctions();
  init_evaluateExpression();
});

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateCondition.js
var evaluateCondition = ({ assign, ...fnArgs }, options) => {
  if (assign && assign in options.referenceRecord) {
    throw new EndpointError2(`'${assign}' is already defined in Reference Record.`);
  }
  const value = callFunction(fnArgs, options);
  options.logger?.debug?.(`${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
  return {
    result: value === "" ? true : !!value,
    ...assign != null && { toAssign: { name: assign, value } }
  };
};
var init_evaluateCondition = __esm(() => {
  init_debug();
  init_types3();
  init_callFunction();
});

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateConditions.js
var evaluateConditions = (conditions = [], options) => {
  const conditionsReferenceRecord = {};
  for (const condition of conditions) {
    const { result, toAssign } = evaluateCondition(condition, {
      ...options,
      referenceRecord: {
        ...options.referenceRecord,
        ...conditionsReferenceRecord
      }
    });
    if (!result) {
      return { result };
    }
    if (toAssign) {
      conditionsReferenceRecord[toAssign.name] = toAssign.value;
      options.logger?.debug?.(`${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
    }
  }
  return { result: true, referenceRecord: conditionsReferenceRecord };
};
var init_evaluateConditions = __esm(() => {
  init_debug();
  init_evaluateCondition();
});

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointHeaders.js
var getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
  ...acc,
  [headerKey]: headerVal.map((headerValEntry) => {
    const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
    if (typeof processedExpr !== "string") {
      throw new EndpointError2(`Header '${headerKey}' value '${processedExpr}' is not a string`);
    }
    return processedExpr;
  })
}), {});
var init_getEndpointHeaders = __esm(() => {
  init_types3();
  init_evaluateExpression();
});

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperty.js
var getEndpointProperty = (property, options) => {
  if (Array.isArray(property)) {
    return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
  }
  switch (typeof property) {
    case "string":
      return evaluateTemplate(property, options);
    case "object":
      if (property === null) {
        throw new EndpointError2(`Unexpected endpoint property: ${property}`);
      }
      return getEndpointProperties(property, options);
    case "boolean":
      return property;
    default:
      throw new EndpointError2(`Unexpected endpoint property type: ${typeof property}`);
  }
};
var init_getEndpointProperty = __esm(() => {
  init_types3();
  init_evaluateTemplate();
  init_getEndpointProperties();
});

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperties.js
var getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
  ...acc,
  [propertyKey]: getEndpointProperty(propertyVal, options)
}), {});
var init_getEndpointProperties = __esm(() => {
  init_getEndpointProperty();
});

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointUrl.js
var getEndpointUrl = (endpointUrl, options) => {
  const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
  if (typeof expression === "string") {
    try {
      return new URL(expression);
    } catch (error) {
      console.error(`Failed to construct URL with ${expression}`, error);
      throw error;
    }
  }
  throw new EndpointError2(`Endpoint URL must be a string, got ${typeof expression}`);
};
var init_getEndpointUrl = __esm(() => {
  init_types3();
  init_evaluateExpression();
});

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateEndpointRule.js
var evaluateEndpointRule = (endpointRule, options) => {
  const { conditions, endpoint } = endpointRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  const endpointRuleOptions = {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  };
  const { url, properties, headers } = endpoint;
  options.logger?.debug?.(`${debugId} Resolving endpoint from template: ${toDebugString(endpoint)}`);
  return {
    ...headers != null && {
      headers: getEndpointHeaders(headers, endpointRuleOptions)
    },
    ...properties != null && {
      properties: getEndpointProperties(properties, endpointRuleOptions)
    },
    url: getEndpointUrl(url, endpointRuleOptions)
  };
};
var init_evaluateEndpointRule = __esm(() => {
  init_debug();
  init_evaluateConditions();
  init_getEndpointHeaders();
  init_getEndpointProperties();
  init_getEndpointUrl();
});

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateErrorRule.js
var evaluateErrorRule = (errorRule, options) => {
  const { conditions, error } = errorRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  throw new EndpointError2(evaluateExpression(error, "Error", {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  }));
};
var init_evaluateErrorRule = __esm(() => {
  init_types3();
  init_evaluateConditions();
  init_evaluateExpression();
});

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTreeRule.js
var evaluateTreeRule = (treeRule, options) => {
  const { conditions, rules } = treeRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  return evaluateRules(rules, {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  });
};
var init_evaluateTreeRule = __esm(() => {
  init_evaluateConditions();
  init_evaluateRules();
});

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateRules.js
var evaluateRules = (rules, options) => {
  for (const rule of rules) {
    if (rule.type === "endpoint") {
      const endpointOrUndefined = evaluateEndpointRule(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else if (rule.type === "error") {
      evaluateErrorRule(rule, options);
    } else if (rule.type === "tree") {
      const endpointOrUndefined = evaluateTreeRule(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else {
      throw new EndpointError2(`Unknown endpoint rule: ${rule}`);
    }
  }
  throw new EndpointError2(`Rules evaluation failed`);
};
var init_evaluateRules = __esm(() => {
  init_types3();
  init_evaluateEndpointRule();
  init_evaluateErrorRule();
  init_evaluateTreeRule();
});

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/index.js
var init_utils = __esm(() => {
  init_customEndpointFunctions();
  init_evaluateRules();
});

// ../../node_modules/@smithy/util-endpoints/dist-es/resolveEndpoint.js
var resolveEndpoint2 = (ruleSetObject, options) => {
  const { endpointParams, logger: logger2 } = options;
  const { parameters, rules } = ruleSetObject;
  options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
  const paramsWithDefault = Object.entries(parameters).filter(([, v2]) => v2.default != null).map(([k2, v2]) => [k2, v2.default]);
  if (paramsWithDefault.length > 0) {
    for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
      endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
    }
  }
  const requiredParams = Object.entries(parameters).filter(([, v2]) => v2.required).map(([k2]) => k2);
  for (const requiredParam of requiredParams) {
    if (endpointParams[requiredParam] == null) {
      throw new EndpointError2(`Missing required parameter: '${requiredParam}'`);
    }
  }
  const endpoint = evaluateRules(rules, { endpointParams, logger: logger2, referenceRecord: {} });
  options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);
  return endpoint;
};
var init_resolveEndpoint = __esm(() => {
  init_debug();
  init_types3();
  init_utils();
});

// ../../node_modules/@smithy/util-endpoints/dist-es/index.js
var init_dist_es16 = __esm(() => {
  init_isIpAddress();
  init_isValidHostLabel();
  init_customEndpointFunctions();
  init_resolveEndpoint();
  init_types3();
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/isIpAddress.js
var init_isIpAddress2 = __esm(() => {
  init_dist_es16();
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js
var isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
  if (allowSubDomains) {
    for (const label of value.split(".")) {
      if (!isVirtualHostableS3Bucket(label)) {
        return false;
      }
    }
    return true;
  }
  if (!isValidHostLabel(value)) {
    return false;
  }
  if (value.length < 3 || value.length > 63) {
    return false;
  }
  if (value !== value.toLowerCase()) {
    return false;
  }
  if (isIpAddress2(value)) {
    return false;
  }
  return true;
};
var init_isVirtualHostableS3Bucket = __esm(() => {
  init_dist_es16();
  init_isIpAddress2();
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/parseArn.js
var ARN_DELIMITER = ":", RESOURCE_DELIMITER = "/", parseArn = (value) => {
  const segments = value.split(ARN_DELIMITER);
  if (segments.length < 6)
    return null;
  const [arn, partition, service, region, accountId, ...resourcePath] = segments;
  if (arn !== "arn" || partition === "" || service === "" || resourcePath.join(ARN_DELIMITER) === "")
    return null;
  const resourceId = resourcePath.map((resource) => resource.split(RESOURCE_DELIMITER)).flat();
  return {
    partition,
    service,
    region,
    accountId,
    resourceId
  };
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partitions.json
var partitions_default;
var init_partitions = __esm(() => {
  partitions_default = {
    partitions: [{
      id: "aws",
      outputs: {
        dnsSuffix: "amazonaws.com",
        dualStackDnsSuffix: "api.aws",
        implicitGlobalRegion: "us-east-1",
        name: "aws",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
      regions: {
        "af-south-1": {
          description: "Africa (Cape Town)"
        },
        "ap-east-1": {
          description: "Asia Pacific (Hong Kong)"
        },
        "ap-northeast-1": {
          description: "Asia Pacific (Tokyo)"
        },
        "ap-northeast-2": {
          description: "Asia Pacific (Seoul)"
        },
        "ap-northeast-3": {
          description: "Asia Pacific (Osaka)"
        },
        "ap-south-1": {
          description: "Asia Pacific (Mumbai)"
        },
        "ap-south-2": {
          description: "Asia Pacific (Hyderabad)"
        },
        "ap-southeast-1": {
          description: "Asia Pacific (Singapore)"
        },
        "ap-southeast-2": {
          description: "Asia Pacific (Sydney)"
        },
        "ap-southeast-3": {
          description: "Asia Pacific (Jakarta)"
        },
        "ap-southeast-4": {
          description: "Asia Pacific (Melbourne)"
        },
        "ap-southeast-5": {
          description: "Asia Pacific (Malaysia)"
        },
        "ap-southeast-7": {
          description: "Asia Pacific (Thailand)"
        },
        "aws-global": {
          description: "AWS Standard global region"
        },
        "ca-central-1": {
          description: "Canada (Central)"
        },
        "ca-west-1": {
          description: "Canada West (Calgary)"
        },
        "eu-central-1": {
          description: "Europe (Frankfurt)"
        },
        "eu-central-2": {
          description: "Europe (Zurich)"
        },
        "eu-north-1": {
          description: "Europe (Stockholm)"
        },
        "eu-south-1": {
          description: "Europe (Milan)"
        },
        "eu-south-2": {
          description: "Europe (Spain)"
        },
        "eu-west-1": {
          description: "Europe (Ireland)"
        },
        "eu-west-2": {
          description: "Europe (London)"
        },
        "eu-west-3": {
          description: "Europe (Paris)"
        },
        "il-central-1": {
          description: "Israel (Tel Aviv)"
        },
        "me-central-1": {
          description: "Middle East (UAE)"
        },
        "me-south-1": {
          description: "Middle East (Bahrain)"
        },
        "mx-central-1": {
          description: "Mexico (Central)"
        },
        "sa-east-1": {
          description: "South America (Sao Paulo)"
        },
        "us-east-1": {
          description: "US East (N. Virginia)"
        },
        "us-east-2": {
          description: "US East (Ohio)"
        },
        "us-west-1": {
          description: "US West (N. California)"
        },
        "us-west-2": {
          description: "US West (Oregon)"
        }
      }
    }, {
      id: "aws-cn",
      outputs: {
        dnsSuffix: "amazonaws.com.cn",
        dualStackDnsSuffix: "api.amazonwebservices.com.cn",
        implicitGlobalRegion: "cn-northwest-1",
        name: "aws-cn",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^cn\\-\\w+\\-\\d+$",
      regions: {
        "aws-cn-global": {
          description: "AWS China global region"
        },
        "cn-north-1": {
          description: "China (Beijing)"
        },
        "cn-northwest-1": {
          description: "China (Ningxia)"
        }
      }
    }, {
      id: "aws-us-gov",
      outputs: {
        dnsSuffix: "amazonaws.com",
        dualStackDnsSuffix: "api.aws",
        implicitGlobalRegion: "us-gov-west-1",
        name: "aws-us-gov",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
      regions: {
        "aws-us-gov-global": {
          description: "AWS GovCloud (US) global region"
        },
        "us-gov-east-1": {
          description: "AWS GovCloud (US-East)"
        },
        "us-gov-west-1": {
          description: "AWS GovCloud (US-West)"
        }
      }
    }, {
      id: "aws-iso",
      outputs: {
        dnsSuffix: "c2s.ic.gov",
        dualStackDnsSuffix: "c2s.ic.gov",
        implicitGlobalRegion: "us-iso-east-1",
        name: "aws-iso",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
      regions: {
        "aws-iso-global": {
          description: "AWS ISO (US) global region"
        },
        "us-iso-east-1": {
          description: "US ISO East"
        },
        "us-iso-west-1": {
          description: "US ISO WEST"
        }
      }
    }, {
      id: "aws-iso-b",
      outputs: {
        dnsSuffix: "sc2s.sgov.gov",
        dualStackDnsSuffix: "sc2s.sgov.gov",
        implicitGlobalRegion: "us-isob-east-1",
        name: "aws-iso-b",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
      regions: {
        "aws-iso-b-global": {
          description: "AWS ISOB (US) global region"
        },
        "us-isob-east-1": {
          description: "US ISOB East (Ohio)"
        }
      }
    }, {
      id: "aws-iso-e",
      outputs: {
        dnsSuffix: "cloud.adc-e.uk",
        dualStackDnsSuffix: "cloud.adc-e.uk",
        implicitGlobalRegion: "eu-isoe-west-1",
        name: "aws-iso-e",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
      regions: {
        "eu-isoe-west-1": {
          description: "EU ISOE West"
        }
      }
    }, {
      id: "aws-iso-f",
      outputs: {
        dnsSuffix: "csp.hci.ic.gov",
        dualStackDnsSuffix: "csp.hci.ic.gov",
        implicitGlobalRegion: "us-isof-south-1",
        name: "aws-iso-f",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
      regions: {}
    }],
    version: "1.1"
  };
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js
var selectedPartitionsInfo, selectedUserAgentPrefix = "", partition = (value) => {
  const { partitions } = selectedPartitionsInfo;
  for (const partition2 of partitions) {
    const { regions, outputs } = partition2;
    for (const [region, regionData] of Object.entries(regions)) {
      if (region === value) {
        return {
          ...outputs,
          ...regionData
        };
      }
    }
  }
  for (const partition2 of partitions) {
    const { regionRegex, outputs } = partition2;
    if (new RegExp(regionRegex).test(value)) {
      return {
        ...outputs
      };
    }
  }
  const DEFAULT_PARTITION = partitions.find((partition2) => partition2.id === "aws");
  if (!DEFAULT_PARTITION) {
    throw new Error("Provided region was not found in the partition array or regex," + " and default partition with id 'aws' doesn't exist.");
  }
  return {
    ...DEFAULT_PARTITION.outputs
  };
}, getUserAgentPrefix = () => selectedUserAgentPrefix;
var init_partition = __esm(() => {
  init_partitions();
  selectedPartitionsInfo = partitions_default;
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/aws.js
var awsEndpointFunctions;
var init_aws = __esm(() => {
  init_dist_es16();
  init_isVirtualHostableS3Bucket();
  init_partition();
  awsEndpointFunctions = {
    isVirtualHostableS3Bucket,
    parseArn,
    partition
  };
  customEndpointFunctions.aws = awsEndpointFunctions;
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/resolveEndpoint.js
var init_resolveEndpoint2 = __esm(() => {
  init_dist_es16();
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointError.js
var init_EndpointError2 = __esm(() => {
  init_dist_es16();
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointRuleObject.js
var init_EndpointRuleObject2 = () => {
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/ErrorRuleObject.js
var init_ErrorRuleObject2 = () => {
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/RuleSetObject.js
var init_RuleSetObject2 = () => {
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/TreeRuleObject.js
var init_TreeRuleObject2 = () => {
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/shared.js
var init_shared2 = () => {
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/index.js
var init_types4 = __esm(() => {
  init_EndpointError2();
  init_EndpointRuleObject2();
  init_ErrorRuleObject2();
  init_RuleSetObject2();
  init_TreeRuleObject2();
  init_shared2();
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/index.js
var init_dist_es17 = __esm(() => {
  init_aws();
  init_partition();
  init_isIpAddress2();
  init_resolveEndpoint2();
  init_types4();
});

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/check-features.js
async function checkFeatures(context, config2, args) {
  const request = args.request;
  if (request?.headers?.["smithy-protocol"] === "rpc-v2-cbor") {
    import_core6.setFeature(context, "PROTOCOL_RPC_V2_CBOR", "M");
  }
  if (typeof config2.retryStrategy === "function") {
    const retryStrategy = await config2.retryStrategy();
    if (typeof retryStrategy.acquireInitialRetryToken === "function") {
      if (retryStrategy.constructor?.name?.includes("Adaptive")) {
        import_core6.setFeature(context, "RETRY_MODE_ADAPTIVE", "F");
      } else {
        import_core6.setFeature(context, "RETRY_MODE_STANDARD", "E");
      }
    } else {
      import_core6.setFeature(context, "RETRY_MODE_LEGACY", "D");
    }
  }
  if (typeof config2.accountIdEndpointMode === "function") {
    const endpointV2 = context.endpointV2;
    if (String(endpointV2?.url?.hostname).match(ACCOUNT_ID_ENDPOINT_REGEX)) {
      import_core6.setFeature(context, "ACCOUNT_ID_ENDPOINT", "O");
    }
    switch (await config2.accountIdEndpointMode?.()) {
      case "disabled":
        import_core6.setFeature(context, "ACCOUNT_ID_MODE_DISABLED", "Q");
        break;
      case "preferred":
        import_core6.setFeature(context, "ACCOUNT_ID_MODE_PREFERRED", "P");
        break;
      case "required":
        import_core6.setFeature(context, "ACCOUNT_ID_MODE_REQUIRED", "R");
        break;
    }
  }
  const identity = context.__smithy_context?.selectedHttpAuthScheme?.identity;
  if (identity?.$source) {
    const credentials = identity;
    if (credentials.accountId) {
      import_core6.setFeature(context, "RESOLVED_ACCOUNT_ID", "T");
    }
    for (const [key, value] of Object.entries(credentials.$source ?? {})) {
      import_core6.setFeature(context, key, value);
    }
  }
}
var import_core6, ACCOUNT_ID_ENDPOINT_REGEX;
var init_check_features = __esm(() => {
  import_core6 = __toESM(require_dist_cjs20(), 1);
  ACCOUNT_ID_ENDPOINT_REGEX = /\d{12}\.ddb/;
});

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/constants.js
var USER_AGENT = "user-agent", X_AMZ_USER_AGENT = "x-amz-user-agent", SPACE = " ", UA_NAME_SEPARATOR = "/", UA_NAME_ESCAPE_REGEX, UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR = "-";
var init_constants2 = __esm(() => {
  UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
  UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
});

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/encode-features.js
function encodeFeatures(features) {
  let buffer = "";
  for (const key in features) {
    const val2 = features[key];
    if (buffer.length + val2.length + 1 <= BYTE_LIMIT) {
      if (buffer.length) {
        buffer += "," + val2;
      } else {
        buffer += val2;
      }
      continue;
    }
    break;
  }
  return buffer;
}
var BYTE_LIMIT = 1024;

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js
var userAgentMiddleware = (options) => (next, context) => async (args) => {
  const { request } = args;
  if (!HttpRequest.isInstance(request)) {
    return next(args);
  }
  const { headers } = request;
  const userAgent = context?.userAgent?.map(escapeUserAgent) || [];
  const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
  await checkFeatures(context, options, args);
  const awsContext = context;
  defaultUserAgent.push(`m/${encodeFeatures(Object.assign({}, context.__smithy_context?.features, awsContext.__aws_sdk_context?.features))}`);
  const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
  const appId = await options.userAgentAppId();
  if (appId) {
    defaultUserAgent.push(escapeUserAgent([`app/${appId}`]));
  }
  const prefix = getUserAgentPrefix();
  const sdkUserAgentValue = (prefix ? [prefix] : []).concat([...defaultUserAgent, ...userAgent, ...customUserAgent]).join(SPACE);
  const normalUAValue = [
    ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
    ...customUserAgent
  ].join(SPACE);
  if (options.runtime !== "browser") {
    if (normalUAValue) {
      headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT] ? `${headers[USER_AGENT]} ${normalUAValue}` : normalUAValue;
    }
    headers[USER_AGENT] = sdkUserAgentValue;
  } else {
    headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
  }
  return next({
    ...args,
    request
  });
}, escapeUserAgent = (userAgentPair) => {
  const name = userAgentPair[0].split(UA_NAME_SEPARATOR).map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR);
  const version = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
  const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR);
  const prefix = name.substring(0, prefixSeparatorIndex);
  let uaName = name.substring(prefixSeparatorIndex + 1);
  if (prefix === "api") {
    uaName = uaName.toLowerCase();
  }
  return [prefix, uaName, version].filter((item) => item && item.length > 0).reduce((acc, item, index) => {
    switch (index) {
      case 0:
        return item;
      case 1:
        return `${acc}/${item}`;
      default:
        return `${acc}#${item}`;
    }
  }, "");
}, getUserAgentMiddlewareOptions, getUserAgentPlugin = (config2) => ({
  applyToStack: (clientStack) => {
    clientStack.add(userAgentMiddleware(config2), getUserAgentMiddlewareOptions);
  }
});
var init_user_agent_middleware = __esm(() => {
  init_dist_es17();
  init_dist_es();
  init_check_features();
  init_constants2();
  getUserAgentMiddlewareOptions = {
    name: "getUserAgentMiddleware",
    step: "build",
    priority: "low",
    tags: ["SET_USER_AGENT", "USER_AGENT"],
    override: true
  };
});

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js
var init_dist_es18 = __esm(() => {
  init_configurations();
  init_user_agent_middleware();
});

// ../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseDualstackEndpointConfigOptions.js
var ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT", CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint", NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS;
var init_NodeUseDualstackEndpointConfigOptions = __esm(() => {
  init_dist_es15();
  NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env2) => booleanSelector(env2, ENV_USE_DUALSTACK_ENDPOINT, SelectorType2.ENV),
    configFileSelector: (profile) => booleanSelector(profile, CONFIG_USE_DUALSTACK_ENDPOINT, SelectorType2.CONFIG),
    default: false
  };
});

// ../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseFipsEndpointConfigOptions.js
var ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT", CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint", NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS;
var init_NodeUseFipsEndpointConfigOptions = __esm(() => {
  init_dist_es15();
  NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env2) => booleanSelector(env2, ENV_USE_FIPS_ENDPOINT, SelectorType2.ENV),
    configFileSelector: (profile) => booleanSelector(profile, CONFIG_USE_FIPS_ENDPOINT, SelectorType2.CONFIG),
    default: false
  };
});

// ../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveCustomEndpointsConfig.js
var init_resolveCustomEndpointsConfig = __esm(() => {
  init_dist_es9();
});
// ../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveEndpointsConfig.js
var init_resolveEndpointsConfig = __esm(() => {
  init_dist_es9();
});

// ../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/index.js
var init_endpointsConfig = __esm(() => {
  init_NodeUseDualstackEndpointConfigOptions();
  init_NodeUseFipsEndpointConfigOptions();
  init_resolveCustomEndpointsConfig();
  init_resolveEndpointsConfig();
});

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/config.js
var REGION_ENV_NAME = "AWS_REGION", REGION_INI_NAME = "region", NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS;
var init_config = __esm(() => {
  NODE_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env2) => env2[REGION_ENV_NAME],
    configFileSelector: (profile) => profile[REGION_INI_NAME],
    default: () => {
      throw new Error("Region is missing");
    }
  };
  NODE_REGION_CONFIG_FILE_OPTIONS = {
    preferredFile: "credentials"
  };
});

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/isFipsRegion.js
var isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/getRealRegion.js
var getRealRegion = (region) => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;
var init_getRealRegion = () => {
};

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/resolveRegionConfig.js
var resolveRegionConfig = (input) => {
  const { region, useFipsEndpoint } = input;
  if (!region) {
    throw new Error("Region is missing");
  }
  return {
    ...input,
    region: async () => {
      if (typeof region === "string") {
        return getRealRegion(region);
      }
      const providedRegion = await region();
      return getRealRegion(providedRegion);
    },
    useFipsEndpoint: async () => {
      const providedRegion = typeof region === "string" ? region : await region();
      if (isFipsRegion(providedRegion)) {
        return true;
      }
      return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
    }
  };
};
var init_resolveRegionConfig = __esm(() => {
  init_getRealRegion();
});

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/index.js
var init_regionConfig = __esm(() => {
  init_config();
  init_resolveRegionConfig();
});

// ../../node_modules/@smithy/config-resolver/dist-es/regionInfo/PartitionHash.js
var init_PartitionHash = () => {
};

// ../../node_modules/@smithy/config-resolver/dist-es/regionInfo/RegionHash.js
var init_RegionHash = () => {
};
// ../../node_modules/@smithy/config-resolver/dist-es/regionInfo/getRegionInfo.js
var init_getRegionInfo = () => {
};

// ../../node_modules/@smithy/config-resolver/dist-es/regionInfo/index.js
var init_regionInfo = __esm(() => {
  init_PartitionHash();
  init_RegionHash();
  init_getRegionInfo();
});

// ../../node_modules/@smithy/config-resolver/dist-es/index.js
var init_dist_es19 = __esm(() => {
  init_endpointsConfig();
  init_regionConfig();
  init_regionInfo();
});

// ../../node_modules/@smithy/middleware-content-length/dist-es/index.js
function contentLengthMiddleware(bodyLengthChecker) {
  return (next) => async (args) => {
    const request = args.request;
    if (HttpRequest.isInstance(request)) {
      const { body, headers } = request;
      if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER) === -1) {
        try {
          const length = bodyLengthChecker(body);
          request.headers = {
            ...request.headers,
            [CONTENT_LENGTH_HEADER]: String(length)
          };
        } catch (error) {
        }
      }
    }
    return next({
      ...args,
      request
    });
  };
}
var CONTENT_LENGTH_HEADER = "content-length", contentLengthMiddlewareOptions, getContentLengthPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
  }
});
var init_dist_es20 = __esm(() => {
  init_dist_es();
  contentLengthMiddlewareOptions = {
    step: "build",
    tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
    name: "contentLengthMiddleware",
    override: true
  };
});

// ../../node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/s3.js
var resolveParamsForS3 = async (endpointParams) => {
  const bucket = endpointParams?.Bucket || "";
  if (typeof endpointParams.Bucket === "string") {
    endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
  }
  if (isArnBucketName(bucket)) {
    if (endpointParams.ForcePathStyle === true) {
      throw new Error("Path-style addressing cannot be used with ARN buckets");
    }
  } else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
    endpointParams.ForcePathStyle = true;
  }
  if (endpointParams.DisableMultiRegionAccessPoints) {
    endpointParams.disableMultiRegionAccessPoints = true;
    endpointParams.DisableMRAP = true;
  }
  return endpointParams;
}, DOMAIN_PATTERN, IP_ADDRESS_PATTERN, DOTS_PATTERN, isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName), isArnBucketName = (bucketName) => {
  const [arn, partition3, service, , , bucket] = bucketName.split(":");
  const isArn = arn === "arn" && bucketName.split(":").length >= 6;
  const isValidArn = Boolean(isArn && partition3 && service && bucket);
  if (isArn && !isValidArn) {
    throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
  }
  return isValidArn;
};
var init_s3 = __esm(() => {
  DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
  IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
  DOTS_PATTERN = /\.\./;
});

// ../../node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/index.js
var init_service_customizations = __esm(() => {
  init_s3();
});

// ../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js
var createConfigValueProvider = (configKey, canonicalEndpointParamKey, config3) => {
  const configProvider = async () => {
    const configValue = config3[configKey] ?? config3[canonicalEndpointParamKey];
    if (typeof configValue === "function") {
      return configValue();
    }
    return configValue;
  };
  if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
    return async () => {
      const credentials = typeof config3.credentials === "function" ? await config3.credentials() : config3.credentials;
      const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
      return configValue;
    };
  }
  if (configKey === "accountId" || canonicalEndpointParamKey === "AccountId") {
    return async () => {
      const credentials = typeof config3.credentials === "function" ? await config3.credentials() : config3.credentials;
      const configValue = credentials?.accountId ?? credentials?.AccountId;
      return configValue;
    };
  }
  if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
    return async () => {
      const endpoint = await configProvider();
      if (endpoint && typeof endpoint === "object") {
        if ("url" in endpoint) {
          return endpoint.url.href;
        }
        if ("hostname" in endpoint) {
          const { protocol, hostname, port, path } = endpoint;
          return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
        }
      }
      return endpoint;
    };
  }
  return configProvider;
};

// ../../node_modules/@smithy/node-config-provider/dist-es/getSelectorName.js
function getSelectorName(functionString) {
  try {
    const constants5 = new Set(Array.from(functionString.match(/([A-Z_]){3,}/g) ?? []));
    constants5.delete("CONFIG");
    constants5.delete("CONFIG_PREFIX_SEPARATOR");
    constants5.delete("ENV");
    return [...constants5].join(", ");
  } catch (e2) {
    return functionString;
  }
}

// ../../node_modules/@smithy/node-config-provider/dist-es/fromEnv.js
var import_property_provider, fromEnv = (envVarSelector, logger2) => async () => {
  try {
    const config3 = envVarSelector(process.env);
    if (config3 === undefined) {
      throw new Error;
    }
    return config3;
  } catch (e2) {
    throw new import_property_provider.CredentialsProviderError(e2.message || `Not found in ENV: ${getSelectorName(envVarSelector.toString())}`, { logger: logger2 });
  }
};
var init_fromEnv = __esm(() => {
  import_property_provider = __toESM(require_dist_cjs16(), 1);
});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js
import { homedir } from "os";
import { sep as sep3 } from "path";
var homeDirCache, getHomeDirCacheKey = () => {
  if (process && process.geteuid) {
    return `${process.geteuid()}`;
  }
  return "DEFAULT";
}, getHomeDir2 = () => {
  const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${sep3}` } = process.env;
  if (HOME)
    return HOME;
  if (USERPROFILE)
    return USERPROFILE;
  if (HOMEPATH)
    return `${HOMEDRIVE}${HOMEPATH}`;
  const homeDirCacheKey = getHomeDirCacheKey();
  if (!homeDirCache[homeDirCacheKey])
    homeDirCache[homeDirCacheKey] = homedir();
  return homeDirCache[homeDirCacheKey];
};
var init_getHomeDir = __esm(() => {
  homeDirCache = {};
});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileName.js
var ENV_PROFILE = "AWS_PROFILE", DEFAULT_PROFILE = "default", getProfileName = (init2) => init2.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js
import { createHash } from "crypto";
import { join as join3 } from "path";
var getSSOTokenFilepath2 = (id) => {
  const hasher = createHash("sha1");
  const cacheName = hasher.update(id).digest("hex");
  return join3(getHomeDir2(), ".aws", "sso", "cache", `${cacheName}.json`);
};
var init_getSSOTokenFilepath = __esm(() => {
  init_getHomeDir();
});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js
import { promises as fsPromises } from "fs";
var readFile, getSSOTokenFromFile2 = async (id) => {
  const ssoTokenFilepath = getSSOTokenFilepath2(id);
  const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
  return JSON.parse(ssoTokenText);
};
var init_getSSOTokenFromFile = __esm(() => {
  init_getSSOTokenFilepath();
  ({ readFile } = fsPromises);
});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigData.js
var import_types20, getConfigData = (data) => Object.entries(data).filter(([key]) => {
  const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
  if (indexOfSeparator === -1) {
    return false;
  }
  return Object.values(import_types20.IniSectionType).includes(key.substring(0, indexOfSeparator));
}).reduce((acc, [key, value]) => {
  const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
  const updatedKey = key.substring(0, indexOfSeparator) === import_types20.IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
  acc[updatedKey] = value;
  return acc;
}, {
  ...data.default && { default: data.default }
});
var init_getConfigData = __esm(() => {
  import_types20 = __toESM(require_dist_cjs(), 1);
  init_loadSharedConfigFiles();
});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js
import { join as join4 } from "path";
var ENV_CONFIG_PATH = "AWS_CONFIG_FILE", getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || join4(getHomeDir2(), ".aws", "config");
var init_getConfigFilepath = __esm(() => {
  init_getHomeDir();
});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js
import { join as join5 } from "path";
var ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE", getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || join5(getHomeDir2(), ".aws", "credentials");
var init_getCredentialsFilepath = __esm(() => {
  init_getHomeDir();
});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js
var import_types21, prefixKeyRegex, profileNameBlockList, parseIni = (iniData) => {
  const map2 = {};
  let currentSection;
  let currentSubSection;
  for (const iniLine of iniData.split(/\r?\n/)) {
    const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
    const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
    if (isSection) {
      currentSection = undefined;
      currentSubSection = undefined;
      const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
      const matches = prefixKeyRegex.exec(sectionName);
      if (matches) {
        const [, prefix, , name] = matches;
        if (Object.values(import_types21.IniSectionType).includes(prefix)) {
          currentSection = [prefix, name].join(CONFIG_PREFIX_SEPARATOR);
        }
      } else {
        currentSection = sectionName;
      }
      if (profileNameBlockList.includes(sectionName)) {
        throw new Error(`Found invalid profile name "${sectionName}"`);
      }
    } else if (currentSection) {
      const indexOfEqualsSign = trimmedLine.indexOf("=");
      if (![0, -1].includes(indexOfEqualsSign)) {
        const [name, value] = [
          trimmedLine.substring(0, indexOfEqualsSign).trim(),
          trimmedLine.substring(indexOfEqualsSign + 1).trim()
        ];
        if (value === "") {
          currentSubSection = name;
        } else {
          if (currentSubSection && iniLine.trimStart() === iniLine) {
            currentSubSection = undefined;
          }
          map2[currentSection] = map2[currentSection] || {};
          const key = currentSubSection ? [currentSubSection, name].join(CONFIG_PREFIX_SEPARATOR) : name;
          map2[currentSection][key] = value;
        }
      }
    }
  }
  return map2;
};
var init_parseIni = __esm(() => {
  import_types21 = __toESM(require_dist_cjs(), 1);
  init_loadSharedConfigFiles();
  prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
  profileNameBlockList = ["__proto__", "profile __proto__"];
});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js
import { promises as fsPromises2 } from "fs";
var readFile2, filePromisesHash, slurpFile = (path, options) => {
  if (!filePromisesHash[path] || options?.ignoreCache) {
    filePromisesHash[path] = readFile2(path, "utf8");
  }
  return filePromisesHash[path];
};
var init_slurpFile = __esm(() => {
  ({ readFile: readFile2 } = fsPromises2);
  filePromisesHash = {};
});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js
import { join as join6 } from "path";
var swallowError = () => ({}), CONFIG_PREFIX_SEPARATOR = ".", loadSharedConfigFiles = async (init2 = {}) => {
  const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath() } = init2;
  const homeDir = getHomeDir2();
  const relativeHomeDirPrefix = "~/";
  let resolvedFilepath = filepath;
  if (filepath.startsWith(relativeHomeDirPrefix)) {
    resolvedFilepath = join6(homeDir, filepath.slice(2));
  }
  let resolvedConfigFilepath = configFilepath;
  if (configFilepath.startsWith(relativeHomeDirPrefix)) {
    resolvedConfigFilepath = join6(homeDir, configFilepath.slice(2));
  }
  const parsedFiles = await Promise.all([
    slurpFile(resolvedConfigFilepath, {
      ignoreCache: init2.ignoreCache
    }).then(parseIni).then(getConfigData).catch(swallowError),
    slurpFile(resolvedFilepath, {
      ignoreCache: init2.ignoreCache
    }).then(parseIni).catch(swallowError)
  ]);
  return {
    configFile: parsedFiles[0],
    credentialsFile: parsedFiles[1]
  };
};
var init_loadSharedConfigFiles = __esm(() => {
  init_getConfigData();
  init_getConfigFilepath();
  init_getCredentialsFilepath();
  init_getHomeDir();
  init_parseIni();
  init_slurpFile();
});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js
var import_types22, getSsoSessionData = (data) => Object.entries(data).filter(([key]) => key.startsWith(import_types22.IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR)).reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});
var init_getSsoSessionData = __esm(() => {
  import_types22 = __toESM(require_dist_cjs(), 1);
  init_loadSharedConfigFiles();
});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js
var swallowError2 = () => ({}), loadSsoSessionData = async (init2 = {}) => slurpFile(init2.configFilepath ?? getConfigFilepath()).then(parseIni).then(getSsoSessionData).catch(swallowError2);
var init_loadSsoSessionData = __esm(() => {
  init_getConfigFilepath();
  init_getSsoSessionData();
  init_parseIni();
  init_slurpFile();
});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/mergeConfigFiles.js
var mergeConfigFiles = (...files) => {
  const merged = {};
  for (const file of files) {
    for (const [key, values] of Object.entries(file)) {
      if (merged[key] !== undefined) {
        Object.assign(merged[key], values);
      } else {
        merged[key] = values;
      }
    }
  }
  return merged;
};

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js
var parseKnownFiles = async (init2) => {
  const parsedFiles = await loadSharedConfigFiles(init2);
  return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
};
var init_parseKnownFiles = __esm(() => {
  init_loadSharedConfigFiles();
});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/types.js
var init_types5 = () => {
};

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/index.js
var init_dist_es21 = __esm(() => {
  init_getHomeDir();
  init_getSSOTokenFilepath();
  init_getSSOTokenFromFile();
  init_loadSharedConfigFiles();
  init_loadSsoSessionData();
  init_parseKnownFiles();
  init_types5();
});

// ../../node_modules/@smithy/node-config-provider/dist-es/fromSharedConfigFiles.js
var import_property_provider2, fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init2 } = {}) => async () => {
  const profile = getProfileName(init2);
  const { configFile, credentialsFile } = await loadSharedConfigFiles(init2);
  const profileFromCredentials = credentialsFile[profile] || {};
  const profileFromConfig = configFile[profile] || {};
  const mergedProfile = preferredFile === "config" ? { ...profileFromCredentials, ...profileFromConfig } : { ...profileFromConfig, ...profileFromCredentials };
  try {
    const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
    const configValue = configSelector(mergedProfile, cfgFile);
    if (configValue === undefined) {
      throw new Error;
    }
    return configValue;
  } catch (e2) {
    throw new import_property_provider2.CredentialsProviderError(e2.message || `Not found in config files w/ profile [${profile}]: ${getSelectorName(configSelector.toString())}`, { logger: init2.logger });
  }
};
var init_fromSharedConfigFiles = __esm(() => {
  import_property_provider2 = __toESM(require_dist_cjs16(), 1);
  init_dist_es21();
});

// ../../node_modules/@smithy/node-config-provider/dist-es/fromStatic.js
var import_property_provider3, isFunction = (func) => typeof func === "function", fromStatic = (defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : import_property_provider3.fromStatic(defaultValue);
var init_fromStatic = __esm(() => {
  import_property_provider3 = __toESM(require_dist_cjs16(), 1);
});

// ../../node_modules/@smithy/node-config-provider/dist-es/configLoader.js
var import_property_provider4, loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => import_property_provider4.memoize(import_property_provider4.chain(fromEnv(environmentVariableSelector), fromSharedConfigFiles(configFileSelector, configuration), fromStatic(defaultValue)));
var init_configLoader = __esm(() => {
  import_property_provider4 = __toESM(require_dist_cjs16(), 1);
  init_fromEnv();
  init_fromSharedConfigFiles();
  init_fromStatic();
});

// ../../node_modules/@smithy/node-config-provider/dist-es/index.js
var init_dist_es22 = __esm(() => {
  init_configLoader();
});

// ../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointUrlConfig.js
var ENV_ENDPOINT_URL = "AWS_ENDPOINT_URL", CONFIG_ENDPOINT_URL = "endpoint_url", getEndpointUrlConfig = (serviceId) => ({
  environmentVariableSelector: (env2) => {
    const serviceSuffixParts = serviceId.split(" ").map((w2) => w2.toUpperCase());
    const serviceEndpointUrl = env2[[ENV_ENDPOINT_URL, ...serviceSuffixParts].join("_")];
    if (serviceEndpointUrl)
      return serviceEndpointUrl;
    const endpointUrl = env2[ENV_ENDPOINT_URL];
    if (endpointUrl)
      return endpointUrl;
    return;
  },
  configFileSelector: (profile, config3) => {
    if (config3 && profile.services) {
      const servicesSection = config3[["services", profile.services].join(CONFIG_PREFIX_SEPARATOR)];
      if (servicesSection) {
        const servicePrefixParts = serviceId.split(" ").map((w2) => w2.toLowerCase());
        const endpointUrl2 = servicesSection[[servicePrefixParts.join("_"), CONFIG_ENDPOINT_URL].join(CONFIG_PREFIX_SEPARATOR)];
        if (endpointUrl2)
          return endpointUrl2;
      }
    }
    const endpointUrl = profile[CONFIG_ENDPOINT_URL];
    if (endpointUrl)
      return endpointUrl;
    return;
  },
  default: undefined
});
var init_getEndpointUrlConfig = __esm(() => {
  init_dist_es21();
});

// ../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromConfig.js
var getEndpointFromConfig = async (serviceId) => loadConfig(getEndpointUrlConfig(serviceId ?? ""))();
var init_getEndpointFromConfig = __esm(() => {
  init_dist_es22();
  init_getEndpointUrlConfig();
});

// ../../node_modules/@smithy/querystring-parser/dist-es/index.js
function parseQueryString(querystring) {
  const query = {};
  querystring = querystring.replace(/^\?/, "");
  if (querystring) {
    for (const pair of querystring.split("&")) {
      let [key, value = null] = pair.split("=");
      key = decodeURIComponent(key);
      if (value) {
        value = decodeURIComponent(value);
      }
      if (!(key in query)) {
        query[key] = value;
      } else if (Array.isArray(query[key])) {
        query[key].push(value);
      } else {
        query[key] = [query[key], value];
      }
    }
  }
  return query;
}

// ../../node_modules/@smithy/url-parser/dist-es/index.js
var parseUrl = (url) => {
  if (typeof url === "string") {
    return parseUrl(new URL(url));
  }
  const { hostname, pathname, port, protocol, search } = url;
  let query;
  if (search) {
    query = parseQueryString(search);
  }
  return {
    hostname,
    port: port ? parseInt(port) : undefined,
    protocol,
    path: pathname,
    query
  };
};
var init_dist_es23 = () => {
};

// ../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js
var toEndpointV1 = (endpoint) => {
  if (typeof endpoint === "object") {
    if ("url" in endpoint) {
      return parseUrl(endpoint.url);
    }
    return endpoint;
  }
  return parseUrl(endpoint);
};
var init_toEndpointV1 = __esm(() => {
  init_dist_es23();
});

// ../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js
var getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
  if (!clientConfig.endpoint) {
    let endpointFromConfig;
    if (clientConfig.serviceConfiguredEndpoint) {
      endpointFromConfig = await clientConfig.serviceConfiguredEndpoint();
    } else {
      endpointFromConfig = await getEndpointFromConfig(clientConfig.serviceId);
    }
    if (endpointFromConfig) {
      clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
    }
  }
  const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
  if (typeof clientConfig.endpointProvider !== "function") {
    throw new Error("config.endpointProvider is not set.");
  }
  const endpoint = clientConfig.endpointProvider(endpointParams, context);
  return endpoint;
}, resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
  const endpointParams = {};
  const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
  for (const [name, instruction] of Object.entries(instructions)) {
    switch (instruction.type) {
      case "staticContextParams":
        endpointParams[name] = instruction.value;
        break;
      case "contextParams":
        endpointParams[name] = commandInput[instruction.name];
        break;
      case "clientContextParams":
      case "builtInParams":
        endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
        break;
      case "operationContextParams":
        endpointParams[name] = instruction.get(commandInput);
        break;
      default:
        throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
    }
  }
  if (Object.keys(instructions).length === 0) {
    Object.assign(endpointParams, clientConfig);
  }
  if (String(clientConfig.serviceId).toLowerCase() === "s3") {
    await resolveParamsForS3(endpointParams);
  }
  return endpointParams;
};
var init_getEndpointFromInstructions = __esm(() => {
  init_service_customizations();
  init_getEndpointFromConfig();
  init_toEndpointV1();
});

// ../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/index.js
var init_adaptors = __esm(() => {
  init_getEndpointFromInstructions();
  init_toEndpointV1();
});

// ../../node_modules/@smithy/middleware-endpoint/dist-es/endpointMiddleware.js
var import_core7, endpointMiddleware = ({ config: config3, instructions }) => {
  return (next, context) => async (args) => {
    if (config3.endpoint) {
      import_core7.setFeature(context, "ENDPOINT_OVERRIDE", "N");
    }
    const endpoint = await getEndpointFromInstructions(args.input, {
      getEndpointParameterInstructions() {
        return instructions;
      }
    }, { ...config3 }, context);
    context.endpointV2 = endpoint;
    context.authSchemes = endpoint.properties?.authSchemes;
    const authScheme = context.authSchemes?.[0];
    if (authScheme) {
      context["signing_region"] = authScheme.signingRegion;
      context["signing_service"] = authScheme.signingName;
      const smithyContext = getSmithyContext(context);
      const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
      if (httpAuthOption) {
        httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
          signing_region: authScheme.signingRegion,
          signingRegion: authScheme.signingRegion,
          signing_service: authScheme.signingName,
          signingName: authScheme.signingName,
          signingRegionSet: authScheme.signingRegionSet
        }, authScheme.properties);
      }
    }
    return next({
      ...args
    });
  };
};
var init_endpointMiddleware = __esm(() => {
  import_core7 = __toESM(require_dist_cjs15(), 1);
  init_dist_es9();
  init_getEndpointFromInstructions();
});

// ../../node_modules/@smithy/middleware-serde/dist-es/deserializerMiddleware.js
var deserializerMiddleware = (options, deserializer) => (next) => async (args) => {
  const { response } = await next(args);
  try {
    const parsed = await deserializer(response, options);
    return {
      response,
      output: parsed
    };
  } catch (error) {
    Object.defineProperty(error, "$response", {
      value: response
    });
    if (!("$metadata" in error)) {
      const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
      error.message += `
  ` + hint;
      if (typeof error.$responseBodyText !== "undefined") {
        if (error.$response) {
          error.$response.body = error.$responseBodyText;
        }
      }
    }
    throw error;
  }
};

// ../../node_modules/@smithy/middleware-serde/dist-es/serializerMiddleware.js
var serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
  const endpoint = context.endpointV2?.url && options.urlParser ? async () => options.urlParser(context.endpointV2.url) : options.endpoint;
  if (!endpoint) {
    throw new Error("No valid endpoint provider available.");
  }
  const request = await serializer(args.input, { ...options, endpoint });
  return next({
    ...args,
    request
  });
};

// ../../node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js
function getSerdePlugin(config3, serializer, deserializer) {
  return {
    applyToStack: (commandStack) => {
      commandStack.add(deserializerMiddleware(config3, deserializer), deserializerMiddlewareOption);
      commandStack.add(serializerMiddleware(config3, serializer), serializerMiddlewareOption);
    }
  };
}
var deserializerMiddlewareOption, serializerMiddlewareOption;
var init_serdePlugin = __esm(() => {
  deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true
  };
  serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true
  };
});

// ../../node_modules/@smithy/middleware-serde/dist-es/index.js
var init_dist_es24 = __esm(() => {
  init_serdePlugin();
});

// ../../node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js
var endpointMiddlewareOptions, getEndpointPlugin = (config3, instructions) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(endpointMiddleware({
      config: config3,
      instructions
    }), endpointMiddlewareOptions);
  }
});
var init_getEndpointPlugin = __esm(() => {
  init_dist_es24();
  init_endpointMiddleware();
  endpointMiddlewareOptions = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: serializerMiddlewareOption.name
  };
});

// ../../node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointConfig.js
var resolveEndpointConfig = (input) => {
  const tls = input.tls ?? true;
  const { endpoint } = input;
  const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await normalizeProvider(endpoint)()) : undefined;
  const isCustomEndpoint = !!endpoint;
  const resolvedConfig = {
    ...input,
    endpoint: customEndpointProvider,
    tls,
    isCustomEndpoint,
    useDualstackEndpoint: normalizeProvider(input.useDualstackEndpoint ?? false),
    useFipsEndpoint: normalizeProvider(input.useFipsEndpoint ?? false)
  };
  let configuredEndpointPromise = undefined;
  resolvedConfig.serviceConfiguredEndpoint = async () => {
    if (input.serviceId && !configuredEndpointPromise) {
      configuredEndpointPromise = getEndpointFromConfig(input.serviceId);
    }
    return configuredEndpointPromise;
  };
  return resolvedConfig;
};
var init_resolveEndpointConfig = __esm(() => {
  init_dist_es9();
  init_getEndpointFromConfig();
  init_toEndpointV1();
});

// ../../node_modules/@smithy/middleware-endpoint/dist-es/types.js
var init_types6 = () => {
};

// ../../node_modules/@smithy/middleware-endpoint/dist-es/index.js
var init_dist_es25 = __esm(() => {
  init_adaptors();
  init_endpointMiddleware();
  init_getEndpointPlugin();
  init_resolveEndpointConfig();
  init_types6();
});

// ../../node_modules/@smithy/util-retry/dist-es/config.js
var RETRY_MODES, DEFAULT_MAX_ATTEMPTS = 3, DEFAULT_RETRY_MODE;
var init_config2 = __esm(() => {
  (function(RETRY_MODES2) {
    RETRY_MODES2["STANDARD"] = "standard";
    RETRY_MODES2["ADAPTIVE"] = "adaptive";
  })(RETRY_MODES || (RETRY_MODES = {}));
  DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;
});

// ../../node_modules/@smithy/service-error-classification/dist-es/constants.js
var THROTTLING_ERROR_CODES, TRANSIENT_ERROR_CODES, TRANSIENT_ERROR_STATUS_CODES, NODEJS_TIMEOUT_ERROR_CODES2;
var init_constants3 = __esm(() => {
  THROTTLING_ERROR_CODES = [
    "BandwidthLimitExceeded",
    "EC2ThrottledException",
    "LimitExceededException",
    "PriorRequestNotComplete",
    "ProvisionedThroughputExceededException",
    "RequestLimitExceeded",
    "RequestThrottled",
    "RequestThrottledException",
    "SlowDown",
    "ThrottledException",
    "Throttling",
    "ThrottlingException",
    "TooManyRequestsException",
    "TransactionInProgressException"
  ];
  TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
  TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
  NODEJS_TIMEOUT_ERROR_CODES2 = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];
});

// ../../node_modules/@smithy/service-error-classification/dist-es/index.js
var isClockSkewCorrectedError = (error) => error.$metadata?.clockSkewCorrected, isThrottlingError = (error) => error.$metadata?.httpStatusCode === 429 || THROTTLING_ERROR_CODES.includes(error.name) || error.$retryable?.throttling == true, isTransientError = (error, depth = 0) => isClockSkewCorrectedError(error) || TRANSIENT_ERROR_CODES.includes(error.name) || NODEJS_TIMEOUT_ERROR_CODES2.includes(error?.code || "") || TRANSIENT_ERROR_STATUS_CODES.includes(error.$metadata?.httpStatusCode || 0) || error.cause !== undefined && depth <= 10 && isTransientError(error.cause, depth + 1), isServerError = (error) => {
  if (error.$metadata?.httpStatusCode !== undefined) {
    const statusCode = error.$metadata.httpStatusCode;
    if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {
      return true;
    }
    return false;
  }
  return false;
};
var init_dist_es26 = __esm(() => {
  init_constants3();
});

// ../../node_modules/@smithy/util-retry/dist-es/DefaultRateLimiter.js
class DefaultRateLimiter {
  constructor(options) {
    this.currentCapacity = 0;
    this.enabled = false;
    this.lastMaxRate = 0;
    this.measuredTxRate = 0;
    this.requestCount = 0;
    this.lastTimestamp = 0;
    this.timeWindow = 0;
    this.beta = options?.beta ?? 0.7;
    this.minCapacity = options?.minCapacity ?? 1;
    this.minFillRate = options?.minFillRate ?? 0.5;
    this.scaleConstant = options?.scaleConstant ?? 0.4;
    this.smooth = options?.smooth ?? 0.8;
    const currentTimeInSeconds = this.getCurrentTimeInSeconds();
    this.lastThrottleTime = currentTimeInSeconds;
    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
    this.fillRate = this.minFillRate;
    this.maxCapacity = this.minCapacity;
  }
  getCurrentTimeInSeconds() {
    return Date.now() / 1000;
  }
  async getSendToken() {
    return this.acquireTokenBucket(1);
  }
  async acquireTokenBucket(amount) {
    if (!this.enabled) {
      return;
    }
    this.refillTokenBucket();
    if (amount > this.currentCapacity) {
      const delay = (amount - this.currentCapacity) / this.fillRate * 1000;
      await new Promise((resolve2) => DefaultRateLimiter.setTimeoutFn(resolve2, delay));
    }
    this.currentCapacity = this.currentCapacity - amount;
  }
  refillTokenBucket() {
    const timestamp = this.getCurrentTimeInSeconds();
    if (!this.lastTimestamp) {
      this.lastTimestamp = timestamp;
      return;
    }
    const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
    this.lastTimestamp = timestamp;
  }
  updateClientSendingRate(response) {
    let calculatedRate;
    this.updateMeasuredRate();
    if (isThrottlingError(response)) {
      const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
      this.lastMaxRate = rateToUse;
      this.calculateTimeWindow();
      this.lastThrottleTime = this.getCurrentTimeInSeconds();
      calculatedRate = this.cubicThrottle(rateToUse);
      this.enableTokenBucket();
    } else {
      this.calculateTimeWindow();
      calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
    }
    const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
    this.updateTokenBucketRate(newRate);
  }
  calculateTimeWindow() {
    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
  }
  cubicThrottle(rateToUse) {
    return this.getPrecise(rateToUse * this.beta);
  }
  cubicSuccess(timestamp) {
    return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
  }
  enableTokenBucket() {
    this.enabled = true;
  }
  updateTokenBucketRate(newRate) {
    this.refillTokenBucket();
    this.fillRate = Math.max(newRate, this.minFillRate);
    this.maxCapacity = Math.max(newRate, this.minCapacity);
    this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
  }
  updateMeasuredRate() {
    const t2 = this.getCurrentTimeInSeconds();
    const timeBucket = Math.floor(t2 * 2) / 2;
    this.requestCount++;
    if (timeBucket > this.lastTxRateBucket) {
      const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
      this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
      this.requestCount = 0;
      this.lastTxRateBucket = timeBucket;
    }
  }
  getPrecise(num) {
    return parseFloat(num.toFixed(8));
  }
}
var init_DefaultRateLimiter = __esm(() => {
  init_dist_es26();
  DefaultRateLimiter.setTimeoutFn = setTimeout;
});

// ../../node_modules/@smithy/util-retry/dist-es/constants.js
var DEFAULT_RETRY_DELAY_BASE = 100, MAXIMUM_RETRY_DELAY, THROTTLING_RETRY_DELAY_BASE = 500, INITIAL_RETRY_TOKENS = 500, RETRY_COST = 5, TIMEOUT_RETRY_COST = 10, NO_RETRY_INCREMENT = 1, INVOCATION_ID_HEADER = "amz-sdk-invocation-id", REQUEST_HEADER = "amz-sdk-request";
var init_constants4 = __esm(() => {
  MAXIMUM_RETRY_DELAY = 20 * 1000;
});

// ../../node_modules/@smithy/util-retry/dist-es/defaultRetryBackoffStrategy.js
var getDefaultRetryBackoffStrategy = () => {
  let delayBase = DEFAULT_RETRY_DELAY_BASE;
  const computeNextBackoffDelay = (attempts) => {
    return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
  };
  const setDelayBase = (delay) => {
    delayBase = delay;
  };
  return {
    computeNextBackoffDelay,
    setDelayBase
  };
};
var init_defaultRetryBackoffStrategy = __esm(() => {
  init_constants4();
});

// ../../node_modules/@smithy/util-retry/dist-es/defaultRetryToken.js
var createDefaultRetryToken = ({ retryDelay, retryCount, retryCost }) => {
  const getRetryCount = () => retryCount;
  const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY, retryDelay);
  const getRetryCost = () => retryCost;
  return {
    getRetryCount,
    getRetryDelay,
    getRetryCost
  };
};
var init_defaultRetryToken = __esm(() => {
  init_constants4();
});

// ../../node_modules/@smithy/util-retry/dist-es/StandardRetryStrategy.js
class StandardRetryStrategy {
  constructor(maxAttempts) {
    this.maxAttempts = maxAttempts;
    this.mode = RETRY_MODES.STANDARD;
    this.capacity = INITIAL_RETRY_TOKENS;
    this.retryBackoffStrategy = getDefaultRetryBackoffStrategy();
    this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
  }
  async acquireInitialRetryToken(retryTokenScope) {
    return createDefaultRetryToken({
      retryDelay: DEFAULT_RETRY_DELAY_BASE,
      retryCount: 0
    });
  }
  async refreshRetryTokenForRetry(token, errorInfo) {
    const maxAttempts = await this.getMaxAttempts();
    if (this.shouldRetry(token, errorInfo, maxAttempts)) {
      const errorType = errorInfo.errorType;
      this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
      const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
      const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
      const capacityCost = this.getCapacityCost(errorType);
      this.capacity -= capacityCost;
      return createDefaultRetryToken({
        retryDelay,
        retryCount: token.getRetryCount() + 1,
        retryCost: capacityCost
      });
    }
    throw new Error("No retry token available");
  }
  recordSuccess(token) {
    this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));
  }
  getCapacity() {
    return this.capacity;
  }
  async getMaxAttempts() {
    try {
      return await this.maxAttemptsProvider();
    } catch (error) {
      console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
      return DEFAULT_MAX_ATTEMPTS;
    }
  }
  shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
    const attempts = tokenToRenew.getRetryCount() + 1;
    return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
  }
  getCapacityCost(errorType) {
    return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
  }
  isRetryableError(errorType) {
    return errorType === "THROTTLING" || errorType === "TRANSIENT";
  }
}
var init_StandardRetryStrategy = __esm(() => {
  init_config2();
  init_constants4();
  init_defaultRetryBackoffStrategy();
  init_defaultRetryToken();
});

// ../../node_modules/@smithy/util-retry/dist-es/AdaptiveRetryStrategy.js
class AdaptiveRetryStrategy {
  constructor(maxAttemptsProvider, options) {
    this.maxAttemptsProvider = maxAttemptsProvider;
    this.mode = RETRY_MODES.ADAPTIVE;
    const { rateLimiter } = options ?? {};
    this.rateLimiter = rateLimiter ?? new DefaultRateLimiter;
    this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
  }
  async acquireInitialRetryToken(retryTokenScope) {
    await this.rateLimiter.getSendToken();
    return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
  }
  async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
    this.rateLimiter.updateClientSendingRate(errorInfo);
    return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
  }
  recordSuccess(token) {
    this.rateLimiter.updateClientSendingRate({});
    this.standardRetryStrategy.recordSuccess(token);
  }
}
var init_AdaptiveRetryStrategy = __esm(() => {
  init_config2();
  init_DefaultRateLimiter();
  init_StandardRetryStrategy();
});

// ../../node_modules/@smithy/util-retry/dist-es/ConfiguredRetryStrategy.js
var init_ConfiguredRetryStrategy = __esm(() => {
  init_constants4();
  init_StandardRetryStrategy();
});

// ../../node_modules/@smithy/util-retry/dist-es/types.js
var init_types7 = () => {
};

// ../../node_modules/@smithy/util-retry/dist-es/index.js
var init_dist_es27 = __esm(() => {
  init_AdaptiveRetryStrategy();
  init_ConfiguredRetryStrategy();
  init_DefaultRateLimiter();
  init_StandardRetryStrategy();
  init_config2();
  init_constants4();
  init_types7();
});

// ../../node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _crypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
  function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }
});

// ../../node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function validate3(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  }
  var _default = validate3;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.unsafeStringify = unsafeStringify;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var byteToHex = [];
  for (let i2 = 0;i2 < 256; ++i2) {
    byteToHex.push((i2 + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
  }
  function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  var _default = stringify;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  function v1(options, buf, offset) {
    let i2 = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node == null) {
        node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i2++] = tl >>> 24 & 255;
    b[i2++] = tl >>> 16 & 255;
    b[i2++] = tl >>> 8 & 255;
    b[i2++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i2++] = tmh >>> 8 & 255;
    b[i2++] = tmh & 255;
    b[i2++] = tmh >>> 24 & 15 | 16;
    b[i2++] = tmh >>> 16 & 255;
    b[i2++] = clockseq >>> 8 | 128;
    b[i2++] = clockseq & 255;
    for (let n2 = 0;n2 < 6; ++n2) {
      b[i2 + n2] = node[n2];
    }
    return buf || (0, _stringify.unsafeStringify)(b);
  }
  var _default = v1;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/parse.js
var require_parse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function parse3(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v2;
    const arr = new Uint8Array(16);
    arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v2 >>> 16 & 255;
    arr[2] = v2 >>> 8 & 255;
    arr[3] = v2 & 255;
    arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v2 & 255;
    arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v2 & 255;
    arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v2 & 255;
    arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v2 / 4294967296 & 255;
    arr[12] = v2 >>> 24 & 255;
    arr[13] = v2 >>> 16 & 255;
    arr[14] = v2 >>> 8 & 255;
    arr[15] = v2 & 255;
    return arr;
  }
  var _default = parse3;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.URL = exports.DNS = undefined;
  exports.default = v35;
  var _stringify = require_stringify();
  var _parse = _interopRequireDefault(require_parse());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i2 = 0;i2 < str.length; ++i2) {
      bytes.push(str.charCodeAt(i2));
    }
    return bytes;
  }
  var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  exports.DNS = DNS;
  var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  exports.URL = URL2;
  function v35(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      var _namespace;
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (((_namespace = namespace) === null || _namespace === undefined ? undefined : _namespace.length) !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i2 = 0;i2 < 16; ++i2) {
          buf[offset + i2] = bytes[i2];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  }
});

// ../../node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function md5(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes).digest();
  }
  var _default = md5;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = v3;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/native.js
var require_native = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var _default = {
    randomUUID: _crypto.default.randomUUID
  };
  exports.default = _default;
});

// ../../node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _native = _interopRequireDefault(require_native());
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function v4(options, buf, offset) {
    if (_native.default.randomUUID && !buf && !options) {
      return _native.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i2 = 0;i2 < 16; ++i2) {
        buf[offset + i2] = rnds[i2];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(rnds);
  }
  var _default = v4;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function sha1(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes).digest();
  }
  var _default = sha1;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = v5;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = "00000000-0000-0000-0000-000000000000";
  exports.default = _default;
});

// ../../node_modules/uuid/dist/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function version(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.slice(14, 15), 16);
  }
  var _default = version;
  exports.default = _default;
});

// ../../node_modules/uuid/dist/index.js
var require_dist = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  var _v = _interopRequireDefault(require_v1());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _nil = _interopRequireDefault(require_nil());
  var _version = _interopRequireDefault(require_version());
  var _validate = _interopRequireDefault(require_validate());
  var _stringify = _interopRequireDefault(require_stringify());
  var _parse = _interopRequireDefault(require_parse());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
});

// ../../node_modules/uuid/wrapper.mjs
var import_dist, v1, v3, v4, v5, NIL, version, validate3, stringify, parse3;
var init_wrapper = __esm(() => {
  import_dist = __toESM(require_dist(), 1);
  v1 = import_dist.default.v1;
  v3 = import_dist.default.v3;
  v4 = import_dist.default.v4;
  v5 = import_dist.default.v5;
  NIL = import_dist.default.NIL;
  version = import_dist.default.version;
  validate3 = import_dist.default.validate;
  stringify = import_dist.default.stringify;
  parse3 = import_dist.default.parse;
});

// ../../node_modules/@smithy/middleware-retry/dist-es/defaultRetryQuota.js
var init_defaultRetryQuota = __esm(() => {
  init_dist_es27();
});

// ../../node_modules/@smithy/middleware-retry/dist-es/delayDecider.js
var init_delayDecider = __esm(() => {
  init_dist_es27();
});

// ../../node_modules/@smithy/middleware-retry/dist-es/retryDecider.js
var init_retryDecider = __esm(() => {
  init_dist_es26();
});

// ../../node_modules/@smithy/middleware-retry/dist-es/util.js
var asSdkError = (error) => {
  if (error instanceof Error)
    return error;
  if (error instanceof Object)
    return Object.assign(new Error, error);
  if (typeof error === "string")
    return new Error(error);
  return new Error(`AWS SDK error wrapper for ${error}`);
};

// ../../node_modules/@smithy/middleware-retry/dist-es/StandardRetryStrategy.js
var init_StandardRetryStrategy2 = __esm(() => {
  init_dist_es();
  init_dist_es26();
  init_dist_es27();
  init_defaultRetryQuota();
  init_delayDecider();
  init_retryDecider();
});

// ../../node_modules/@smithy/middleware-retry/dist-es/AdaptiveRetryStrategy.js
var init_AdaptiveRetryStrategy2 = __esm(() => {
  init_dist_es27();
  init_StandardRetryStrategy2();
});

// ../../node_modules/@smithy/middleware-retry/dist-es/configurations.js
var ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS", CONFIG_MAX_ATTEMPTS = "max_attempts", NODE_MAX_ATTEMPT_CONFIG_OPTIONS, resolveRetryConfig = (input) => {
  const { retryStrategy } = input;
  const maxAttempts = normalizeProvider(input.maxAttempts ?? DEFAULT_MAX_ATTEMPTS);
  return {
    ...input,
    maxAttempts,
    retryStrategy: async () => {
      if (retryStrategy) {
        return retryStrategy;
      }
      const retryMode = await normalizeProvider(input.retryMode)();
      if (retryMode === RETRY_MODES.ADAPTIVE) {
        return new AdaptiveRetryStrategy(maxAttempts);
      }
      return new StandardRetryStrategy(maxAttempts);
    }
  };
}, ENV_RETRY_MODE = "AWS_RETRY_MODE", CONFIG_RETRY_MODE = "retry_mode", NODE_RETRY_MODE_CONFIG_OPTIONS;
var init_configurations2 = __esm(() => {
  init_dist_es9();
  init_dist_es27();
  NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env2) => {
      const value = env2[ENV_MAX_ATTEMPTS];
      if (!value)
        return;
      const maxAttempt = parseInt(value);
      if (Number.isNaN(maxAttempt)) {
        throw new Error(`Environment variable ${ENV_MAX_ATTEMPTS} mast be a number, got "${value}"`);
      }
      return maxAttempt;
    },
    configFileSelector: (profile) => {
      const value = profile[CONFIG_MAX_ATTEMPTS];
      if (!value)
        return;
      const maxAttempt = parseInt(value);
      if (Number.isNaN(maxAttempt)) {
        throw new Error(`Shared config file entry ${CONFIG_MAX_ATTEMPTS} mast be a number, got "${value}"`);
      }
      return maxAttempt;
    },
    default: DEFAULT_MAX_ATTEMPTS
  };
  NODE_RETRY_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env2) => env2[ENV_RETRY_MODE],
    configFileSelector: (profile) => profile[CONFIG_RETRY_MODE],
    default: DEFAULT_RETRY_MODE
  };
});

// ../../node_modules/@smithy/middleware-retry/dist-es/omitRetryHeadersMiddleware.js
var init_omitRetryHeadersMiddleware = __esm(() => {
  init_dist_es();
  init_dist_es27();
});

// ../../node_modules/@smithy/middleware-retry/dist-es/isStreamingPayload/isStreamingPayload.js
import { Readable as Readable4 } from "stream";
var isStreamingPayload = (request) => request?.body instanceof Readable4 || typeof ReadableStream !== "undefined" && request?.body instanceof ReadableStream;
var init_isStreamingPayload = () => {
};

// ../../node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js
var retryMiddleware = (options) => (next, context) => async (args) => {
  let retryStrategy = await options.retryStrategy();
  const maxAttempts = await options.maxAttempts();
  if (isRetryStrategyV2(retryStrategy)) {
    retryStrategy = retryStrategy;
    let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
    let lastError = new Error;
    let attempts = 0;
    let totalRetryDelay = 0;
    const { request } = args;
    const isRequest = HttpRequest.isInstance(request);
    if (isRequest) {
      request.headers[INVOCATION_ID_HEADER] = v4();
    }
    while (true) {
      try {
        if (isRequest) {
          request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
        }
        const { response, output } = await next(args);
        retryStrategy.recordSuccess(retryToken);
        output.$metadata.attempts = attempts + 1;
        output.$metadata.totalRetryDelay = totalRetryDelay;
        return { response, output };
      } catch (e2) {
        const retryErrorInfo = getRetryErrorInfo(e2);
        lastError = asSdkError(e2);
        if (isRequest && isStreamingPayload(request)) {
          (context.logger instanceof NoOpLogger ? console : context.logger)?.warn("An error was encountered in a non-retryable streaming request.");
          throw lastError;
        }
        try {
          retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
        } catch (refreshError) {
          if (!lastError.$metadata) {
            lastError.$metadata = {};
          }
          lastError.$metadata.attempts = attempts + 1;
          lastError.$metadata.totalRetryDelay = totalRetryDelay;
          throw lastError;
        }
        attempts = retryToken.getRetryCount();
        const delay = retryToken.getRetryDelay();
        totalRetryDelay += delay;
        await new Promise((resolve2) => setTimeout(resolve2, delay));
      }
    }
  } else {
    retryStrategy = retryStrategy;
    if (retryStrategy?.mode)
      context.userAgent = [...context.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
    return retryStrategy.retry(next, args);
  }
}, isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined", getRetryErrorInfo = (error) => {
  const errorInfo = {
    error,
    errorType: getRetryErrorType(error)
  };
  const retryAfterHint = getRetryAfterHint(error.$response);
  if (retryAfterHint) {
    errorInfo.retryAfterHint = retryAfterHint;
  }
  return errorInfo;
}, getRetryErrorType = (error) => {
  if (isThrottlingError(error))
    return "THROTTLING";
  if (isTransientError(error))
    return "TRANSIENT";
  if (isServerError(error))
    return "SERVER_ERROR";
  return "CLIENT_ERROR";
}, retryMiddlewareOptions, getRetryPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
  }
}), getRetryAfterHint = (response) => {
  if (!HttpResponse.isInstance(response))
    return;
  const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
  if (!retryAfterHeaderName)
    return;
  const retryAfter = response.headers[retryAfterHeaderName];
  const retryAfterSeconds = Number(retryAfter);
  if (!Number.isNaN(retryAfterSeconds))
    return new Date(retryAfterSeconds * 1000);
  const retryAfterDate = new Date(retryAfter);
  return retryAfterDate;
};
var init_retryMiddleware = __esm(() => {
  init_dist_es();
  init_dist_es26();
  init_dist_es14();
  init_dist_es27();
  init_wrapper();
  init_isStreamingPayload();
  retryMiddlewareOptions = {
    name: "retryMiddleware",
    tags: ["RETRY"],
    step: "finalizeRequest",
    priority: "high",
    override: true
  };
});

// ../../node_modules/@smithy/middleware-retry/dist-es/index.js
var init_dist_es28 = __esm(() => {
  init_AdaptiveRetryStrategy2();
  init_StandardRetryStrategy2();
  init_configurations2();
  init_delayDecider();
  init_omitRetryHeadersMiddleware();
  init_retryDecider();
  init_retryMiddleware();
});

// ../../node_modules/@aws-sdk/credential-provider-env/dist-es/fromEnv.js
var import_client, import_property_provider5, ENV_KEY = "AWS_ACCESS_KEY_ID", ENV_SECRET = "AWS_SECRET_ACCESS_KEY", ENV_SESSION = "AWS_SESSION_TOKEN", ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION", ENV_CREDENTIAL_SCOPE = "AWS_CREDENTIAL_SCOPE", ENV_ACCOUNT_ID = "AWS_ACCOUNT_ID", fromEnv2 = (init2) => async () => {
  init2?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv");
  const accessKeyId = process.env[ENV_KEY];
  const secretAccessKey = process.env[ENV_SECRET];
  const sessionToken = process.env[ENV_SESSION];
  const expiry = process.env[ENV_EXPIRATION];
  const credentialScope = process.env[ENV_CREDENTIAL_SCOPE];
  const accountId = process.env[ENV_ACCOUNT_ID];
  if (accessKeyId && secretAccessKey) {
    const credentials = {
      accessKeyId,
      secretAccessKey,
      ...sessionToken && { sessionToken },
      ...expiry && { expiration: new Date(expiry) },
      ...credentialScope && { credentialScope },
      ...accountId && { accountId }
    };
    import_client.setCredentialFeature(credentials, "CREDENTIALS_ENV_VARS", "g");
    return credentials;
  }
  throw new import_property_provider5.CredentialsProviderError("Unable to find environment variable credentials.", { logger: init2?.logger });
};
var init_fromEnv2 = __esm(() => {
  import_client = __toESM(require_client(), 1);
  import_property_provider5 = __toESM(require_dist_cjs16(), 1);
});

// ../../node_modules/@aws-sdk/credential-provider-env/dist-es/index.js
var exports_dist_es = {};
__export(exports_dist_es, {
  fromEnv: () => fromEnv2,
  ENV_SESSION: () => ENV_SESSION,
  ENV_SECRET: () => ENV_SECRET,
  ENV_KEY: () => ENV_KEY,
  ENV_EXPIRATION: () => ENV_EXPIRATION,
  ENV_CREDENTIAL_SCOPE: () => ENV_CREDENTIAL_SCOPE,
  ENV_ACCOUNT_ID: () => ENV_ACCOUNT_ID
});
var init_dist_es29 = __esm(() => {
  init_fromEnv2();
});

// ../../node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/httpRequest.js
import { Buffer as Buffer4 } from "buffer";
import { request } from "http";
function httpRequest2(options) {
  return new Promise((resolve2, reject) => {
    const req = request({
      method: "GET",
      ...options,
      hostname: options.hostname?.replace(/^\[(.+)\]$/, "$1")
    });
    req.on("error", (err) => {
      reject(Object.assign(new import_property_provider6.ProviderError("Unable to connect to instance metadata service"), err));
      req.destroy();
    });
    req.on("timeout", () => {
      reject(new import_property_provider6.ProviderError("TimeoutError from instance metadata service"));
      req.destroy();
    });
    req.on("response", (res) => {
      const { statusCode = 400 } = res;
      if (statusCode < 200 || 300 <= statusCode) {
        reject(Object.assign(new import_property_provider6.ProviderError("Error response received from instance metadata service"), { statusCode }));
        req.destroy();
      }
      const chunks = [];
      res.on("data", (chunk) => {
        chunks.push(chunk);
      });
      res.on("end", () => {
        resolve2(Buffer4.concat(chunks));
        req.destroy();
      });
    });
    req.end();
  });
}
var import_property_provider6;
var init_httpRequest = __esm(() => {
  import_property_provider6 = __toESM(require_dist_cjs16(), 1);
});

// ../../node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/ImdsCredentials.js
var isImdsCredentials = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.AccessKeyId === "string" && typeof arg.SecretAccessKey === "string" && typeof arg.Token === "string" && typeof arg.Expiration === "string", fromImdsCredentials = (creds) => ({
  accessKeyId: creds.AccessKeyId,
  secretAccessKey: creds.SecretAccessKey,
  sessionToken: creds.Token,
  expiration: new Date(creds.Expiration),
  ...creds.AccountId && { accountId: creds.AccountId }
});

// ../../node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/RemoteProviderInit.js
var DEFAULT_TIMEOUT = 1000, DEFAULT_MAX_RETRIES = 0, providerConfigFromInit = ({ maxRetries = DEFAULT_MAX_RETRIES, timeout = DEFAULT_TIMEOUT }) => ({ maxRetries, timeout });

// ../../node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/retry.js
var retry = (toRetry, maxRetries) => {
  let promise = toRetry();
  for (let i3 = 0;i3 < maxRetries; i3++) {
    promise = promise.catch(toRetry);
  }
  return promise;
};

// ../../node_modules/@smithy/credential-provider-imds/dist-es/fromContainerMetadata.js
import { parse as parse4 } from "url";
var import_property_provider7, ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI", ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI", ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN", fromContainerMetadata = (init2 = {}) => {
  const { timeout, maxRetries } = providerConfigFromInit(init2);
  return () => retry(async () => {
    const requestOptions = await getCmdsUri({ logger: init2.logger });
    const credsResponse = JSON.parse(await requestFromEcsImds(timeout, requestOptions));
    if (!isImdsCredentials(credsResponse)) {
      throw new import_property_provider7.CredentialsProviderError("Invalid response received from instance metadata service.", {
        logger: init2.logger
      });
    }
    return fromImdsCredentials(credsResponse);
  }, maxRetries);
}, requestFromEcsImds = async (timeout, options) => {
  if (process.env[ENV_CMDS_AUTH_TOKEN]) {
    options.headers = {
      ...options.headers,
      Authorization: process.env[ENV_CMDS_AUTH_TOKEN]
    };
  }
  const buffer = await httpRequest2({
    ...options,
    timeout
  });
  return buffer.toString();
}, CMDS_IP = "169.254.170.2", GREENGRASS_HOSTS, GREENGRASS_PROTOCOLS, getCmdsUri = async ({ logger: logger2 }) => {
  if (process.env[ENV_CMDS_RELATIVE_URI]) {
    return {
      hostname: CMDS_IP,
      path: process.env[ENV_CMDS_RELATIVE_URI]
    };
  }
  if (process.env[ENV_CMDS_FULL_URI]) {
    const parsed = parse4(process.env[ENV_CMDS_FULL_URI]);
    if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {
      throw new import_property_provider7.CredentialsProviderError(`${parsed.hostname} is not a valid container metadata service hostname`, {
        tryNextLink: false,
        logger: logger2
      });
    }
    if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {
      throw new import_property_provider7.CredentialsProviderError(`${parsed.protocol} is not a valid container metadata service protocol`, {
        tryNextLink: false,
        logger: logger2
      });
    }
    return {
      ...parsed,
      port: parsed.port ? parseInt(parsed.port, 10) : undefined
    };
  }
  throw new import_property_provider7.CredentialsProviderError("The container metadata credential provider cannot be used unless" + ` the ${ENV_CMDS_RELATIVE_URI} or ${ENV_CMDS_FULL_URI} environment` + " variable is set", {
    tryNextLink: false,
    logger: logger2
  });
};
var init_fromContainerMetadata = __esm(() => {
  import_property_provider7 = __toESM(require_dist_cjs16(), 1);
  init_httpRequest();
  GREENGRASS_HOSTS = {
    localhost: true,
    "127.0.0.1": true
  };
  GREENGRASS_PROTOCOLS = {
    "http:": true,
    "https:": true
  };
});

// ../../node_modules/@smithy/credential-provider-imds/dist-es/error/InstanceMetadataV1FallbackError.js
var import_property_provider8, InstanceMetadataV1FallbackError;
var init_InstanceMetadataV1FallbackError = __esm(() => {
  import_property_provider8 = __toESM(require_dist_cjs16(), 1);
  InstanceMetadataV1FallbackError = class InstanceMetadataV1FallbackError extends import_property_provider8.CredentialsProviderError {
    constructor(message, tryNextLink = true) {
      super(message, tryNextLink);
      this.tryNextLink = tryNextLink;
      this.name = "InstanceMetadataV1FallbackError";
      Object.setPrototypeOf(this, InstanceMetadataV1FallbackError.prototype);
    }
  };
});

// ../../node_modules/@smithy/credential-provider-imds/dist-es/config/Endpoint.js
var Endpoint;
var init_Endpoint = __esm(() => {
  (function(Endpoint2) {
    Endpoint2["IPv4"] = "http://169.254.169.254";
    Endpoint2["IPv6"] = "http://[fd00:ec2::254]";
  })(Endpoint || (Endpoint = {}));
});

// ../../node_modules/@smithy/credential-provider-imds/dist-es/config/EndpointConfigOptions.js
var ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT", CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint", ENDPOINT_CONFIG_OPTIONS;
var init_EndpointConfigOptions = __esm(() => {
  ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env2) => env2[ENV_ENDPOINT_NAME],
    configFileSelector: (profile) => profile[CONFIG_ENDPOINT_NAME],
    default: undefined
  };
});

// ../../node_modules/@smithy/credential-provider-imds/dist-es/config/EndpointMode.js
var EndpointMode;
var init_EndpointMode = __esm(() => {
  (function(EndpointMode2) {
    EndpointMode2["IPv4"] = "IPv4";
    EndpointMode2["IPv6"] = "IPv6";
  })(EndpointMode || (EndpointMode = {}));
});

// ../../node_modules/@smithy/credential-provider-imds/dist-es/config/EndpointModeConfigOptions.js
var ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE", CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode", ENDPOINT_MODE_CONFIG_OPTIONS;
var init_EndpointModeConfigOptions = __esm(() => {
  init_EndpointMode();
  ENDPOINT_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env2) => env2[ENV_ENDPOINT_MODE_NAME],
    configFileSelector: (profile) => profile[CONFIG_ENDPOINT_MODE_NAME],
    default: EndpointMode.IPv4
  };
});

// ../../node_modules/@smithy/credential-provider-imds/dist-es/utils/getInstanceMetadataEndpoint.js
var getInstanceMetadataEndpoint = async () => parseUrl(await getFromEndpointConfig() || await getFromEndpointModeConfig()), getFromEndpointConfig = async () => loadConfig(ENDPOINT_CONFIG_OPTIONS)(), getFromEndpointModeConfig = async () => {
  const endpointMode = await loadConfig(ENDPOINT_MODE_CONFIG_OPTIONS)();
  switch (endpointMode) {
    case EndpointMode.IPv4:
      return Endpoint.IPv4;
    case EndpointMode.IPv6:
      return Endpoint.IPv6;
    default:
      throw new Error(`Unsupported endpoint mode: ${endpointMode}.` + ` Select from ${Object.values(EndpointMode)}`);
  }
};
var init_getInstanceMetadataEndpoint = __esm(() => {
  init_dist_es22();
  init_dist_es23();
  init_Endpoint();
  init_EndpointConfigOptions();
  init_EndpointMode();
  init_EndpointModeConfigOptions();
});

// ../../node_modules/@smithy/credential-provider-imds/dist-es/utils/getExtendedInstanceMetadataCredentials.js
var STATIC_STABILITY_REFRESH_INTERVAL_SECONDS, STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS, STATIC_STABILITY_DOC_URL = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html", getExtendedInstanceMetadataCredentials = (credentials, logger2) => {
  const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS + Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS);
  const newExpiration = new Date(Date.now() + refreshInterval * 1000);
  logger2.warn("Attempting credential expiration extension due to a credential service availability issue. A refresh of these " + `credentials will be attempted after ${new Date(newExpiration)}.
For more information, please visit: ` + STATIC_STABILITY_DOC_URL);
  const originalExpiration = credentials.originalExpiration ?? credentials.expiration;
  return {
    ...credentials,
    ...originalExpiration ? { originalExpiration } : {},
    expiration: newExpiration
  };
};
var init_getExtendedInstanceMetadataCredentials = __esm(() => {
  STATIC_STABILITY_REFRESH_INTERVAL_SECONDS = 5 * 60;
  STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS = 5 * 60;
});

// ../../node_modules/@smithy/credential-provider-imds/dist-es/utils/staticStabilityProvider.js
var staticStabilityProvider = (provider, options = {}) => {
  const logger2 = options?.logger || console;
  let pastCredentials;
  return async () => {
    let credentials;
    try {
      credentials = await provider();
      if (credentials.expiration && credentials.expiration.getTime() < Date.now()) {
        credentials = getExtendedInstanceMetadataCredentials(credentials, logger2);
      }
    } catch (e3) {
      if (pastCredentials) {
        logger2.warn("Credential renew failed: ", e3);
        credentials = getExtendedInstanceMetadataCredentials(pastCredentials, logger2);
      } else {
        throw e3;
      }
    }
    pastCredentials = credentials;
    return credentials;
  };
};
var init_staticStabilityProvider = __esm(() => {
  init_getExtendedInstanceMetadataCredentials();
});

// ../../node_modules/@smithy/credential-provider-imds/dist-es/fromInstanceMetadata.js
var import_property_provider9, IMDS_PATH = "/latest/meta-data/iam/security-credentials/", IMDS_TOKEN_PATH = "/latest/api/token", AWS_EC2_METADATA_V1_DISABLED = "AWS_EC2_METADATA_V1_DISABLED", PROFILE_AWS_EC2_METADATA_V1_DISABLED = "ec2_metadata_v1_disabled", X_AWS_EC2_METADATA_TOKEN = "x-aws-ec2-metadata-token", fromInstanceMetadata = (init2 = {}) => staticStabilityProvider(getInstanceMetadataProvider(init2), { logger: init2.logger }), getInstanceMetadataProvider = (init2 = {}) => {
  let disableFetchToken = false;
  const { logger: logger2, profile } = init2;
  const { timeout, maxRetries } = providerConfigFromInit(init2);
  const getCredentials = async (maxRetries2, options) => {
    const isImdsV1Fallback = disableFetchToken || options.headers?.[X_AWS_EC2_METADATA_TOKEN] == null;
    if (isImdsV1Fallback) {
      let fallbackBlockedFromProfile = false;
      let fallbackBlockedFromProcessEnv = false;
      const configValue = await loadConfig({
        environmentVariableSelector: (env2) => {
          const envValue = env2[AWS_EC2_METADATA_V1_DISABLED];
          fallbackBlockedFromProcessEnv = !!envValue && envValue !== "false";
          if (envValue === undefined) {
            throw new import_property_provider9.CredentialsProviderError(`${AWS_EC2_METADATA_V1_DISABLED} not set in env, checking config file next.`, { logger: init2.logger });
          }
          return fallbackBlockedFromProcessEnv;
        },
        configFileSelector: (profile2) => {
          const profileValue = profile2[PROFILE_AWS_EC2_METADATA_V1_DISABLED];
          fallbackBlockedFromProfile = !!profileValue && profileValue !== "false";
          return fallbackBlockedFromProfile;
        },
        default: false
      }, {
        profile
      })();
      if (init2.ec2MetadataV1Disabled || configValue) {
        const causes = [];
        if (init2.ec2MetadataV1Disabled)
          causes.push("credential provider initialization (runtime option ec2MetadataV1Disabled)");
        if (fallbackBlockedFromProfile)
          causes.push(`config file profile (${PROFILE_AWS_EC2_METADATA_V1_DISABLED})`);
        if (fallbackBlockedFromProcessEnv)
          causes.push(`process environment variable (${AWS_EC2_METADATA_V1_DISABLED})`);
        throw new InstanceMetadataV1FallbackError(`AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${causes.join(", ")}].`);
      }
    }
    const imdsProfile = (await retry(async () => {
      let profile2;
      try {
        profile2 = await getProfile(options);
      } catch (err) {
        if (err.statusCode === 401) {
          disableFetchToken = false;
        }
        throw err;
      }
      return profile2;
    }, maxRetries2)).trim();
    return retry(async () => {
      let creds;
      try {
        creds = await getCredentialsFromProfile(imdsProfile, options, init2);
      } catch (err) {
        if (err.statusCode === 401) {
          disableFetchToken = false;
        }
        throw err;
      }
      return creds;
    }, maxRetries2);
  };
  return async () => {
    const endpoint = await getInstanceMetadataEndpoint();
    if (disableFetchToken) {
      logger2?.debug("AWS SDK Instance Metadata", "using v1 fallback (no token fetch)");
      return getCredentials(maxRetries, { ...endpoint, timeout });
    } else {
      let token;
      try {
        token = (await getMetadataToken({ ...endpoint, timeout })).toString();
      } catch (error) {
        if (error?.statusCode === 400) {
          throw Object.assign(error, {
            message: "EC2 Metadata token request returned error"
          });
        } else if (error.message === "TimeoutError" || [403, 404, 405].includes(error.statusCode)) {
          disableFetchToken = true;
        }
        logger2?.debug("AWS SDK Instance Metadata", "using v1 fallback (initial)");
        return getCredentials(maxRetries, { ...endpoint, timeout });
      }
      return getCredentials(maxRetries, {
        ...endpoint,
        headers: {
          [X_AWS_EC2_METADATA_TOKEN]: token
        },
        timeout
      });
    }
  };
}, getMetadataToken = async (options) => httpRequest2({
  ...options,
  path: IMDS_TOKEN_PATH,
  method: "PUT",
  headers: {
    "x-aws-ec2-metadata-token-ttl-seconds": "21600"
  }
}), getProfile = async (options) => (await httpRequest2({ ...options, path: IMDS_PATH })).toString(), getCredentialsFromProfile = async (profile, options, init2) => {
  const credentialsResponse = JSON.parse((await httpRequest2({
    ...options,
    path: IMDS_PATH + profile
  })).toString());
  if (!isImdsCredentials(credentialsResponse)) {
    throw new import_property_provider9.CredentialsProviderError("Invalid response received from instance metadata service.", {
      logger: init2.logger
    });
  }
  return fromImdsCredentials(credentialsResponse);
};
var init_fromInstanceMetadata = __esm(() => {
  init_dist_es22();
  import_property_provider9 = __toESM(require_dist_cjs16(), 1);
  init_InstanceMetadataV1FallbackError();
  init_httpRequest();
  init_getInstanceMetadataEndpoint();
  init_staticStabilityProvider();
});

// ../../node_modules/@smithy/credential-provider-imds/dist-es/types.js
var init_types8 = () => {
};

// ../../node_modules/@smithy/credential-provider-imds/dist-es/index.js
var exports_dist_es2 = {};
__export(exports_dist_es2, {
  providerConfigFromInit: () => providerConfigFromInit,
  httpRequest: () => httpRequest2,
  getInstanceMetadataEndpoint: () => getInstanceMetadataEndpoint,
  fromInstanceMetadata: () => fromInstanceMetadata,
  fromContainerMetadata: () => fromContainerMetadata,
  Endpoint: () => Endpoint,
  ENV_CMDS_RELATIVE_URI: () => ENV_CMDS_RELATIVE_URI,
  ENV_CMDS_FULL_URI: () => ENV_CMDS_FULL_URI,
  ENV_CMDS_AUTH_TOKEN: () => ENV_CMDS_AUTH_TOKEN,
  DEFAULT_TIMEOUT: () => DEFAULT_TIMEOUT,
  DEFAULT_MAX_RETRIES: () => DEFAULT_MAX_RETRIES
});
var init_dist_es30 = __esm(() => {
  init_fromContainerMetadata();
  init_fromInstanceMetadata();
  init_types8();
  init_httpRequest();
  init_getInstanceMetadataEndpoint();
  init_Endpoint();
});

// ../../node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/checkUrl.js
var import_property_provider10, ECS_CONTAINER_HOST = "169.254.170.2", EKS_CONTAINER_HOST_IPv4 = "169.254.170.23", EKS_CONTAINER_HOST_IPv6 = "[fd00:ec2::23]", checkUrl = (url, logger2) => {
  if (url.protocol === "https:") {
    return;
  }
  if (url.hostname === ECS_CONTAINER_HOST || url.hostname === EKS_CONTAINER_HOST_IPv4 || url.hostname === EKS_CONTAINER_HOST_IPv6) {
    return;
  }
  if (url.hostname.includes("[")) {
    if (url.hostname === "[::1]" || url.hostname === "[0000:0000:0000:0000:0000:0000:0000:0001]") {
      return;
    }
  } else {
    if (url.hostname === "localhost") {
      return;
    }
    const ipComponents = url.hostname.split(".");
    const inRange = (component) => {
      const num = parseInt(component, 10);
      return 0 <= num && num <= 255;
    };
    if (ipComponents[0] === "127" && inRange(ipComponents[1]) && inRange(ipComponents[2]) && inRange(ipComponents[3]) && ipComponents.length === 4) {
      return;
    }
  }
  throw new import_property_provider10.CredentialsProviderError(`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`, { logger: logger2 });
};
var init_checkUrl = __esm(() => {
  import_property_provider10 = __toESM(require_dist_cjs16(), 1);
});

// ../../node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/requestHelpers.js
function createGetRequest(url) {
  return new HttpRequest({
    protocol: url.protocol,
    hostname: url.hostname,
    port: Number(url.port),
    path: url.pathname,
    query: Array.from(url.searchParams.entries()).reduce((acc, [k3, v6]) => {
      acc[k3] = v6;
      return acc;
    }, {}),
    fragment: url.hash
  });
}
async function getCredentials(response, logger2) {
  const stream = sdkStreamMixin3(response.body);
  const str = await stream.transformToString();
  if (response.statusCode === 200) {
    const parsed = JSON.parse(str);
    if (typeof parsed.AccessKeyId !== "string" || typeof parsed.SecretAccessKey !== "string" || typeof parsed.Token !== "string" || typeof parsed.Expiration !== "string") {
      throw new import_property_provider11.CredentialsProviderError("HTTP credential provider response not of the required format, an object matching: " + "{ AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }", { logger: logger2 });
    }
    return {
      accessKeyId: parsed.AccessKeyId,
      secretAccessKey: parsed.SecretAccessKey,
      sessionToken: parsed.Token,
      expiration: parseRfc3339DateTime(parsed.Expiration)
    };
  }
  if (response.statusCode >= 400 && response.statusCode < 500) {
    let parsedBody = {};
    try {
      parsedBody = JSON.parse(str);
    } catch (e3) {
    }
    throw Object.assign(new import_property_provider11.CredentialsProviderError(`Server responded with status: ${response.statusCode}`, { logger: logger2 }), {
      Code: parsedBody.Code,
      Message: parsedBody.Message
    });
  }
  throw new import_property_provider11.CredentialsProviderError(`Server responded with status: ${response.statusCode}`, { logger: logger2 });
}
var import_property_provider11;
var init_requestHelpers = __esm(() => {
  import_property_provider11 = __toESM(require_dist_cjs16(), 1);
  init_dist_es();
  init_dist_es14();
  init_dist_es8();
});

// ../../node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/retry-wrapper.js
var retryWrapper = (toRetry, maxRetries, delayMs) => {
  return async () => {
    for (let i3 = 0;i3 < maxRetries; ++i3) {
      try {
        return await toRetry();
      } catch (e3) {
        await new Promise((resolve2) => setTimeout(resolve2, delayMs));
      }
    }
    return await toRetry();
  };
};

// ../../node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/fromHttp.js
import fs2 from "fs/promises";
var import_client2, import_property_provider12, AWS_CONTAINER_CREDENTIALS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI", DEFAULT_LINK_LOCAL_HOST = "http://169.254.170.2", AWS_CONTAINER_CREDENTIALS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI", AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE = "AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE", AWS_CONTAINER_AUTHORIZATION_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN", fromHttp = (options = {}) => {
  options.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");
  let host;
  const relative2 = options.awsContainerCredentialsRelativeUri ?? process.env[AWS_CONTAINER_CREDENTIALS_RELATIVE_URI];
  const full = options.awsContainerCredentialsFullUri ?? process.env[AWS_CONTAINER_CREDENTIALS_FULL_URI];
  const token = options.awsContainerAuthorizationToken ?? process.env[AWS_CONTAINER_AUTHORIZATION_TOKEN];
  const tokenFile = options.awsContainerAuthorizationTokenFile ?? process.env[AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE];
  const warn = options.logger?.constructor?.name === "NoOpLogger" || !options.logger ? console.warn : options.logger.warn;
  if (relative2 && full) {
    warn("@aws-sdk/credential-provider-http: " + "you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri.");
    warn("awsContainerCredentialsFullUri will take precedence.");
  }
  if (token && tokenFile) {
    warn("@aws-sdk/credential-provider-http: " + "you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile.");
    warn("awsContainerAuthorizationToken will take precedence.");
  }
  if (full) {
    host = full;
  } else if (relative2) {
    host = `${DEFAULT_LINK_LOCAL_HOST}${relative2}`;
  } else {
    throw new import_property_provider12.CredentialsProviderError(`No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`, { logger: options.logger });
  }
  const url = new URL(host);
  checkUrl(url, options.logger);
  const requestHandler = new NodeHttpHandler({
    requestTimeout: options.timeout ?? 1000,
    connectionTimeout: options.timeout ?? 1000
  });
  return retryWrapper(async () => {
    const request2 = createGetRequest(url);
    if (token) {
      request2.headers.Authorization = token;
    } else if (tokenFile) {
      request2.headers.Authorization = (await fs2.readFile(tokenFile)).toString();
    }
    try {
      const result = await requestHandler.handle(request2);
      return getCredentials(result.response).then((creds) => import_client2.setCredentialFeature(creds, "CREDENTIALS_HTTP", "z"));
    } catch (e3) {
      throw new import_property_provider12.CredentialsProviderError(String(e3), { logger: options.logger });
    }
  }, options.maxRetries ?? 3, options.timeout ?? 1000);
};
var init_fromHttp = __esm(() => {
  import_client2 = __toESM(require_client(), 1);
  init_dist_es6();
  import_property_provider12 = __toESM(require_dist_cjs16(), 1);
  init_checkUrl();
  init_requestHelpers();
});

// ../../node_modules/@aws-sdk/credential-provider-http/dist-es/index.js
var exports_dist_es3 = {};
__export(exports_dist_es3, {
  fromHttp: () => fromHttp
});
var init_dist_es31 = __esm(() => {
  init_fromHttp();
});

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/isSsoProfile.js
var isSsoProfile = (arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string");

// ../../node_modules/@aws-sdk/token-providers/dist-es/constants.js
var EXPIRE_WINDOW_MS, REFRESH_MESSAGE = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;
var init_constants5 = __esm(() => {
  EXPIRE_WINDOW_MS = 5 * 60 * 1000;
});

// ../../node_modules/@aws-sdk/middleware-host-header/dist-cjs/index.js
var require_dist_cjs21 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    getHostHeaderPlugin: () => getHostHeaderPlugin2,
    hostHeaderMiddleware: () => hostHeaderMiddleware2,
    hostHeaderMiddlewareOptions: () => hostHeaderMiddlewareOptions2,
    resolveHostHeaderConfig: () => resolveHostHeaderConfig2
  });
  module.exports = __toCommonJS(src_exports);
  var import_protocol_http23 = require_dist_cjs2();
  function resolveHostHeaderConfig2(input) {
    return input;
  }
  __name2(resolveHostHeaderConfig2, "resolveHostHeaderConfig");
  var hostHeaderMiddleware2 = /* @__PURE__ */ __name2((options) => (next) => async (args) => {
    if (!import_protocol_http23.HttpRequest.isInstance(args.request))
      return next(args);
    const { request: request2 } = args;
    const { handlerProtocol = "" } = options.requestHandler.metadata || {};
    if (handlerProtocol.indexOf("h2") >= 0 && !request2.headers[":authority"]) {
      delete request2.headers["host"];
      request2.headers[":authority"] = request2.hostname + (request2.port ? ":" + request2.port : "");
    } else if (!request2.headers["host"]) {
      let host = request2.hostname;
      if (request2.port != null)
        host += `:${request2.port}`;
      request2.headers["host"] = host;
    }
    return next(args);
  }, "hostHeaderMiddleware");
  var hostHeaderMiddlewareOptions2 = {
    name: "hostHeaderMiddleware",
    step: "build",
    priority: "low",
    tags: ["HOST"],
    override: true
  };
  var getHostHeaderPlugin2 = /* @__PURE__ */ __name2((options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(hostHeaderMiddleware2(options), hostHeaderMiddlewareOptions2);
    }
  }), "getHostHeaderPlugin");
});

// ../../node_modules/@aws-sdk/middleware-logger/dist-cjs/index.js
var require_dist_cjs22 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    getLoggerPlugin: () => getLoggerPlugin2,
    loggerMiddleware: () => loggerMiddleware3,
    loggerMiddlewareOptions: () => loggerMiddlewareOptions2
  });
  module.exports = __toCommonJS(src_exports);
  var loggerMiddleware3 = /* @__PURE__ */ __name2(() => (next, context) => async (args) => {
    try {
      const response = await next(args);
      const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context;
      const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
      const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
      const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
      const { $metadata, ...outputWithoutMetadata } = response.output;
      logger2?.info?.({
        clientName,
        commandName,
        input: inputFilterSensitiveLog(args.input),
        output: outputFilterSensitiveLog(outputWithoutMetadata),
        metadata: $metadata
      });
      return response;
    } catch (error) {
      const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context;
      const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
      const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
      logger2?.error?.({
        clientName,
        commandName,
        input: inputFilterSensitiveLog(args.input),
        error,
        metadata: error.$metadata
      });
      throw error;
    }
  }, "loggerMiddleware");
  var loggerMiddlewareOptions2 = {
    name: "loggerMiddleware",
    tags: ["LOGGER"],
    step: "initialize",
    override: true
  };
  var getLoggerPlugin2 = /* @__PURE__ */ __name2((options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(loggerMiddleware3(), loggerMiddlewareOptions2);
    }
  }), "getLoggerPlugin");
});

// ../../node_modules/@aws-sdk/middleware-recursion-detection/dist-cjs/index.js
var require_dist_cjs23 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    addRecursionDetectionMiddlewareOptions: () => addRecursionDetectionMiddlewareOptions2,
    getRecursionDetectionPlugin: () => getRecursionDetectionPlugin2,
    recursionDetectionMiddleware: () => recursionDetectionMiddleware2
  });
  module.exports = __toCommonJS(src_exports);
  var import_protocol_http23 = require_dist_cjs2();
  var TRACE_ID_HEADER_NAME2 = "X-Amzn-Trace-Id";
  var ENV_LAMBDA_FUNCTION_NAME2 = "AWS_LAMBDA_FUNCTION_NAME";
  var ENV_TRACE_ID2 = "_X_AMZN_TRACE_ID";
  var recursionDetectionMiddleware2 = /* @__PURE__ */ __name2((options) => (next) => async (args) => {
    const { request: request2 } = args;
    if (!import_protocol_http23.HttpRequest.isInstance(request2) || options.runtime !== "node" || request2.headers.hasOwnProperty(TRACE_ID_HEADER_NAME2)) {
      return next(args);
    }
    const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME2];
    const traceId = process.env[ENV_TRACE_ID2];
    const nonEmptyString = /* @__PURE__ */ __name2((str) => typeof str === "string" && str.length > 0, "nonEmptyString");
    if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
      request2.headers[TRACE_ID_HEADER_NAME2] = traceId;
    }
    return next({
      ...args,
      request: request2
    });
  }, "recursionDetectionMiddleware");
  var addRecursionDetectionMiddlewareOptions2 = {
    step: "build",
    tags: ["RECURSION_DETECTION"],
    name: "recursionDetectionMiddleware",
    override: true,
    priority: "low"
  };
  var getRecursionDetectionPlugin2 = /* @__PURE__ */ __name2((options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(recursionDetectionMiddleware2(options), addRecursionDetectionMiddlewareOptions2);
    }
  }), "getRecursionDetectionPlugin");
});

// ../../node_modules/@smithy/util-endpoints/dist-cjs/index.js
var require_dist_cjs24 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    EndpointCache: () => EndpointCache3,
    EndpointError: () => EndpointError5,
    customEndpointFunctions: () => customEndpointFunctions4,
    isIpAddress: () => isIpAddress5,
    isValidHostLabel: () => isValidHostLabel4,
    resolveEndpoint: () => resolveEndpoint5
  });
  module.exports = __toCommonJS(src_exports);
  var EndpointCache3 = class {
    constructor({ size, params }) {
      this.data = /* @__PURE__ */ new Map;
      this.parameters = [];
      this.capacity = size ?? 50;
      if (params) {
        this.parameters = params;
      }
    }
    static {
      __name2(this, "EndpointCache");
    }
    get(endpointParams, resolver) {
      const key = this.hash(endpointParams);
      if (key === false) {
        return resolver();
      }
      if (!this.data.has(key)) {
        if (this.data.size > this.capacity + 10) {
          const keys = this.data.keys();
          let i3 = 0;
          while (true) {
            const { value, done } = keys.next();
            this.data.delete(value);
            if (done || ++i3 > 10) {
              break;
            }
          }
        }
        this.data.set(key, resolver());
      }
      return this.data.get(key);
    }
    size() {
      return this.data.size;
    }
    hash(endpointParams) {
      let buffer = "";
      const { parameters } = this;
      if (parameters.length === 0) {
        return false;
      }
      for (const param of parameters) {
        const val2 = String(endpointParams[param] ?? "");
        if (val2.includes("|;")) {
          return false;
        }
        buffer += val2 + "|;";
      }
      return buffer;
    }
  };
  var IP_V4_REGEX2 = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
  var isIpAddress5 = /* @__PURE__ */ __name2((value) => IP_V4_REGEX2.test(value) || value.startsWith("[") && value.endsWith("]"), "isIpAddress");
  var VALID_HOST_LABEL_REGEX2 = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
  var isValidHostLabel4 = /* @__PURE__ */ __name2((value, allowSubDomains = false) => {
    if (!allowSubDomains) {
      return VALID_HOST_LABEL_REGEX2.test(value);
    }
    const labels = value.split(".");
    for (const label of labels) {
      if (!isValidHostLabel4(label)) {
        return false;
      }
    }
    return true;
  }, "isValidHostLabel");
  var customEndpointFunctions4 = {};
  var debugId3 = "endpoints";
  function toDebugString3(input) {
    if (typeof input !== "object" || input == null) {
      return input;
    }
    if ("ref" in input) {
      return `$${toDebugString3(input.ref)}`;
    }
    if ("fn" in input) {
      return `${input.fn}(${(input.argv || []).map(toDebugString3).join(", ")})`;
    }
    return JSON.stringify(input, null, 2);
  }
  __name2(toDebugString3, "toDebugString");
  var EndpointError5 = class extends Error {
    static {
      __name2(this, "EndpointError");
    }
    constructor(message) {
      super(message);
      this.name = "EndpointError";
    }
  };
  var booleanEquals3 = /* @__PURE__ */ __name2((value1, value2) => value1 === value2, "booleanEquals");
  var getAttrPathList2 = /* @__PURE__ */ __name2((path) => {
    const parts = path.split(".");
    const pathList = [];
    for (const part of parts) {
      const squareBracketIndex = part.indexOf("[");
      if (squareBracketIndex !== -1) {
        if (part.indexOf("]") !== part.length - 1) {
          throw new EndpointError5(`Path: '${path}' does not end with ']'`);
        }
        const arrayIndex = part.slice(squareBracketIndex + 1, -1);
        if (Number.isNaN(parseInt(arrayIndex))) {
          throw new EndpointError5(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
        }
        if (squareBracketIndex !== 0) {
          pathList.push(part.slice(0, squareBracketIndex));
        }
        pathList.push(arrayIndex);
      } else {
        pathList.push(part);
      }
    }
    return pathList;
  }, "getAttrPathList");
  var getAttr3 = /* @__PURE__ */ __name2((value, path) => getAttrPathList2(path).reduce((acc, index) => {
    if (typeof acc !== "object") {
      throw new EndpointError5(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
    } else if (Array.isArray(acc)) {
      return acc[parseInt(index)];
    }
    return acc[index];
  }, value), "getAttr");
  var isSet3 = /* @__PURE__ */ __name2((value) => value != null, "isSet");
  var not3 = /* @__PURE__ */ __name2((value) => !value, "not");
  var import_types32 = require_dist_cjs();
  var DEFAULT_PORTS2 = {
    [import_types32.EndpointURLScheme.HTTP]: 80,
    [import_types32.EndpointURLScheme.HTTPS]: 443
  };
  var parseURL3 = /* @__PURE__ */ __name2((value) => {
    const whatwgURL = (() => {
      try {
        if (value instanceof URL) {
          return value;
        }
        if (typeof value === "object" && "hostname" in value) {
          const { hostname: hostname2, port, protocol: protocol2 = "", path = "", query = {} } = value;
          const url = new URL(`${protocol2}//${hostname2}${port ? `:${port}` : ""}${path}`);
          url.search = Object.entries(query).map(([k3, v6]) => `${k3}=${v6}`).join("&");
          return url;
        }
        return new URL(value);
      } catch (error) {
        return null;
      }
    })();
    if (!whatwgURL) {
      console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
      return null;
    }
    const urlString = whatwgURL.href;
    const { host, hostname, pathname, protocol, search } = whatwgURL;
    if (search) {
      return null;
    }
    const scheme = protocol.slice(0, -1);
    if (!Object.values(import_types32.EndpointURLScheme).includes(scheme)) {
      return null;
    }
    const isIp = isIpAddress5(hostname);
    const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS2[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS2[scheme]}`);
    const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS2[scheme]}` : ``}`;
    return {
      scheme,
      authority,
      path: pathname,
      normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
      isIp
    };
  }, "parseURL");
  var stringEquals3 = /* @__PURE__ */ __name2((value1, value2) => value1 === value2, "stringEquals");
  var substring3 = /* @__PURE__ */ __name2((input, start, stop, reverse) => {
    if (start >= stop || input.length < stop) {
      return null;
    }
    if (!reverse) {
      return input.substring(start, stop);
    }
    return input.substring(input.length - stop, input.length - start);
  }, "substring");
  var uriEncode3 = /* @__PURE__ */ __name2((value) => encodeURIComponent(value).replace(/[!*'()]/g, (c4) => `%${c4.charCodeAt(0).toString(16).toUpperCase()}`), "uriEncode");
  var endpointFunctions2 = {
    booleanEquals: booleanEquals3,
    getAttr: getAttr3,
    isSet: isSet3,
    isValidHostLabel: isValidHostLabel4,
    not: not3,
    parseURL: parseURL3,
    stringEquals: stringEquals3,
    substring: substring3,
    uriEncode: uriEncode3
  };
  var evaluateTemplate2 = /* @__PURE__ */ __name2((template, options) => {
    const evaluatedTemplateArr = [];
    const templateContext = {
      ...options.endpointParams,
      ...options.referenceRecord
    };
    let currentIndex = 0;
    while (currentIndex < template.length) {
      const openingBraceIndex = template.indexOf("{", currentIndex);
      if (openingBraceIndex === -1) {
        evaluatedTemplateArr.push(template.slice(currentIndex));
        break;
      }
      evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
      const closingBraceIndex = template.indexOf("}", openingBraceIndex);
      if (closingBraceIndex === -1) {
        evaluatedTemplateArr.push(template.slice(openingBraceIndex));
        break;
      }
      if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
        evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
        currentIndex = closingBraceIndex + 2;
      }
      const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
      if (parameterName.includes("#")) {
        const [refName, attrName] = parameterName.split("#");
        evaluatedTemplateArr.push(getAttr3(templateContext[refName], attrName));
      } else {
        evaluatedTemplateArr.push(templateContext[parameterName]);
      }
      currentIndex = closingBraceIndex + 1;
    }
    return evaluatedTemplateArr.join("");
  }, "evaluateTemplate");
  var getReferenceValue2 = /* @__PURE__ */ __name2(({ ref }, options) => {
    const referenceRecord = {
      ...options.endpointParams,
      ...options.referenceRecord
    };
    return referenceRecord[ref];
  }, "getReferenceValue");
  var evaluateExpression2 = /* @__PURE__ */ __name2((obj, keyName, options) => {
    if (typeof obj === "string") {
      return evaluateTemplate2(obj, options);
    } else if (obj["fn"]) {
      return callFunction2(obj, options);
    } else if (obj["ref"]) {
      return getReferenceValue2(obj, options);
    }
    throw new EndpointError5(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
  }, "evaluateExpression");
  var callFunction2 = /* @__PURE__ */ __name2(({ fn, argv: argv2 }, options) => {
    const evaluatedArgs = argv2.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression2(arg, "arg", options));
    const fnSegments = fn.split(".");
    if (fnSegments[0] in customEndpointFunctions4 && fnSegments[1] != null) {
      return customEndpointFunctions4[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
    }
    return endpointFunctions2[fn](...evaluatedArgs);
  }, "callFunction");
  var evaluateCondition2 = /* @__PURE__ */ __name2(({ assign, ...fnArgs }, options) => {
    if (assign && assign in options.referenceRecord) {
      throw new EndpointError5(`'${assign}' is already defined in Reference Record.`);
    }
    const value = callFunction2(fnArgs, options);
    options.logger?.debug?.(`${debugId3} evaluateCondition: ${toDebugString3(fnArgs)} = ${toDebugString3(value)}`);
    return {
      result: value === "" ? true : !!value,
      ...assign != null && { toAssign: { name: assign, value } }
    };
  }, "evaluateCondition");
  var evaluateConditions2 = /* @__PURE__ */ __name2((conditions = [], options) => {
    const conditionsReferenceRecord = {};
    for (const condition of conditions) {
      const { result, toAssign } = evaluateCondition2(condition, {
        ...options,
        referenceRecord: {
          ...options.referenceRecord,
          ...conditionsReferenceRecord
        }
      });
      if (!result) {
        return { result };
      }
      if (toAssign) {
        conditionsReferenceRecord[toAssign.name] = toAssign.value;
        options.logger?.debug?.(`${debugId3} assign: ${toAssign.name} := ${toDebugString3(toAssign.value)}`);
      }
    }
    return { result: true, referenceRecord: conditionsReferenceRecord };
  }, "evaluateConditions");
  var getEndpointHeaders2 = /* @__PURE__ */ __name2((headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
    ...acc,
    [headerKey]: headerVal.map((headerValEntry) => {
      const processedExpr = evaluateExpression2(headerValEntry, "Header value entry", options);
      if (typeof processedExpr !== "string") {
        throw new EndpointError5(`Header '${headerKey}' value '${processedExpr}' is not a string`);
      }
      return processedExpr;
    })
  }), {}), "getEndpointHeaders");
  var getEndpointProperty2 = /* @__PURE__ */ __name2((property, options) => {
    if (Array.isArray(property)) {
      return property.map((propertyEntry) => getEndpointProperty2(propertyEntry, options));
    }
    switch (typeof property) {
      case "string":
        return evaluateTemplate2(property, options);
      case "object":
        if (property === null) {
          throw new EndpointError5(`Unexpected endpoint property: ${property}`);
        }
        return getEndpointProperties2(property, options);
      case "boolean":
        return property;
      default:
        throw new EndpointError5(`Unexpected endpoint property type: ${typeof property}`);
    }
  }, "getEndpointProperty");
  var getEndpointProperties2 = /* @__PURE__ */ __name2((properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
    ...acc,
    [propertyKey]: getEndpointProperty2(propertyVal, options)
  }), {}), "getEndpointProperties");
  var getEndpointUrl2 = /* @__PURE__ */ __name2((endpointUrl, options) => {
    const expression = evaluateExpression2(endpointUrl, "Endpoint URL", options);
    if (typeof expression === "string") {
      try {
        return new URL(expression);
      } catch (error) {
        console.error(`Failed to construct URL with ${expression}`, error);
        throw error;
      }
    }
    throw new EndpointError5(`Endpoint URL must be a string, got ${typeof expression}`);
  }, "getEndpointUrl");
  var evaluateEndpointRule2 = /* @__PURE__ */ __name2((endpointRule, options) => {
    const { conditions, endpoint } = endpointRule;
    const { result, referenceRecord } = evaluateConditions2(conditions, options);
    if (!result) {
      return;
    }
    const endpointRuleOptions = {
      ...options,
      referenceRecord: { ...options.referenceRecord, ...referenceRecord }
    };
    const { url, properties, headers } = endpoint;
    options.logger?.debug?.(`${debugId3} Resolving endpoint from template: ${toDebugString3(endpoint)}`);
    return {
      ...headers != null && {
        headers: getEndpointHeaders2(headers, endpointRuleOptions)
      },
      ...properties != null && {
        properties: getEndpointProperties2(properties, endpointRuleOptions)
      },
      url: getEndpointUrl2(url, endpointRuleOptions)
    };
  }, "evaluateEndpointRule");
  var evaluateErrorRule2 = /* @__PURE__ */ __name2((errorRule, options) => {
    const { conditions, error } = errorRule;
    const { result, referenceRecord } = evaluateConditions2(conditions, options);
    if (!result) {
      return;
    }
    throw new EndpointError5(evaluateExpression2(error, "Error", {
      ...options,
      referenceRecord: { ...options.referenceRecord, ...referenceRecord }
    }));
  }, "evaluateErrorRule");
  var evaluateTreeRule2 = /* @__PURE__ */ __name2((treeRule, options) => {
    const { conditions, rules } = treeRule;
    const { result, referenceRecord } = evaluateConditions2(conditions, options);
    if (!result) {
      return;
    }
    return evaluateRules3(rules, {
      ...options,
      referenceRecord: { ...options.referenceRecord, ...referenceRecord }
    });
  }, "evaluateTreeRule");
  var evaluateRules3 = /* @__PURE__ */ __name2((rules, options) => {
    for (const rule of rules) {
      if (rule.type === "endpoint") {
        const endpointOrUndefined = evaluateEndpointRule2(rule, options);
        if (endpointOrUndefined) {
          return endpointOrUndefined;
        }
      } else if (rule.type === "error") {
        evaluateErrorRule2(rule, options);
      } else if (rule.type === "tree") {
        const endpointOrUndefined = evaluateTreeRule2(rule, options);
        if (endpointOrUndefined) {
          return endpointOrUndefined;
        }
      } else {
        throw new EndpointError5(`Unknown endpoint rule: ${rule}`);
      }
    }
    throw new EndpointError5(`Rules evaluation failed`);
  }, "evaluateRules");
  var resolveEndpoint5 = /* @__PURE__ */ __name2((ruleSetObject, options) => {
    const { endpointParams, logger: logger2 } = options;
    const { parameters, rules } = ruleSetObject;
    options.logger?.debug?.(`${debugId3} Initial EndpointParams: ${toDebugString3(endpointParams)}`);
    const paramsWithDefault = Object.entries(parameters).filter(([, v6]) => v6.default != null).map(([k3, v6]) => [k3, v6.default]);
    if (paramsWithDefault.length > 0) {
      for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
        endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
      }
    }
    const requiredParams = Object.entries(parameters).filter(([, v6]) => v6.required).map(([k3]) => k3);
    for (const requiredParam of requiredParams) {
      if (endpointParams[requiredParam] == null) {
        throw new EndpointError5(`Missing required parameter: '${requiredParam}'`);
      }
    }
    const endpoint = evaluateRules3(rules, { endpointParams, logger: logger2, referenceRecord: {} });
    options.logger?.debug?.(`${debugId3} Resolved endpoint: ${toDebugString3(endpoint)}`);
    return endpoint;
  }, "resolveEndpoint");
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-cjs/index.js
var require_dist_cjs25 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    ConditionObject: () => import_util_endpoints9.ConditionObject,
    DeprecatedObject: () => import_util_endpoints9.DeprecatedObject,
    EndpointError: () => import_util_endpoints9.EndpointError,
    EndpointObject: () => import_util_endpoints9.EndpointObject,
    EndpointObjectHeaders: () => import_util_endpoints9.EndpointObjectHeaders,
    EndpointObjectProperties: () => import_util_endpoints9.EndpointObjectProperties,
    EndpointParams: () => import_util_endpoints9.EndpointParams,
    EndpointResolverOptions: () => import_util_endpoints9.EndpointResolverOptions,
    EndpointRuleObject: () => import_util_endpoints9.EndpointRuleObject,
    ErrorRuleObject: () => import_util_endpoints9.ErrorRuleObject,
    EvaluateOptions: () => import_util_endpoints9.EvaluateOptions,
    Expression: () => import_util_endpoints9.Expression,
    FunctionArgv: () => import_util_endpoints9.FunctionArgv,
    FunctionObject: () => import_util_endpoints9.FunctionObject,
    FunctionReturn: () => import_util_endpoints9.FunctionReturn,
    ParameterObject: () => import_util_endpoints9.ParameterObject,
    ReferenceObject: () => import_util_endpoints9.ReferenceObject,
    ReferenceRecord: () => import_util_endpoints9.ReferenceRecord,
    RuleSetObject: () => import_util_endpoints9.RuleSetObject,
    RuleSetRules: () => import_util_endpoints9.RuleSetRules,
    TreeRuleObject: () => import_util_endpoints9.TreeRuleObject,
    awsEndpointFunctions: () => awsEndpointFunctions2,
    getUserAgentPrefix: () => getUserAgentPrefix2,
    isIpAddress: () => import_util_endpoints9.isIpAddress,
    partition: () => partition3,
    resolveEndpoint: () => import_util_endpoints9.resolveEndpoint,
    setPartitionInfo: () => setPartitionInfo,
    useDefaultPartitionInfo: () => useDefaultPartitionInfo
  });
  module.exports = __toCommonJS(src_exports);
  var import_util_endpoints9 = require_dist_cjs24();
  var isVirtualHostableS3Bucket2 = /* @__PURE__ */ __name2((value, allowSubDomains = false) => {
    if (allowSubDomains) {
      for (const label of value.split(".")) {
        if (!isVirtualHostableS3Bucket2(label)) {
          return false;
        }
      }
      return true;
    }
    if (!(0, import_util_endpoints9.isValidHostLabel)(value)) {
      return false;
    }
    if (value.length < 3 || value.length > 63) {
      return false;
    }
    if (value !== value.toLowerCase()) {
      return false;
    }
    if ((0, import_util_endpoints9.isIpAddress)(value)) {
      return false;
    }
    return true;
  }, "isVirtualHostableS3Bucket");
  var ARN_DELIMITER2 = ":";
  var RESOURCE_DELIMITER2 = "/";
  var parseArn2 = /* @__PURE__ */ __name2((value) => {
    const segments = value.split(ARN_DELIMITER2);
    if (segments.length < 6)
      return null;
    const [arn, partition22, service, region, accountId, ...resourcePath] = segments;
    if (arn !== "arn" || partition22 === "" || service === "" || resourcePath.join(ARN_DELIMITER2) === "")
      return null;
    const resourceId = resourcePath.map((resource) => resource.split(RESOURCE_DELIMITER2)).flat();
    return {
      partition: partition22,
      service,
      region,
      accountId,
      resourceId
    };
  }, "parseArn");
  var partitions_default2 = {
    partitions: [{
      id: "aws",
      outputs: {
        dnsSuffix: "amazonaws.com",
        dualStackDnsSuffix: "api.aws",
        implicitGlobalRegion: "us-east-1",
        name: "aws",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
      regions: {
        "af-south-1": {
          description: "Africa (Cape Town)"
        },
        "ap-east-1": {
          description: "Asia Pacific (Hong Kong)"
        },
        "ap-northeast-1": {
          description: "Asia Pacific (Tokyo)"
        },
        "ap-northeast-2": {
          description: "Asia Pacific (Seoul)"
        },
        "ap-northeast-3": {
          description: "Asia Pacific (Osaka)"
        },
        "ap-south-1": {
          description: "Asia Pacific (Mumbai)"
        },
        "ap-south-2": {
          description: "Asia Pacific (Hyderabad)"
        },
        "ap-southeast-1": {
          description: "Asia Pacific (Singapore)"
        },
        "ap-southeast-2": {
          description: "Asia Pacific (Sydney)"
        },
        "ap-southeast-3": {
          description: "Asia Pacific (Jakarta)"
        },
        "ap-southeast-4": {
          description: "Asia Pacific (Melbourne)"
        },
        "ap-southeast-5": {
          description: "Asia Pacific (Malaysia)"
        },
        "ap-southeast-7": {
          description: "Asia Pacific (Thailand)"
        },
        "aws-global": {
          description: "AWS Standard global region"
        },
        "ca-central-1": {
          description: "Canada (Central)"
        },
        "ca-west-1": {
          description: "Canada West (Calgary)"
        },
        "eu-central-1": {
          description: "Europe (Frankfurt)"
        },
        "eu-central-2": {
          description: "Europe (Zurich)"
        },
        "eu-north-1": {
          description: "Europe (Stockholm)"
        },
        "eu-south-1": {
          description: "Europe (Milan)"
        },
        "eu-south-2": {
          description: "Europe (Spain)"
        },
        "eu-west-1": {
          description: "Europe (Ireland)"
        },
        "eu-west-2": {
          description: "Europe (London)"
        },
        "eu-west-3": {
          description: "Europe (Paris)"
        },
        "il-central-1": {
          description: "Israel (Tel Aviv)"
        },
        "me-central-1": {
          description: "Middle East (UAE)"
        },
        "me-south-1": {
          description: "Middle East (Bahrain)"
        },
        "mx-central-1": {
          description: "Mexico (Central)"
        },
        "sa-east-1": {
          description: "South America (Sao Paulo)"
        },
        "us-east-1": {
          description: "US East (N. Virginia)"
        },
        "us-east-2": {
          description: "US East (Ohio)"
        },
        "us-west-1": {
          description: "US West (N. California)"
        },
        "us-west-2": {
          description: "US West (Oregon)"
        }
      }
    }, {
      id: "aws-cn",
      outputs: {
        dnsSuffix: "amazonaws.com.cn",
        dualStackDnsSuffix: "api.amazonwebservices.com.cn",
        implicitGlobalRegion: "cn-northwest-1",
        name: "aws-cn",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^cn\\-\\w+\\-\\d+$",
      regions: {
        "aws-cn-global": {
          description: "AWS China global region"
        },
        "cn-north-1": {
          description: "China (Beijing)"
        },
        "cn-northwest-1": {
          description: "China (Ningxia)"
        }
      }
    }, {
      id: "aws-us-gov",
      outputs: {
        dnsSuffix: "amazonaws.com",
        dualStackDnsSuffix: "api.aws",
        implicitGlobalRegion: "us-gov-west-1",
        name: "aws-us-gov",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
      regions: {
        "aws-us-gov-global": {
          description: "AWS GovCloud (US) global region"
        },
        "us-gov-east-1": {
          description: "AWS GovCloud (US-East)"
        },
        "us-gov-west-1": {
          description: "AWS GovCloud (US-West)"
        }
      }
    }, {
      id: "aws-iso",
      outputs: {
        dnsSuffix: "c2s.ic.gov",
        dualStackDnsSuffix: "c2s.ic.gov",
        implicitGlobalRegion: "us-iso-east-1",
        name: "aws-iso",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
      regions: {
        "aws-iso-global": {
          description: "AWS ISO (US) global region"
        },
        "us-iso-east-1": {
          description: "US ISO East"
        },
        "us-iso-west-1": {
          description: "US ISO WEST"
        }
      }
    }, {
      id: "aws-iso-b",
      outputs: {
        dnsSuffix: "sc2s.sgov.gov",
        dualStackDnsSuffix: "sc2s.sgov.gov",
        implicitGlobalRegion: "us-isob-east-1",
        name: "aws-iso-b",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
      regions: {
        "aws-iso-b-global": {
          description: "AWS ISOB (US) global region"
        },
        "us-isob-east-1": {
          description: "US ISOB East (Ohio)"
        }
      }
    }, {
      id: "aws-iso-e",
      outputs: {
        dnsSuffix: "cloud.adc-e.uk",
        dualStackDnsSuffix: "cloud.adc-e.uk",
        implicitGlobalRegion: "eu-isoe-west-1",
        name: "aws-iso-e",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
      regions: {
        "eu-isoe-west-1": {
          description: "EU ISOE West"
        }
      }
    }, {
      id: "aws-iso-f",
      outputs: {
        dnsSuffix: "csp.hci.ic.gov",
        dualStackDnsSuffix: "csp.hci.ic.gov",
        implicitGlobalRegion: "us-isof-south-1",
        name: "aws-iso-f",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
      regions: {}
    }],
    version: "1.1"
  };
  var selectedPartitionsInfo2 = partitions_default2;
  var selectedUserAgentPrefix2 = "";
  var partition3 = /* @__PURE__ */ __name2((value) => {
    const { partitions } = selectedPartitionsInfo2;
    for (const partition22 of partitions) {
      const { regions, outputs } = partition22;
      for (const [region, regionData] of Object.entries(regions)) {
        if (region === value) {
          return {
            ...outputs,
            ...regionData
          };
        }
      }
    }
    for (const partition22 of partitions) {
      const { regionRegex, outputs } = partition22;
      if (new RegExp(regionRegex).test(value)) {
        return {
          ...outputs
        };
      }
    }
    const DEFAULT_PARTITION = partitions.find((partition22) => partition22.id === "aws");
    if (!DEFAULT_PARTITION) {
      throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
    }
    return {
      ...DEFAULT_PARTITION.outputs
    };
  }, "partition");
  var setPartitionInfo = /* @__PURE__ */ __name2((partitionsInfo, userAgentPrefix = "") => {
    selectedPartitionsInfo2 = partitionsInfo;
    selectedUserAgentPrefix2 = userAgentPrefix;
  }, "setPartitionInfo");
  var useDefaultPartitionInfo = /* @__PURE__ */ __name2(() => {
    setPartitionInfo(partitions_default2, "");
  }, "useDefaultPartitionInfo");
  var getUserAgentPrefix2 = /* @__PURE__ */ __name2(() => selectedUserAgentPrefix2, "getUserAgentPrefix");
  var awsEndpointFunctions2 = {
    isVirtualHostableS3Bucket: isVirtualHostableS3Bucket2,
    parseArn: parseArn2,
    partition: partition3
  };
  import_util_endpoints9.customEndpointFunctions.aws = awsEndpointFunctions2;
});

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-cjs/index.js
var require_dist_cjs26 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    DEFAULT_UA_APP_ID: () => DEFAULT_UA_APP_ID2,
    getUserAgentMiddlewareOptions: () => getUserAgentMiddlewareOptions2,
    getUserAgentPlugin: () => getUserAgentPlugin2,
    resolveUserAgentConfig: () => resolveUserAgentConfig2,
    userAgentMiddleware: () => userAgentMiddleware2
  });
  module.exports = __toCommonJS(src_exports);
  var import_core11 = require_dist_cjs15();
  var DEFAULT_UA_APP_ID2 = undefined;
  function isValidUserAgentAppId2(appId) {
    if (appId === undefined) {
      return true;
    }
    return typeof appId === "string" && appId.length <= 50;
  }
  __name2(isValidUserAgentAppId2, "isValidUserAgentAppId");
  function resolveUserAgentConfig2(input) {
    const normalizedAppIdProvider = (0, import_core11.normalizeProvider)(input.userAgentAppId ?? DEFAULT_UA_APP_ID2);
    return {
      ...input,
      customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent,
      userAgentAppId: async () => {
        const appId = await normalizedAppIdProvider();
        if (!isValidUserAgentAppId2(appId)) {
          const logger2 = input.logger?.constructor?.name === "NoOpLogger" || !input.logger ? console : input.logger;
          if (typeof appId !== "string") {
            logger2?.warn("userAgentAppId must be a string or undefined.");
          } else if (appId.length > 50) {
            logger2?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.");
          }
        }
        return appId;
      }
    };
  }
  __name2(resolveUserAgentConfig2, "resolveUserAgentConfig");
  var import_util_endpoints9 = require_dist_cjs25();
  var import_protocol_http23 = require_dist_cjs2();
  var import_core22 = require_dist_cjs20();
  var ACCOUNT_ID_ENDPOINT_REGEX2 = /\d{12}\.ddb/;
  async function checkFeatures2(context, config4, args) {
    const request2 = args.request;
    if (request2?.headers?.["smithy-protocol"] === "rpc-v2-cbor") {
      (0, import_core22.setFeature)(context, "PROTOCOL_RPC_V2_CBOR", "M");
    }
    if (typeof config4.retryStrategy === "function") {
      const retryStrategy = await config4.retryStrategy();
      if (typeof retryStrategy.acquireInitialRetryToken === "function") {
        if (retryStrategy.constructor?.name?.includes("Adaptive")) {
          (0, import_core22.setFeature)(context, "RETRY_MODE_ADAPTIVE", "F");
        } else {
          (0, import_core22.setFeature)(context, "RETRY_MODE_STANDARD", "E");
        }
      } else {
        (0, import_core22.setFeature)(context, "RETRY_MODE_LEGACY", "D");
      }
    }
    if (typeof config4.accountIdEndpointMode === "function") {
      const endpointV2 = context.endpointV2;
      if (String(endpointV2?.url?.hostname).match(ACCOUNT_ID_ENDPOINT_REGEX2)) {
        (0, import_core22.setFeature)(context, "ACCOUNT_ID_ENDPOINT", "O");
      }
      switch (await config4.accountIdEndpointMode?.()) {
        case "disabled":
          (0, import_core22.setFeature)(context, "ACCOUNT_ID_MODE_DISABLED", "Q");
          break;
        case "preferred":
          (0, import_core22.setFeature)(context, "ACCOUNT_ID_MODE_PREFERRED", "P");
          break;
        case "required":
          (0, import_core22.setFeature)(context, "ACCOUNT_ID_MODE_REQUIRED", "R");
          break;
      }
    }
    const identity = context.__smithy_context?.selectedHttpAuthScheme?.identity;
    if (identity?.$source) {
      const credentials = identity;
      if (credentials.accountId) {
        (0, import_core22.setFeature)(context, "RESOLVED_ACCOUNT_ID", "T");
      }
      for (const [key, value] of Object.entries(credentials.$source ?? {})) {
        (0, import_core22.setFeature)(context, key, value);
      }
    }
  }
  __name2(checkFeatures2, "checkFeatures");
  var USER_AGENT2 = "user-agent";
  var X_AMZ_USER_AGENT2 = "x-amz-user-agent";
  var SPACE2 = " ";
  var UA_NAME_SEPARATOR2 = "/";
  var UA_NAME_ESCAPE_REGEX2 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
  var UA_VALUE_ESCAPE_REGEX2 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
  var UA_ESCAPE_CHAR2 = "-";
  var BYTE_LIMIT2 = 1024;
  function encodeFeatures2(features) {
    let buffer = "";
    for (const key in features) {
      const val2 = features[key];
      if (buffer.length + val2.length + 1 <= BYTE_LIMIT2) {
        if (buffer.length) {
          buffer += "," + val2;
        } else {
          buffer += val2;
        }
        continue;
      }
      break;
    }
    return buffer;
  }
  __name2(encodeFeatures2, "encodeFeatures");
  var userAgentMiddleware2 = /* @__PURE__ */ __name2((options) => (next, context) => async (args) => {
    const { request: request2 } = args;
    if (!import_protocol_http23.HttpRequest.isInstance(request2)) {
      return next(args);
    }
    const { headers } = request2;
    const userAgent = context?.userAgent?.map(escapeUserAgent2) || [];
    const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent2);
    await checkFeatures2(context, options, args);
    const awsContext = context;
    defaultUserAgent.push(`m/${encodeFeatures2(Object.assign({}, context.__smithy_context?.features, awsContext.__aws_sdk_context?.features))}`);
    const customUserAgent = options?.customUserAgent?.map(escapeUserAgent2) || [];
    const appId = await options.userAgentAppId();
    if (appId) {
      defaultUserAgent.push(escapeUserAgent2([`app/${appId}`]));
    }
    const prefix = (0, import_util_endpoints9.getUserAgentPrefix)();
    const sdkUserAgentValue = (prefix ? [prefix] : []).concat([...defaultUserAgent, ...userAgent, ...customUserAgent]).join(SPACE2);
    const normalUAValue = [
      ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
      ...customUserAgent
    ].join(SPACE2);
    if (options.runtime !== "browser") {
      if (normalUAValue) {
        headers[X_AMZ_USER_AGENT2] = headers[X_AMZ_USER_AGENT2] ? `${headers[USER_AGENT2]} ${normalUAValue}` : normalUAValue;
      }
      headers[USER_AGENT2] = sdkUserAgentValue;
    } else {
      headers[X_AMZ_USER_AGENT2] = sdkUserAgentValue;
    }
    return next({
      ...args,
      request: request2
    });
  }, "userAgentMiddleware");
  var escapeUserAgent2 = /* @__PURE__ */ __name2((userAgentPair) => {
    const name = userAgentPair[0].split(UA_NAME_SEPARATOR2).map((part) => part.replace(UA_NAME_ESCAPE_REGEX2, UA_ESCAPE_CHAR2)).join(UA_NAME_SEPARATOR2);
    const version2 = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX2, UA_ESCAPE_CHAR2);
    const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR2);
    const prefix = name.substring(0, prefixSeparatorIndex);
    let uaName = name.substring(prefixSeparatorIndex + 1);
    if (prefix === "api") {
      uaName = uaName.toLowerCase();
    }
    return [prefix, uaName, version2].filter((item) => item && item.length > 0).reduce((acc, item, index) => {
      switch (index) {
        case 0:
          return item;
        case 1:
          return `${acc}/${item}`;
        default:
          return `${acc}#${item}`;
      }
    }, "");
  }, "escapeUserAgent");
  var getUserAgentMiddlewareOptions2 = {
    name: "getUserAgentMiddleware",
    step: "build",
    priority: "low",
    tags: ["SET_USER_AGENT", "USER_AGENT"],
    override: true
  };
  var getUserAgentPlugin2 = /* @__PURE__ */ __name2((config4) => ({
    applyToStack: (clientStack) => {
      clientStack.add(userAgentMiddleware2(config4), getUserAgentMiddlewareOptions2);
    }
  }), "getUserAgentPlugin");
});

// ../../node_modules/@smithy/util-config-provider/dist-cjs/index.js
var require_dist_cjs27 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    SelectorType: () => SelectorType3,
    booleanSelector: () => booleanSelector3,
    numberSelector: () => numberSelector2
  });
  module.exports = __toCommonJS(src_exports);
  var booleanSelector3 = /* @__PURE__ */ __name2((obj, key, type) => {
    if (!(key in obj))
      return;
    if (obj[key] === "true")
      return true;
    if (obj[key] === "false")
      return false;
    throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
  }, "booleanSelector");
  var numberSelector2 = /* @__PURE__ */ __name2((obj, key, type) => {
    if (!(key in obj))
      return;
    const numberValue = parseInt(obj[key], 10);
    if (Number.isNaN(numberValue)) {
      throw new TypeError(`Cannot load ${type} '${key}'. Expected number, got '${obj[key]}'.`);
    }
    return numberValue;
  }, "numberSelector");
  var SelectorType3 = /* @__PURE__ */ ((SelectorType22) => {
    SelectorType22["ENV"] = "env";
    SelectorType22["CONFIG"] = "shared config entry";
    return SelectorType22;
  })(SelectorType3 || {});
});

// ../../node_modules/@smithy/config-resolver/dist-cjs/index.js
var require_dist_cjs28 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    CONFIG_USE_DUALSTACK_ENDPOINT: () => CONFIG_USE_DUALSTACK_ENDPOINT2,
    CONFIG_USE_FIPS_ENDPOINT: () => CONFIG_USE_FIPS_ENDPOINT2,
    DEFAULT_USE_DUALSTACK_ENDPOINT: () => DEFAULT_USE_DUALSTACK_ENDPOINT,
    DEFAULT_USE_FIPS_ENDPOINT: () => DEFAULT_USE_FIPS_ENDPOINT,
    ENV_USE_DUALSTACK_ENDPOINT: () => ENV_USE_DUALSTACK_ENDPOINT2,
    ENV_USE_FIPS_ENDPOINT: () => ENV_USE_FIPS_ENDPOINT2,
    NODE_REGION_CONFIG_FILE_OPTIONS: () => NODE_REGION_CONFIG_FILE_OPTIONS2,
    NODE_REGION_CONFIG_OPTIONS: () => NODE_REGION_CONFIG_OPTIONS2,
    NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS: () => NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS2,
    NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS: () => NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS2,
    REGION_ENV_NAME: () => REGION_ENV_NAME2,
    REGION_INI_NAME: () => REGION_INI_NAME2,
    getRegionInfo: () => getRegionInfo2,
    resolveCustomEndpointsConfig: () => resolveCustomEndpointsConfig2,
    resolveEndpointsConfig: () => resolveEndpointsConfig2,
    resolveRegionConfig: () => resolveRegionConfig3
  });
  module.exports = __toCommonJS(src_exports);
  var import_util_config_provider4 = require_dist_cjs27();
  var ENV_USE_DUALSTACK_ENDPOINT2 = "AWS_USE_DUALSTACK_ENDPOINT";
  var CONFIG_USE_DUALSTACK_ENDPOINT2 = "use_dualstack_endpoint";
  var DEFAULT_USE_DUALSTACK_ENDPOINT = false;
  var NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS2 = {
    environmentVariableSelector: (env2) => (0, import_util_config_provider4.booleanSelector)(env2, ENV_USE_DUALSTACK_ENDPOINT2, import_util_config_provider4.SelectorType.ENV),
    configFileSelector: (profile) => (0, import_util_config_provider4.booleanSelector)(profile, CONFIG_USE_DUALSTACK_ENDPOINT2, import_util_config_provider4.SelectorType.CONFIG),
    default: false
  };
  var ENV_USE_FIPS_ENDPOINT2 = "AWS_USE_FIPS_ENDPOINT";
  var CONFIG_USE_FIPS_ENDPOINT2 = "use_fips_endpoint";
  var DEFAULT_USE_FIPS_ENDPOINT = false;
  var NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS2 = {
    environmentVariableSelector: (env2) => (0, import_util_config_provider4.booleanSelector)(env2, ENV_USE_FIPS_ENDPOINT2, import_util_config_provider4.SelectorType.ENV),
    configFileSelector: (profile) => (0, import_util_config_provider4.booleanSelector)(profile, CONFIG_USE_FIPS_ENDPOINT2, import_util_config_provider4.SelectorType.CONFIG),
    default: false
  };
  var import_util_middleware10 = require_dist_cjs3();
  var resolveCustomEndpointsConfig2 = /* @__PURE__ */ __name2((input) => {
    const { endpoint, urlParser } = input;
    return {
      ...input,
      tls: input.tls ?? true,
      endpoint: (0, import_util_middleware10.normalizeProvider)(typeof endpoint === "string" ? urlParser(endpoint) : endpoint),
      isCustomEndpoint: true,
      useDualstackEndpoint: (0, import_util_middleware10.normalizeProvider)(input.useDualstackEndpoint ?? false)
    };
  }, "resolveCustomEndpointsConfig");
  var getEndpointFromRegion2 = /* @__PURE__ */ __name2(async (input) => {
    const { tls = true } = input;
    const region = await input.region();
    const dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
    if (!dnsHostRegex.test(region)) {
      throw new Error("Invalid region in client config");
    }
    const useDualstackEndpoint = await input.useDualstackEndpoint();
    const useFipsEndpoint = await input.useFipsEndpoint();
    const { hostname } = await input.regionInfoProvider(region, { useDualstackEndpoint, useFipsEndpoint }) ?? {};
    if (!hostname) {
      throw new Error("Cannot resolve hostname from client config");
    }
    return input.urlParser(`${tls ? "https:" : "http:"}//${hostname}`);
  }, "getEndpointFromRegion");
  var resolveEndpointsConfig2 = /* @__PURE__ */ __name2((input) => {
    const useDualstackEndpoint = (0, import_util_middleware10.normalizeProvider)(input.useDualstackEndpoint ?? false);
    const { endpoint, useFipsEndpoint, urlParser } = input;
    return {
      ...input,
      tls: input.tls ?? true,
      endpoint: endpoint ? (0, import_util_middleware10.normalizeProvider)(typeof endpoint === "string" ? urlParser(endpoint) : endpoint) : () => getEndpointFromRegion2({ ...input, useDualstackEndpoint, useFipsEndpoint }),
      isCustomEndpoint: !!endpoint,
      useDualstackEndpoint
    };
  }, "resolveEndpointsConfig");
  var REGION_ENV_NAME2 = "AWS_REGION";
  var REGION_INI_NAME2 = "region";
  var NODE_REGION_CONFIG_OPTIONS2 = {
    environmentVariableSelector: (env2) => env2[REGION_ENV_NAME2],
    configFileSelector: (profile) => profile[REGION_INI_NAME2],
    default: () => {
      throw new Error("Region is missing");
    }
  };
  var NODE_REGION_CONFIG_FILE_OPTIONS2 = {
    preferredFile: "credentials"
  };
  var isFipsRegion2 = /* @__PURE__ */ __name2((region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips")), "isFipsRegion");
  var getRealRegion2 = /* @__PURE__ */ __name2((region) => isFipsRegion2(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region, "getRealRegion");
  var resolveRegionConfig3 = /* @__PURE__ */ __name2((input) => {
    const { region, useFipsEndpoint } = input;
    if (!region) {
      throw new Error("Region is missing");
    }
    return {
      ...input,
      region: async () => {
        if (typeof region === "string") {
          return getRealRegion2(region);
        }
        const providedRegion = await region();
        return getRealRegion2(providedRegion);
      },
      useFipsEndpoint: async () => {
        const providedRegion = typeof region === "string" ? region : await region();
        if (isFipsRegion2(providedRegion)) {
          return true;
        }
        return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
      }
    };
  }, "resolveRegionConfig");
  var getHostnameFromVariants2 = /* @__PURE__ */ __name2((variants = [], { useFipsEndpoint, useDualstackEndpoint }) => variants.find(({ tags }) => useFipsEndpoint === tags.includes("fips") && useDualstackEndpoint === tags.includes("dualstack"))?.hostname, "getHostnameFromVariants");
  var getResolvedHostname2 = /* @__PURE__ */ __name2((resolvedRegion, { regionHostname, partitionHostname }) => regionHostname ? regionHostname : partitionHostname ? partitionHostname.replace("{region}", resolvedRegion) : undefined, "getResolvedHostname");
  var getResolvedPartition2 = /* @__PURE__ */ __name2((region, { partitionHash }) => Object.keys(partitionHash || {}).find((key) => partitionHash[key].regions.includes(region)) ?? "aws", "getResolvedPartition");
  var getResolvedSigningRegion2 = /* @__PURE__ */ __name2((hostname, { signingRegion, regionRegex, useFipsEndpoint }) => {
    if (signingRegion) {
      return signingRegion;
    } else if (useFipsEndpoint) {
      const regionRegexJs = regionRegex.replace("\\\\", "\\").replace(/^\^/g, "\\.").replace(/\$$/g, "\\.");
      const regionRegexmatchArray = hostname.match(regionRegexJs);
      if (regionRegexmatchArray) {
        return regionRegexmatchArray[0].slice(1, -1);
      }
    }
  }, "getResolvedSigningRegion");
  var getRegionInfo2 = /* @__PURE__ */ __name2((region, {
    useFipsEndpoint = false,
    useDualstackEndpoint = false,
    signingService,
    regionHash,
    partitionHash
  }) => {
    const partition3 = getResolvedPartition2(region, { partitionHash });
    const resolvedRegion = region in regionHash ? region : partitionHash[partition3]?.endpoint ?? region;
    const hostnameOptions = { useFipsEndpoint, useDualstackEndpoint };
    const regionHostname = getHostnameFromVariants2(regionHash[resolvedRegion]?.variants, hostnameOptions);
    const partitionHostname = getHostnameFromVariants2(partitionHash[partition3]?.variants, hostnameOptions);
    const hostname = getResolvedHostname2(resolvedRegion, { regionHostname, partitionHostname });
    if (hostname === undefined) {
      throw new Error(`Endpoint resolution failed for: ${{ resolvedRegion, useFipsEndpoint, useDualstackEndpoint }}`);
    }
    const signingRegion = getResolvedSigningRegion2(hostname, {
      signingRegion: regionHash[resolvedRegion]?.signingRegion,
      regionRegex: partitionHash[partition3].regionRegex,
      useFipsEndpoint
    });
    return {
      partition: partition3,
      signingService,
      hostname,
      ...signingRegion && { signingRegion },
      ...regionHash[resolvedRegion]?.signingService && {
        signingService: regionHash[resolvedRegion].signingService
      }
    };
  }, "getRegionInfo");
});

// ../../node_modules/@smithy/middleware-content-length/dist-cjs/index.js
var require_dist_cjs29 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    contentLengthMiddleware: () => contentLengthMiddleware2,
    contentLengthMiddlewareOptions: () => contentLengthMiddlewareOptions2,
    getContentLengthPlugin: () => getContentLengthPlugin2
  });
  module.exports = __toCommonJS(src_exports);
  var import_protocol_http23 = require_dist_cjs2();
  var CONTENT_LENGTH_HEADER2 = "content-length";
  function contentLengthMiddleware2(bodyLengthChecker) {
    return (next) => async (args) => {
      const request2 = args.request;
      if (import_protocol_http23.HttpRequest.isInstance(request2)) {
        const { body, headers } = request2;
        if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER2) === -1) {
          try {
            const length = bodyLengthChecker(body);
            request2.headers = {
              ...request2.headers,
              [CONTENT_LENGTH_HEADER2]: String(length)
            };
          } catch (error) {
          }
        }
      }
      return next({
        ...args,
        request: request2
      });
    };
  }
  __name2(contentLengthMiddleware2, "contentLengthMiddleware");
  var contentLengthMiddlewareOptions2 = {
    step: "build",
    tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
    name: "contentLengthMiddleware",
    override: true
  };
  var getContentLengthPlugin2 = /* @__PURE__ */ __name2((options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(contentLengthMiddleware2(options.bodyLengthChecker), contentLengthMiddlewareOptions2);
    }
  }), "getContentLengthPlugin");
});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-cjs/getHomeDir.js
var require_getHomeDir = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHomeDir = undefined;
  var os_1 = __require("os");
  var path_1 = __require("path");
  var homeDirCache2 = {};
  var getHomeDirCacheKey2 = () => {
    if (process && process.geteuid) {
      return `${process.geteuid()}`;
    }
    return "DEFAULT";
  };
  var getHomeDir4 = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${path_1.sep}` } = process.env;
    if (HOME)
      return HOME;
    if (USERPROFILE)
      return USERPROFILE;
    if (HOMEPATH)
      return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey2();
    if (!homeDirCache2[homeDirCacheKey])
      homeDirCache2[homeDirCacheKey] = (0, os_1.homedir)();
    return homeDirCache2[homeDirCacheKey];
  };
  exports.getHomeDir = getHomeDir4;
});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-cjs/getSSOTokenFilepath.js
var require_getSSOTokenFilepath = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSSOTokenFilepath = undefined;
  var crypto_1 = __require("crypto");
  var path_1 = __require("path");
  var getHomeDir_1 = require_getHomeDir();
  var getSSOTokenFilepath4 = (id) => {
    const hasher = (0, crypto_1.createHash)("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "sso", "cache", `${cacheName}.json`);
  };
  exports.getSSOTokenFilepath = getSSOTokenFilepath4;
});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-cjs/getSSOTokenFromFile.js
var require_getSSOTokenFromFile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSSOTokenFromFile = undefined;
  var fs_1 = __require("fs");
  var getSSOTokenFilepath_1 = require_getSSOTokenFilepath();
  var { readFile: readFile3 } = fs_1.promises;
  var getSSOTokenFromFile4 = async (id) => {
    const ssoTokenFilepath = (0, getSSOTokenFilepath_1.getSSOTokenFilepath)(id);
    const ssoTokenText = await readFile3(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
  };
  exports.getSSOTokenFromFile = getSSOTokenFromFile4;
});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-cjs/slurpFile.js
var require_slurpFile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.slurpFile = undefined;
  var fs_1 = __require("fs");
  var { readFile: readFile3 } = fs_1.promises;
  var filePromisesHash2 = {};
  var slurpFile2 = (path, options) => {
    if (!filePromisesHash2[path] || (options === null || options === undefined ? undefined : options.ignoreCache)) {
      filePromisesHash2[path] = readFile3(path, "utf8");
    }
    return filePromisesHash2[path];
  };
  exports.slurpFile = slurpFile2;
});

// ../../node_modules/@smithy/shared-ini-file-loader/dist-cjs/index.js
var require_dist_cjs30 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    CONFIG_PREFIX_SEPARATOR: () => CONFIG_PREFIX_SEPARATOR2,
    DEFAULT_PROFILE: () => DEFAULT_PROFILE2,
    ENV_PROFILE: () => ENV_PROFILE2,
    getProfileName: () => getProfileName3,
    loadSharedConfigFiles: () => loadSharedConfigFiles3,
    loadSsoSessionData: () => loadSsoSessionData3,
    parseKnownFiles: () => parseKnownFiles3
  });
  module.exports = __toCommonJS(src_exports);
  __reExport(src_exports, require_getHomeDir(), module.exports);
  var ENV_PROFILE2 = "AWS_PROFILE";
  var DEFAULT_PROFILE2 = "default";
  var getProfileName3 = /* @__PURE__ */ __name2((init2) => init2.profile || process.env[ENV_PROFILE2] || DEFAULT_PROFILE2, "getProfileName");
  __reExport(src_exports, require_getSSOTokenFilepath(), module.exports);
  __reExport(src_exports, require_getSSOTokenFromFile(), module.exports);
  var import_types23 = require_dist_cjs();
  var getConfigData2 = /* @__PURE__ */ __name2((data) => Object.entries(data).filter(([key]) => {
    const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR2);
    if (indexOfSeparator === -1) {
      return false;
    }
    return Object.values(import_types23.IniSectionType).includes(key.substring(0, indexOfSeparator));
  }).reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR2);
    const updatedKey = key.substring(0, indexOfSeparator) === import_types23.IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
  }, {
    ...data.default && { default: data.default }
  }), "getConfigData");
  var import_path6 = __require("path");
  var import_getHomeDir5 = require_getHomeDir();
  var ENV_CONFIG_PATH2 = "AWS_CONFIG_FILE";
  var getConfigFilepath2 = /* @__PURE__ */ __name2(() => process.env[ENV_CONFIG_PATH2] || (0, import_path6.join)((0, import_getHomeDir5.getHomeDir)(), ".aws", "config"), "getConfigFilepath");
  var import_getHomeDir22 = require_getHomeDir();
  var ENV_CREDENTIALS_PATH2 = "AWS_SHARED_CREDENTIALS_FILE";
  var getCredentialsFilepath2 = /* @__PURE__ */ __name2(() => process.env[ENV_CREDENTIALS_PATH2] || (0, import_path6.join)((0, import_getHomeDir22.getHomeDir)(), ".aws", "credentials"), "getCredentialsFilepath");
  var import_getHomeDir32 = require_getHomeDir();
  var prefixKeyRegex2 = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
  var profileNameBlockList2 = ["__proto__", "profile __proto__"];
  var parseIni2 = /* @__PURE__ */ __name2((iniData) => {
    const map2 = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
      const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
      const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
      if (isSection) {
        currentSection = undefined;
        currentSubSection = undefined;
        const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
        const matches = prefixKeyRegex2.exec(sectionName);
        if (matches) {
          const [, prefix, , name] = matches;
          if (Object.values(import_types23.IniSectionType).includes(prefix)) {
            currentSection = [prefix, name].join(CONFIG_PREFIX_SEPARATOR2);
          }
        } else {
          currentSection = sectionName;
        }
        if (profileNameBlockList2.includes(sectionName)) {
          throw new Error(`Found invalid profile name "${sectionName}"`);
        }
      } else if (currentSection) {
        const indexOfEqualsSign = trimmedLine.indexOf("=");
        if (![0, -1].includes(indexOfEqualsSign)) {
          const [name, value] = [
            trimmedLine.substring(0, indexOfEqualsSign).trim(),
            trimmedLine.substring(indexOfEqualsSign + 1).trim()
          ];
          if (value === "") {
            currentSubSection = name;
          } else {
            if (currentSubSection && iniLine.trimStart() === iniLine) {
              currentSubSection = undefined;
            }
            map2[currentSection] = map2[currentSection] || {};
            const key = currentSubSection ? [currentSubSection, name].join(CONFIG_PREFIX_SEPARATOR2) : name;
            map2[currentSection][key] = value;
          }
        }
      }
    }
    return map2;
  }, "parseIni");
  var import_slurpFile3 = require_slurpFile();
  var swallowError3 = /* @__PURE__ */ __name2(() => ({}), "swallowError");
  var CONFIG_PREFIX_SEPARATOR2 = ".";
  var loadSharedConfigFiles3 = /* @__PURE__ */ __name2(async (init2 = {}) => {
    const { filepath = getCredentialsFilepath2(), configFilepath = getConfigFilepath2() } = init2;
    const homeDir = (0, import_getHomeDir32.getHomeDir)();
    const relativeHomeDirPrefix = "~/";
    let resolvedFilepath = filepath;
    if (filepath.startsWith(relativeHomeDirPrefix)) {
      resolvedFilepath = (0, import_path6.join)(homeDir, filepath.slice(2));
    }
    let resolvedConfigFilepath = configFilepath;
    if (configFilepath.startsWith(relativeHomeDirPrefix)) {
      resolvedConfigFilepath = (0, import_path6.join)(homeDir, configFilepath.slice(2));
    }
    const parsedFiles = await Promise.all([
      (0, import_slurpFile3.slurpFile)(resolvedConfigFilepath, {
        ignoreCache: init2.ignoreCache
      }).then(parseIni2).then(getConfigData2).catch(swallowError3),
      (0, import_slurpFile3.slurpFile)(resolvedFilepath, {
        ignoreCache: init2.ignoreCache
      }).then(parseIni2).catch(swallowError3)
    ]);
    return {
      configFile: parsedFiles[0],
      credentialsFile: parsedFiles[1]
    };
  }, "loadSharedConfigFiles");
  var getSsoSessionData2 = /* @__PURE__ */ __name2((data) => Object.entries(data).filter(([key]) => key.startsWith(import_types23.IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR2)).reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR2) + 1)]: value }), {}), "getSsoSessionData");
  var import_slurpFile22 = require_slurpFile();
  var swallowError22 = /* @__PURE__ */ __name2(() => ({}), "swallowError");
  var loadSsoSessionData3 = /* @__PURE__ */ __name2(async (init2 = {}) => (0, import_slurpFile22.slurpFile)(init2.configFilepath ?? getConfigFilepath2()).then(parseIni2).then(getSsoSessionData2).catch(swallowError22), "loadSsoSessionData");
  var mergeConfigFiles2 = /* @__PURE__ */ __name2((...files) => {
    const merged = {};
    for (const file of files) {
      for (const [key, values] of Object.entries(file)) {
        if (merged[key] !== undefined) {
          Object.assign(merged[key], values);
        } else {
          merged[key] = values;
        }
      }
    }
    return merged;
  }, "mergeConfigFiles");
  var parseKnownFiles3 = /* @__PURE__ */ __name2(async (init2) => {
    const parsedFiles = await loadSharedConfigFiles3(init2);
    return mergeConfigFiles2(parsedFiles.configFile, parsedFiles.credentialsFile);
  }, "parseKnownFiles");
});

// ../../node_modules/@smithy/node-config-provider/dist-cjs/index.js
var require_dist_cjs31 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    loadConfig: () => loadConfig2
  });
  module.exports = __toCommonJS(src_exports);
  var import_property_provider14 = require_dist_cjs16();
  function getSelectorName2(functionString) {
    try {
      const constants6 = new Set(Array.from(functionString.match(/([A-Z_]){3,}/g) ?? []));
      constants6.delete("CONFIG");
      constants6.delete("CONFIG_PREFIX_SEPARATOR");
      constants6.delete("ENV");
      return [...constants6].join(", ");
    } catch (e3) {
      return functionString;
    }
  }
  __name2(getSelectorName2, "getSelectorName");
  var fromEnv4 = /* @__PURE__ */ __name2((envVarSelector, logger2) => async () => {
    try {
      const config4 = envVarSelector(process.env);
      if (config4 === undefined) {
        throw new Error;
      }
      return config4;
    } catch (e3) {
      throw new import_property_provider14.CredentialsProviderError(e3.message || `Not found in ENV: ${getSelectorName2(envVarSelector.toString())}`, { logger: logger2 });
    }
  }, "fromEnv");
  var import_shared_ini_file_loader3 = require_dist_cjs30();
  var fromSharedConfigFiles2 = /* @__PURE__ */ __name2((configSelector, { preferredFile = "config", ...init2 } = {}) => async () => {
    const profile = (0, import_shared_ini_file_loader3.getProfileName)(init2);
    const { configFile, credentialsFile } = await (0, import_shared_ini_file_loader3.loadSharedConfigFiles)(init2);
    const profileFromCredentials = credentialsFile[profile] || {};
    const profileFromConfig = configFile[profile] || {};
    const mergedProfile = preferredFile === "config" ? { ...profileFromCredentials, ...profileFromConfig } : { ...profileFromConfig, ...profileFromCredentials };
    try {
      const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
      const configValue = configSelector(mergedProfile, cfgFile);
      if (configValue === undefined) {
        throw new Error;
      }
      return configValue;
    } catch (e3) {
      throw new import_property_provider14.CredentialsProviderError(e3.message || `Not found in config files w/ profile [${profile}]: ${getSelectorName2(configSelector.toString())}`, { logger: init2.logger });
    }
  }, "fromSharedConfigFiles");
  var isFunction2 = /* @__PURE__ */ __name2((func) => typeof func === "function", "isFunction");
  var fromStatic2 = /* @__PURE__ */ __name2((defaultValue) => isFunction2(defaultValue) ? async () => await defaultValue() : (0, import_property_provider14.fromStatic)(defaultValue), "fromStatic");
  var loadConfig2 = /* @__PURE__ */ __name2(({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => (0, import_property_provider14.memoize)((0, import_property_provider14.chain)(fromEnv4(environmentVariableSelector), fromSharedConfigFiles2(configFileSelector, configuration), fromStatic2(defaultValue))), "loadConfig");
});

// ../../node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/getEndpointUrlConfig.js
var require_getEndpointUrlConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEndpointUrlConfig = undefined;
  var shared_ini_file_loader_1 = require_dist_cjs30();
  var ENV_ENDPOINT_URL2 = "AWS_ENDPOINT_URL";
  var CONFIG_ENDPOINT_URL2 = "endpoint_url";
  var getEndpointUrlConfig2 = (serviceId) => ({
    environmentVariableSelector: (env2) => {
      const serviceSuffixParts = serviceId.split(" ").map((w3) => w3.toUpperCase());
      const serviceEndpointUrl = env2[[ENV_ENDPOINT_URL2, ...serviceSuffixParts].join("_")];
      if (serviceEndpointUrl)
        return serviceEndpointUrl;
      const endpointUrl = env2[ENV_ENDPOINT_URL2];
      if (endpointUrl)
        return endpointUrl;
      return;
    },
    configFileSelector: (profile, config4) => {
      if (config4 && profile.services) {
        const servicesSection = config4[["services", profile.services].join(shared_ini_file_loader_1.CONFIG_PREFIX_SEPARATOR)];
        if (servicesSection) {
          const servicePrefixParts = serviceId.split(" ").map((w3) => w3.toLowerCase());
          const endpointUrl2 = servicesSection[[servicePrefixParts.join("_"), CONFIG_ENDPOINT_URL2].join(shared_ini_file_loader_1.CONFIG_PREFIX_SEPARATOR)];
          if (endpointUrl2)
            return endpointUrl2;
        }
      }
      const endpointUrl = profile[CONFIG_ENDPOINT_URL2];
      if (endpointUrl)
        return endpointUrl;
      return;
    },
    default: undefined
  });
  exports.getEndpointUrlConfig = getEndpointUrlConfig2;
});

// ../../node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/getEndpointFromConfig.js
var require_getEndpointFromConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEndpointFromConfig = undefined;
  var node_config_provider_1 = require_dist_cjs31();
  var getEndpointUrlConfig_1 = require_getEndpointUrlConfig();
  var getEndpointFromConfig2 = async (serviceId) => (0, node_config_provider_1.loadConfig)((0, getEndpointUrlConfig_1.getEndpointUrlConfig)(serviceId !== null && serviceId !== undefined ? serviceId : ""))();
  exports.getEndpointFromConfig = getEndpointFromConfig2;
});

// ../../node_modules/@smithy/querystring-parser/dist-cjs/index.js
var require_dist_cjs32 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    parseQueryString: () => parseQueryString2
  });
  module.exports = __toCommonJS(src_exports);
  function parseQueryString2(querystring) {
    const query = {};
    querystring = querystring.replace(/^\?/, "");
    if (querystring) {
      for (const pair of querystring.split("&")) {
        let [key, value = null] = pair.split("=");
        key = decodeURIComponent(key);
        if (value) {
          value = decodeURIComponent(value);
        }
        if (!(key in query)) {
          query[key] = value;
        } else if (Array.isArray(query[key])) {
          query[key].push(value);
        } else {
          query[key] = [query[key], value];
        }
      }
    }
    return query;
  }
  __name2(parseQueryString2, "parseQueryString");
});

// ../../node_modules/@smithy/url-parser/dist-cjs/index.js
var require_dist_cjs33 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    parseUrl: () => parseUrl2
  });
  module.exports = __toCommonJS(src_exports);
  var import_querystring_parser2 = require_dist_cjs32();
  var parseUrl2 = /* @__PURE__ */ __name2((url) => {
    if (typeof url === "string") {
      return parseUrl2(new URL(url));
    }
    const { hostname, pathname, port, protocol, search } = url;
    let query;
    if (search) {
      query = (0, import_querystring_parser2.parseQueryString)(search);
    }
    return {
      hostname,
      port: port ? parseInt(port) : undefined,
      protocol,
      path: pathname,
      query
    };
  }, "parseUrl");
});

// ../../node_modules/@smithy/middleware-endpoint/dist-cjs/index.js
var require_dist_cjs34 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    endpointMiddleware: () => endpointMiddleware3,
    endpointMiddlewareOptions: () => endpointMiddlewareOptions2,
    getEndpointFromInstructions: () => getEndpointFromInstructions3,
    getEndpointPlugin: () => getEndpointPlugin3,
    resolveEndpointConfig: () => resolveEndpointConfig3,
    resolveParams: () => resolveParams2,
    toEndpointV1: () => toEndpointV13
  });
  module.exports = __toCommonJS(src_exports);
  var resolveParamsForS32 = /* @__PURE__ */ __name2(async (endpointParams) => {
    const bucket = endpointParams?.Bucket || "";
    if (typeof endpointParams.Bucket === "string") {
      endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
    }
    if (isArnBucketName2(bucket)) {
      if (endpointParams.ForcePathStyle === true) {
        throw new Error("Path-style addressing cannot be used with ARN buckets");
      }
    } else if (!isDnsCompatibleBucketName2(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
      endpointParams.ForcePathStyle = true;
    }
    if (endpointParams.DisableMultiRegionAccessPoints) {
      endpointParams.disableMultiRegionAccessPoints = true;
      endpointParams.DisableMRAP = true;
    }
    return endpointParams;
  }, "resolveParamsForS3");
  var DOMAIN_PATTERN2 = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
  var IP_ADDRESS_PATTERN2 = /(\d+\.){3}\d+/;
  var DOTS_PATTERN2 = /\.\./;
  var isDnsCompatibleBucketName2 = /* @__PURE__ */ __name2((bucketName) => DOMAIN_PATTERN2.test(bucketName) && !IP_ADDRESS_PATTERN2.test(bucketName) && !DOTS_PATTERN2.test(bucketName), "isDnsCompatibleBucketName");
  var isArnBucketName2 = /* @__PURE__ */ __name2((bucketName) => {
    const [arn, partition3, service, , , bucket] = bucketName.split(":");
    const isArn = arn === "arn" && bucketName.split(":").length >= 6;
    const isValidArn = Boolean(isArn && partition3 && service && bucket);
    if (isArn && !isValidArn) {
      throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
    }
    return isValidArn;
  }, "isArnBucketName");
  var createConfigValueProvider2 = /* @__PURE__ */ __name2((configKey, canonicalEndpointParamKey, config4) => {
    const configProvider = /* @__PURE__ */ __name2(async () => {
      const configValue = config4[configKey] ?? config4[canonicalEndpointParamKey];
      if (typeof configValue === "function") {
        return configValue();
      }
      return configValue;
    }, "configProvider");
    if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
      return async () => {
        const credentials = typeof config4.credentials === "function" ? await config4.credentials() : config4.credentials;
        const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
        return configValue;
      };
    }
    if (configKey === "accountId" || canonicalEndpointParamKey === "AccountId") {
      return async () => {
        const credentials = typeof config4.credentials === "function" ? await config4.credentials() : config4.credentials;
        const configValue = credentials?.accountId ?? credentials?.AccountId;
        return configValue;
      };
    }
    if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
      return async () => {
        const endpoint = await configProvider();
        if (endpoint && typeof endpoint === "object") {
          if ("url" in endpoint) {
            return endpoint.url.href;
          }
          if ("hostname" in endpoint) {
            const { protocol, hostname, port, path } = endpoint;
            return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
          }
        }
        return endpoint;
      };
    }
    return configProvider;
  }, "createConfigValueProvider");
  var import_getEndpointFromConfig3 = require_getEndpointFromConfig();
  var import_url_parser3 = require_dist_cjs33();
  var toEndpointV13 = /* @__PURE__ */ __name2((endpoint) => {
    if (typeof endpoint === "object") {
      if ("url" in endpoint) {
        return (0, import_url_parser3.parseUrl)(endpoint.url);
      }
      return endpoint;
    }
    return (0, import_url_parser3.parseUrl)(endpoint);
  }, "toEndpointV1");
  var getEndpointFromInstructions3 = /* @__PURE__ */ __name2(async (commandInput, instructionsSupplier, clientConfig, context) => {
    if (!clientConfig.endpoint) {
      let endpointFromConfig;
      if (clientConfig.serviceConfiguredEndpoint) {
        endpointFromConfig = await clientConfig.serviceConfiguredEndpoint();
      } else {
        endpointFromConfig = await (0, import_getEndpointFromConfig3.getEndpointFromConfig)(clientConfig.serviceId);
      }
      if (endpointFromConfig) {
        clientConfig.endpoint = () => Promise.resolve(toEndpointV13(endpointFromConfig));
      }
    }
    const endpointParams = await resolveParams2(commandInput, instructionsSupplier, clientConfig);
    if (typeof clientConfig.endpointProvider !== "function") {
      throw new Error("config.endpointProvider is not set.");
    }
    const endpoint = clientConfig.endpointProvider(endpointParams, context);
    return endpoint;
  }, "getEndpointFromInstructions");
  var resolveParams2 = /* @__PURE__ */ __name2(async (commandInput, instructionsSupplier, clientConfig) => {
    const endpointParams = {};
    const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
    for (const [name, instruction] of Object.entries(instructions)) {
      switch (instruction.type) {
        case "staticContextParams":
          endpointParams[name] = instruction.value;
          break;
        case "contextParams":
          endpointParams[name] = commandInput[instruction.name];
          break;
        case "clientContextParams":
        case "builtInParams":
          endpointParams[name] = await createConfigValueProvider2(instruction.name, name, clientConfig)();
          break;
        case "operationContextParams":
          endpointParams[name] = instruction.get(commandInput);
          break;
        default:
          throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
      }
    }
    if (Object.keys(instructions).length === 0) {
      Object.assign(endpointParams, clientConfig);
    }
    if (String(clientConfig.serviceId).toLowerCase() === "s3") {
      await resolveParamsForS32(endpointParams);
    }
    return endpointParams;
  }, "resolveParams");
  var import_core11 = require_dist_cjs15();
  var import_util_middleware10 = require_dist_cjs3();
  var endpointMiddleware3 = /* @__PURE__ */ __name2(({
    config: config4,
    instructions
  }) => {
    return (next, context) => async (args) => {
      if (config4.endpoint) {
        (0, import_core11.setFeature)(context, "ENDPOINT_OVERRIDE", "N");
      }
      const endpoint = await getEndpointFromInstructions3(args.input, {
        getEndpointParameterInstructions() {
          return instructions;
        }
      }, { ...config4 }, context);
      context.endpointV2 = endpoint;
      context.authSchemes = endpoint.properties?.authSchemes;
      const authScheme = context.authSchemes?.[0];
      if (authScheme) {
        context["signing_region"] = authScheme.signingRegion;
        context["signing_service"] = authScheme.signingName;
        const smithyContext = (0, import_util_middleware10.getSmithyContext)(context);
        const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
        if (httpAuthOption) {
          httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
            signing_region: authScheme.signingRegion,
            signingRegion: authScheme.signingRegion,
            signing_service: authScheme.signingName,
            signingName: authScheme.signingName,
            signingRegionSet: authScheme.signingRegionSet
          }, authScheme.properties);
        }
      }
      return next({
        ...args
      });
    };
  }, "endpointMiddleware");
  var import_middleware_serde3 = require_dist_cjs4();
  var endpointMiddlewareOptions2 = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: import_middleware_serde3.serializerMiddlewareOption.name
  };
  var getEndpointPlugin3 = /* @__PURE__ */ __name2((config4, instructions) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(endpointMiddleware3({
        config: config4,
        instructions
      }), endpointMiddlewareOptions2);
    }
  }), "getEndpointPlugin");
  var import_getEndpointFromConfig22 = require_getEndpointFromConfig();
  var resolveEndpointConfig3 = /* @__PURE__ */ __name2((input) => {
    const tls = input.tls ?? true;
    const { endpoint } = input;
    const customEndpointProvider = endpoint != null ? async () => toEndpointV13(await (0, import_util_middleware10.normalizeProvider)(endpoint)()) : undefined;
    const isCustomEndpoint = !!endpoint;
    const resolvedConfig = {
      ...input,
      endpoint: customEndpointProvider,
      tls,
      isCustomEndpoint,
      useDualstackEndpoint: (0, import_util_middleware10.normalizeProvider)(input.useDualstackEndpoint ?? false),
      useFipsEndpoint: (0, import_util_middleware10.normalizeProvider)(input.useFipsEndpoint ?? false)
    };
    let configuredEndpointPromise = undefined;
    resolvedConfig.serviceConfiguredEndpoint = async () => {
      if (input.serviceId && !configuredEndpointPromise) {
        configuredEndpointPromise = (0, import_getEndpointFromConfig22.getEndpointFromConfig)(input.serviceId);
      }
      return configuredEndpointPromise;
    };
    return resolvedConfig;
  }, "resolveEndpointConfig");
});

// ../../node_modules/@smithy/service-error-classification/dist-cjs/index.js
var require_dist_cjs35 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    isClockSkewCorrectedError: () => isClockSkewCorrectedError2,
    isClockSkewError: () => isClockSkewError2,
    isRetryableByTrait: () => isRetryableByTrait2,
    isServerError: () => isServerError2,
    isThrottlingError: () => isThrottlingError2,
    isTransientError: () => isTransientError2
  });
  module.exports = __toCommonJS(src_exports);
  var CLOCK_SKEW_ERROR_CODES2 = [
    "AuthFailure",
    "InvalidSignatureException",
    "RequestExpired",
    "RequestInTheFuture",
    "RequestTimeTooSkewed",
    "SignatureDoesNotMatch"
  ];
  var THROTTLING_ERROR_CODES2 = [
    "BandwidthLimitExceeded",
    "EC2ThrottledException",
    "LimitExceededException",
    "PriorRequestNotComplete",
    "ProvisionedThroughputExceededException",
    "RequestLimitExceeded",
    "RequestThrottled",
    "RequestThrottledException",
    "SlowDown",
    "ThrottledException",
    "Throttling",
    "ThrottlingException",
    "TooManyRequestsException",
    "TransactionInProgressException"
  ];
  var TRANSIENT_ERROR_CODES2 = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
  var TRANSIENT_ERROR_STATUS_CODES2 = [500, 502, 503, 504];
  var NODEJS_TIMEOUT_ERROR_CODES3 = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];
  var isRetryableByTrait2 = /* @__PURE__ */ __name2((error) => error.$retryable !== undefined, "isRetryableByTrait");
  var isClockSkewError2 = /* @__PURE__ */ __name2((error) => CLOCK_SKEW_ERROR_CODES2.includes(error.name), "isClockSkewError");
  var isClockSkewCorrectedError2 = /* @__PURE__ */ __name2((error) => error.$metadata?.clockSkewCorrected, "isClockSkewCorrectedError");
  var isThrottlingError2 = /* @__PURE__ */ __name2((error) => error.$metadata?.httpStatusCode === 429 || THROTTLING_ERROR_CODES2.includes(error.name) || error.$retryable?.throttling == true, "isThrottlingError");
  var isTransientError2 = /* @__PURE__ */ __name2((error, depth = 0) => isClockSkewCorrectedError2(error) || TRANSIENT_ERROR_CODES2.includes(error.name) || NODEJS_TIMEOUT_ERROR_CODES3.includes(error?.code || "") || TRANSIENT_ERROR_STATUS_CODES2.includes(error.$metadata?.httpStatusCode || 0) || error.cause !== undefined && depth <= 10 && isTransientError2(error.cause, depth + 1), "isTransientError");
  var isServerError2 = /* @__PURE__ */ __name2((error) => {
    if (error.$metadata?.httpStatusCode !== undefined) {
      const statusCode = error.$metadata.httpStatusCode;
      if (500 <= statusCode && statusCode <= 599 && !isTransientError2(error)) {
        return true;
      }
      return false;
    }
    return false;
  }, "isServerError");
});

// ../../node_modules/@smithy/util-retry/dist-cjs/index.js
var require_dist_cjs36 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    AdaptiveRetryStrategy: () => AdaptiveRetryStrategy4,
    ConfiguredRetryStrategy: () => ConfiguredRetryStrategy2,
    DEFAULT_MAX_ATTEMPTS: () => DEFAULT_MAX_ATTEMPTS2,
    DEFAULT_RETRY_DELAY_BASE: () => DEFAULT_RETRY_DELAY_BASE2,
    DEFAULT_RETRY_MODE: () => DEFAULT_RETRY_MODE2,
    DefaultRateLimiter: () => DefaultRateLimiter3,
    INITIAL_RETRY_TOKENS: () => INITIAL_RETRY_TOKENS2,
    INVOCATION_ID_HEADER: () => INVOCATION_ID_HEADER2,
    MAXIMUM_RETRY_DELAY: () => MAXIMUM_RETRY_DELAY2,
    NO_RETRY_INCREMENT: () => NO_RETRY_INCREMENT2,
    REQUEST_HEADER: () => REQUEST_HEADER2,
    RETRY_COST: () => RETRY_COST2,
    RETRY_MODES: () => RETRY_MODES2,
    StandardRetryStrategy: () => StandardRetryStrategy5,
    THROTTLING_RETRY_DELAY_BASE: () => THROTTLING_RETRY_DELAY_BASE2,
    TIMEOUT_RETRY_COST: () => TIMEOUT_RETRY_COST2
  });
  module.exports = __toCommonJS(src_exports);
  var RETRY_MODES2 = /* @__PURE__ */ ((RETRY_MODES22) => {
    RETRY_MODES22["STANDARD"] = "standard";
    RETRY_MODES22["ADAPTIVE"] = "adaptive";
    return RETRY_MODES22;
  })(RETRY_MODES2 || {});
  var DEFAULT_MAX_ATTEMPTS2 = 3;
  var DEFAULT_RETRY_MODE2 = "standard";
  var import_service_error_classification5 = require_dist_cjs35();
  var DefaultRateLimiter3 = class _DefaultRateLimiter {
    constructor(options) {
      this.currentCapacity = 0;
      this.enabled = false;
      this.lastMaxRate = 0;
      this.measuredTxRate = 0;
      this.requestCount = 0;
      this.lastTimestamp = 0;
      this.timeWindow = 0;
      this.beta = options?.beta ?? 0.7;
      this.minCapacity = options?.minCapacity ?? 1;
      this.minFillRate = options?.minFillRate ?? 0.5;
      this.scaleConstant = options?.scaleConstant ?? 0.4;
      this.smooth = options?.smooth ?? 0.8;
      const currentTimeInSeconds = this.getCurrentTimeInSeconds();
      this.lastThrottleTime = currentTimeInSeconds;
      this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
      this.fillRate = this.minFillRate;
      this.maxCapacity = this.minCapacity;
    }
    static {
      __name2(this, "DefaultRateLimiter");
    }
    static {
      this.setTimeoutFn = setTimeout;
    }
    getCurrentTimeInSeconds() {
      return Date.now() / 1000;
    }
    async getSendToken() {
      return this.acquireTokenBucket(1);
    }
    async acquireTokenBucket(amount) {
      if (!this.enabled) {
        return;
      }
      this.refillTokenBucket();
      if (amount > this.currentCapacity) {
        const delay = (amount - this.currentCapacity) / this.fillRate * 1000;
        await new Promise((resolve2) => _DefaultRateLimiter.setTimeoutFn(resolve2, delay));
      }
      this.currentCapacity = this.currentCapacity - amount;
    }
    refillTokenBucket() {
      const timestamp = this.getCurrentTimeInSeconds();
      if (!this.lastTimestamp) {
        this.lastTimestamp = timestamp;
        return;
      }
      const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
      this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
      this.lastTimestamp = timestamp;
    }
    updateClientSendingRate(response) {
      let calculatedRate;
      this.updateMeasuredRate();
      if ((0, import_service_error_classification5.isThrottlingError)(response)) {
        const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
        this.lastMaxRate = rateToUse;
        this.calculateTimeWindow();
        this.lastThrottleTime = this.getCurrentTimeInSeconds();
        calculatedRate = this.cubicThrottle(rateToUse);
        this.enableTokenBucket();
      } else {
        this.calculateTimeWindow();
        calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
      }
      const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
      this.updateTokenBucketRate(newRate);
    }
    calculateTimeWindow() {
      this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
    }
    cubicThrottle(rateToUse) {
      return this.getPrecise(rateToUse * this.beta);
    }
    cubicSuccess(timestamp) {
      return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
    }
    enableTokenBucket() {
      this.enabled = true;
    }
    updateTokenBucketRate(newRate) {
      this.refillTokenBucket();
      this.fillRate = Math.max(newRate, this.minFillRate);
      this.maxCapacity = Math.max(newRate, this.minCapacity);
      this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
    }
    updateMeasuredRate() {
      const t3 = this.getCurrentTimeInSeconds();
      const timeBucket = Math.floor(t3 * 2) / 2;
      this.requestCount++;
      if (timeBucket > this.lastTxRateBucket) {
        const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
        this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
        this.requestCount = 0;
        this.lastTxRateBucket = timeBucket;
      }
    }
    getPrecise(num) {
      return parseFloat(num.toFixed(8));
    }
  };
  var DEFAULT_RETRY_DELAY_BASE2 = 100;
  var MAXIMUM_RETRY_DELAY2 = 20 * 1000;
  var THROTTLING_RETRY_DELAY_BASE2 = 500;
  var INITIAL_RETRY_TOKENS2 = 500;
  var RETRY_COST2 = 5;
  var TIMEOUT_RETRY_COST2 = 10;
  var NO_RETRY_INCREMENT2 = 1;
  var INVOCATION_ID_HEADER2 = "amz-sdk-invocation-id";
  var REQUEST_HEADER2 = "amz-sdk-request";
  var getDefaultRetryBackoffStrategy2 = /* @__PURE__ */ __name2(() => {
    let delayBase = DEFAULT_RETRY_DELAY_BASE2;
    const computeNextBackoffDelay = /* @__PURE__ */ __name2((attempts) => {
      return Math.floor(Math.min(MAXIMUM_RETRY_DELAY2, Math.random() * 2 ** attempts * delayBase));
    }, "computeNextBackoffDelay");
    const setDelayBase = /* @__PURE__ */ __name2((delay) => {
      delayBase = delay;
    }, "setDelayBase");
    return {
      computeNextBackoffDelay,
      setDelayBase
    };
  }, "getDefaultRetryBackoffStrategy");
  var createDefaultRetryToken2 = /* @__PURE__ */ __name2(({
    retryDelay,
    retryCount,
    retryCost
  }) => {
    const getRetryCount = /* @__PURE__ */ __name2(() => retryCount, "getRetryCount");
    const getRetryDelay = /* @__PURE__ */ __name2(() => Math.min(MAXIMUM_RETRY_DELAY2, retryDelay), "getRetryDelay");
    const getRetryCost = /* @__PURE__ */ __name2(() => retryCost, "getRetryCost");
    return {
      getRetryCount,
      getRetryDelay,
      getRetryCost
    };
  }, "createDefaultRetryToken");
  var StandardRetryStrategy5 = class {
    constructor(maxAttempts) {
      this.maxAttempts = maxAttempts;
      this.mode = "standard";
      this.capacity = INITIAL_RETRY_TOKENS2;
      this.retryBackoffStrategy = getDefaultRetryBackoffStrategy2();
      this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
    }
    static {
      __name2(this, "StandardRetryStrategy");
    }
    async acquireInitialRetryToken(retryTokenScope) {
      return createDefaultRetryToken2({
        retryDelay: DEFAULT_RETRY_DELAY_BASE2,
        retryCount: 0
      });
    }
    async refreshRetryTokenForRetry(token, errorInfo) {
      const maxAttempts = await this.getMaxAttempts();
      if (this.shouldRetry(token, errorInfo, maxAttempts)) {
        const errorType = errorInfo.errorType;
        this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE2 : DEFAULT_RETRY_DELAY_BASE2);
        const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
        const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
        const capacityCost = this.getCapacityCost(errorType);
        this.capacity -= capacityCost;
        return createDefaultRetryToken2({
          retryDelay,
          retryCount: token.getRetryCount() + 1,
          retryCost: capacityCost
        });
      }
      throw new Error("No retry token available");
    }
    recordSuccess(token) {
      this.capacity = Math.max(INITIAL_RETRY_TOKENS2, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT2));
    }
    getCapacity() {
      return this.capacity;
    }
    async getMaxAttempts() {
      try {
        return await this.maxAttemptsProvider();
      } catch (error) {
        console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS2}`);
        return DEFAULT_MAX_ATTEMPTS2;
      }
    }
    shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
      const attempts = tokenToRenew.getRetryCount() + 1;
      return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
    }
    getCapacityCost(errorType) {
      return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST2 : RETRY_COST2;
    }
    isRetryableError(errorType) {
      return errorType === "THROTTLING" || errorType === "TRANSIENT";
    }
  };
  var AdaptiveRetryStrategy4 = class {
    constructor(maxAttemptsProvider, options) {
      this.maxAttemptsProvider = maxAttemptsProvider;
      this.mode = "adaptive";
      const { rateLimiter } = options ?? {};
      this.rateLimiter = rateLimiter ?? new DefaultRateLimiter3;
      this.standardRetryStrategy = new StandardRetryStrategy5(maxAttemptsProvider);
    }
    static {
      __name2(this, "AdaptiveRetryStrategy");
    }
    async acquireInitialRetryToken(retryTokenScope) {
      await this.rateLimiter.getSendToken();
      return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
      this.rateLimiter.updateClientSendingRate(errorInfo);
      return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
    }
    recordSuccess(token) {
      this.rateLimiter.updateClientSendingRate({});
      this.standardRetryStrategy.recordSuccess(token);
    }
  };
  var ConfiguredRetryStrategy2 = class extends StandardRetryStrategy5 {
    static {
      __name2(this, "ConfiguredRetryStrategy");
    }
    constructor(maxAttempts, computeNextBackoffDelay = DEFAULT_RETRY_DELAY_BASE2) {
      super(typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts);
      if (typeof computeNextBackoffDelay === "number") {
        this.computeNextBackoffDelay = () => computeNextBackoffDelay;
      } else {
        this.computeNextBackoffDelay = computeNextBackoffDelay;
      }
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
      const token = await super.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
      token.getRetryDelay = () => this.computeNextBackoffDelay(token.getRetryCount());
      return token;
    }
  };
});

// ../../node_modules/@smithy/middleware-retry/dist-cjs/isStreamingPayload/isStreamingPayload.js
var require_isStreamingPayload = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isStreamingPayload = undefined;
  var stream_1 = __require("stream");
  var isStreamingPayload2 = (request2) => (request2 === null || request2 === undefined ? undefined : request2.body) instanceof stream_1.Readable || typeof ReadableStream !== "undefined" && (request2 === null || request2 === undefined ? undefined : request2.body) instanceof ReadableStream;
  exports.isStreamingPayload = isStreamingPayload2;
});

// ../../node_modules/@smithy/middleware-retry/dist-cjs/index.js
var require_dist_cjs37 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    AdaptiveRetryStrategy: () => AdaptiveRetryStrategy4,
    CONFIG_MAX_ATTEMPTS: () => CONFIG_MAX_ATTEMPTS2,
    CONFIG_RETRY_MODE: () => CONFIG_RETRY_MODE2,
    ENV_MAX_ATTEMPTS: () => ENV_MAX_ATTEMPTS2,
    ENV_RETRY_MODE: () => ENV_RETRY_MODE2,
    NODE_MAX_ATTEMPT_CONFIG_OPTIONS: () => NODE_MAX_ATTEMPT_CONFIG_OPTIONS2,
    NODE_RETRY_MODE_CONFIG_OPTIONS: () => NODE_RETRY_MODE_CONFIG_OPTIONS2,
    StandardRetryStrategy: () => StandardRetryStrategy5,
    defaultDelayDecider: () => defaultDelayDecider2,
    defaultRetryDecider: () => defaultRetryDecider2,
    getOmitRetryHeadersPlugin: () => getOmitRetryHeadersPlugin,
    getRetryAfterHint: () => getRetryAfterHint2,
    getRetryPlugin: () => getRetryPlugin2,
    omitRetryHeadersMiddleware: () => omitRetryHeadersMiddleware2,
    omitRetryHeadersMiddlewareOptions: () => omitRetryHeadersMiddlewareOptions,
    resolveRetryConfig: () => resolveRetryConfig2,
    retryMiddleware: () => retryMiddleware3,
    retryMiddlewareOptions: () => retryMiddlewareOptions2
  });
  module.exports = __toCommonJS(src_exports);
  var import_protocol_http23 = require_dist_cjs2();
  var import_uuid2 = require_dist();
  var import_util_retry8 = require_dist_cjs36();
  var getDefaultRetryQuota2 = /* @__PURE__ */ __name2((initialRetryTokens, options) => {
    const MAX_CAPACITY = initialRetryTokens;
    const noRetryIncrement = options?.noRetryIncrement ?? import_util_retry8.NO_RETRY_INCREMENT;
    const retryCost = options?.retryCost ?? import_util_retry8.RETRY_COST;
    const timeoutRetryCost = options?.timeoutRetryCost ?? import_util_retry8.TIMEOUT_RETRY_COST;
    let availableCapacity = initialRetryTokens;
    const getCapacityAmount = /* @__PURE__ */ __name2((error) => error.name === "TimeoutError" ? timeoutRetryCost : retryCost, "getCapacityAmount");
    const hasRetryTokens = /* @__PURE__ */ __name2((error) => getCapacityAmount(error) <= availableCapacity, "hasRetryTokens");
    const retrieveRetryTokens = /* @__PURE__ */ __name2((error) => {
      if (!hasRetryTokens(error)) {
        throw new Error("No retry token available");
      }
      const capacityAmount = getCapacityAmount(error);
      availableCapacity -= capacityAmount;
      return capacityAmount;
    }, "retrieveRetryTokens");
    const releaseRetryTokens = /* @__PURE__ */ __name2((capacityReleaseAmount) => {
      availableCapacity += capacityReleaseAmount ?? noRetryIncrement;
      availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
    }, "releaseRetryTokens");
    return Object.freeze({
      hasRetryTokens,
      retrieveRetryTokens,
      releaseRetryTokens
    });
  }, "getDefaultRetryQuota");
  var defaultDelayDecider2 = /* @__PURE__ */ __name2((delayBase, attempts) => Math.floor(Math.min(import_util_retry8.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase)), "defaultDelayDecider");
  var import_service_error_classification5 = require_dist_cjs35();
  var defaultRetryDecider2 = /* @__PURE__ */ __name2((error) => {
    if (!error) {
      return false;
    }
    return (0, import_service_error_classification5.isRetryableByTrait)(error) || (0, import_service_error_classification5.isClockSkewError)(error) || (0, import_service_error_classification5.isThrottlingError)(error) || (0, import_service_error_classification5.isTransientError)(error);
  }, "defaultRetryDecider");
  var asSdkError2 = /* @__PURE__ */ __name2((error) => {
    if (error instanceof Error)
      return error;
    if (error instanceof Object)
      return Object.assign(new Error, error);
    if (typeof error === "string")
      return new Error(error);
    return new Error(`AWS SDK error wrapper for ${error}`);
  }, "asSdkError");
  var StandardRetryStrategy5 = class {
    constructor(maxAttemptsProvider, options) {
      this.maxAttemptsProvider = maxAttemptsProvider;
      this.mode = import_util_retry8.RETRY_MODES.STANDARD;
      this.retryDecider = options?.retryDecider ?? defaultRetryDecider2;
      this.delayDecider = options?.delayDecider ?? defaultDelayDecider2;
      this.retryQuota = options?.retryQuota ?? getDefaultRetryQuota2(import_util_retry8.INITIAL_RETRY_TOKENS);
    }
    static {
      __name2(this, "StandardRetryStrategy");
    }
    shouldRetry(error, attempts, maxAttempts) {
      return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);
    }
    async getMaxAttempts() {
      let maxAttempts;
      try {
        maxAttempts = await this.maxAttemptsProvider();
      } catch (error) {
        maxAttempts = import_util_retry8.DEFAULT_MAX_ATTEMPTS;
      }
      return maxAttempts;
    }
    async retry(next, args, options) {
      let retryTokenAmount;
      let attempts = 0;
      let totalDelay = 0;
      const maxAttempts = await this.getMaxAttempts();
      const { request: request2 } = args;
      if (import_protocol_http23.HttpRequest.isInstance(request2)) {
        request2.headers[import_util_retry8.INVOCATION_ID_HEADER] = (0, import_uuid2.v4)();
      }
      while (true) {
        try {
          if (import_protocol_http23.HttpRequest.isInstance(request2)) {
            request2.headers[import_util_retry8.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
          }
          if (options?.beforeRequest) {
            await options.beforeRequest();
          }
          const { response, output } = await next(args);
          if (options?.afterRequest) {
            options.afterRequest(response);
          }
          this.retryQuota.releaseRetryTokens(retryTokenAmount);
          output.$metadata.attempts = attempts + 1;
          output.$metadata.totalRetryDelay = totalDelay;
          return { response, output };
        } catch (e3) {
          const err = asSdkError2(e3);
          attempts++;
          if (this.shouldRetry(err, attempts, maxAttempts)) {
            retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);
            const delayFromDecider = this.delayDecider((0, import_service_error_classification5.isThrottlingError)(err) ? import_util_retry8.THROTTLING_RETRY_DELAY_BASE : import_util_retry8.DEFAULT_RETRY_DELAY_BASE, attempts);
            const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);
            const delay = Math.max(delayFromResponse || 0, delayFromDecider);
            totalDelay += delay;
            await new Promise((resolve2) => setTimeout(resolve2, delay));
            continue;
          }
          if (!err.$metadata) {
            err.$metadata = {};
          }
          err.$metadata.attempts = attempts;
          err.$metadata.totalRetryDelay = totalDelay;
          throw err;
        }
      }
    }
  };
  var getDelayFromRetryAfterHeader = /* @__PURE__ */ __name2((response) => {
    if (!import_protocol_http23.HttpResponse.isInstance(response))
      return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
      return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
      return retryAfterSeconds * 1000;
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate.getTime() - Date.now();
  }, "getDelayFromRetryAfterHeader");
  var AdaptiveRetryStrategy4 = class extends StandardRetryStrategy5 {
    static {
      __name2(this, "AdaptiveRetryStrategy");
    }
    constructor(maxAttemptsProvider, options) {
      const { rateLimiter, ...superOptions } = options ?? {};
      super(maxAttemptsProvider, superOptions);
      this.rateLimiter = rateLimiter ?? new import_util_retry8.DefaultRateLimiter;
      this.mode = import_util_retry8.RETRY_MODES.ADAPTIVE;
    }
    async retry(next, args) {
      return super.retry(next, args, {
        beforeRequest: async () => {
          return this.rateLimiter.getSendToken();
        },
        afterRequest: (response) => {
          this.rateLimiter.updateClientSendingRate(response);
        }
      });
    }
  };
  var import_util_middleware10 = require_dist_cjs3();
  var ENV_MAX_ATTEMPTS2 = "AWS_MAX_ATTEMPTS";
  var CONFIG_MAX_ATTEMPTS2 = "max_attempts";
  var NODE_MAX_ATTEMPT_CONFIG_OPTIONS2 = {
    environmentVariableSelector: (env2) => {
      const value = env2[ENV_MAX_ATTEMPTS2];
      if (!value)
        return;
      const maxAttempt = parseInt(value);
      if (Number.isNaN(maxAttempt)) {
        throw new Error(`Environment variable ${ENV_MAX_ATTEMPTS2} mast be a number, got "${value}"`);
      }
      return maxAttempt;
    },
    configFileSelector: (profile) => {
      const value = profile[CONFIG_MAX_ATTEMPTS2];
      if (!value)
        return;
      const maxAttempt = parseInt(value);
      if (Number.isNaN(maxAttempt)) {
        throw new Error(`Shared config file entry ${CONFIG_MAX_ATTEMPTS2} mast be a number, got "${value}"`);
      }
      return maxAttempt;
    },
    default: import_util_retry8.DEFAULT_MAX_ATTEMPTS
  };
  var resolveRetryConfig2 = /* @__PURE__ */ __name2((input) => {
    const { retryStrategy } = input;
    const maxAttempts = (0, import_util_middleware10.normalizeProvider)(input.maxAttempts ?? import_util_retry8.DEFAULT_MAX_ATTEMPTS);
    return {
      ...input,
      maxAttempts,
      retryStrategy: async () => {
        if (retryStrategy) {
          return retryStrategy;
        }
        const retryMode = await (0, import_util_middleware10.normalizeProvider)(input.retryMode)();
        if (retryMode === import_util_retry8.RETRY_MODES.ADAPTIVE) {
          return new import_util_retry8.AdaptiveRetryStrategy(maxAttempts);
        }
        return new import_util_retry8.StandardRetryStrategy(maxAttempts);
      }
    };
  }, "resolveRetryConfig");
  var ENV_RETRY_MODE2 = "AWS_RETRY_MODE";
  var CONFIG_RETRY_MODE2 = "retry_mode";
  var NODE_RETRY_MODE_CONFIG_OPTIONS2 = {
    environmentVariableSelector: (env2) => env2[ENV_RETRY_MODE2],
    configFileSelector: (profile) => profile[CONFIG_RETRY_MODE2],
    default: import_util_retry8.DEFAULT_RETRY_MODE
  };
  var omitRetryHeadersMiddleware2 = /* @__PURE__ */ __name2(() => (next) => async (args) => {
    const { request: request2 } = args;
    if (import_protocol_http23.HttpRequest.isInstance(request2)) {
      delete request2.headers[import_util_retry8.INVOCATION_ID_HEADER];
      delete request2.headers[import_util_retry8.REQUEST_HEADER];
    }
    return next(args);
  }, "omitRetryHeadersMiddleware");
  var omitRetryHeadersMiddlewareOptions = {
    name: "omitRetryHeadersMiddleware",
    tags: ["RETRY", "HEADERS", "OMIT_RETRY_HEADERS"],
    relation: "before",
    toMiddleware: "awsAuthMiddleware",
    override: true
  };
  var getOmitRetryHeadersPlugin = /* @__PURE__ */ __name2((options) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(omitRetryHeadersMiddleware2(), omitRetryHeadersMiddlewareOptions);
    }
  }), "getOmitRetryHeadersPlugin");
  var import_smithy_client10 = require_dist_cjs19();
  var import_isStreamingPayload2 = require_isStreamingPayload();
  var retryMiddleware3 = /* @__PURE__ */ __name2((options) => (next, context) => async (args) => {
    let retryStrategy = await options.retryStrategy();
    const maxAttempts = await options.maxAttempts();
    if (isRetryStrategyV22(retryStrategy)) {
      retryStrategy = retryStrategy;
      let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
      let lastError = new Error;
      let attempts = 0;
      let totalRetryDelay = 0;
      const { request: request2 } = args;
      const isRequest = import_protocol_http23.HttpRequest.isInstance(request2);
      if (isRequest) {
        request2.headers[import_util_retry8.INVOCATION_ID_HEADER] = (0, import_uuid2.v4)();
      }
      while (true) {
        try {
          if (isRequest) {
            request2.headers[import_util_retry8.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
          }
          const { response, output } = await next(args);
          retryStrategy.recordSuccess(retryToken);
          output.$metadata.attempts = attempts + 1;
          output.$metadata.totalRetryDelay = totalRetryDelay;
          return { response, output };
        } catch (e3) {
          const retryErrorInfo = getRetryErrorInfo2(e3);
          lastError = asSdkError2(e3);
          if (isRequest && (0, import_isStreamingPayload2.isStreamingPayload)(request2)) {
            (context.logger instanceof import_smithy_client10.NoOpLogger ? console : context.logger)?.warn("An error was encountered in a non-retryable streaming request.");
            throw lastError;
          }
          try {
            retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
          } catch (refreshError) {
            if (!lastError.$metadata) {
              lastError.$metadata = {};
            }
            lastError.$metadata.attempts = attempts + 1;
            lastError.$metadata.totalRetryDelay = totalRetryDelay;
            throw lastError;
          }
          attempts = retryToken.getRetryCount();
          const delay = retryToken.getRetryDelay();
          totalRetryDelay += delay;
          await new Promise((resolve2) => setTimeout(resolve2, delay));
        }
      }
    } else {
      retryStrategy = retryStrategy;
      if (retryStrategy?.mode)
        context.userAgent = [...context.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
      return retryStrategy.retry(next, args);
    }
  }, "retryMiddleware");
  var isRetryStrategyV22 = /* @__PURE__ */ __name2((retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined", "isRetryStrategyV2");
  var getRetryErrorInfo2 = /* @__PURE__ */ __name2((error) => {
    const errorInfo = {
      error,
      errorType: getRetryErrorType2(error)
    };
    const retryAfterHint = getRetryAfterHint2(error.$response);
    if (retryAfterHint) {
      errorInfo.retryAfterHint = retryAfterHint;
    }
    return errorInfo;
  }, "getRetryErrorInfo");
  var getRetryErrorType2 = /* @__PURE__ */ __name2((error) => {
    if ((0, import_service_error_classification5.isThrottlingError)(error))
      return "THROTTLING";
    if ((0, import_service_error_classification5.isTransientError)(error))
      return "TRANSIENT";
    if ((0, import_service_error_classification5.isServerError)(error))
      return "SERVER_ERROR";
    return "CLIENT_ERROR";
  }, "getRetryErrorType");
  var retryMiddlewareOptions2 = {
    name: "retryMiddleware",
    tags: ["RETRY"],
    step: "finalizeRequest",
    priority: "high",
    override: true
  };
  var getRetryPlugin2 = /* @__PURE__ */ __name2((options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(retryMiddleware3(options), retryMiddlewareOptions2);
    }
  }), "getRetryPlugin");
  var getRetryAfterHint2 = /* @__PURE__ */ __name2((response) => {
    if (!import_protocol_http23.HttpResponse.isInstance(response))
      return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
      return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
      return new Date(retryAfterSeconds * 1000);
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate;
  }, "getRetryAfterHint");
});

// ../../node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/auth/httpAuthSchemeProvider.js
var require_httpAuthSchemeProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveHttpAuthSchemeConfig = exports.defaultSSOOIDCHttpAuthSchemeProvider = exports.defaultSSOOIDCHttpAuthSchemeParametersProvider = undefined;
  var core_1 = require_dist_cjs20();
  var util_middleware_1 = require_dist_cjs3();
  var defaultSSOOIDCHttpAuthSchemeParametersProvider = async (config4, context, input) => {
    return {
      operation: (0, util_middleware_1.getSmithyContext)(context).operation,
      region: await (0, util_middleware_1.normalizeProvider)(config4.region)() || (() => {
        throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
      })()
    };
  };
  exports.defaultSSOOIDCHttpAuthSchemeParametersProvider = defaultSSOOIDCHttpAuthSchemeParametersProvider;
  function createAwsAuthSigv4HttpAuthOption2(authParameters) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "sso-oauth",
        region: authParameters.region
      },
      propertiesExtractor: (config4, context) => ({
        signingProperties: {
          config: config4,
          context
        }
      })
    };
  }
  function createSmithyApiNoAuthHttpAuthOption(authParameters) {
    return {
      schemeId: "smithy.api#noAuth"
    };
  }
  var defaultSSOOIDCHttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
      case "CreateToken": {
        options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
        break;
      }
      default: {
        options.push(createAwsAuthSigv4HttpAuthOption2(authParameters));
      }
    }
    return options;
  };
  exports.defaultSSOOIDCHttpAuthSchemeProvider = defaultSSOOIDCHttpAuthSchemeProvider;
  var resolveHttpAuthSchemeConfig2 = (config4) => {
    const config_0 = (0, core_1.resolveAwsSdkSigV4Config)(config4);
    return {
      ...config_0
    };
  };
  exports.resolveHttpAuthSchemeConfig = resolveHttpAuthSchemeConfig2;
});

// ../../node_modules/@aws-sdk/nested-clients/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "@aws-sdk/nested-clients",
    version: "3.734.0",
    description: "Nested clients for AWS SDK packages.",
    main: "./dist-cjs/index.js",
    module: "./dist-es/index.js",
    types: "./dist-types/index.d.ts",
    scripts: {
      build: "yarn lint && concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline nested-clients",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      lint: "node ../../scripts/validation/submodules-linter.js --pkg nested-clients",
      test: "yarn g:vitest run",
      "test:watch": "yarn g:vitest watch"
    },
    engines: {
      node: ">=18.0.0"
    },
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.734.0",
      "@aws-sdk/middleware-host-header": "3.734.0",
      "@aws-sdk/middleware-logger": "3.734.0",
      "@aws-sdk/middleware-recursion-detection": "3.734.0",
      "@aws-sdk/middleware-user-agent": "3.734.0",
      "@aws-sdk/region-config-resolver": "3.734.0",
      "@aws-sdk/types": "3.734.0",
      "@aws-sdk/util-endpoints": "3.734.0",
      "@aws-sdk/util-user-agent-browser": "3.734.0",
      "@aws-sdk/util-user-agent-node": "3.734.0",
      "@smithy/config-resolver": "^4.0.1",
      "@smithy/core": "^3.1.1",
      "@smithy/fetch-http-handler": "^5.0.1",
      "@smithy/hash-node": "^4.0.1",
      "@smithy/invalid-dependency": "^4.0.1",
      "@smithy/middleware-content-length": "^4.0.1",
      "@smithy/middleware-endpoint": "^4.0.2",
      "@smithy/middleware-retry": "^4.0.3",
      "@smithy/middleware-serde": "^4.0.1",
      "@smithy/middleware-stack": "^4.0.1",
      "@smithy/node-config-provider": "^4.0.1",
      "@smithy/node-http-handler": "^4.0.2",
      "@smithy/protocol-http": "^5.0.1",
      "@smithy/smithy-client": "^4.1.2",
      "@smithy/types": "^4.1.0",
      "@smithy/url-parser": "^4.0.1",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.3",
      "@smithy/util-defaults-mode-node": "^4.0.3",
      "@smithy/util-endpoints": "^3.0.1",
      "@smithy/util-middleware": "^4.0.1",
      "@smithy/util-retry": "^4.0.1",
      "@smithy/util-utf8": "^4.0.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.2.2"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": [
          "dist-types/ts3.4/*"
        ]
      }
    },
    files: [
      "./sso-oidc.d.ts",
      "./sso-oidc.js",
      "./sts.d.ts",
      "./sts.js",
      "dist-*/**"
    ],
    browser: {
      "./dist-es/submodules/sso-oidc/runtimeConfig": "./dist-es/submodules/sso-oidc/runtimeConfig.browser",
      "./dist-es/submodules/sts/runtimeConfig": "./dist-es/submodules/sts/runtimeConfig.browser"
    },
    "react-native": {},
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/nested-clients",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "packages/nested-clients"
    },
    exports: {
      "./sso-oidc": {
        module: "./dist-es/submodules/sso-oidc/index.js",
        node: "./dist-cjs/submodules/sso-oidc/index.js",
        import: "./dist-es/submodules/sso-oidc/index.js",
        require: "./dist-cjs/submodules/sso-oidc/index.js",
        types: "./dist-types/submodules/sso-oidc/index.d.ts"
      },
      "./sts": {
        module: "./dist-es/submodules/sts/index.js",
        node: "./dist-cjs/submodules/sts/index.js",
        import: "./dist-es/submodules/sts/index.js",
        require: "./dist-cjs/submodules/sts/index.js",
        types: "./dist-types/submodules/sts/index.d.ts"
      }
    }
  };
});

// ../../node_modules/@aws-sdk/util-user-agent-node/dist-cjs/index.js
var require_dist_cjs38 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    NODE_APP_ID_CONFIG_OPTIONS: () => NODE_APP_ID_CONFIG_OPTIONS,
    UA_APP_ID_ENV_NAME: () => UA_APP_ID_ENV_NAME,
    UA_APP_ID_INI_NAME: () => UA_APP_ID_INI_NAME,
    createDefaultUserAgentProvider: () => createDefaultUserAgentProvider,
    crtAvailability: () => crtAvailability,
    defaultUserAgent: () => defaultUserAgent
  });
  module.exports = __toCommonJS(src_exports);
  var import_os2 = __require("os");
  var import_process = __require("process");
  var crtAvailability = {
    isCrtAvailable: false
  };
  var isCrtAvailable = /* @__PURE__ */ __name2(() => {
    if (crtAvailability.isCrtAvailable) {
      return ["md/crt-avail"];
    }
    return null;
  }, "isCrtAvailable");
  var createDefaultUserAgentProvider = /* @__PURE__ */ __name2(({ serviceId, clientVersion }) => {
    return async (config4) => {
      const sections = [
        ["aws-sdk-js", clientVersion],
        ["ua", "2.1"],
        [`os/${(0, import_os2.platform)()}`, (0, import_os2.release)()],
        ["lang/js"],
        ["md/nodejs", `${import_process.versions.node}`]
      ];
      const crtAvailable = isCrtAvailable();
      if (crtAvailable) {
        sections.push(crtAvailable);
      }
      if (serviceId) {
        sections.push([`api/${serviceId}`, clientVersion]);
      }
      if (import_process.env.AWS_EXECUTION_ENV) {
        sections.push([`exec-env/${import_process.env.AWS_EXECUTION_ENV}`]);
      }
      const appId = await config4?.userAgentAppId?.();
      const resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
      return resolvedUserAgent;
    };
  }, "createDefaultUserAgentProvider");
  var defaultUserAgent = createDefaultUserAgentProvider;
  var import_middleware_user_agent = require_dist_cjs26();
  var UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
  var UA_APP_ID_INI_NAME = "sdk_ua_app_id";
  var UA_APP_ID_INI_NAME_DEPRECATED = "sdk-ua-app-id";
  var NODE_APP_ID_CONFIG_OPTIONS = {
    environmentVariableSelector: (env2) => env2[UA_APP_ID_ENV_NAME],
    configFileSelector: (profile) => profile[UA_APP_ID_INI_NAME] ?? profile[UA_APP_ID_INI_NAME_DEPRECATED],
    default: import_middleware_user_agent.DEFAULT_UA_APP_ID
  };
});

// ../../node_modules/@smithy/hash-node/dist-cjs/index.js
var require_dist_cjs39 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Hash: () => Hash
  });
  module.exports = __toCommonJS(src_exports);
  var import_util_buffer_from8 = require_dist_cjs6();
  var import_util_utf810 = require_dist_cjs7();
  var import_buffer5 = __require("buffer");
  var import_crypto3 = __require("crypto");
  var Hash = class {
    static {
      __name2(this, "Hash");
    }
    constructor(algorithmIdentifier, secret) {
      this.algorithmIdentifier = algorithmIdentifier;
      this.secret = secret;
      this.reset();
    }
    update(toHash, encoding) {
      this.hash.update((0, import_util_utf810.toUint8Array)(castSourceData(toHash, encoding)));
    }
    digest() {
      return Promise.resolve(this.hash.digest());
    }
    reset() {
      this.hash = this.secret ? (0, import_crypto3.createHmac)(this.algorithmIdentifier, castSourceData(this.secret)) : (0, import_crypto3.createHash)(this.algorithmIdentifier);
    }
  };
  function castSourceData(toCast, encoding) {
    if (import_buffer5.Buffer.isBuffer(toCast)) {
      return toCast;
    }
    if (typeof toCast === "string") {
      return (0, import_util_buffer_from8.fromString)(toCast, encoding);
    }
    if (ArrayBuffer.isView(toCast)) {
      return (0, import_util_buffer_from8.fromArrayBuffer)(toCast.buffer, toCast.byteOffset, toCast.byteLength);
    }
    return (0, import_util_buffer_from8.fromArrayBuffer)(toCast);
  }
  __name2(castSourceData, "castSourceData");
});

// ../../node_modules/@smithy/util-body-length-node/dist-cjs/index.js
var require_dist_cjs40 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    calculateBodyLength: () => calculateBodyLength
  });
  module.exports = __toCommonJS(src_exports);
  var import_fs3 = __require("fs");
  var calculateBodyLength = /* @__PURE__ */ __name2((body) => {
    if (!body) {
      return 0;
    }
    if (typeof body === "string") {
      return Buffer.byteLength(body);
    } else if (typeof body.byteLength === "number") {
      return body.byteLength;
    } else if (typeof body.size === "number") {
      return body.size;
    } else if (typeof body.start === "number" && typeof body.end === "number") {
      return body.end + 1 - body.start;
    } else if (typeof body.path === "string" || Buffer.isBuffer(body.path)) {
      return (0, import_fs3.lstatSync)(body.path).size;
    } else if (typeof body.fd === "number") {
      return (0, import_fs3.fstatSync)(body.fd).size;
    }
    throw new Error(`Body Length computation failed for ${body}`);
  }, "calculateBodyLength");
});

// ../../node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/endpoint/ruleset.js
var require_ruleset = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ruleSet = undefined;
  var u4 = "required";
  var v6 = "fn";
  var w3 = "argv";
  var x3 = "ref";
  var a4 = true;
  var b2 = "isSet";
  var c4 = "booleanEquals";
  var d3 = "error";
  var e3 = "endpoint";
  var f3 = "tree";
  var g2 = "PartitionResult";
  var h3 = "getAttr";
  var i3 = { [u4]: false, type: "String" };
  var j3 = { [u4]: true, default: false, type: "Boolean" };
  var k3 = { [x3]: "Endpoint" };
  var l3 = { [v6]: c4, [w3]: [{ [x3]: "UseFIPS" }, true] };
  var m3 = { [v6]: c4, [w3]: [{ [x3]: "UseDualStack" }, true] };
  var n3 = {};
  var o2 = { [v6]: h3, [w3]: [{ [x3]: g2 }, "supportsFIPS"] };
  var p4 = { [x3]: g2 };
  var q3 = { [v6]: c4, [w3]: [true, { [v6]: h3, [w3]: [p4, "supportsDualStack"] }] };
  var r4 = [l3];
  var s4 = [m3];
  var t3 = [{ [x3]: "Region" }];
  var _data2 = { version: "1.0", parameters: { Region: i3, UseDualStack: j3, UseFIPS: j3, Endpoint: i3 }, rules: [{ conditions: [{ [v6]: b2, [w3]: [k3] }], rules: [{ conditions: r4, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d3 }, { conditions: s4, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d3 }, { endpoint: { url: k3, properties: n3, headers: n3 }, type: e3 }], type: f3 }, { conditions: [{ [v6]: b2, [w3]: t3 }], rules: [{ conditions: [{ [v6]: "aws.partition", [w3]: t3, assign: g2 }], rules: [{ conditions: [l3, m3], rules: [{ conditions: [{ [v6]: c4, [w3]: [a4, o2] }, q3], rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n3, headers: n3 }, type: e3 }], type: f3 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d3 }], type: f3 }, { conditions: r4, rules: [{ conditions: [{ [v6]: c4, [w3]: [o2, a4] }], rules: [{ conditions: [{ [v6]: "stringEquals", [w3]: [{ [v6]: h3, [w3]: [p4, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://oidc.{Region}.amazonaws.com", properties: n3, headers: n3 }, type: e3 }, { endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n3, headers: n3 }, type: e3 }], type: f3 }, { error: "FIPS is enabled but this partition does not support FIPS", type: d3 }], type: f3 }, { conditions: s4, rules: [{ conditions: [q3], rules: [{ endpoint: { url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n3, headers: n3 }, type: e3 }], type: f3 }, { error: "DualStack is enabled but this partition does not support DualStack", type: d3 }], type: f3 }, { endpoint: { url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}", properties: n3, headers: n3 }, type: e3 }], type: f3 }], type: f3 }, { error: "Invalid Configuration: Missing Region", type: d3 }] };
  exports.ruleSet = _data2;
});

// ../../node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/endpoint/endpointResolver.js
var require_endpointResolver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultEndpointResolver = undefined;
  var util_endpoints_1 = require_dist_cjs25();
  var util_endpoints_2 = require_dist_cjs24();
  var ruleset_1 = require_ruleset();
  var cache2 = new util_endpoints_2.EndpointCache({
    size: 50,
    params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
  });
  var defaultEndpointResolver2 = (endpointParams, context = {}) => {
    return cache2.get(endpointParams, () => (0, util_endpoints_2.resolveEndpoint)(ruleset_1.ruleSet, {
      endpointParams,
      logger: context.logger
    }));
  };
  exports.defaultEndpointResolver = defaultEndpointResolver2;
  util_endpoints_2.customEndpointFunctions.aws = util_endpoints_1.awsEndpointFunctions;
});

// ../../node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/runtimeConfig.shared.js
var require_runtimeConfig_shared = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var core_1 = require_dist_cjs20();
  var core_2 = require_dist_cjs15();
  var smithy_client_1 = require_dist_cjs19();
  var url_parser_1 = require_dist_cjs33();
  var util_base64_1 = require_dist_cjs8();
  var util_utf8_1 = require_dist_cjs7();
  var httpAuthSchemeProvider_1 = require_httpAuthSchemeProvider();
  var endpointResolver_1 = require_endpointResolver();
  var getRuntimeConfig = (config4) => {
    return {
      apiVersion: "2019-06-10",
      base64Decoder: config4?.base64Decoder ?? util_base64_1.fromBase64,
      base64Encoder: config4?.base64Encoder ?? util_base64_1.toBase64,
      disableHostPrefix: config4?.disableHostPrefix ?? false,
      endpointProvider: config4?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
      extensions: config4?.extensions ?? [],
      httpAuthSchemeProvider: config4?.httpAuthSchemeProvider ?? httpAuthSchemeProvider_1.defaultSSOOIDCHttpAuthSchemeProvider,
      httpAuthSchemes: config4?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
          signer: new core_1.AwsSdkSigV4Signer
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new core_2.NoAuthSigner
        }
      ],
      logger: config4?.logger ?? new smithy_client_1.NoOpLogger,
      serviceId: config4?.serviceId ?? "SSO OIDC",
      urlParser: config4?.urlParser ?? url_parser_1.parseUrl,
      utf8Decoder: config4?.utf8Decoder ?? util_utf8_1.fromUtf8,
      utf8Encoder: config4?.utf8Encoder ?? util_utf8_1.toUtf8
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// ../../node_modules/@smithy/credential-provider-imds/dist-cjs/index.js
var require_dist_cjs41 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    DEFAULT_MAX_RETRIES: () => DEFAULT_MAX_RETRIES2,
    DEFAULT_TIMEOUT: () => DEFAULT_TIMEOUT2,
    ENV_CMDS_AUTH_TOKEN: () => ENV_CMDS_AUTH_TOKEN2,
    ENV_CMDS_FULL_URI: () => ENV_CMDS_FULL_URI2,
    ENV_CMDS_RELATIVE_URI: () => ENV_CMDS_RELATIVE_URI2,
    Endpoint: () => Endpoint2,
    fromContainerMetadata: () => fromContainerMetadata3,
    fromInstanceMetadata: () => fromInstanceMetadata3,
    getInstanceMetadataEndpoint: () => getInstanceMetadataEndpoint2,
    httpRequest: () => httpRequest3,
    providerConfigFromInit: () => providerConfigFromInit2
  });
  module.exports = __toCommonJS(src_exports);
  var import_url8 = __require("url");
  var import_property_provider14 = require_dist_cjs16();
  var import_buffer5 = __require("buffer");
  var import_http3 = __require("http");
  function httpRequest3(options) {
    return new Promise((resolve2, reject) => {
      const req = (0, import_http3.request)({
        method: "GET",
        ...options,
        hostname: options.hostname?.replace(/^\[(.+)\]$/, "$1")
      });
      req.on("error", (err) => {
        reject(Object.assign(new import_property_provider14.ProviderError("Unable to connect to instance metadata service"), err));
        req.destroy();
      });
      req.on("timeout", () => {
        reject(new import_property_provider14.ProviderError("TimeoutError from instance metadata service"));
        req.destroy();
      });
      req.on("response", (res) => {
        const { statusCode = 400 } = res;
        if (statusCode < 200 || 300 <= statusCode) {
          reject(Object.assign(new import_property_provider14.ProviderError("Error response received from instance metadata service"), { statusCode }));
          req.destroy();
        }
        const chunks = [];
        res.on("data", (chunk) => {
          chunks.push(chunk);
        });
        res.on("end", () => {
          resolve2(import_buffer5.Buffer.concat(chunks));
          req.destroy();
        });
      });
      req.end();
    });
  }
  __name2(httpRequest3, "httpRequest");
  var isImdsCredentials2 = /* @__PURE__ */ __name2((arg) => Boolean(arg) && typeof arg === "object" && typeof arg.AccessKeyId === "string" && typeof arg.SecretAccessKey === "string" && typeof arg.Token === "string" && typeof arg.Expiration === "string", "isImdsCredentials");
  var fromImdsCredentials2 = /* @__PURE__ */ __name2((creds) => ({
    accessKeyId: creds.AccessKeyId,
    secretAccessKey: creds.SecretAccessKey,
    sessionToken: creds.Token,
    expiration: new Date(creds.Expiration),
    ...creds.AccountId && { accountId: creds.AccountId }
  }), "fromImdsCredentials");
  var DEFAULT_TIMEOUT2 = 1000;
  var DEFAULT_MAX_RETRIES2 = 0;
  var providerConfigFromInit2 = /* @__PURE__ */ __name2(({
    maxRetries = DEFAULT_MAX_RETRIES2,
    timeout = DEFAULT_TIMEOUT2
  }) => ({ maxRetries, timeout }), "providerConfigFromInit");
  var retry2 = /* @__PURE__ */ __name2((toRetry, maxRetries) => {
    let promise = toRetry();
    for (let i3 = 0;i3 < maxRetries; i3++) {
      promise = promise.catch(toRetry);
    }
    return promise;
  }, "retry");
  var ENV_CMDS_FULL_URI2 = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
  var ENV_CMDS_RELATIVE_URI2 = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
  var ENV_CMDS_AUTH_TOKEN2 = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
  var fromContainerMetadata3 = /* @__PURE__ */ __name2((init2 = {}) => {
    const { timeout, maxRetries } = providerConfigFromInit2(init2);
    return () => retry2(async () => {
      const requestOptions = await getCmdsUri2({ logger: init2.logger });
      const credsResponse = JSON.parse(await requestFromEcsImds2(timeout, requestOptions));
      if (!isImdsCredentials2(credsResponse)) {
        throw new import_property_provider14.CredentialsProviderError("Invalid response received from instance metadata service.", {
          logger: init2.logger
        });
      }
      return fromImdsCredentials2(credsResponse);
    }, maxRetries);
  }, "fromContainerMetadata");
  var requestFromEcsImds2 = /* @__PURE__ */ __name2(async (timeout, options) => {
    if (process.env[ENV_CMDS_AUTH_TOKEN2]) {
      options.headers = {
        ...options.headers,
        Authorization: process.env[ENV_CMDS_AUTH_TOKEN2]
      };
    }
    const buffer = await httpRequest3({
      ...options,
      timeout
    });
    return buffer.toString();
  }, "requestFromEcsImds");
  var CMDS_IP2 = "169.254.170.2";
  var GREENGRASS_HOSTS2 = {
    localhost: true,
    "127.0.0.1": true
  };
  var GREENGRASS_PROTOCOLS2 = {
    "http:": true,
    "https:": true
  };
  var getCmdsUri2 = /* @__PURE__ */ __name2(async ({ logger: logger2 }) => {
    if (process.env[ENV_CMDS_RELATIVE_URI2]) {
      return {
        hostname: CMDS_IP2,
        path: process.env[ENV_CMDS_RELATIVE_URI2]
      };
    }
    if (process.env[ENV_CMDS_FULL_URI2]) {
      const parsed = (0, import_url8.parse)(process.env[ENV_CMDS_FULL_URI2]);
      if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS2)) {
        throw new import_property_provider14.CredentialsProviderError(`${parsed.hostname} is not a valid container metadata service hostname`, {
          tryNextLink: false,
          logger: logger2
        });
      }
      if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS2)) {
        throw new import_property_provider14.CredentialsProviderError(`${parsed.protocol} is not a valid container metadata service protocol`, {
          tryNextLink: false,
          logger: logger2
        });
      }
      return {
        ...parsed,
        port: parsed.port ? parseInt(parsed.port, 10) : undefined
      };
    }
    throw new import_property_provider14.CredentialsProviderError(`The container metadata credential provider cannot be used unless the ${ENV_CMDS_RELATIVE_URI2} or ${ENV_CMDS_FULL_URI2} environment variable is set`, {
      tryNextLink: false,
      logger: logger2
    });
  }, "getCmdsUri");
  var InstanceMetadataV1FallbackError2 = class _InstanceMetadataV1FallbackError extends import_property_provider14.CredentialsProviderError {
    constructor(message, tryNextLink = true) {
      super(message, tryNextLink);
      this.tryNextLink = tryNextLink;
      this.name = "InstanceMetadataV1FallbackError";
      Object.setPrototypeOf(this, _InstanceMetadataV1FallbackError.prototype);
    }
    static {
      __name2(this, "InstanceMetadataV1FallbackError");
    }
  };
  var import_node_config_provider4 = require_dist_cjs31();
  var import_url_parser3 = require_dist_cjs33();
  var Endpoint2 = /* @__PURE__ */ ((Endpoint22) => {
    Endpoint22["IPv4"] = "http://169.254.169.254";
    Endpoint22["IPv6"] = "http://[fd00:ec2::254]";
    return Endpoint22;
  })(Endpoint2 || {});
  var ENV_ENDPOINT_NAME2 = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
  var CONFIG_ENDPOINT_NAME2 = "ec2_metadata_service_endpoint";
  var ENDPOINT_CONFIG_OPTIONS2 = {
    environmentVariableSelector: (env2) => env2[ENV_ENDPOINT_NAME2],
    configFileSelector: (profile) => profile[CONFIG_ENDPOINT_NAME2],
    default: undefined
  };
  var EndpointMode2 = /* @__PURE__ */ ((EndpointMode22) => {
    EndpointMode22["IPv4"] = "IPv4";
    EndpointMode22["IPv6"] = "IPv6";
    return EndpointMode22;
  })(EndpointMode2 || {});
  var ENV_ENDPOINT_MODE_NAME2 = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
  var CONFIG_ENDPOINT_MODE_NAME2 = "ec2_metadata_service_endpoint_mode";
  var ENDPOINT_MODE_CONFIG_OPTIONS2 = {
    environmentVariableSelector: (env2) => env2[ENV_ENDPOINT_MODE_NAME2],
    configFileSelector: (profile) => profile[CONFIG_ENDPOINT_MODE_NAME2],
    default: "IPv4"
  };
  var getInstanceMetadataEndpoint2 = /* @__PURE__ */ __name2(async () => (0, import_url_parser3.parseUrl)(await getFromEndpointConfig2() || await getFromEndpointModeConfig2()), "getInstanceMetadataEndpoint");
  var getFromEndpointConfig2 = /* @__PURE__ */ __name2(async () => (0, import_node_config_provider4.loadConfig)(ENDPOINT_CONFIG_OPTIONS2)(), "getFromEndpointConfig");
  var getFromEndpointModeConfig2 = /* @__PURE__ */ __name2(async () => {
    const endpointMode = await (0, import_node_config_provider4.loadConfig)(ENDPOINT_MODE_CONFIG_OPTIONS2)();
    switch (endpointMode) {
      case "IPv4":
        return "http://169.254.169.254";
      case "IPv6":
        return "http://[fd00:ec2::254]";
      default:
        throw new Error(`Unsupported endpoint mode: ${endpointMode}. Select from ${Object.values(EndpointMode2)}`);
    }
  }, "getFromEndpointModeConfig");
  var STATIC_STABILITY_REFRESH_INTERVAL_SECONDS2 = 5 * 60;
  var STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS2 = 5 * 60;
  var STATIC_STABILITY_DOC_URL2 = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html";
  var getExtendedInstanceMetadataCredentials2 = /* @__PURE__ */ __name2((credentials, logger2) => {
    const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS2 + Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS2);
    const newExpiration = new Date(Date.now() + refreshInterval * 1000);
    logger2.warn(`Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(newExpiration)}.
For more information, please visit: ` + STATIC_STABILITY_DOC_URL2);
    const originalExpiration = credentials.originalExpiration ?? credentials.expiration;
    return {
      ...credentials,
      ...originalExpiration ? { originalExpiration } : {},
      expiration: newExpiration
    };
  }, "getExtendedInstanceMetadataCredentials");
  var staticStabilityProvider2 = /* @__PURE__ */ __name2((provider, options = {}) => {
    const logger2 = options?.logger || console;
    let pastCredentials;
    return async () => {
      let credentials;
      try {
        credentials = await provider();
        if (credentials.expiration && credentials.expiration.getTime() < Date.now()) {
          credentials = getExtendedInstanceMetadataCredentials2(credentials, logger2);
        }
      } catch (e3) {
        if (pastCredentials) {
          logger2.warn("Credential renew failed: ", e3);
          credentials = getExtendedInstanceMetadataCredentials2(pastCredentials, logger2);
        } else {
          throw e3;
        }
      }
      pastCredentials = credentials;
      return credentials;
    };
  }, "staticStabilityProvider");
  var IMDS_PATH2 = "/latest/meta-data/iam/security-credentials/";
  var IMDS_TOKEN_PATH2 = "/latest/api/token";
  var AWS_EC2_METADATA_V1_DISABLED2 = "AWS_EC2_METADATA_V1_DISABLED";
  var PROFILE_AWS_EC2_METADATA_V1_DISABLED2 = "ec2_metadata_v1_disabled";
  var X_AWS_EC2_METADATA_TOKEN2 = "x-aws-ec2-metadata-token";
  var fromInstanceMetadata3 = /* @__PURE__ */ __name2((init2 = {}) => staticStabilityProvider2(getInstanceMetadataProvider2(init2), { logger: init2.logger }), "fromInstanceMetadata");
  var getInstanceMetadataProvider2 = /* @__PURE__ */ __name2((init2 = {}) => {
    let disableFetchToken = false;
    const { logger: logger2, profile } = init2;
    const { timeout, maxRetries } = providerConfigFromInit2(init2);
    const getCredentials2 = /* @__PURE__ */ __name2(async (maxRetries2, options) => {
      const isImdsV1Fallback = disableFetchToken || options.headers?.[X_AWS_EC2_METADATA_TOKEN2] == null;
      if (isImdsV1Fallback) {
        let fallbackBlockedFromProfile = false;
        let fallbackBlockedFromProcessEnv = false;
        const configValue = await (0, import_node_config_provider4.loadConfig)({
          environmentVariableSelector: (env2) => {
            const envValue = env2[AWS_EC2_METADATA_V1_DISABLED2];
            fallbackBlockedFromProcessEnv = !!envValue && envValue !== "false";
            if (envValue === undefined) {
              throw new import_property_provider14.CredentialsProviderError(`${AWS_EC2_METADATA_V1_DISABLED2} not set in env, checking config file next.`, { logger: init2.logger });
            }
            return fallbackBlockedFromProcessEnv;
          },
          configFileSelector: (profile2) => {
            const profileValue = profile2[PROFILE_AWS_EC2_METADATA_V1_DISABLED2];
            fallbackBlockedFromProfile = !!profileValue && profileValue !== "false";
            return fallbackBlockedFromProfile;
          },
          default: false
        }, {
          profile
        })();
        if (init2.ec2MetadataV1Disabled || configValue) {
          const causes = [];
          if (init2.ec2MetadataV1Disabled)
            causes.push("credential provider initialization (runtime option ec2MetadataV1Disabled)");
          if (fallbackBlockedFromProfile)
            causes.push(`config file profile (${PROFILE_AWS_EC2_METADATA_V1_DISABLED2})`);
          if (fallbackBlockedFromProcessEnv)
            causes.push(`process environment variable (${AWS_EC2_METADATA_V1_DISABLED2})`);
          throw new InstanceMetadataV1FallbackError2(`AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${causes.join(", ")}].`);
        }
      }
      const imdsProfile = (await retry2(async () => {
        let profile2;
        try {
          profile2 = await getProfile2(options);
        } catch (err) {
          if (err.statusCode === 401) {
            disableFetchToken = false;
          }
          throw err;
        }
        return profile2;
      }, maxRetries2)).trim();
      return retry2(async () => {
        let creds;
        try {
          creds = await getCredentialsFromProfile2(imdsProfile, options, init2);
        } catch (err) {
          if (err.statusCode === 401) {
            disableFetchToken = false;
          }
          throw err;
        }
        return creds;
      }, maxRetries2);
    }, "getCredentials");
    return async () => {
      const endpoint = await getInstanceMetadataEndpoint2();
      if (disableFetchToken) {
        logger2?.debug("AWS SDK Instance Metadata", "using v1 fallback (no token fetch)");
        return getCredentials2(maxRetries, { ...endpoint, timeout });
      } else {
        let token;
        try {
          token = (await getMetadataToken2({ ...endpoint, timeout })).toString();
        } catch (error) {
          if (error?.statusCode === 400) {
            throw Object.assign(error, {
              message: "EC2 Metadata token request returned error"
            });
          } else if (error.message === "TimeoutError" || [403, 404, 405].includes(error.statusCode)) {
            disableFetchToken = true;
          }
          logger2?.debug("AWS SDK Instance Metadata", "using v1 fallback (initial)");
          return getCredentials2(maxRetries, { ...endpoint, timeout });
        }
        return getCredentials2(maxRetries, {
          ...endpoint,
          headers: {
            [X_AWS_EC2_METADATA_TOKEN2]: token
          },
          timeout
        });
      }
    };
  }, "getInstanceMetadataProvider");
  var getMetadataToken2 = /* @__PURE__ */ __name2(async (options) => httpRequest3({
    ...options,
    path: IMDS_TOKEN_PATH2,
    method: "PUT",
    headers: {
      "x-aws-ec2-metadata-token-ttl-seconds": "21600"
    }
  }), "getMetadataToken");
  var getProfile2 = /* @__PURE__ */ __name2(async (options) => (await httpRequest3({ ...options, path: IMDS_PATH2 })).toString(), "getProfile");
  var getCredentialsFromProfile2 = /* @__PURE__ */ __name2(async (profile, options, init2) => {
    const credentialsResponse = JSON.parse((await httpRequest3({
      ...options,
      path: IMDS_PATH2 + profile
    })).toString());
    if (!isImdsCredentials2(credentialsResponse)) {
      throw new import_property_provider14.CredentialsProviderError("Invalid response received from instance metadata service.", {
        logger: init2.logger
      });
    }
    return fromImdsCredentials2(credentialsResponse);
  }, "getCredentialsFromProfile");
});

// ../../node_modules/@smithy/util-defaults-mode-node/dist-cjs/index.js
var require_dist_cjs42 = __commonJS((exports, module) => {
  var __create2 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp3(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    resolveDefaultsModeConfig: () => resolveDefaultsModeConfig
  });
  module.exports = __toCommonJS(src_exports);
  var import_config_resolver = require_dist_cjs28();
  var import_node_config_provider4 = require_dist_cjs31();
  var import_property_provider14 = require_dist_cjs16();
  var AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
  var AWS_REGION_ENV = "AWS_REGION";
  var AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
  var ENV_IMDS_DISABLED2 = "AWS_EC2_METADATA_DISABLED";
  var DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
  var IMDS_REGION_PATH = "/latest/meta-data/placement/region";
  var AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE";
  var AWS_DEFAULTS_MODE_CONFIG = "defaults_mode";
  var NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env2) => {
      return env2[AWS_DEFAULTS_MODE_ENV];
    },
    configFileSelector: (profile) => {
      return profile[AWS_DEFAULTS_MODE_CONFIG];
    },
    default: "legacy"
  };
  var resolveDefaultsModeConfig = /* @__PURE__ */ __name2(({
    region = (0, import_node_config_provider4.loadConfig)(import_config_resolver.NODE_REGION_CONFIG_OPTIONS),
    defaultsMode = (0, import_node_config_provider4.loadConfig)(NODE_DEFAULTS_MODE_CONFIG_OPTIONS)
  } = {}) => (0, import_property_provider14.memoize)(async () => {
    const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
    switch (mode?.toLowerCase()) {
      case "auto":
        return resolveNodeDefaultsModeAuto(region);
      case "in-region":
      case "cross-region":
      case "mobile":
      case "standard":
      case "legacy":
        return Promise.resolve(mode?.toLocaleLowerCase());
      case undefined:
        return Promise.resolve("legacy");
      default:
        throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
    }
  }), "resolveDefaultsModeConfig");
  var resolveNodeDefaultsModeAuto = /* @__PURE__ */ __name2(async (clientRegion) => {
    if (clientRegion) {
      const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
      const inferredRegion = await inferPhysicalRegion();
      if (!inferredRegion) {
        return "standard";
      }
      if (resolvedRegion === inferredRegion) {
        return "in-region";
      } else {
        return "cross-region";
      }
    }
    return "standard";
  }, "resolveNodeDefaultsModeAuto");
  var inferPhysicalRegion = /* @__PURE__ */ __name2(async () => {
    if (process.env[AWS_EXECUTION_ENV] && (process.env[AWS_REGION_ENV] || process.env[AWS_DEFAULT_REGION_ENV])) {
      return process.env[AWS_REGION_ENV] ?? process.env[AWS_DEFAULT_REGION_ENV];
    }
    if (!process.env[ENV_IMDS_DISABLED2]) {
      try {
        const { getInstanceMetadataEndpoint: getInstanceMetadataEndpoint2, httpRequest: httpRequest3 } = await Promise.resolve().then(() => __toESM2(require_dist_cjs41()));
        const endpoint = await getInstanceMetadataEndpoint2();
        return (await httpRequest3({ ...endpoint, path: IMDS_REGION_PATH })).toString();
      } catch (e3) {
      }
    }
  }, "inferPhysicalRegion");
});

// ../../node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/runtimeConfig.js
var require_runtimeConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var tslib_1 = require_tslib();
  var package_json_1 = tslib_1.__importDefault(require_package());
  var core_1 = require_dist_cjs20();
  var util_user_agent_node_1 = require_dist_cjs38();
  var config_resolver_1 = require_dist_cjs28();
  var hash_node_1 = require_dist_cjs39();
  var middleware_retry_1 = require_dist_cjs37();
  var node_config_provider_1 = require_dist_cjs31();
  var node_http_handler_1 = require_dist_cjs11();
  var util_body_length_node_1 = require_dist_cjs40();
  var util_retry_1 = require_dist_cjs36();
  var runtimeConfig_shared_1 = require_runtimeConfig_shared();
  var smithy_client_1 = require_dist_cjs19();
  var util_defaults_mode_node_1 = require_dist_cjs42();
  var smithy_client_2 = require_dist_cjs19();
  var getRuntimeConfig = (config4) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config4);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config4);
    (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
    const profileConfig = { profile: config4?.profile };
    return {
      ...clientSharedValues,
      ...config4,
      runtime: "node",
      defaultsMode,
      bodyLengthChecker: config4?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
      defaultUserAgentProvider: config4?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.createDefaultUserAgentProvider)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
      maxAttempts: config4?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config4),
      region: config4?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, { ...config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS, ...profileConfig }),
      requestHandler: node_http_handler_1.NodeHttpHandler.create(config4?.requestHandler ?? defaultConfigProvider),
      retryMode: config4?.retryMode ?? (0, node_config_provider_1.loadConfig)({
        ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
        default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
      }, config4),
      sha256: config4?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
      streamCollector: config4?.streamCollector ?? node_http_handler_1.streamCollector,
      useDualstackEndpoint: config4?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, profileConfig),
      useFipsEndpoint: config4?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, profileConfig),
      userAgentAppId: config4?.userAgentAppId ?? (0, node_config_provider_1.loadConfig)(util_user_agent_node_1.NODE_APP_ID_CONFIG_OPTIONS, profileConfig)
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// ../../node_modules/@aws-sdk/region-config-resolver/dist-cjs/index.js
var require_dist_cjs43 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    NODE_REGION_CONFIG_FILE_OPTIONS: () => NODE_REGION_CONFIG_FILE_OPTIONS2,
    NODE_REGION_CONFIG_OPTIONS: () => NODE_REGION_CONFIG_OPTIONS2,
    REGION_ENV_NAME: () => REGION_ENV_NAME2,
    REGION_INI_NAME: () => REGION_INI_NAME2,
    getAwsRegionExtensionConfiguration: () => getAwsRegionExtensionConfiguration,
    resolveAwsRegionExtensionConfiguration: () => resolveAwsRegionExtensionConfiguration,
    resolveRegionConfig: () => resolveRegionConfig3
  });
  module.exports = __toCommonJS(src_exports);
  var getAwsRegionExtensionConfiguration = /* @__PURE__ */ __name2((runtimeConfig) => {
    let runtimeConfigRegion = /* @__PURE__ */ __name2(async () => {
      if (runtimeConfig.region === undefined) {
        throw new Error("Region is missing from runtimeConfig");
      }
      const region = runtimeConfig.region;
      if (typeof region === "string") {
        return region;
      }
      return region();
    }, "runtimeConfigRegion");
    return {
      setRegion(region) {
        runtimeConfigRegion = region;
      },
      region() {
        return runtimeConfigRegion;
      }
    };
  }, "getAwsRegionExtensionConfiguration");
  var resolveAwsRegionExtensionConfiguration = /* @__PURE__ */ __name2((awsRegionExtensionConfiguration) => {
    return {
      region: awsRegionExtensionConfiguration.region()
    };
  }, "resolveAwsRegionExtensionConfiguration");
  var REGION_ENV_NAME2 = "AWS_REGION";
  var REGION_INI_NAME2 = "region";
  var NODE_REGION_CONFIG_OPTIONS2 = {
    environmentVariableSelector: (env2) => env2[REGION_ENV_NAME2],
    configFileSelector: (profile) => profile[REGION_INI_NAME2],
    default: () => {
      throw new Error("Region is missing");
    }
  };
  var NODE_REGION_CONFIG_FILE_OPTIONS2 = {
    preferredFile: "credentials"
  };
  var isFipsRegion2 = /* @__PURE__ */ __name2((region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips")), "isFipsRegion");
  var getRealRegion2 = /* @__PURE__ */ __name2((region) => isFipsRegion2(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region, "getRealRegion");
  var resolveRegionConfig3 = /* @__PURE__ */ __name2((input) => {
    const { region, useFipsEndpoint } = input;
    if (!region) {
      throw new Error("Region is missing");
    }
    return {
      ...input,
      region: async () => {
        if (typeof region === "string") {
          return getRealRegion2(region);
        }
        const providedRegion = await region();
        return getRealRegion2(providedRegion);
      },
      useFipsEndpoint: async () => {
        const providedRegion = typeof region === "string" ? region : await region();
        if (isFipsRegion2(providedRegion)) {
          return true;
        }
        return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
      }
    };
  }, "resolveRegionConfig");
});

// ../../node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/index.js
var require_sso_oidc = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var sso_oidc_exports = {};
  __export2(sso_oidc_exports, {
    $Command: () => import_smithy_client62.Command,
    AccessDeniedException: () => AccessDeniedException,
    AuthorizationPendingException: () => AuthorizationPendingException,
    CreateTokenCommand: () => CreateTokenCommand,
    CreateTokenRequestFilterSensitiveLog: () => CreateTokenRequestFilterSensitiveLog,
    CreateTokenResponseFilterSensitiveLog: () => CreateTokenResponseFilterSensitiveLog,
    ExpiredTokenException: () => ExpiredTokenException,
    InternalServerException: () => InternalServerException,
    InvalidClientException: () => InvalidClientException,
    InvalidGrantException: () => InvalidGrantException,
    InvalidRequestException: () => InvalidRequestException,
    InvalidScopeException: () => InvalidScopeException,
    SSOOIDC: () => SSOOIDC,
    SSOOIDCClient: () => SSOOIDCClient,
    SSOOIDCServiceException: () => SSOOIDCServiceException,
    SlowDownException: () => SlowDownException,
    UnauthorizedClientException: () => UnauthorizedClientException,
    UnsupportedGrantTypeException: () => UnsupportedGrantTypeException,
    __Client: () => import_smithy_client22.Client
  });
  module.exports = __toCommonJS(sso_oidc_exports);
  var import_middleware_host_header = require_dist_cjs21();
  var import_middleware_logger = require_dist_cjs22();
  var import_middleware_recursion_detection = require_dist_cjs23();
  var import_middleware_user_agent = require_dist_cjs26();
  var import_config_resolver = require_dist_cjs28();
  var import_core11 = require_dist_cjs15();
  var import_middleware_content_length = require_dist_cjs29();
  var import_middleware_endpoint3 = require_dist_cjs34();
  var import_middleware_retry = require_dist_cjs37();
  var import_smithy_client22 = require_dist_cjs19();
  var import_httpAuthSchemeProvider = require_httpAuthSchemeProvider();
  var resolveClientEndpointParameters2 = /* @__PURE__ */ __name2((options) => {
    return {
      ...options,
      useDualstackEndpoint: options.useDualstackEndpoint ?? false,
      useFipsEndpoint: options.useFipsEndpoint ?? false,
      defaultSigningName: "sso-oauth"
    };
  }, "resolveClientEndpointParameters");
  var commonParams2 = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
  };
  var import_runtimeConfig = require_runtimeConfig();
  var import_region_config_resolver = require_dist_cjs43();
  var import_protocol_http23 = require_dist_cjs2();
  var import_smithy_client10 = require_dist_cjs19();
  var getHttpAuthExtensionConfiguration = /* @__PURE__ */ __name2((runtimeConfig) => {
    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
    let _credentials = runtimeConfig.credentials;
    return {
      setHttpAuthScheme(httpAuthScheme) {
        const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
        if (index === -1) {
          _httpAuthSchemes.push(httpAuthScheme);
        } else {
          _httpAuthSchemes.splice(index, 1, httpAuthScheme);
        }
      },
      httpAuthSchemes() {
        return _httpAuthSchemes;
      },
      setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
        _httpAuthSchemeProvider = httpAuthSchemeProvider;
      },
      httpAuthSchemeProvider() {
        return _httpAuthSchemeProvider;
      },
      setCredentials(credentials) {
        _credentials = credentials;
      },
      credentials() {
        return _credentials;
      }
    };
  }, "getHttpAuthExtensionConfiguration");
  var resolveHttpAuthRuntimeConfig = /* @__PURE__ */ __name2((config4) => {
    return {
      httpAuthSchemes: config4.httpAuthSchemes(),
      httpAuthSchemeProvider: config4.httpAuthSchemeProvider(),
      credentials: config4.credentials()
    };
  }, "resolveHttpAuthRuntimeConfig");
  var asPartial = /* @__PURE__ */ __name2((t3) => t3, "asPartial");
  var resolveRuntimeExtensions = /* @__PURE__ */ __name2((runtimeConfig, extensions3) => {
    const extensionConfiguration = {
      ...asPartial((0, import_region_config_resolver.getAwsRegionExtensionConfiguration)(runtimeConfig)),
      ...asPartial((0, import_smithy_client10.getDefaultExtensionConfiguration)(runtimeConfig)),
      ...asPartial((0, import_protocol_http23.getHttpHandlerExtensionConfiguration)(runtimeConfig)),
      ...asPartial(getHttpAuthExtensionConfiguration(runtimeConfig))
    };
    extensions3.forEach((extension) => extension.configure(extensionConfiguration));
    return {
      ...runtimeConfig,
      ...(0, import_region_config_resolver.resolveAwsRegionExtensionConfiguration)(extensionConfiguration),
      ...(0, import_smithy_client10.resolveDefaultRuntimeConfig)(extensionConfiguration),
      ...(0, import_protocol_http23.resolveHttpHandlerRuntimeConfig)(extensionConfiguration),
      ...resolveHttpAuthRuntimeConfig(extensionConfiguration)
    };
  }, "resolveRuntimeExtensions");
  var SSOOIDCClient = class extends import_smithy_client22.Client {
    static {
      __name2(this, "SSOOIDCClient");
    }
    config;
    constructor(...[configuration]) {
      const _config_0 = (0, import_runtimeConfig.getRuntimeConfig)(configuration || {});
      const _config_1 = resolveClientEndpointParameters2(_config_0);
      const _config_2 = (0, import_middleware_user_agent.resolveUserAgentConfig)(_config_1);
      const _config_3 = (0, import_middleware_retry.resolveRetryConfig)(_config_2);
      const _config_4 = (0, import_config_resolver.resolveRegionConfig)(_config_3);
      const _config_5 = (0, import_middleware_host_header.resolveHostHeaderConfig)(_config_4);
      const _config_6 = (0, import_middleware_endpoint3.resolveEndpointConfig)(_config_5);
      const _config_7 = (0, import_httpAuthSchemeProvider.resolveHttpAuthSchemeConfig)(_config_6);
      const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
      super(_config_8);
      this.config = _config_8;
      this.middlewareStack.use((0, import_middleware_user_agent.getUserAgentPlugin)(this.config));
      this.middlewareStack.use((0, import_middleware_retry.getRetryPlugin)(this.config));
      this.middlewareStack.use((0, import_middleware_content_length.getContentLengthPlugin)(this.config));
      this.middlewareStack.use((0, import_middleware_host_header.getHostHeaderPlugin)(this.config));
      this.middlewareStack.use((0, import_middleware_logger.getLoggerPlugin)(this.config));
      this.middlewareStack.use((0, import_middleware_recursion_detection.getRecursionDetectionPlugin)(this.config));
      this.middlewareStack.use((0, import_core11.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
        httpAuthSchemeParametersProvider: import_httpAuthSchemeProvider.defaultSSOOIDCHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (config4) => new import_core11.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": config4.credentials
        })
      }));
      this.middlewareStack.use((0, import_core11.getHttpSigningPlugin)(this.config));
    }
    destroy() {
      super.destroy();
    }
  };
  var import_smithy_client72 = require_dist_cjs19();
  var import_middleware_endpoint22 = require_dist_cjs34();
  var import_middleware_serde3 = require_dist_cjs4();
  var import_smithy_client62 = require_dist_cjs19();
  var import_smithy_client42 = require_dist_cjs19();
  var import_smithy_client32 = require_dist_cjs19();
  var SSOOIDCServiceException = class _SSOOIDCServiceException extends import_smithy_client32.ServiceException {
    static {
      __name2(this, "SSOOIDCServiceException");
    }
    constructor(options) {
      super(options);
      Object.setPrototypeOf(this, _SSOOIDCServiceException.prototype);
    }
  };
  var AccessDeniedException = class _AccessDeniedException extends SSOOIDCServiceException {
    static {
      __name2(this, "AccessDeniedException");
    }
    name = "AccessDeniedException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "AccessDeniedException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _AccessDeniedException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  var AuthorizationPendingException = class _AuthorizationPendingException extends SSOOIDCServiceException {
    static {
      __name2(this, "AuthorizationPendingException");
    }
    name = "AuthorizationPendingException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "AuthorizationPendingException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _AuthorizationPendingException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  var CreateTokenRequestFilterSensitiveLog = /* @__PURE__ */ __name2((obj) => ({
    ...obj,
    ...obj.clientSecret && { clientSecret: import_smithy_client42.SENSITIVE_STRING },
    ...obj.refreshToken && { refreshToken: import_smithy_client42.SENSITIVE_STRING },
    ...obj.codeVerifier && { codeVerifier: import_smithy_client42.SENSITIVE_STRING }
  }), "CreateTokenRequestFilterSensitiveLog");
  var CreateTokenResponseFilterSensitiveLog = /* @__PURE__ */ __name2((obj) => ({
    ...obj,
    ...obj.accessToken && { accessToken: import_smithy_client42.SENSITIVE_STRING },
    ...obj.refreshToken && { refreshToken: import_smithy_client42.SENSITIVE_STRING },
    ...obj.idToken && { idToken: import_smithy_client42.SENSITIVE_STRING }
  }), "CreateTokenResponseFilterSensitiveLog");
  var ExpiredTokenException = class _ExpiredTokenException extends SSOOIDCServiceException {
    static {
      __name2(this, "ExpiredTokenException");
    }
    name = "ExpiredTokenException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "ExpiredTokenException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _ExpiredTokenException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  var InternalServerException = class _InternalServerException extends SSOOIDCServiceException {
    static {
      __name2(this, "InternalServerException");
    }
    name = "InternalServerException";
    $fault = "server";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "InternalServerException",
        $fault: "server",
        ...opts
      });
      Object.setPrototypeOf(this, _InternalServerException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  var InvalidClientException = class _InvalidClientException extends SSOOIDCServiceException {
    static {
      __name2(this, "InvalidClientException");
    }
    name = "InvalidClientException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "InvalidClientException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _InvalidClientException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  var InvalidGrantException = class _InvalidGrantException extends SSOOIDCServiceException {
    static {
      __name2(this, "InvalidGrantException");
    }
    name = "InvalidGrantException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "InvalidGrantException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _InvalidGrantException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  var InvalidRequestException = class _InvalidRequestException extends SSOOIDCServiceException {
    static {
      __name2(this, "InvalidRequestException");
    }
    name = "InvalidRequestException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "InvalidRequestException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _InvalidRequestException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  var InvalidScopeException = class _InvalidScopeException extends SSOOIDCServiceException {
    static {
      __name2(this, "InvalidScopeException");
    }
    name = "InvalidScopeException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "InvalidScopeException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _InvalidScopeException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  var SlowDownException = class _SlowDownException extends SSOOIDCServiceException {
    static {
      __name2(this, "SlowDownException");
    }
    name = "SlowDownException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "SlowDownException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _SlowDownException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  var UnauthorizedClientException = class _UnauthorizedClientException extends SSOOIDCServiceException {
    static {
      __name2(this, "UnauthorizedClientException");
    }
    name = "UnauthorizedClientException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "UnauthorizedClientException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _UnauthorizedClientException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  var UnsupportedGrantTypeException = class _UnsupportedGrantTypeException extends SSOOIDCServiceException {
    static {
      __name2(this, "UnsupportedGrantTypeException");
    }
    name = "UnsupportedGrantTypeException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "UnsupportedGrantTypeException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _UnsupportedGrantTypeException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  };
  var import_core22 = require_dist_cjs20();
  var import_core32 = require_dist_cjs15();
  var import_smithy_client52 = require_dist_cjs19();
  var se_CreateTokenCommand = /* @__PURE__ */ __name2(async (input, context) => {
    const b2 = (0, import_core32.requestBuilder)(input, context);
    const headers = {
      "content-type": "application/json"
    };
    b2.bp("/token");
    let body;
    body = JSON.stringify((0, import_smithy_client52.take)(input, {
      clientId: [],
      clientSecret: [],
      code: [],
      codeVerifier: [],
      deviceCode: [],
      grantType: [],
      redirectUri: [],
      refreshToken: [],
      scope: (_3) => (0, import_smithy_client52._json)(_3)
    }));
    b2.m("POST").h(headers).b(body);
    return b2.build();
  }, "se_CreateTokenCommand");
  var de_CreateTokenCommand = /* @__PURE__ */ __name2(async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_CommandError2(output, context);
    }
    const contents = (0, import_smithy_client52.map)({
      $metadata: deserializeMetadata3(output)
    });
    const data = (0, import_smithy_client52.expectNonNull)((0, import_smithy_client52.expectObject)(await (0, import_core22.parseJsonBody)(output.body, context)), "body");
    const doc = (0, import_smithy_client52.take)(data, {
      accessToken: import_smithy_client52.expectString,
      expiresIn: import_smithy_client52.expectInt32,
      idToken: import_smithy_client52.expectString,
      refreshToken: import_smithy_client52.expectString,
      tokenType: import_smithy_client52.expectString
    });
    Object.assign(contents, doc);
    return contents;
  }, "de_CreateTokenCommand");
  var de_CommandError2 = /* @__PURE__ */ __name2(async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await (0, import_core22.parseJsonErrorBody)(output.body, context)
    };
    const errorCode = (0, import_core22.loadRestJsonErrorCode)(output, parsedOutput.body);
    switch (errorCode) {
      case "AccessDeniedException":
      case "com.amazonaws.ssooidc#AccessDeniedException":
        throw await de_AccessDeniedExceptionRes(parsedOutput, context);
      case "AuthorizationPendingException":
      case "com.amazonaws.ssooidc#AuthorizationPendingException":
        throw await de_AuthorizationPendingExceptionRes(parsedOutput, context);
      case "ExpiredTokenException":
      case "com.amazonaws.ssooidc#ExpiredTokenException":
        throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
      case "InternalServerException":
      case "com.amazonaws.ssooidc#InternalServerException":
        throw await de_InternalServerExceptionRes(parsedOutput, context);
      case "InvalidClientException":
      case "com.amazonaws.ssooidc#InvalidClientException":
        throw await de_InvalidClientExceptionRes(parsedOutput, context);
      case "InvalidGrantException":
      case "com.amazonaws.ssooidc#InvalidGrantException":
        throw await de_InvalidGrantExceptionRes(parsedOutput, context);
      case "InvalidRequestException":
      case "com.amazonaws.ssooidc#InvalidRequestException":
        throw await de_InvalidRequestExceptionRes(parsedOutput, context);
      case "InvalidScopeException":
      case "com.amazonaws.ssooidc#InvalidScopeException":
        throw await de_InvalidScopeExceptionRes(parsedOutput, context);
      case "SlowDownException":
      case "com.amazonaws.ssooidc#SlowDownException":
        throw await de_SlowDownExceptionRes(parsedOutput, context);
      case "UnauthorizedClientException":
      case "com.amazonaws.ssooidc#UnauthorizedClientException":
        throw await de_UnauthorizedClientExceptionRes(parsedOutput, context);
      case "UnsupportedGrantTypeException":
      case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
        throw await de_UnsupportedGrantTypeExceptionRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError3({
          output,
          parsedBody,
          errorCode
        });
    }
  }, "de_CommandError");
  var throwDefaultError3 = (0, import_smithy_client52.withBaseException)(SSOOIDCServiceException);
  var de_AccessDeniedExceptionRes = /* @__PURE__ */ __name2(async (parsedOutput, context) => {
    const contents = (0, import_smithy_client52.map)({});
    const data = parsedOutput.body;
    const doc = (0, import_smithy_client52.take)(data, {
      error: import_smithy_client52.expectString,
      error_description: import_smithy_client52.expectString
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
      $metadata: deserializeMetadata3(parsedOutput),
      ...contents
    });
    return (0, import_smithy_client52.decorateServiceException)(exception, parsedOutput.body);
  }, "de_AccessDeniedExceptionRes");
  var de_AuthorizationPendingExceptionRes = /* @__PURE__ */ __name2(async (parsedOutput, context) => {
    const contents = (0, import_smithy_client52.map)({});
    const data = parsedOutput.body;
    const doc = (0, import_smithy_client52.take)(data, {
      error: import_smithy_client52.expectString,
      error_description: import_smithy_client52.expectString
    });
    Object.assign(contents, doc);
    const exception = new AuthorizationPendingException({
      $metadata: deserializeMetadata3(parsedOutput),
      ...contents
    });
    return (0, import_smithy_client52.decorateServiceException)(exception, parsedOutput.body);
  }, "de_AuthorizationPendingExceptionRes");
  var de_ExpiredTokenExceptionRes = /* @__PURE__ */ __name2(async (parsedOutput, context) => {
    const contents = (0, import_smithy_client52.map)({});
    const data = parsedOutput.body;
    const doc = (0, import_smithy_client52.take)(data, {
      error: import_smithy_client52.expectString,
      error_description: import_smithy_client52.expectString
    });
    Object.assign(contents, doc);
    const exception = new ExpiredTokenException({
      $metadata: deserializeMetadata3(parsedOutput),
      ...contents
    });
    return (0, import_smithy_client52.decorateServiceException)(exception, parsedOutput.body);
  }, "de_ExpiredTokenExceptionRes");
  var de_InternalServerExceptionRes = /* @__PURE__ */ __name2(async (parsedOutput, context) => {
    const contents = (0, import_smithy_client52.map)({});
    const data = parsedOutput.body;
    const doc = (0, import_smithy_client52.take)(data, {
      error: import_smithy_client52.expectString,
      error_description: import_smithy_client52.expectString
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
      $metadata: deserializeMetadata3(parsedOutput),
      ...contents
    });
    return (0, import_smithy_client52.decorateServiceException)(exception, parsedOutput.body);
  }, "de_InternalServerExceptionRes");
  var de_InvalidClientExceptionRes = /* @__PURE__ */ __name2(async (parsedOutput, context) => {
    const contents = (0, import_smithy_client52.map)({});
    const data = parsedOutput.body;
    const doc = (0, import_smithy_client52.take)(data, {
      error: import_smithy_client52.expectString,
      error_description: import_smithy_client52.expectString
    });
    Object.assign(contents, doc);
    const exception = new InvalidClientException({
      $metadata: deserializeMetadata3(parsedOutput),
      ...contents
    });
    return (0, import_smithy_client52.decorateServiceException)(exception, parsedOutput.body);
  }, "de_InvalidClientExceptionRes");
  var de_InvalidGrantExceptionRes = /* @__PURE__ */ __name2(async (parsedOutput, context) => {
    const contents = (0, import_smithy_client52.map)({});
    const data = parsedOutput.body;
    const doc = (0, import_smithy_client52.take)(data, {
      error: import_smithy_client52.expectString,
      error_description: import_smithy_client52.expectString
    });
    Object.assign(contents, doc);
    const exception = new InvalidGrantException({
      $metadata: deserializeMetadata3(parsedOutput),
      ...contents
    });
    return (0, import_smithy_client52.decorateServiceException)(exception, parsedOutput.body);
  }, "de_InvalidGrantExceptionRes");
  var de_InvalidRequestExceptionRes = /* @__PURE__ */ __name2(async (parsedOutput, context) => {
    const contents = (0, import_smithy_client52.map)({});
    const data = parsedOutput.body;
    const doc = (0, import_smithy_client52.take)(data, {
      error: import_smithy_client52.expectString,
      error_description: import_smithy_client52.expectString
    });
    Object.assign(contents, doc);
    const exception = new InvalidRequestException({
      $metadata: deserializeMetadata3(parsedOutput),
      ...contents
    });
    return (0, import_smithy_client52.decorateServiceException)(exception, parsedOutput.body);
  }, "de_InvalidRequestExceptionRes");
  var de_InvalidScopeExceptionRes = /* @__PURE__ */ __name2(async (parsedOutput, context) => {
    const contents = (0, import_smithy_client52.map)({});
    const data = parsedOutput.body;
    const doc = (0, import_smithy_client52.take)(data, {
      error: import_smithy_client52.expectString,
      error_description: import_smithy_client52.expectString
    });
    Object.assign(contents, doc);
    const exception = new InvalidScopeException({
      $metadata: deserializeMetadata3(parsedOutput),
      ...contents
    });
    return (0, import_smithy_client52.decorateServiceException)(exception, parsedOutput.body);
  }, "de_InvalidScopeExceptionRes");
  var de_SlowDownExceptionRes = /* @__PURE__ */ __name2(async (parsedOutput, context) => {
    const contents = (0, import_smithy_client52.map)({});
    const data = parsedOutput.body;
    const doc = (0, import_smithy_client52.take)(data, {
      error: import_smithy_client52.expectString,
      error_description: import_smithy_client52.expectString
    });
    Object.assign(contents, doc);
    const exception = new SlowDownException({
      $metadata: deserializeMetadata3(parsedOutput),
      ...contents
    });
    return (0, import_smithy_client52.decorateServiceException)(exception, parsedOutput.body);
  }, "de_SlowDownExceptionRes");
  var de_UnauthorizedClientExceptionRes = /* @__PURE__ */ __name2(async (parsedOutput, context) => {
    const contents = (0, import_smithy_client52.map)({});
    const data = parsedOutput.body;
    const doc = (0, import_smithy_client52.take)(data, {
      error: import_smithy_client52.expectString,
      error_description: import_smithy_client52.expectString
    });
    Object.assign(contents, doc);
    const exception = new UnauthorizedClientException({
      $metadata: deserializeMetadata3(parsedOutput),
      ...contents
    });
    return (0, import_smithy_client52.decorateServiceException)(exception, parsedOutput.body);
  }, "de_UnauthorizedClientExceptionRes");
  var de_UnsupportedGrantTypeExceptionRes = /* @__PURE__ */ __name2(async (parsedOutput, context) => {
    const contents = (0, import_smithy_client52.map)({});
    const data = parsedOutput.body;
    const doc = (0, import_smithy_client52.take)(data, {
      error: import_smithy_client52.expectString,
      error_description: import_smithy_client52.expectString
    });
    Object.assign(contents, doc);
    const exception = new UnsupportedGrantTypeException({
      $metadata: deserializeMetadata3(parsedOutput),
      ...contents
    });
    return (0, import_smithy_client52.decorateServiceException)(exception, parsedOutput.body);
  }, "de_UnsupportedGrantTypeExceptionRes");
  var deserializeMetadata3 = /* @__PURE__ */ __name2((output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"]
  }), "deserializeMetadata");
  var CreateTokenCommand = class extends import_smithy_client62.Command.classBuilder().ep(commonParams2).m(function(Command2, cs2, config4, o2) {
    return [
      (0, import_middleware_serde3.getSerdePlugin)(config4, this.serialize, this.deserialize),
      (0, import_middleware_endpoint22.getEndpointPlugin)(config4, Command2.getEndpointParameterInstructions())
    ];
  }).s("AWSSSOOIDCService", "CreateToken", {}).n("SSOOIDCClient", "CreateTokenCommand").f(CreateTokenRequestFilterSensitiveLog, CreateTokenResponseFilterSensitiveLog).ser(se_CreateTokenCommand).de(de_CreateTokenCommand).build() {
    static {
      __name2(this, "CreateTokenCommand");
    }
  };
  var commands = {
    CreateTokenCommand
  };
  var SSOOIDC = class extends SSOOIDCClient {
    static {
      __name2(this, "SSOOIDC");
    }
  };
  (0, import_smithy_client72.createAggregatedClient)(commands, SSOOIDC);
});

// ../../node_modules/@aws-sdk/token-providers/dist-es/getSsoOidcClient.js
var getSsoOidcClient = async (ssoRegion, init2 = {}) => {
  const { SSOOIDCClient } = await Promise.resolve().then(() => __toESM(require_sso_oidc(), 1));
  const ssoOidcClient = new SSOOIDCClient(Object.assign({}, init2.clientConfig ?? {}, {
    region: ssoRegion ?? init2.clientConfig?.region,
    logger: init2.clientConfig?.logger ?? init2.parentClientConfig?.logger
  }));
  return ssoOidcClient;
};

// ../../node_modules/@aws-sdk/token-providers/dist-es/getNewSsoOidcToken.js
var getNewSsoOidcToken = async (ssoToken, ssoRegion, init2 = {}) => {
  const { CreateTokenCommand } = await Promise.resolve().then(() => __toESM(require_sso_oidc(), 1));
  const ssoOidcClient = await getSsoOidcClient(ssoRegion, init2);
  return ssoOidcClient.send(new CreateTokenCommand({
    clientId: ssoToken.clientId,
    clientSecret: ssoToken.clientSecret,
    refreshToken: ssoToken.refreshToken,
    grantType: "refresh_token"
  }));
};
var init_getNewSsoOidcToken = () => {
};

// ../../node_modules/@aws-sdk/token-providers/dist-es/validateTokenExpiry.js
var import_property_provider14, validateTokenExpiry = (token) => {
  if (token.expiration && token.expiration.getTime() < Date.now()) {
    throw new import_property_provider14.TokenProviderError(`Token is expired. ${REFRESH_MESSAGE}`, false);
  }
};
var init_validateTokenExpiry = __esm(() => {
  import_property_provider14 = __toESM(require_dist_cjs16(), 1);
  init_constants5();
});

// ../../node_modules/@aws-sdk/token-providers/dist-es/validateTokenKey.js
var import_property_provider15, validateTokenKey = (key, value, forRefresh = false) => {
  if (typeof value === "undefined") {
    throw new import_property_provider15.TokenProviderError(`Value not present for '${key}' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${REFRESH_MESSAGE}`, false);
  }
};
var init_validateTokenKey = __esm(() => {
  import_property_provider15 = __toESM(require_dist_cjs16(), 1);
  init_constants5();
});

// ../../node_modules/@aws-sdk/token-providers/dist-es/writeSSOTokenToFile.js
import { promises as fsPromises3 } from "fs";
var writeFile2, writeSSOTokenToFile = (id, ssoToken) => {
  const tokenFilepath = getSSOTokenFilepath2(id);
  const tokenString = JSON.stringify(ssoToken, null, 2);
  return writeFile2(tokenFilepath, tokenString);
};
var init_writeSSOTokenToFile = __esm(() => {
  init_dist_es21();
  ({ writeFile: writeFile2 } = fsPromises3);
});

// ../../node_modules/@aws-sdk/token-providers/dist-es/fromSso.js
var import_property_provider16, lastRefreshAttemptTime, fromSso = (_init = {}) => async ({ callerClientConfig } = {}) => {
  const init2 = {
    ..._init,
    parentClientConfig: {
      ...callerClientConfig,
      ..._init.parentClientConfig
    }
  };
  init2.logger?.debug("@aws-sdk/token-providers - fromSso");
  const profiles = await parseKnownFiles(init2);
  const profileName = getProfileName({
    profile: init2.profile ?? callerClientConfig?.profile
  });
  const profile = profiles[profileName];
  if (!profile) {
    throw new import_property_provider16.TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);
  } else if (!profile["sso_session"]) {
    throw new import_property_provider16.TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);
  }
  const ssoSessionName = profile["sso_session"];
  const ssoSessions = await loadSsoSessionData(init2);
  const ssoSession = ssoSessions[ssoSessionName];
  if (!ssoSession) {
    throw new import_property_provider16.TokenProviderError(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);
  }
  for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) {
    if (!ssoSession[ssoSessionRequiredKey]) {
      throw new import_property_provider16.TokenProviderError(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);
    }
  }
  const ssoStartUrl = ssoSession["sso_start_url"];
  const ssoRegion = ssoSession["sso_region"];
  let ssoToken;
  try {
    ssoToken = await getSSOTokenFromFile2(ssoSessionName);
  } catch (e3) {
    throw new import_property_provider16.TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${REFRESH_MESSAGE}`, false);
  }
  validateTokenKey("accessToken", ssoToken.accessToken);
  validateTokenKey("expiresAt", ssoToken.expiresAt);
  const { accessToken, expiresAt } = ssoToken;
  const existingToken = { token: accessToken, expiration: new Date(expiresAt) };
  if (existingToken.expiration.getTime() - Date.now() > EXPIRE_WINDOW_MS) {
    return existingToken;
  }
  if (Date.now() - lastRefreshAttemptTime.getTime() < 30 * 1000) {
    validateTokenExpiry(existingToken);
    return existingToken;
  }
  validateTokenKey("clientId", ssoToken.clientId, true);
  validateTokenKey("clientSecret", ssoToken.clientSecret, true);
  validateTokenKey("refreshToken", ssoToken.refreshToken, true);
  try {
    lastRefreshAttemptTime.setTime(Date.now());
    const newSsoOidcToken = await getNewSsoOidcToken(ssoToken, ssoRegion, init2);
    validateTokenKey("accessToken", newSsoOidcToken.accessToken);
    validateTokenKey("expiresIn", newSsoOidcToken.expiresIn);
    const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1000);
    try {
      await writeSSOTokenToFile(ssoSessionName, {
        ...ssoToken,
        accessToken: newSsoOidcToken.accessToken,
        expiresAt: newTokenExpiration.toISOString(),
        refreshToken: newSsoOidcToken.refreshToken
      });
    } catch (error) {
    }
    return {
      token: newSsoOidcToken.accessToken,
      expiration: newTokenExpiration
    };
  } catch (error) {
    validateTokenExpiry(existingToken);
    return existingToken;
  }
};
var init_fromSso = __esm(() => {
  import_property_provider16 = __toESM(require_dist_cjs16(), 1);
  init_dist_es21();
  init_constants5();
  init_getNewSsoOidcToken();
  init_validateTokenExpiry();
  init_validateTokenKey();
  init_writeSSOTokenToFile();
  lastRefreshAttemptTime = new Date(0);
});

// ../../node_modules/@aws-sdk/token-providers/dist-es/fromStatic.js
var import_property_provider17;
var init_fromStatic2 = __esm(() => {
  import_property_provider17 = __toESM(require_dist_cjs16(), 1);
});

// ../../node_modules/@aws-sdk/token-providers/dist-es/nodeProvider.js
var import_property_provider18;
var init_nodeProvider = __esm(() => {
  import_property_provider18 = __toESM(require_dist_cjs16(), 1);
});

// ../../node_modules/@aws-sdk/token-providers/dist-es/index.js
var init_dist_es32 = __esm(() => {
  init_fromSso();
  init_fromStatic2();
  init_nodeProvider();
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/auth/httpAuthSchemeProvider.js
function createAwsAuthSigv4HttpAuthOption2(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "awsssoportal",
      region: authParameters.region
    },
    propertiesExtractor: (config4, context) => ({
      signingProperties: {
        config: config4,
        context
      }
    })
  };
}
function createSmithyApiNoAuthHttpAuthOption(authParameters) {
  return {
    schemeId: "smithy.api#noAuth"
  };
}
var import_core11, defaultSSOHttpAuthSchemeParametersProvider = async (config4, context, input) => {
  return {
    operation: getSmithyContext(context).operation,
    region: await normalizeProvider(config4.region)() || (() => {
      throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
    })()
  };
}, defaultSSOHttpAuthSchemeProvider = (authParameters) => {
  const options = [];
  switch (authParameters.operation) {
    case "GetRoleCredentials": {
      options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
      break;
    }
    case "ListAccountRoles": {
      options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
      break;
    }
    case "ListAccounts": {
      options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
      break;
    }
    case "Logout": {
      options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
      break;
    }
    default: {
      options.push(createAwsAuthSigv4HttpAuthOption2(authParameters));
    }
  }
  return options;
}, resolveHttpAuthSchemeConfig2 = (config4) => {
  const config_0 = import_core11.resolveAwsSdkSigV4Config(config4);
  return {
    ...config_0
  };
};
var init_httpAuthSchemeProvider = __esm(() => {
  import_core11 = __toESM(require_dist_cjs20(), 1);
  init_dist_es9();
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters2 = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "awsssoportal"
  };
}, commonParams2;
var init_EndpointParameters = __esm(() => {
  commonParams2 = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
  };
});

// ../../node_modules/@aws-sdk/client-sso/package.json
var package_default2;
var init_package = __esm(() => {
  package_default2 = {
    name: "@aws-sdk/client-sso",
    description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
    version: "3.734.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-sso",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo sso"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: false,
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.734.0",
      "@aws-sdk/middleware-host-header": "3.734.0",
      "@aws-sdk/middleware-logger": "3.734.0",
      "@aws-sdk/middleware-recursion-detection": "3.734.0",
      "@aws-sdk/middleware-user-agent": "3.734.0",
      "@aws-sdk/region-config-resolver": "3.734.0",
      "@aws-sdk/types": "3.734.0",
      "@aws-sdk/util-endpoints": "3.734.0",
      "@aws-sdk/util-user-agent-browser": "3.734.0",
      "@aws-sdk/util-user-agent-node": "3.734.0",
      "@smithy/config-resolver": "^4.0.1",
      "@smithy/core": "^3.1.1",
      "@smithy/fetch-http-handler": "^5.0.1",
      "@smithy/hash-node": "^4.0.1",
      "@smithy/invalid-dependency": "^4.0.1",
      "@smithy/middleware-content-length": "^4.0.1",
      "@smithy/middleware-endpoint": "^4.0.2",
      "@smithy/middleware-retry": "^4.0.3",
      "@smithy/middleware-serde": "^4.0.1",
      "@smithy/middleware-stack": "^4.0.1",
      "@smithy/node-config-provider": "^4.0.1",
      "@smithy/node-http-handler": "^4.0.2",
      "@smithy/protocol-http": "^5.0.1",
      "@smithy/smithy-client": "^4.1.2",
      "@smithy/types": "^4.1.0",
      "@smithy/url-parser": "^4.0.1",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.3",
      "@smithy/util-defaults-mode-node": "^4.0.3",
      "@smithy/util-endpoints": "^3.0.1",
      "@smithy/util-middleware": "^4.0.1",
      "@smithy/util-retry": "^4.0.1",
      "@smithy/util-utf8": "^4.0.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      "@tsconfig/node18": "18.2.4",
      "@types/node": "^18.19.69",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.2.2"
    },
    engines: {
      node: ">=18.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": [
          "dist-types/ts3.4/*"
        ]
      }
    },
    files: [
      "dist-*/**"
    ],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-sso"
    }
  };
});

// ../../node_modules/@aws-sdk/util-user-agent-node/dist-es/crt-availability.js
var crtAvailability;
var init_crt_availability = __esm(() => {
  crtAvailability = {
    isCrtAvailable: false
  };
});

// ../../node_modules/@aws-sdk/util-user-agent-node/dist-es/is-crt-available.js
var isCrtAvailable = () => {
  if (crtAvailability.isCrtAvailable) {
    return ["md/crt-avail"];
  }
  return null;
};
var init_is_crt_available = __esm(() => {
  init_crt_availability();
});

// ../../node_modules/@aws-sdk/util-user-agent-node/dist-es/defaultUserAgent.js
import { platform as platform2, release } from "os";
import { env as env2, versions } from "process";
var createDefaultUserAgentProvider = ({ serviceId, clientVersion }) => {
  return async (config4) => {
    const sections = [
      ["aws-sdk-js", clientVersion],
      ["ua", "2.1"],
      [`os/${platform2()}`, release()],
      ["lang/js"],
      ["md/nodejs", `${versions.node}`]
    ];
    const crtAvailable = isCrtAvailable();
    if (crtAvailable) {
      sections.push(crtAvailable);
    }
    if (serviceId) {
      sections.push([`api/${serviceId}`, clientVersion]);
    }
    if (env2.AWS_EXECUTION_ENV) {
      sections.push([`exec-env/${env2.AWS_EXECUTION_ENV}`]);
    }
    const appId = await config4?.userAgentAppId?.();
    const resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
    return resolvedUserAgent;
  };
};
var init_defaultUserAgent = __esm(() => {
  init_is_crt_available();
  init_crt_availability();
});

// ../../node_modules/@aws-sdk/util-user-agent-node/dist-es/nodeAppIdConfigOptions.js
var UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID", UA_APP_ID_INI_NAME = "sdk_ua_app_id", UA_APP_ID_INI_NAME_DEPRECATED = "sdk-ua-app-id", NODE_APP_ID_CONFIG_OPTIONS;
var init_nodeAppIdConfigOptions = __esm(() => {
  init_dist_es18();
  NODE_APP_ID_CONFIG_OPTIONS = {
    environmentVariableSelector: (env3) => env3[UA_APP_ID_ENV_NAME],
    configFileSelector: (profile) => profile[UA_APP_ID_INI_NAME] ?? profile[UA_APP_ID_INI_NAME_DEPRECATED],
    default: DEFAULT_UA_APP_ID
  };
});

// ../../node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js
var init_dist_es33 = __esm(() => {
  init_defaultUserAgent();
  init_nodeAppIdConfigOptions();
});

// ../../node_modules/@smithy/hash-node/dist-es/index.js
import { Buffer as Buffer5 } from "buffer";
import { createHash as createHash2, createHmac } from "crypto";

class Hash {
  constructor(algorithmIdentifier, secret) {
    this.algorithmIdentifier = algorithmIdentifier;
    this.secret = secret;
    this.reset();
  }
  update(toHash, encoding) {
    this.hash.update(toUint8Array2(castSourceData(toHash, encoding)));
  }
  digest() {
    return Promise.resolve(this.hash.digest());
  }
  reset() {
    this.hash = this.secret ? createHmac(this.algorithmIdentifier, castSourceData(this.secret)) : createHash2(this.algorithmIdentifier);
  }
}
function castSourceData(toCast, encoding) {
  if (Buffer5.isBuffer(toCast)) {
    return toCast;
  }
  if (typeof toCast === "string") {
    return fromString2(toCast, encoding);
  }
  if (ArrayBuffer.isView(toCast)) {
    return fromArrayBuffer2(toCast.buffer, toCast.byteOffset, toCast.byteLength);
  }
  return fromArrayBuffer2(toCast);
}
var init_dist_es34 = __esm(() => {
  init_dist_es2();
  init_dist_es3();
});

// ../../node_modules/@smithy/util-body-length-node/dist-es/calculateBodyLength.js
import { fstatSync, lstatSync } from "fs";
var calculateBodyLength = (body) => {
  if (!body) {
    return 0;
  }
  if (typeof body === "string") {
    return Buffer.byteLength(body);
  } else if (typeof body.byteLength === "number") {
    return body.byteLength;
  } else if (typeof body.size === "number") {
    return body.size;
  } else if (typeof body.start === "number" && typeof body.end === "number") {
    return body.end + 1 - body.start;
  } else if (typeof body.path === "string" || Buffer.isBuffer(body.path)) {
    return lstatSync(body.path).size;
  } else if (typeof body.fd === "number") {
    return fstatSync(body.fd).size;
  }
  throw new Error(`Body Length computation failed for ${body}`);
};
var init_calculateBodyLength = () => {
};

// ../../node_modules/@smithy/util-body-length-node/dist-es/index.js
var init_dist_es35 = __esm(() => {
  init_calculateBodyLength();
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/endpoint/ruleset.js
var u4 = "required", v6 = "fn", w3 = "argv", x3 = "ref", a4 = true, b2 = "isSet", c4 = "booleanEquals", d3 = "error", e3 = "endpoint", f3 = "tree", g2 = "PartitionResult", h3 = "getAttr", i3, j3, k3, l3, m3, n3, o2, p4, q3, r4, s4, t3, _data2, ruleSet2;
var init_ruleset = __esm(() => {
  i3 = { [u4]: false, type: "String" };
  j3 = { [u4]: true, default: false, type: "Boolean" };
  k3 = { [x3]: "Endpoint" };
  l3 = { [v6]: c4, [w3]: [{ [x3]: "UseFIPS" }, true] };
  m3 = { [v6]: c4, [w3]: [{ [x3]: "UseDualStack" }, true] };
  n3 = {};
  o2 = { [v6]: h3, [w3]: [{ [x3]: g2 }, "supportsFIPS"] };
  p4 = { [x3]: g2 };
  q3 = { [v6]: c4, [w3]: [true, { [v6]: h3, [w3]: [p4, "supportsDualStack"] }] };
  r4 = [l3];
  s4 = [m3];
  t3 = [{ [x3]: "Region" }];
  _data2 = { version: "1.0", parameters: { Region: i3, UseDualStack: j3, UseFIPS: j3, Endpoint: i3 }, rules: [{ conditions: [{ [v6]: b2, [w3]: [k3] }], rules: [{ conditions: r4, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d3 }, { conditions: s4, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d3 }, { endpoint: { url: k3, properties: n3, headers: n3 }, type: e3 }], type: f3 }, { conditions: [{ [v6]: b2, [w3]: t3 }], rules: [{ conditions: [{ [v6]: "aws.partition", [w3]: t3, assign: g2 }], rules: [{ conditions: [l3, m3], rules: [{ conditions: [{ [v6]: c4, [w3]: [a4, o2] }, q3], rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n3, headers: n3 }, type: e3 }], type: f3 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d3 }], type: f3 }, { conditions: r4, rules: [{ conditions: [{ [v6]: c4, [w3]: [o2, a4] }], rules: [{ conditions: [{ [v6]: "stringEquals", [w3]: [{ [v6]: h3, [w3]: [p4, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://portal.sso.{Region}.amazonaws.com", properties: n3, headers: n3 }, type: e3 }, { endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n3, headers: n3 }, type: e3 }], type: f3 }, { error: "FIPS is enabled but this partition does not support FIPS", type: d3 }], type: f3 }, { conditions: s4, rules: [{ conditions: [q3], rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n3, headers: n3 }, type: e3 }], type: f3 }, { error: "DualStack is enabled but this partition does not support DualStack", type: d3 }], type: f3 }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: n3, headers: n3 }, type: e3 }], type: f3 }], type: f3 }, { error: "Invalid Configuration: Missing Region", type: d3 }] };
  ruleSet2 = _data2;
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/endpoint/endpointResolver.js
var cache2, defaultEndpointResolver2 = (endpointParams, context = {}) => {
  return cache2.get(endpointParams, () => resolveEndpoint2(ruleSet2, {
    endpointParams,
    logger: context.logger
  }));
};
var init_endpointResolver = __esm(() => {
  init_dist_es17();
  init_dist_es16();
  init_ruleset();
  cache2 = new EndpointCache({
    size: 50,
    params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
  });
  customEndpointFunctions.aws = awsEndpointFunctions;
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.shared.js
var import_core12, import_core13, getRuntimeConfig = (config4) => {
  return {
    apiVersion: "2019-06-10",
    base64Decoder: config4?.base64Decoder ?? fromBase643,
    base64Encoder: config4?.base64Encoder ?? toBase643,
    disableHostPrefix: config4?.disableHostPrefix ?? false,
    endpointProvider: config4?.endpointProvider ?? defaultEndpointResolver2,
    extensions: config4?.extensions ?? [],
    httpAuthSchemeProvider: config4?.httpAuthSchemeProvider ?? defaultSSOHttpAuthSchemeProvider,
    httpAuthSchemes: config4?.httpAuthSchemes ?? [
      {
        schemeId: "aws.auth#sigv4",
        identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
        signer: new import_core12.AwsSdkSigV4Signer
      },
      {
        schemeId: "smithy.api#noAuth",
        identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
        signer: new import_core13.NoAuthSigner
      }
    ],
    logger: config4?.logger ?? new NoOpLogger,
    serviceId: config4?.serviceId ?? "SSO",
    urlParser: config4?.urlParser ?? parseUrl,
    utf8Decoder: config4?.utf8Decoder ?? fromUtf84,
    utf8Encoder: config4?.utf8Encoder ?? toUtf82
  };
};
var init_runtimeConfig_shared = __esm(() => {
  import_core12 = __toESM(require_dist_cjs20(), 1);
  import_core13 = __toESM(require_dist_cjs15(), 1);
  init_dist_es14();
  init_dist_es23();
  init_dist_es4();
  init_dist_es3();
  init_httpAuthSchemeProvider();
  init_endpointResolver();
});

// ../../node_modules/@smithy/util-defaults-mode-node/dist-es/constants.js
var AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV", AWS_REGION_ENV = "AWS_REGION", AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION", ENV_IMDS_DISABLED2 = "AWS_EC2_METADATA_DISABLED", DEFAULTS_MODE_OPTIONS, IMDS_REGION_PATH = "/latest/meta-data/placement/region";
var init_constants6 = __esm(() => {
  DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
});

// ../../node_modules/@smithy/util-defaults-mode-node/dist-es/defaultsModeConfig.js
var AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE", AWS_DEFAULTS_MODE_CONFIG = "defaults_mode", NODE_DEFAULTS_MODE_CONFIG_OPTIONS;
var init_defaultsModeConfig = __esm(() => {
  NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env3) => {
      return env3[AWS_DEFAULTS_MODE_ENV];
    },
    configFileSelector: (profile) => {
      return profile[AWS_DEFAULTS_MODE_CONFIG];
    },
    default: "legacy"
  };
});

// ../../node_modules/@smithy/util-defaults-mode-node/dist-es/resolveDefaultsModeConfig.js
var import_property_provider19, resolveDefaultsModeConfig = ({ region = loadConfig(NODE_REGION_CONFIG_OPTIONS), defaultsMode = loadConfig(NODE_DEFAULTS_MODE_CONFIG_OPTIONS) } = {}) => import_property_provider19.memoize(async () => {
  const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
  switch (mode?.toLowerCase()) {
    case "auto":
      return resolveNodeDefaultsModeAuto(region);
    case "in-region":
    case "cross-region":
    case "mobile":
    case "standard":
    case "legacy":
      return Promise.resolve(mode?.toLocaleLowerCase());
    case undefined:
      return Promise.resolve("legacy");
    default:
      throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
  }
}), resolveNodeDefaultsModeAuto = async (clientRegion) => {
  if (clientRegion) {
    const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
    const inferredRegion = await inferPhysicalRegion();
    if (!inferredRegion) {
      return "standard";
    }
    if (resolvedRegion === inferredRegion) {
      return "in-region";
    } else {
      return "cross-region";
    }
  }
  return "standard";
}, inferPhysicalRegion = async () => {
  if (process.env[AWS_EXECUTION_ENV] && (process.env[AWS_REGION_ENV] || process.env[AWS_DEFAULT_REGION_ENV])) {
    return process.env[AWS_REGION_ENV] ?? process.env[AWS_DEFAULT_REGION_ENV];
  }
  if (!process.env[ENV_IMDS_DISABLED2]) {
    try {
      const { getInstanceMetadataEndpoint: getInstanceMetadataEndpoint2, httpRequest: httpRequest3 } = await Promise.resolve().then(() => (init_dist_es30(), exports_dist_es2));
      const endpoint = await getInstanceMetadataEndpoint2();
      return (await httpRequest3({ ...endpoint, path: IMDS_REGION_PATH })).toString();
    } catch (e4) {
    }
  }
};
var init_resolveDefaultsModeConfig = __esm(() => {
  init_dist_es19();
  init_dist_es22();
  import_property_provider19 = __toESM(require_dist_cjs16(), 1);
  init_constants6();
  init_defaultsModeConfig();
});

// ../../node_modules/@smithy/util-defaults-mode-node/dist-es/index.js
var init_dist_es36 = __esm(() => {
  init_resolveDefaultsModeConfig();
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.js
var import_core14, getRuntimeConfig2 = (config4) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config4);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig(config4);
  import_core14.emitWarningIfUnsupportedVersion(process.version);
  const profileConfig = { profile: config4?.profile };
  return {
    ...clientSharedValues,
    ...config4,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config4?.bodyLengthChecker ?? calculateBodyLength,
    defaultUserAgentProvider: config4?.defaultUserAgentProvider ?? createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: package_default2.version }),
    maxAttempts: config4?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config4),
    region: config4?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, { ...NODE_REGION_CONFIG_FILE_OPTIONS, ...profileConfig }),
    requestHandler: NodeHttpHandler.create(config4?.requestHandler ?? defaultConfigProvider),
    retryMode: config4?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }, config4),
    sha256: config4?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config4?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config4?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, profileConfig),
    useFipsEndpoint: config4?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, profileConfig),
    userAgentAppId: config4?.userAgentAppId ?? loadConfig(NODE_APP_ID_CONFIG_OPTIONS, profileConfig)
  };
};
var init_runtimeConfig = __esm(() => {
  init_package();
  import_core14 = __toESM(require_dist_cjs20(), 1);
  init_dist_es33();
  init_dist_es19();
  init_dist_es34();
  init_dist_es28();
  init_dist_es22();
  init_dist_es6();
  init_dist_es35();
  init_dist_es27();
  init_runtimeConfig_shared();
  init_dist_es14();
  init_dist_es36();
  init_dist_es14();
});

// ../../node_modules/@aws-sdk/region-config-resolver/dist-es/extensions/index.js
var getAwsRegionExtensionConfiguration = (runtimeConfig) => {
  let runtimeConfigRegion = async () => {
    if (runtimeConfig.region === undefined) {
      throw new Error("Region is missing from runtimeConfig");
    }
    const region = runtimeConfig.region;
    if (typeof region === "string") {
      return region;
    }
    return region();
  };
  return {
    setRegion(region) {
      runtimeConfigRegion = region;
    },
    region() {
      return runtimeConfigRegion;
    }
  };
}, resolveAwsRegionExtensionConfiguration = (awsRegionExtensionConfiguration) => {
  return {
    region: awsRegionExtensionConfiguration.region()
  };
};

// ../../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/config.js
var init_config3 = () => {
};
// ../../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/getRealRegion.js
var init_getRealRegion2 = () => {
};

// ../../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/resolveRegionConfig.js
var init_resolveRegionConfig2 = __esm(() => {
  init_getRealRegion2();
});

// ../../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/index.js
var init_regionConfig2 = __esm(() => {
  init_config3();
  init_resolveRegionConfig2();
});

// ../../node_modules/@aws-sdk/region-config-resolver/dist-es/index.js
var init_dist_es37 = __esm(() => {
  init_regionConfig2();
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration = (runtimeConfig) => {
  const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
  let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
  let _credentials = runtimeConfig.credentials;
  return {
    setHttpAuthScheme(httpAuthScheme) {
      const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
      if (index === -1) {
        _httpAuthSchemes.push(httpAuthScheme);
      } else {
        _httpAuthSchemes.splice(index, 1, httpAuthScheme);
      }
    },
    httpAuthSchemes() {
      return _httpAuthSchemes;
    },
    setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
      _httpAuthSchemeProvider = httpAuthSchemeProvider;
    },
    httpAuthSchemeProvider() {
      return _httpAuthSchemeProvider;
    },
    setCredentials(credentials) {
      _credentials = credentials;
    },
    credentials() {
      return _credentials;
    }
  };
}, resolveHttpAuthRuntimeConfig = (config5) => {
  return {
    httpAuthSchemes: config5.httpAuthSchemes(),
    httpAuthSchemeProvider: config5.httpAuthSchemeProvider(),
    credentials: config5.credentials()
  };
};

// ../../node_modules/@aws-sdk/client-sso/dist-es/runtimeExtensions.js
var asPartial = (t4) => t4, resolveRuntimeExtensions = (runtimeConfig, extensions4) => {
  const extensionConfiguration = {
    ...asPartial(getAwsRegionExtensionConfiguration(runtimeConfig)),
    ...asPartial(getDefaultExtensionConfiguration(runtimeConfig)),
    ...asPartial(getHttpHandlerExtensionConfiguration(runtimeConfig)),
    ...asPartial(getHttpAuthExtensionConfiguration(runtimeConfig))
  };
  extensions4.forEach((extension) => extension.configure(extensionConfiguration));
  return {
    ...runtimeConfig,
    ...resolveAwsRegionExtensionConfiguration(extensionConfiguration),
    ...resolveDefaultRuntimeConfig(extensionConfiguration),
    ...resolveHttpHandlerRuntimeConfig(extensionConfiguration),
    ...resolveHttpAuthRuntimeConfig(extensionConfiguration)
  };
};
var init_runtimeExtensions = __esm(() => {
  init_dist_es37();
  init_dist_es();
  init_dist_es14();
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/SSOClient.js
var import_core15, SSOClient;
var init_SSOClient = __esm(() => {
  init_dist_es10();
  init_dist_es11();
  init_dist_es12();
  init_dist_es18();
  init_dist_es19();
  import_core15 = __toESM(require_dist_cjs15(), 1);
  init_dist_es20();
  init_dist_es25();
  init_dist_es28();
  init_dist_es14();
  init_httpAuthSchemeProvider();
  init_EndpointParameters();
  init_runtimeConfig();
  init_runtimeExtensions();
  SSOClient = class SSOClient extends Client {
    config;
    constructor(...[configuration]) {
      const _config_0 = getRuntimeConfig2(configuration || {});
      const _config_1 = resolveClientEndpointParameters2(_config_0);
      const _config_2 = resolveUserAgentConfig(_config_1);
      const _config_3 = resolveRetryConfig(_config_2);
      const _config_4 = resolveRegionConfig(_config_3);
      const _config_5 = resolveHostHeaderConfig(_config_4);
      const _config_6 = resolveEndpointConfig(_config_5);
      const _config_7 = resolveHttpAuthSchemeConfig2(_config_6);
      const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
      super(_config_8);
      this.config = _config_8;
      this.middlewareStack.use(getUserAgentPlugin(this.config));
      this.middlewareStack.use(getRetryPlugin(this.config));
      this.middlewareStack.use(getContentLengthPlugin(this.config));
      this.middlewareStack.use(getHostHeaderPlugin(this.config));
      this.middlewareStack.use(getLoggerPlugin(this.config));
      this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
      this.middlewareStack.use(import_core15.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
        httpAuthSchemeParametersProvider: defaultSSOHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (config5) => new import_core15.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": config5.credentials
        })
      }));
      this.middlewareStack.use(import_core15.getHttpSigningPlugin(this.config));
    }
    destroy() {
      super.destroy();
    }
  };
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/models/SSOServiceException.js
var SSOServiceException;
var init_SSOServiceException = __esm(() => {
  init_dist_es14();
  SSOServiceException = class SSOServiceException extends ServiceException {
    constructor(options) {
      super(options);
      Object.setPrototypeOf(this, SSOServiceException.prototype);
    }
  };
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/models/models_0.js
var InvalidRequestException, ResourceNotFoundException, TooManyRequestsException, UnauthorizedException, GetRoleCredentialsRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.accessToken && { accessToken: SENSITIVE_STRING }
}), RoleCredentialsFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.secretAccessKey && { secretAccessKey: SENSITIVE_STRING },
  ...obj.sessionToken && { sessionToken: SENSITIVE_STRING }
}), GetRoleCredentialsResponseFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.roleCredentials && { roleCredentials: RoleCredentialsFilterSensitiveLog(obj.roleCredentials) }
}), ListAccountRolesRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.accessToken && { accessToken: SENSITIVE_STRING }
}), ListAccountsRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.accessToken && { accessToken: SENSITIVE_STRING }
}), LogoutRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.accessToken && { accessToken: SENSITIVE_STRING }
});
var init_models_0 = __esm(() => {
  init_dist_es14();
  init_SSOServiceException();
  InvalidRequestException = class InvalidRequestException extends SSOServiceException {
    name = "InvalidRequestException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "InvalidRequestException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, InvalidRequestException.prototype);
    }
  };
  ResourceNotFoundException = class ResourceNotFoundException extends SSOServiceException {
    name = "ResourceNotFoundException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ResourceNotFoundException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
    }
  };
  TooManyRequestsException = class TooManyRequestsException extends SSOServiceException {
    name = "TooManyRequestsException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "TooManyRequestsException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, TooManyRequestsException.prototype);
    }
  };
  UnauthorizedException = class UnauthorizedException extends SSOServiceException {
    name = "UnauthorizedException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "UnauthorizedException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, UnauthorizedException.prototype);
    }
  };
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/protocols/Aws_restJson1.js
var import_core16, import_core17, se_GetRoleCredentialsCommand = async (input, context) => {
  const b3 = import_core17.requestBuilder(input, context);
  const headers = map({}, isSerializableHeaderValue, {
    [_xasbt]: input[_aT]
  });
  b3.bp("/federation/credentials");
  const query = map({
    [_rn]: [, expectNonNull(input[_rN], `roleName`)],
    [_ai]: [, expectNonNull(input[_aI], `accountId`)]
  });
  let body;
  b3.m("GET").h(headers).q(query).b(body);
  return b3.build();
}, se_ListAccountRolesCommand = async (input, context) => {
  const b3 = import_core17.requestBuilder(input, context);
  const headers = map({}, isSerializableHeaderValue, {
    [_xasbt]: input[_aT]
  });
  b3.bp("/assignment/roles");
  const query = map({
    [_nt]: [, input[_nT]],
    [_mr]: [() => input.maxResults !== undefined, () => input[_mR].toString()],
    [_ai]: [, expectNonNull(input[_aI], `accountId`)]
  });
  let body;
  b3.m("GET").h(headers).q(query).b(body);
  return b3.build();
}, se_ListAccountsCommand = async (input, context) => {
  const b3 = import_core17.requestBuilder(input, context);
  const headers = map({}, isSerializableHeaderValue, {
    [_xasbt]: input[_aT]
  });
  b3.bp("/assignment/accounts");
  const query = map({
    [_nt]: [, input[_nT]],
    [_mr]: [() => input.maxResults !== undefined, () => input[_mR].toString()]
  });
  let body;
  b3.m("GET").h(headers).q(query).b(body);
  return b3.build();
}, se_LogoutCommand = async (input, context) => {
  const b3 = import_core17.requestBuilder(input, context);
  const headers = map({}, isSerializableHeaderValue, {
    [_xasbt]: input[_aT]
  });
  b3.bp("/logout");
  let body;
  b3.m("POST").h(headers).b(body);
  return b3.build();
}, de_GetRoleCredentialsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError2(output, context);
  }
  const contents = map({
    $metadata: deserializeMetadata3(output)
  });
  const data = expectNonNull(expectObject(await import_core16.parseJsonBody(output.body, context)), "body");
  const doc = take(data, {
    roleCredentials: _json
  });
  Object.assign(contents, doc);
  return contents;
}, de_ListAccountRolesCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError2(output, context);
  }
  const contents = map({
    $metadata: deserializeMetadata3(output)
  });
  const data = expectNonNull(expectObject(await import_core16.parseJsonBody(output.body, context)), "body");
  const doc = take(data, {
    nextToken: expectString,
    roleList: _json
  });
  Object.assign(contents, doc);
  return contents;
}, de_ListAccountsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError2(output, context);
  }
  const contents = map({
    $metadata: deserializeMetadata3(output)
  });
  const data = expectNonNull(expectObject(await import_core16.parseJsonBody(output.body, context)), "body");
  const doc = take(data, {
    accountList: _json,
    nextToken: expectString
  });
  Object.assign(contents, doc);
  return contents;
}, de_LogoutCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError2(output, context);
  }
  const contents = map({
    $metadata: deserializeMetadata3(output)
  });
  await import_protocols.collectBody(output.body, context);
  return contents;
}, de_CommandError2 = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await import_core16.parseJsonErrorBody(output.body, context)
  };
  const errorCode = import_core16.loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.sso#InvalidRequestException":
      throw await de_InvalidRequestExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.sso#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "TooManyRequestsException":
    case "com.amazonaws.sso#TooManyRequestsException":
      throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
    case "UnauthorizedException":
    case "com.amazonaws.sso#UnauthorizedException":
      throw await de_UnauthorizedExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError3({
        output,
        parsedBody,
        errorCode
      });
  }
}, throwDefaultError3, de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidRequestException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new ResourceNotFoundException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new TooManyRequestsException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, de_UnauthorizedExceptionRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new UnauthorizedException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, deserializeMetadata3 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
}), _aI = "accountId", _aT = "accessToken", _ai = "account_id", _mR = "maxResults", _mr = "max_result", _nT = "nextToken", _nt = "next_token", _rN = "roleName", _rn = "role_name", _xasbt = "x-amz-sso_bearer_token";
var init_Aws_restJson1 = __esm(() => {
  import_core16 = __toESM(require_dist_cjs20(), 1);
  import_core17 = __toESM(require_dist_cjs15(), 1);
  init_dist_es14();
  init_models_0();
  init_SSOServiceException();
  throwDefaultError3 = withBaseException(SSOServiceException);
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/commands/GetRoleCredentialsCommand.js
var GetRoleCredentialsCommand;
var init_GetRoleCredentialsCommand = __esm(() => {
  init_dist_es25();
  init_dist_es24();
  init_dist_es14();
  init_EndpointParameters();
  init_models_0();
  init_Aws_restJson1();
  GetRoleCredentialsCommand = class GetRoleCredentialsCommand extends Command.classBuilder().ep(commonParams2).m(function(Command2, cs2, config5, o3) {
    return [
      getSerdePlugin(config5, this.serialize, this.deserialize),
      getEndpointPlugin(config5, Command2.getEndpointParameterInstructions())
    ];
  }).s("SWBPortalService", "GetRoleCredentials", {}).n("SSOClient", "GetRoleCredentialsCommand").f(GetRoleCredentialsRequestFilterSensitiveLog, GetRoleCredentialsResponseFilterSensitiveLog).ser(se_GetRoleCredentialsCommand).de(de_GetRoleCredentialsCommand).build() {
  };
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/commands/ListAccountRolesCommand.js
var ListAccountRolesCommand;
var init_ListAccountRolesCommand = __esm(() => {
  init_dist_es25();
  init_dist_es24();
  init_dist_es14();
  init_EndpointParameters();
  init_models_0();
  init_Aws_restJson1();
  ListAccountRolesCommand = class ListAccountRolesCommand extends Command.classBuilder().ep(commonParams2).m(function(Command2, cs2, config5, o3) {
    return [
      getSerdePlugin(config5, this.serialize, this.deserialize),
      getEndpointPlugin(config5, Command2.getEndpointParameterInstructions())
    ];
  }).s("SWBPortalService", "ListAccountRoles", {}).n("SSOClient", "ListAccountRolesCommand").f(ListAccountRolesRequestFilterSensitiveLog, undefined).ser(se_ListAccountRolesCommand).de(de_ListAccountRolesCommand).build() {
  };
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/commands/ListAccountsCommand.js
var ListAccountsCommand;
var init_ListAccountsCommand = __esm(() => {
  init_dist_es25();
  init_dist_es24();
  init_dist_es14();
  init_EndpointParameters();
  init_models_0();
  init_Aws_restJson1();
  ListAccountsCommand = class ListAccountsCommand extends Command.classBuilder().ep(commonParams2).m(function(Command2, cs2, config5, o3) {
    return [
      getSerdePlugin(config5, this.serialize, this.deserialize),
      getEndpointPlugin(config5, Command2.getEndpointParameterInstructions())
    ];
  }).s("SWBPortalService", "ListAccounts", {}).n("SSOClient", "ListAccountsCommand").f(ListAccountsRequestFilterSensitiveLog, undefined).ser(se_ListAccountsCommand).de(de_ListAccountsCommand).build() {
  };
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/commands/LogoutCommand.js
var LogoutCommand;
var init_LogoutCommand = __esm(() => {
  init_dist_es25();
  init_dist_es24();
  init_dist_es14();
  init_EndpointParameters();
  init_models_0();
  init_Aws_restJson1();
  LogoutCommand = class LogoutCommand extends Command.classBuilder().ep(commonParams2).m(function(Command2, cs2, config5, o3) {
    return [
      getSerdePlugin(config5, this.serialize, this.deserialize),
      getEndpointPlugin(config5, Command2.getEndpointParameterInstructions())
    ];
  }).s("SWBPortalService", "Logout", {}).n("SSOClient", "LogoutCommand").f(LogoutRequestFilterSensitiveLog, undefined).ser(se_LogoutCommand).de(de_LogoutCommand).build() {
  };
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/SSO.js
var commands, SSO;
var init_SSO = __esm(() => {
  init_dist_es14();
  init_GetRoleCredentialsCommand();
  init_ListAccountRolesCommand();
  init_ListAccountsCommand();
  init_LogoutCommand();
  init_SSOClient();
  commands = {
    GetRoleCredentialsCommand,
    ListAccountRolesCommand,
    ListAccountsCommand,
    LogoutCommand
  };
  SSO = class SSO extends SSOClient {
  };
  createAggregatedClient(commands, SSO);
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/commands/index.js
var init_commands = __esm(() => {
  init_GetRoleCredentialsCommand();
  init_ListAccountRolesCommand();
  init_ListAccountsCommand();
  init_LogoutCommand();
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/pagination/Interfaces.js
var init_Interfaces = () => {
};

// ../../node_modules/@aws-sdk/client-sso/dist-es/pagination/ListAccountRolesPaginator.js
var import_core18, paginateListAccountRoles;
var init_ListAccountRolesPaginator = __esm(() => {
  import_core18 = __toESM(require_dist_cjs15(), 1);
  init_ListAccountRolesCommand();
  init_SSOClient();
  paginateListAccountRoles = import_core18.createPaginator(SSOClient, ListAccountRolesCommand, "nextToken", "nextToken", "maxResults");
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/pagination/ListAccountsPaginator.js
var import_core19, paginateListAccounts;
var init_ListAccountsPaginator = __esm(() => {
  import_core19 = __toESM(require_dist_cjs15(), 1);
  init_ListAccountsCommand();
  init_SSOClient();
  paginateListAccounts = import_core19.createPaginator(SSOClient, ListAccountsCommand, "nextToken", "nextToken", "maxResults");
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/pagination/index.js
var init_pagination = __esm(() => {
  init_Interfaces();
  init_ListAccountRolesPaginator();
  init_ListAccountsPaginator();
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/models/index.js
var init_models = __esm(() => {
  init_models_0();
});

// ../../node_modules/@aws-sdk/client-sso/dist-es/index.js
var init_dist_es38 = __esm(() => {
  init_SSOClient();
  init_SSO();
  init_commands();
  init_pagination();
  init_models();
});

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/loadSso.js
var exports_loadSso = {};
__export(exports_loadSso, {
  SSOClient: () => SSOClient,
  GetRoleCredentialsCommand: () => GetRoleCredentialsCommand
});
var init_loadSso = __esm(() => {
  init_dist_es38();
});

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/resolveSSOCredentials.js
var import_client3, import_property_provider20, SHOULD_FAIL_CREDENTIAL_CHAIN = false, resolveSSOCredentials = async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, clientConfig, parentClientConfig, profile, logger: logger2 }) => {
  let token;
  const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
  if (ssoSession) {
    try {
      const _token = await fromSso({ profile })();
      token = {
        accessToken: _token.token,
        expiresAt: new Date(_token.expiration).toISOString()
      };
    } catch (e4) {
      throw new import_property_provider20.CredentialsProviderError(e4.message, {
        tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
        logger: logger2
      });
    }
  } else {
    try {
      token = await getSSOTokenFromFile2(ssoStartUrl);
    } catch (e4) {
      throw new import_property_provider20.CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, {
        tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
        logger: logger2
      });
    }
  }
  if (new Date(token.expiresAt).getTime() - Date.now() <= 0) {
    throw new import_property_provider20.CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, {
      tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
      logger: logger2
    });
  }
  const { accessToken } = token;
  const { SSOClient: SSOClient3, GetRoleCredentialsCommand: GetRoleCredentialsCommand3 } = await Promise.resolve().then(() => (init_loadSso(), exports_loadSso));
  const sso = ssoClient || new SSOClient3(Object.assign({}, clientConfig ?? {}, {
    logger: clientConfig?.logger ?? parentClientConfig?.logger,
    region: clientConfig?.region ?? ssoRegion
  }));
  let ssoResp;
  try {
    ssoResp = await sso.send(new GetRoleCredentialsCommand3({
      accountId: ssoAccountId,
      roleName: ssoRoleName,
      accessToken
    }));
  } catch (e4) {
    throw new import_property_provider20.CredentialsProviderError(e4, {
      tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
      logger: logger2
    });
  }
  const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration, credentialScope, accountId } = {} } = ssoResp;
  if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
    throw new import_property_provider20.CredentialsProviderError("SSO returns an invalid temporary credential.", {
      tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
      logger: logger2
    });
  }
  const credentials = {
    accessKeyId,
    secretAccessKey,
    sessionToken,
    expiration: new Date(expiration),
    ...credentialScope && { credentialScope },
    ...accountId && { accountId }
  };
  if (ssoSession) {
    import_client3.setCredentialFeature(credentials, "CREDENTIALS_SSO", "s");
  } else {
    import_client3.setCredentialFeature(credentials, "CREDENTIALS_SSO_LEGACY", "u");
  }
  return credentials;
};
var init_resolveSSOCredentials = __esm(() => {
  import_client3 = __toESM(require_client(), 1);
  init_dist_es32();
  import_property_provider20 = __toESM(require_dist_cjs16(), 1);
  init_dist_es21();
});

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/validateSsoProfile.js
var import_property_provider21, validateSsoProfile = (profile, logger2) => {
  const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile;
  if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {
    throw new import_property_provider21.CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", ` + `"sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, { tryNextLink: false, logger: logger2 });
  }
  return profile;
};
var init_validateSsoProfile = __esm(() => {
  import_property_provider21 = __toESM(require_dist_cjs16(), 1);
});

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/fromSSO.js
var import_property_provider22, fromSSO = (init2 = {}) => async ({ callerClientConfig } = {}) => {
  init2.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO");
  const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init2;
  const { ssoClient } = init2;
  const profileName = getProfileName({
    profile: init2.profile ?? callerClientConfig?.profile
  });
  if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
    const profiles = await parseKnownFiles(init2);
    const profile = profiles[profileName];
    if (!profile) {
      throw new import_property_provider22.CredentialsProviderError(`Profile ${profileName} was not found.`, { logger: init2.logger });
    }
    if (!isSsoProfile(profile)) {
      throw new import_property_provider22.CredentialsProviderError(`Profile ${profileName} is not configured with SSO credentials.`, {
        logger: init2.logger
      });
    }
    if (profile?.sso_session) {
      const ssoSessions = await loadSsoSessionData(init2);
      const session = ssoSessions[profile.sso_session];
      const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile.sso_session}`;
      if (ssoRegion && ssoRegion !== session.sso_region) {
        throw new import_property_provider22.CredentialsProviderError(`Conflicting SSO region` + conflictMsg, {
          tryNextLink: false,
          logger: init2.logger
        });
      }
      if (ssoStartUrl && ssoStartUrl !== session.sso_start_url) {
        throw new import_property_provider22.CredentialsProviderError(`Conflicting SSO start_url` + conflictMsg, {
          tryNextLink: false,
          logger: init2.logger
        });
      }
      profile.sso_region = session.sso_region;
      profile.sso_start_url = session.sso_start_url;
    }
    const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = validateSsoProfile(profile, init2.logger);
    return resolveSSOCredentials({
      ssoStartUrl: sso_start_url,
      ssoSession: sso_session,
      ssoAccountId: sso_account_id,
      ssoRegion: sso_region,
      ssoRoleName: sso_role_name,
      ssoClient,
      clientConfig: init2.clientConfig,
      parentClientConfig: init2.parentClientConfig,
      profile: profileName
    });
  } else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {
    throw new import_property_provider22.CredentialsProviderError("Incomplete configuration. The fromSSO() argument hash must include " + '"ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"', { tryNextLink: false, logger: init2.logger });
  } else {
    return resolveSSOCredentials({
      ssoStartUrl,
      ssoSession,
      ssoAccountId,
      ssoRegion,
      ssoRoleName,
      ssoClient,
      clientConfig: init2.clientConfig,
      parentClientConfig: init2.parentClientConfig,
      profile: profileName
    });
  }
};
var init_fromSSO = __esm(() => {
  import_property_provider22 = __toESM(require_dist_cjs16(), 1);
  init_dist_es21();
  init_resolveSSOCredentials();
  init_validateSsoProfile();
});

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/types.js
var init_types9 = () => {
};

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/index.js
var exports_dist_es4 = {};
__export(exports_dist_es4, {
  validateSsoProfile: () => validateSsoProfile,
  isSsoProfile: () => isSsoProfile,
  fromSSO: () => fromSSO
});
var init_dist_es39 = __esm(() => {
  init_fromSSO();
  init_types9();
  init_validateSsoProfile();
});

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveCredentialSource.js
var import_client4, import_property_provider23, resolveCredentialSource = (credentialSource, profileName, logger2) => {
  const sourceProvidersMap = {
    EcsContainer: async (options) => {
      const { fromHttp: fromHttp2 } = await Promise.resolve().then(() => (init_dist_es31(), exports_dist_es3));
      const { fromContainerMetadata: fromContainerMetadata3 } = await Promise.resolve().then(() => (init_dist_es30(), exports_dist_es2));
      logger2?.debug("@aws-sdk/credential-provider-ini - credential_source is EcsContainer");
      return async () => import_property_provider23.chain(fromHttp2(options ?? {}), fromContainerMetadata3(options))().then(setNamedProvider);
    },
    Ec2InstanceMetadata: async (options) => {
      logger2?.debug("@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata");
      const { fromInstanceMetadata: fromInstanceMetadata3 } = await Promise.resolve().then(() => (init_dist_es30(), exports_dist_es2));
      return async () => fromInstanceMetadata3(options)().then(setNamedProvider);
    },
    Environment: async (options) => {
      logger2?.debug("@aws-sdk/credential-provider-ini - credential_source is Environment");
      const { fromEnv: fromEnv4 } = await Promise.resolve().then(() => (init_dist_es29(), exports_dist_es));
      return async () => fromEnv4(options)().then(setNamedProvider);
    }
  };
  if (credentialSource in sourceProvidersMap) {
    return sourceProvidersMap[credentialSource];
  } else {
    throw new import_property_provider23.CredentialsProviderError(`Unsupported credential source in profile ${profileName}. Got ${credentialSource}, expected EcsContainer or Ec2InstanceMetadata or Environment.`, { logger: logger2 });
  }
}, setNamedProvider = (creds) => import_client4.setCredentialFeature(creds, "CREDENTIALS_PROFILE_NAMED_PROVIDER", "p");
var init_resolveCredentialSource = __esm(() => {
  import_client4 = __toESM(require_client(), 1);
  import_property_provider23 = __toESM(require_dist_cjs16(), 1);
});

// ../../node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/auth/httpAuthSchemeProvider.js
var require_httpAuthSchemeProvider2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveHttpAuthSchemeConfig = exports.resolveStsAuthConfig = exports.defaultSTSHttpAuthSchemeProvider = exports.defaultSTSHttpAuthSchemeParametersProvider = undefined;
  var core_1 = require_dist_cjs20();
  var util_middleware_1 = require_dist_cjs3();
  var STSClient_1 = require_STSClient();
  var defaultSTSHttpAuthSchemeParametersProvider = async (config5, context, input) => {
    return {
      operation: (0, util_middleware_1.getSmithyContext)(context).operation,
      region: await (0, util_middleware_1.normalizeProvider)(config5.region)() || (() => {
        throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
      })()
    };
  };
  exports.defaultSTSHttpAuthSchemeParametersProvider = defaultSTSHttpAuthSchemeParametersProvider;
  function createAwsAuthSigv4HttpAuthOption3(authParameters) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "sts",
        region: authParameters.region
      },
      propertiesExtractor: (config5, context) => ({
        signingProperties: {
          config: config5,
          context
        }
      })
    };
  }
  function createSmithyApiNoAuthHttpAuthOption2(authParameters) {
    return {
      schemeId: "smithy.api#noAuth"
    };
  }
  var defaultSTSHttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
      case "AssumeRoleWithWebIdentity": {
        options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
        break;
      }
      default: {
        options.push(createAwsAuthSigv4HttpAuthOption3(authParameters));
      }
    }
    return options;
  };
  exports.defaultSTSHttpAuthSchemeProvider = defaultSTSHttpAuthSchemeProvider;
  var resolveStsAuthConfig = (input) => ({
    ...input,
    stsClientCtor: STSClient_1.STSClient
  });
  exports.resolveStsAuthConfig = resolveStsAuthConfig;
  var resolveHttpAuthSchemeConfig3 = (config5) => {
    const config_0 = (0, exports.resolveStsAuthConfig)(config5);
    const config_1 = (0, core_1.resolveAwsSdkSigV4Config)(config_0);
    return {
      ...config_1
    };
  };
  exports.resolveHttpAuthSchemeConfig = resolveHttpAuthSchemeConfig3;
});

// ../../node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/endpoint/EndpointParameters.js
var require_EndpointParameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.commonParams = exports.resolveClientEndpointParameters = undefined;
  var resolveClientEndpointParameters3 = (options) => {
    return {
      ...options,
      useDualstackEndpoint: options.useDualstackEndpoint ?? false,
      useFipsEndpoint: options.useFipsEndpoint ?? false,
      useGlobalEndpoint: options.useGlobalEndpoint ?? false,
      defaultSigningName: "sts"
    };
  };
  exports.resolveClientEndpointParameters = resolveClientEndpointParameters3;
  exports.commonParams = {
    UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
  };
});

// ../../node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/endpoint/ruleset.js
var require_ruleset2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ruleSet = undefined;
  var F3 = "required";
  var G4 = "type";
  var H2 = "fn";
  var I4 = "argv";
  var J3 = "ref";
  var a5 = false;
  var b3 = true;
  var c5 = "booleanEquals";
  var d4 = "stringEquals";
  var e4 = "sigv4";
  var f4 = "sts";
  var g3 = "us-east-1";
  var h4 = "endpoint";
  var i4 = "https://sts.{Region}.{PartitionResult#dnsSuffix}";
  var j4 = "tree";
  var k4 = "error";
  var l4 = "getAttr";
  var m4 = { [F3]: false, [G4]: "String" };
  var n4 = { [F3]: true, default: false, [G4]: "Boolean" };
  var o3 = { [J3]: "Endpoint" };
  var p5 = { [H2]: "isSet", [I4]: [{ [J3]: "Region" }] };
  var q4 = { [J3]: "Region" };
  var r5 = { [H2]: "aws.partition", [I4]: [q4], assign: "PartitionResult" };
  var s5 = { [J3]: "UseFIPS" };
  var t4 = { [J3]: "UseDualStack" };
  var u5 = { url: "https://sts.amazonaws.com", properties: { authSchemes: [{ name: e4, signingName: f4, signingRegion: g3 }] }, headers: {} };
  var v7 = {};
  var w4 = { conditions: [{ [H2]: d4, [I4]: [q4, "aws-global"] }], [h4]: u5, [G4]: h4 };
  var x4 = { [H2]: c5, [I4]: [s5, true] };
  var y4 = { [H2]: c5, [I4]: [t4, true] };
  var z3 = { [H2]: l4, [I4]: [{ [J3]: "PartitionResult" }, "supportsFIPS"] };
  var A4 = { [J3]: "PartitionResult" };
  var B4 = { [H2]: c5, [I4]: [true, { [H2]: l4, [I4]: [A4, "supportsDualStack"] }] };
  var C3 = [{ [H2]: "isSet", [I4]: [o3] }];
  var D3 = [x4];
  var E3 = [y4];
  var _data3 = { version: "1.0", parameters: { Region: m4, UseDualStack: n4, UseFIPS: n4, Endpoint: m4, UseGlobalEndpoint: n4 }, rules: [{ conditions: [{ [H2]: c5, [I4]: [{ [J3]: "UseGlobalEndpoint" }, b3] }, { [H2]: "not", [I4]: C3 }, p5, r5, { [H2]: c5, [I4]: [s5, a5] }, { [H2]: c5, [I4]: [t4, a5] }], rules: [{ conditions: [{ [H2]: d4, [I4]: [q4, "ap-northeast-1"] }], endpoint: u5, [G4]: h4 }, { conditions: [{ [H2]: d4, [I4]: [q4, "ap-south-1"] }], endpoint: u5, [G4]: h4 }, { conditions: [{ [H2]: d4, [I4]: [q4, "ap-southeast-1"] }], endpoint: u5, [G4]: h4 }, { conditions: [{ [H2]: d4, [I4]: [q4, "ap-southeast-2"] }], endpoint: u5, [G4]: h4 }, w4, { conditions: [{ [H2]: d4, [I4]: [q4, "ca-central-1"] }], endpoint: u5, [G4]: h4 }, { conditions: [{ [H2]: d4, [I4]: [q4, "eu-central-1"] }], endpoint: u5, [G4]: h4 }, { conditions: [{ [H2]: d4, [I4]: [q4, "eu-north-1"] }], endpoint: u5, [G4]: h4 }, { conditions: [{ [H2]: d4, [I4]: [q4, "eu-west-1"] }], endpoint: u5, [G4]: h4 }, { conditions: [{ [H2]: d4, [I4]: [q4, "eu-west-2"] }], endpoint: u5, [G4]: h4 }, { conditions: [{ [H2]: d4, [I4]: [q4, "eu-west-3"] }], endpoint: u5, [G4]: h4 }, { conditions: [{ [H2]: d4, [I4]: [q4, "sa-east-1"] }], endpoint: u5, [G4]: h4 }, { conditions: [{ [H2]: d4, [I4]: [q4, g3] }], endpoint: u5, [G4]: h4 }, { conditions: [{ [H2]: d4, [I4]: [q4, "us-east-2"] }], endpoint: u5, [G4]: h4 }, { conditions: [{ [H2]: d4, [I4]: [q4, "us-west-1"] }], endpoint: u5, [G4]: h4 }, { conditions: [{ [H2]: d4, [I4]: [q4, "us-west-2"] }], endpoint: u5, [G4]: h4 }, { endpoint: { url: i4, properties: { authSchemes: [{ name: e4, signingName: f4, signingRegion: "{Region}" }] }, headers: v7 }, [G4]: h4 }], [G4]: j4 }, { conditions: C3, rules: [{ conditions: D3, error: "Invalid Configuration: FIPS and custom endpoint are not supported", [G4]: k4 }, { conditions: E3, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", [G4]: k4 }, { endpoint: { url: o3, properties: v7, headers: v7 }, [G4]: h4 }], [G4]: j4 }, { conditions: [p5], rules: [{ conditions: [r5], rules: [{ conditions: [x4, y4], rules: [{ conditions: [{ [H2]: c5, [I4]: [b3, z3] }, B4], rules: [{ endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v7, headers: v7 }, [G4]: h4 }], [G4]: j4 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [G4]: k4 }], [G4]: j4 }, { conditions: D3, rules: [{ conditions: [{ [H2]: c5, [I4]: [z3, b3] }], rules: [{ conditions: [{ [H2]: d4, [I4]: [{ [H2]: l4, [I4]: [A4, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://sts.{Region}.amazonaws.com", properties: v7, headers: v7 }, [G4]: h4 }, { endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}", properties: v7, headers: v7 }, [G4]: h4 }], [G4]: j4 }, { error: "FIPS is enabled but this partition does not support FIPS", [G4]: k4 }], [G4]: j4 }, { conditions: E3, rules: [{ conditions: [B4], rules: [{ endpoint: { url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v7, headers: v7 }, [G4]: h4 }], [G4]: j4 }, { error: "DualStack is enabled but this partition does not support DualStack", [G4]: k4 }], [G4]: j4 }, w4, { endpoint: { url: i4, properties: v7, headers: v7 }, [G4]: h4 }], [G4]: j4 }], [G4]: j4 }, { error: "Invalid Configuration: Missing Region", [G4]: k4 }] };
  exports.ruleSet = _data3;
});

// ../../node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/endpoint/endpointResolver.js
var require_endpointResolver2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultEndpointResolver = undefined;
  var util_endpoints_1 = require_dist_cjs25();
  var util_endpoints_2 = require_dist_cjs24();
  var ruleset_1 = require_ruleset2();
  var cache3 = new util_endpoints_2.EndpointCache({
    size: 50,
    params: ["Endpoint", "Region", "UseDualStack", "UseFIPS", "UseGlobalEndpoint"]
  });
  var defaultEndpointResolver3 = (endpointParams, context = {}) => {
    return cache3.get(endpointParams, () => (0, util_endpoints_2.resolveEndpoint)(ruleset_1.ruleSet, {
      endpointParams,
      logger: context.logger
    }));
  };
  exports.defaultEndpointResolver = defaultEndpointResolver3;
  util_endpoints_2.customEndpointFunctions.aws = util_endpoints_1.awsEndpointFunctions;
});

// ../../node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/runtimeConfig.shared.js
var require_runtimeConfig_shared2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var core_1 = require_dist_cjs20();
  var core_2 = require_dist_cjs15();
  var smithy_client_1 = require_dist_cjs19();
  var url_parser_1 = require_dist_cjs33();
  var util_base64_1 = require_dist_cjs8();
  var util_utf8_1 = require_dist_cjs7();
  var httpAuthSchemeProvider_1 = require_httpAuthSchemeProvider2();
  var endpointResolver_1 = require_endpointResolver2();
  var getRuntimeConfig3 = (config5) => {
    return {
      apiVersion: "2011-06-15",
      base64Decoder: config5?.base64Decoder ?? util_base64_1.fromBase64,
      base64Encoder: config5?.base64Encoder ?? util_base64_1.toBase64,
      disableHostPrefix: config5?.disableHostPrefix ?? false,
      endpointProvider: config5?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
      extensions: config5?.extensions ?? [],
      httpAuthSchemeProvider: config5?.httpAuthSchemeProvider ?? httpAuthSchemeProvider_1.defaultSTSHttpAuthSchemeProvider,
      httpAuthSchemes: config5?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
          signer: new core_1.AwsSdkSigV4Signer
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new core_2.NoAuthSigner
        }
      ],
      logger: config5?.logger ?? new smithy_client_1.NoOpLogger,
      serviceId: config5?.serviceId ?? "STS",
      urlParser: config5?.urlParser ?? url_parser_1.parseUrl,
      utf8Decoder: config5?.utf8Decoder ?? util_utf8_1.fromUtf8,
      utf8Encoder: config5?.utf8Encoder ?? util_utf8_1.toUtf8
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig3;
});

// ../../node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/runtimeConfig.js
var require_runtimeConfig2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var tslib_1 = require_tslib();
  var package_json_1 = tslib_1.__importDefault(require_package());
  var core_1 = require_dist_cjs20();
  var util_user_agent_node_1 = require_dist_cjs38();
  var config_resolver_1 = require_dist_cjs28();
  var core_2 = require_dist_cjs15();
  var hash_node_1 = require_dist_cjs39();
  var middleware_retry_1 = require_dist_cjs37();
  var node_config_provider_1 = require_dist_cjs31();
  var node_http_handler_1 = require_dist_cjs11();
  var util_body_length_node_1 = require_dist_cjs40();
  var util_retry_1 = require_dist_cjs36();
  var runtimeConfig_shared_1 = require_runtimeConfig_shared2();
  var smithy_client_1 = require_dist_cjs19();
  var util_defaults_mode_node_1 = require_dist_cjs42();
  var smithy_client_2 = require_dist_cjs19();
  var getRuntimeConfig3 = (config5) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config5);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config5);
    (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
    const profileConfig = { profile: config5?.profile };
    return {
      ...clientSharedValues,
      ...config5,
      runtime: "node",
      defaultsMode,
      bodyLengthChecker: config5?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
      defaultUserAgentProvider: config5?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.createDefaultUserAgentProvider)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
      httpAuthSchemes: config5?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4") || (async (idProps) => await config5.credentialDefaultProvider(idProps?.__config || {})()),
          signer: new core_1.AwsSdkSigV4Signer
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new core_2.NoAuthSigner
        }
      ],
      maxAttempts: config5?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config5),
      region: config5?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, { ...config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS, ...profileConfig }),
      requestHandler: node_http_handler_1.NodeHttpHandler.create(config5?.requestHandler ?? defaultConfigProvider),
      retryMode: config5?.retryMode ?? (0, node_config_provider_1.loadConfig)({
        ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
        default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
      }, config5),
      sha256: config5?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
      streamCollector: config5?.streamCollector ?? node_http_handler_1.streamCollector,
      useDualstackEndpoint: config5?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, profileConfig),
      useFipsEndpoint: config5?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, profileConfig),
      userAgentAppId: config5?.userAgentAppId ?? (0, node_config_provider_1.loadConfig)(util_user_agent_node_1.NODE_APP_ID_CONFIG_OPTIONS, profileConfig)
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig3;
});

// ../../node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/auth/httpAuthExtensionConfiguration.js
var require_httpAuthExtensionConfiguration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveHttpAuthRuntimeConfig = exports.getHttpAuthExtensionConfiguration = undefined;
  var getHttpAuthExtensionConfiguration2 = (runtimeConfig) => {
    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
    let _credentials = runtimeConfig.credentials;
    return {
      setHttpAuthScheme(httpAuthScheme) {
        const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
        if (index === -1) {
          _httpAuthSchemes.push(httpAuthScheme);
        } else {
          _httpAuthSchemes.splice(index, 1, httpAuthScheme);
        }
      },
      httpAuthSchemes() {
        return _httpAuthSchemes;
      },
      setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
        _httpAuthSchemeProvider = httpAuthSchemeProvider;
      },
      httpAuthSchemeProvider() {
        return _httpAuthSchemeProvider;
      },
      setCredentials(credentials) {
        _credentials = credentials;
      },
      credentials() {
        return _credentials;
      }
    };
  };
  exports.getHttpAuthExtensionConfiguration = getHttpAuthExtensionConfiguration2;
  var resolveHttpAuthRuntimeConfig2 = (config5) => {
    return {
      httpAuthSchemes: config5.httpAuthSchemes(),
      httpAuthSchemeProvider: config5.httpAuthSchemeProvider(),
      credentials: config5.credentials()
    };
  };
  exports.resolveHttpAuthRuntimeConfig = resolveHttpAuthRuntimeConfig2;
});

// ../../node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/runtimeExtensions.js
var require_runtimeExtensions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveRuntimeExtensions = undefined;
  var region_config_resolver_1 = require_dist_cjs43();
  var protocol_http_1 = require_dist_cjs2();
  var smithy_client_1 = require_dist_cjs19();
  var httpAuthExtensionConfiguration_1 = require_httpAuthExtensionConfiguration();
  var asPartial2 = (t4) => t4;
  var resolveRuntimeExtensions2 = (runtimeConfig, extensions4) => {
    const extensionConfiguration = {
      ...asPartial2((0, region_config_resolver_1.getAwsRegionExtensionConfiguration)(runtimeConfig)),
      ...asPartial2((0, smithy_client_1.getDefaultExtensionConfiguration)(runtimeConfig)),
      ...asPartial2((0, protocol_http_1.getHttpHandlerExtensionConfiguration)(runtimeConfig)),
      ...asPartial2((0, httpAuthExtensionConfiguration_1.getHttpAuthExtensionConfiguration)(runtimeConfig))
    };
    extensions4.forEach((extension) => extension.configure(extensionConfiguration));
    return {
      ...runtimeConfig,
      ...(0, region_config_resolver_1.resolveAwsRegionExtensionConfiguration)(extensionConfiguration),
      ...(0, smithy_client_1.resolveDefaultRuntimeConfig)(extensionConfiguration),
      ...(0, protocol_http_1.resolveHttpHandlerRuntimeConfig)(extensionConfiguration),
      ...(0, httpAuthExtensionConfiguration_1.resolveHttpAuthRuntimeConfig)(extensionConfiguration)
    };
  };
  exports.resolveRuntimeExtensions = resolveRuntimeExtensions2;
});

// ../../node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/STSClient.js
var require_STSClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.STSClient = exports.__Client = undefined;
  var middleware_host_header_1 = require_dist_cjs21();
  var middleware_logger_1 = require_dist_cjs22();
  var middleware_recursion_detection_1 = require_dist_cjs23();
  var middleware_user_agent_1 = require_dist_cjs26();
  var config_resolver_1 = require_dist_cjs28();
  var core_1 = require_dist_cjs15();
  var middleware_content_length_1 = require_dist_cjs29();
  var middleware_endpoint_1 = require_dist_cjs34();
  var middleware_retry_1 = require_dist_cjs37();
  var smithy_client_1 = require_dist_cjs19();
  Object.defineProperty(exports, "__Client", { enumerable: true, get: function() {
    return smithy_client_1.Client;
  } });
  var httpAuthSchemeProvider_1 = require_httpAuthSchemeProvider2();
  var EndpointParameters_1 = require_EndpointParameters();
  var runtimeConfig_1 = require_runtimeConfig2();
  var runtimeExtensions_1 = require_runtimeExtensions();

  class STSClient extends smithy_client_1.Client {
    config;
    constructor(...[configuration]) {
      const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration || {});
      const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
      const _config_2 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_1);
      const _config_3 = (0, middleware_retry_1.resolveRetryConfig)(_config_2);
      const _config_4 = (0, config_resolver_1.resolveRegionConfig)(_config_3);
      const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
      const _config_6 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_5);
      const _config_7 = (0, httpAuthSchemeProvider_1.resolveHttpAuthSchemeConfig)(_config_6);
      const _config_8 = (0, runtimeExtensions_1.resolveRuntimeExtensions)(_config_7, configuration?.extensions || []);
      super(_config_8);
      this.config = _config_8;
      this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
      this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
      this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
      this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
      this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
      this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
      this.middlewareStack.use((0, core_1.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
        httpAuthSchemeParametersProvider: httpAuthSchemeProvider_1.defaultSTSHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (config5) => new core_1.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": config5.credentials
        })
      }));
      this.middlewareStack.use((0, core_1.getHttpSigningPlugin)(this.config));
    }
    destroy() {
      super.destroy();
    }
  }
  exports.STSClient = STSClient;
});

// ../../node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/index.js
var require_sts = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var sts_exports = {};
  __export2(sts_exports, {
    AssumeRoleCommand: () => AssumeRoleCommand,
    AssumeRoleResponseFilterSensitiveLog: () => AssumeRoleResponseFilterSensitiveLog,
    AssumeRoleWithWebIdentityCommand: () => AssumeRoleWithWebIdentityCommand,
    AssumeRoleWithWebIdentityRequestFilterSensitiveLog: () => AssumeRoleWithWebIdentityRequestFilterSensitiveLog,
    AssumeRoleWithWebIdentityResponseFilterSensitiveLog: () => AssumeRoleWithWebIdentityResponseFilterSensitiveLog,
    ClientInputEndpointParameters: () => import_EndpointParameters32.ClientInputEndpointParameters,
    CredentialsFilterSensitiveLog: () => CredentialsFilterSensitiveLog,
    ExpiredTokenException: () => ExpiredTokenException,
    IDPCommunicationErrorException: () => IDPCommunicationErrorException,
    IDPRejectedClaimException: () => IDPRejectedClaimException,
    InvalidIdentityTokenException: () => InvalidIdentityTokenException,
    MalformedPolicyDocumentException: () => MalformedPolicyDocumentException,
    PackedPolicyTooLargeException: () => PackedPolicyTooLargeException,
    RegionDisabledException: () => RegionDisabledException,
    STS: () => STS,
    STSServiceException: () => STSServiceException,
    decorateDefaultCredentialProvider: () => decorateDefaultCredentialProvider,
    getDefaultRoleAssumer: () => getDefaultRoleAssumer2,
    getDefaultRoleAssumerWithWebIdentity: () => getDefaultRoleAssumerWithWebIdentity2
  });
  module.exports = __toCommonJS(sts_exports);
  __reExport(sts_exports, require_STSClient(), module.exports);
  var import_smithy_client62 = require_dist_cjs19();
  var import_middleware_endpoint8 = require_dist_cjs34();
  var import_middleware_serde7 = require_dist_cjs4();
  var import_smithy_client42 = require_dist_cjs19();
  var import_EndpointParameters7 = require_EndpointParameters();
  var import_smithy_client23 = require_dist_cjs19();
  var import_smithy_client24 = require_dist_cjs19();
  var STSServiceException = class _STSServiceException extends import_smithy_client24.ServiceException {
    static {
      __name2(this, "STSServiceException");
    }
    constructor(options) {
      super(options);
      Object.setPrototypeOf(this, _STSServiceException.prototype);
    }
  };
  var CredentialsFilterSensitiveLog = /* @__PURE__ */ __name2((obj) => ({
    ...obj,
    ...obj.SecretAccessKey && { SecretAccessKey: import_smithy_client23.SENSITIVE_STRING }
  }), "CredentialsFilterSensitiveLog");
  var AssumeRoleResponseFilterSensitiveLog = /* @__PURE__ */ __name2((obj) => ({
    ...obj,
    ...obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }
  }), "AssumeRoleResponseFilterSensitiveLog");
  var ExpiredTokenException = class _ExpiredTokenException extends STSServiceException {
    static {
      __name2(this, "ExpiredTokenException");
    }
    name = "ExpiredTokenException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ExpiredTokenException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _ExpiredTokenException.prototype);
    }
  };
  var MalformedPolicyDocumentException = class _MalformedPolicyDocumentException extends STSServiceException {
    static {
      __name2(this, "MalformedPolicyDocumentException");
    }
    name = "MalformedPolicyDocumentException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "MalformedPolicyDocumentException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _MalformedPolicyDocumentException.prototype);
    }
  };
  var PackedPolicyTooLargeException = class _PackedPolicyTooLargeException extends STSServiceException {
    static {
      __name2(this, "PackedPolicyTooLargeException");
    }
    name = "PackedPolicyTooLargeException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "PackedPolicyTooLargeException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _PackedPolicyTooLargeException.prototype);
    }
  };
  var RegionDisabledException = class _RegionDisabledException extends STSServiceException {
    static {
      __name2(this, "RegionDisabledException");
    }
    name = "RegionDisabledException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "RegionDisabledException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _RegionDisabledException.prototype);
    }
  };
  var IDPRejectedClaimException = class _IDPRejectedClaimException extends STSServiceException {
    static {
      __name2(this, "IDPRejectedClaimException");
    }
    name = "IDPRejectedClaimException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "IDPRejectedClaimException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _IDPRejectedClaimException.prototype);
    }
  };
  var InvalidIdentityTokenException = class _InvalidIdentityTokenException extends STSServiceException {
    static {
      __name2(this, "InvalidIdentityTokenException");
    }
    name = "InvalidIdentityTokenException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "InvalidIdentityTokenException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _InvalidIdentityTokenException.prototype);
    }
  };
  var AssumeRoleWithWebIdentityRequestFilterSensitiveLog = /* @__PURE__ */ __name2((obj) => ({
    ...obj,
    ...obj.WebIdentityToken && { WebIdentityToken: import_smithy_client23.SENSITIVE_STRING }
  }), "AssumeRoleWithWebIdentityRequestFilterSensitiveLog");
  var AssumeRoleWithWebIdentityResponseFilterSensitiveLog = /* @__PURE__ */ __name2((obj) => ({
    ...obj,
    ...obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }
  }), "AssumeRoleWithWebIdentityResponseFilterSensitiveLog");
  var IDPCommunicationErrorException = class _IDPCommunicationErrorException extends STSServiceException {
    static {
      __name2(this, "IDPCommunicationErrorException");
    }
    name = "IDPCommunicationErrorException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "IDPCommunicationErrorException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _IDPCommunicationErrorException.prototype);
    }
  };
  var import_core20 = require_dist_cjs20();
  var import_protocol_http24 = require_dist_cjs2();
  var import_smithy_client32 = require_dist_cjs19();
  var se_AssumeRoleCommand = /* @__PURE__ */ __name2(async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
      ...se_AssumeRoleRequest(input, context),
      [_A]: _AR,
      [_V]: _3
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
  }, "se_AssumeRoleCommand");
  var se_AssumeRoleWithWebIdentityCommand = /* @__PURE__ */ __name2(async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
      ...se_AssumeRoleWithWebIdentityRequest(input, context),
      [_A]: _ARWWI,
      [_V]: _3
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
  }, "se_AssumeRoleWithWebIdentityCommand");
  var de_AssumeRoleCommand = /* @__PURE__ */ __name2(async (output, context) => {
    if (output.statusCode >= 300) {
      return de_CommandError3(output, context);
    }
    const data = await (0, import_core20.parseXmlBody)(output.body, context);
    let contents = {};
    contents = de_AssumeRoleResponse(data.AssumeRoleResult, context);
    const response = {
      $metadata: deserializeMetadata4(output),
      ...contents
    };
    return response;
  }, "de_AssumeRoleCommand");
  var de_AssumeRoleWithWebIdentityCommand = /* @__PURE__ */ __name2(async (output, context) => {
    if (output.statusCode >= 300) {
      return de_CommandError3(output, context);
    }
    const data = await (0, import_core20.parseXmlBody)(output.body, context);
    let contents = {};
    contents = de_AssumeRoleWithWebIdentityResponse(data.AssumeRoleWithWebIdentityResult, context);
    const response = {
      $metadata: deserializeMetadata4(output),
      ...contents
    };
    return response;
  }, "de_AssumeRoleWithWebIdentityCommand");
  var de_CommandError3 = /* @__PURE__ */ __name2(async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await (0, import_core20.parseXmlErrorBody)(output.body, context)
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "ExpiredTokenException":
      case "com.amazonaws.sts#ExpiredTokenException":
        throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
      case "MalformedPolicyDocument":
      case "com.amazonaws.sts#MalformedPolicyDocumentException":
        throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
      case "PackedPolicyTooLarge":
      case "com.amazonaws.sts#PackedPolicyTooLargeException":
        throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
      case "RegionDisabledException":
      case "com.amazonaws.sts#RegionDisabledException":
        throw await de_RegionDisabledExceptionRes(parsedOutput, context);
      case "IDPCommunicationError":
      case "com.amazonaws.sts#IDPCommunicationErrorException":
        throw await de_IDPCommunicationErrorExceptionRes(parsedOutput, context);
      case "IDPRejectedClaim":
      case "com.amazonaws.sts#IDPRejectedClaimException":
        throw await de_IDPRejectedClaimExceptionRes(parsedOutput, context);
      case "InvalidIdentityToken":
      case "com.amazonaws.sts#InvalidIdentityTokenException":
        throw await de_InvalidIdentityTokenExceptionRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError4({
          output,
          parsedBody: parsedBody.Error,
          errorCode
        });
    }
  }, "de_CommandError");
  var de_ExpiredTokenExceptionRes = /* @__PURE__ */ __name2(async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ExpiredTokenException(body.Error, context);
    const exception = new ExpiredTokenException({
      $metadata: deserializeMetadata4(parsedOutput),
      ...deserialized
    });
    return (0, import_smithy_client32.decorateServiceException)(exception, body);
  }, "de_ExpiredTokenExceptionRes");
  var de_IDPCommunicationErrorExceptionRes = /* @__PURE__ */ __name2(async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IDPCommunicationErrorException(body.Error, context);
    const exception = new IDPCommunicationErrorException({
      $metadata: deserializeMetadata4(parsedOutput),
      ...deserialized
    });
    return (0, import_smithy_client32.decorateServiceException)(exception, body);
  }, "de_IDPCommunicationErrorExceptionRes");
  var de_IDPRejectedClaimExceptionRes = /* @__PURE__ */ __name2(async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IDPRejectedClaimException(body.Error, context);
    const exception = new IDPRejectedClaimException({
      $metadata: deserializeMetadata4(parsedOutput),
      ...deserialized
    });
    return (0, import_smithy_client32.decorateServiceException)(exception, body);
  }, "de_IDPRejectedClaimExceptionRes");
  var de_InvalidIdentityTokenExceptionRes = /* @__PURE__ */ __name2(async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidIdentityTokenException(body.Error, context);
    const exception = new InvalidIdentityTokenException({
      $metadata: deserializeMetadata4(parsedOutput),
      ...deserialized
    });
    return (0, import_smithy_client32.decorateServiceException)(exception, body);
  }, "de_InvalidIdentityTokenExceptionRes");
  var de_MalformedPolicyDocumentExceptionRes = /* @__PURE__ */ __name2(async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_MalformedPolicyDocumentException(body.Error, context);
    const exception = new MalformedPolicyDocumentException({
      $metadata: deserializeMetadata4(parsedOutput),
      ...deserialized
    });
    return (0, import_smithy_client32.decorateServiceException)(exception, body);
  }, "de_MalformedPolicyDocumentExceptionRes");
  var de_PackedPolicyTooLargeExceptionRes = /* @__PURE__ */ __name2(async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PackedPolicyTooLargeException(body.Error, context);
    const exception = new PackedPolicyTooLargeException({
      $metadata: deserializeMetadata4(parsedOutput),
      ...deserialized
    });
    return (0, import_smithy_client32.decorateServiceException)(exception, body);
  }, "de_PackedPolicyTooLargeExceptionRes");
  var de_RegionDisabledExceptionRes = /* @__PURE__ */ __name2(async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_RegionDisabledException(body.Error, context);
    const exception = new RegionDisabledException({
      $metadata: deserializeMetadata4(parsedOutput),
      ...deserialized
    });
    return (0, import_smithy_client32.decorateServiceException)(exception, body);
  }, "de_RegionDisabledExceptionRes");
  var se_AssumeRoleRequest = /* @__PURE__ */ __name2((input, context) => {
    const entries = {};
    if (input[_RA] != null) {
      entries[_RA] = input[_RA];
    }
    if (input[_RSN] != null) {
      entries[_RSN] = input[_RSN];
    }
    if (input[_PA] != null) {
      const memberEntries = se_policyDescriptorListType(input[_PA], context);
      if (input[_PA]?.length === 0) {
        entries.PolicyArns = [];
      }
      Object.entries(memberEntries).forEach(([key, value]) => {
        const loc = `PolicyArns.${key}`;
        entries[loc] = value;
      });
    }
    if (input[_P] != null) {
      entries[_P] = input[_P];
    }
    if (input[_DS] != null) {
      entries[_DS] = input[_DS];
    }
    if (input[_T] != null) {
      const memberEntries = se_tagListType(input[_T], context);
      if (input[_T]?.length === 0) {
        entries.Tags = [];
      }
      Object.entries(memberEntries).forEach(([key, value]) => {
        const loc = `Tags.${key}`;
        entries[loc] = value;
      });
    }
    if (input[_TTK] != null) {
      const memberEntries = se_tagKeyListType(input[_TTK], context);
      if (input[_TTK]?.length === 0) {
        entries.TransitiveTagKeys = [];
      }
      Object.entries(memberEntries).forEach(([key, value]) => {
        const loc = `TransitiveTagKeys.${key}`;
        entries[loc] = value;
      });
    }
    if (input[_EI] != null) {
      entries[_EI] = input[_EI];
    }
    if (input[_SN] != null) {
      entries[_SN] = input[_SN];
    }
    if (input[_TC] != null) {
      entries[_TC] = input[_TC];
    }
    if (input[_SI] != null) {
      entries[_SI] = input[_SI];
    }
    if (input[_PC] != null) {
      const memberEntries = se_ProvidedContextsListType(input[_PC], context);
      if (input[_PC]?.length === 0) {
        entries.ProvidedContexts = [];
      }
      Object.entries(memberEntries).forEach(([key, value]) => {
        const loc = `ProvidedContexts.${key}`;
        entries[loc] = value;
      });
    }
    return entries;
  }, "se_AssumeRoleRequest");
  var se_AssumeRoleWithWebIdentityRequest = /* @__PURE__ */ __name2((input, context) => {
    const entries = {};
    if (input[_RA] != null) {
      entries[_RA] = input[_RA];
    }
    if (input[_RSN] != null) {
      entries[_RSN] = input[_RSN];
    }
    if (input[_WIT] != null) {
      entries[_WIT] = input[_WIT];
    }
    if (input[_PI] != null) {
      entries[_PI] = input[_PI];
    }
    if (input[_PA] != null) {
      const memberEntries = se_policyDescriptorListType(input[_PA], context);
      if (input[_PA]?.length === 0) {
        entries.PolicyArns = [];
      }
      Object.entries(memberEntries).forEach(([key, value]) => {
        const loc = `PolicyArns.${key}`;
        entries[loc] = value;
      });
    }
    if (input[_P] != null) {
      entries[_P] = input[_P];
    }
    if (input[_DS] != null) {
      entries[_DS] = input[_DS];
    }
    return entries;
  }, "se_AssumeRoleWithWebIdentityRequest");
  var se_policyDescriptorListType = /* @__PURE__ */ __name2((input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
      if (entry === null) {
        continue;
      }
      const memberEntries = se_PolicyDescriptorType(entry, context);
      Object.entries(memberEntries).forEach(([key, value]) => {
        entries[`member.${counter}.${key}`] = value;
      });
      counter++;
    }
    return entries;
  }, "se_policyDescriptorListType");
  var se_PolicyDescriptorType = /* @__PURE__ */ __name2((input, context) => {
    const entries = {};
    if (input[_a2] != null) {
      entries[_a2] = input[_a2];
    }
    return entries;
  }, "se_PolicyDescriptorType");
  var se_ProvidedContext = /* @__PURE__ */ __name2((input, context) => {
    const entries = {};
    if (input[_PAr] != null) {
      entries[_PAr] = input[_PAr];
    }
    if (input[_CA] != null) {
      entries[_CA] = input[_CA];
    }
    return entries;
  }, "se_ProvidedContext");
  var se_ProvidedContextsListType = /* @__PURE__ */ __name2((input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
      if (entry === null) {
        continue;
      }
      const memberEntries = se_ProvidedContext(entry, context);
      Object.entries(memberEntries).forEach(([key, value]) => {
        entries[`member.${counter}.${key}`] = value;
      });
      counter++;
    }
    return entries;
  }, "se_ProvidedContextsListType");
  var se_Tag = /* @__PURE__ */ __name2((input, context) => {
    const entries = {};
    if (input[_K] != null) {
      entries[_K] = input[_K];
    }
    if (input[_Va] != null) {
      entries[_Va] = input[_Va];
    }
    return entries;
  }, "se_Tag");
  var se_tagKeyListType = /* @__PURE__ */ __name2((input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
      if (entry === null) {
        continue;
      }
      entries[`member.${counter}`] = entry;
      counter++;
    }
    return entries;
  }, "se_tagKeyListType");
  var se_tagListType = /* @__PURE__ */ __name2((input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
      if (entry === null) {
        continue;
      }
      const memberEntries = se_Tag(entry, context);
      Object.entries(memberEntries).forEach(([key, value]) => {
        entries[`member.${counter}.${key}`] = value;
      });
      counter++;
    }
    return entries;
  }, "se_tagListType");
  var de_AssumedRoleUser = /* @__PURE__ */ __name2((output, context) => {
    const contents = {};
    if (output[_ARI] != null) {
      contents[_ARI] = (0, import_smithy_client32.expectString)(output[_ARI]);
    }
    if (output[_Ar] != null) {
      contents[_Ar] = (0, import_smithy_client32.expectString)(output[_Ar]);
    }
    return contents;
  }, "de_AssumedRoleUser");
  var de_AssumeRoleResponse = /* @__PURE__ */ __name2((output, context) => {
    const contents = {};
    if (output[_C2] != null) {
      contents[_C2] = de_Credentials(output[_C2], context);
    }
    if (output[_ARU] != null) {
      contents[_ARU] = de_AssumedRoleUser(output[_ARU], context);
    }
    if (output[_PPS] != null) {
      contents[_PPS] = (0, import_smithy_client32.strictParseInt32)(output[_PPS]);
    }
    if (output[_SI] != null) {
      contents[_SI] = (0, import_smithy_client32.expectString)(output[_SI]);
    }
    return contents;
  }, "de_AssumeRoleResponse");
  var de_AssumeRoleWithWebIdentityResponse = /* @__PURE__ */ __name2((output, context) => {
    const contents = {};
    if (output[_C2] != null) {
      contents[_C2] = de_Credentials(output[_C2], context);
    }
    if (output[_SFWIT] != null) {
      contents[_SFWIT] = (0, import_smithy_client32.expectString)(output[_SFWIT]);
    }
    if (output[_ARU] != null) {
      contents[_ARU] = de_AssumedRoleUser(output[_ARU], context);
    }
    if (output[_PPS] != null) {
      contents[_PPS] = (0, import_smithy_client32.strictParseInt32)(output[_PPS]);
    }
    if (output[_Pr] != null) {
      contents[_Pr] = (0, import_smithy_client32.expectString)(output[_Pr]);
    }
    if (output[_Au] != null) {
      contents[_Au] = (0, import_smithy_client32.expectString)(output[_Au]);
    }
    if (output[_SI] != null) {
      contents[_SI] = (0, import_smithy_client32.expectString)(output[_SI]);
    }
    return contents;
  }, "de_AssumeRoleWithWebIdentityResponse");
  var de_Credentials = /* @__PURE__ */ __name2((output, context) => {
    const contents = {};
    if (output[_AKI2] != null) {
      contents[_AKI2] = (0, import_smithy_client32.expectString)(output[_AKI2]);
    }
    if (output[_SAK2] != null) {
      contents[_SAK2] = (0, import_smithy_client32.expectString)(output[_SAK2]);
    }
    if (output[_ST2] != null) {
      contents[_ST2] = (0, import_smithy_client32.expectString)(output[_ST2]);
    }
    if (output[_E] != null) {
      contents[_E] = (0, import_smithy_client32.expectNonNull)((0, import_smithy_client32.parseRfc3339DateTimeWithOffset)(output[_E]));
    }
    return contents;
  }, "de_Credentials");
  var de_ExpiredTokenException = /* @__PURE__ */ __name2((output, context) => {
    const contents = {};
    if (output[_m] != null) {
      contents[_m] = (0, import_smithy_client32.expectString)(output[_m]);
    }
    return contents;
  }, "de_ExpiredTokenException");
  var de_IDPCommunicationErrorException = /* @__PURE__ */ __name2((output, context) => {
    const contents = {};
    if (output[_m] != null) {
      contents[_m] = (0, import_smithy_client32.expectString)(output[_m]);
    }
    return contents;
  }, "de_IDPCommunicationErrorException");
  var de_IDPRejectedClaimException = /* @__PURE__ */ __name2((output, context) => {
    const contents = {};
    if (output[_m] != null) {
      contents[_m] = (0, import_smithy_client32.expectString)(output[_m]);
    }
    return contents;
  }, "de_IDPRejectedClaimException");
  var de_InvalidIdentityTokenException = /* @__PURE__ */ __name2((output, context) => {
    const contents = {};
    if (output[_m] != null) {
      contents[_m] = (0, import_smithy_client32.expectString)(output[_m]);
    }
    return contents;
  }, "de_InvalidIdentityTokenException");
  var de_MalformedPolicyDocumentException = /* @__PURE__ */ __name2((output, context) => {
    const contents = {};
    if (output[_m] != null) {
      contents[_m] = (0, import_smithy_client32.expectString)(output[_m]);
    }
    return contents;
  }, "de_MalformedPolicyDocumentException");
  var de_PackedPolicyTooLargeException = /* @__PURE__ */ __name2((output, context) => {
    const contents = {};
    if (output[_m] != null) {
      contents[_m] = (0, import_smithy_client32.expectString)(output[_m]);
    }
    return contents;
  }, "de_PackedPolicyTooLargeException");
  var de_RegionDisabledException = /* @__PURE__ */ __name2((output, context) => {
    const contents = {};
    if (output[_m] != null) {
      contents[_m] = (0, import_smithy_client32.expectString)(output[_m]);
    }
    return contents;
  }, "de_RegionDisabledException");
  var deserializeMetadata4 = /* @__PURE__ */ __name2((output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"]
  }), "deserializeMetadata");
  var throwDefaultError4 = (0, import_smithy_client32.withBaseException)(STSServiceException);
  var buildHttpRpcRequest = /* @__PURE__ */ __name2(async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
      protocol,
      hostname,
      port,
      method: "POST",
      path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
      headers
    };
    if (resolvedHostname !== undefined) {
      contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
      contents.body = body;
    }
    return new import_protocol_http24.HttpRequest(contents);
  }, "buildHttpRpcRequest");
  var SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded"
  };
  var _3 = "2011-06-15";
  var _A = "Action";
  var _AKI2 = "AccessKeyId";
  var _AR = "AssumeRole";
  var _ARI = "AssumedRoleId";
  var _ARU = "AssumedRoleUser";
  var _ARWWI = "AssumeRoleWithWebIdentity";
  var _Ar = "Arn";
  var _Au = "Audience";
  var _C2 = "Credentials";
  var _CA = "ContextAssertion";
  var _DS = "DurationSeconds";
  var _E = "Expiration";
  var _EI = "ExternalId";
  var _K = "Key";
  var _P = "Policy";
  var _PA = "PolicyArns";
  var _PAr = "ProviderArn";
  var _PC = "ProvidedContexts";
  var _PI = "ProviderId";
  var _PPS = "PackedPolicySize";
  var _Pr = "Provider";
  var _RA = "RoleArn";
  var _RSN = "RoleSessionName";
  var _SAK2 = "SecretAccessKey";
  var _SFWIT = "SubjectFromWebIdentityToken";
  var _SI = "SourceIdentity";
  var _SN = "SerialNumber";
  var _ST2 = "SessionToken";
  var _T = "Tags";
  var _TC = "TokenCode";
  var _TTK = "TransitiveTagKeys";
  var _V = "Version";
  var _Va = "Value";
  var _WIT = "WebIdentityToken";
  var _a2 = "arn";
  var _m = "message";
  var buildFormUrlencodedString = /* @__PURE__ */ __name2((formEntries) => Object.entries(formEntries).map(([key, value]) => (0, import_smithy_client32.extendedEncodeURIComponent)(key) + "=" + (0, import_smithy_client32.extendedEncodeURIComponent)(value)).join("&"), "buildFormUrlencodedString");
  var loadQueryErrorCode = /* @__PURE__ */ __name2((output, data) => {
    if (data.Error?.Code !== undefined) {
      return data.Error.Code;
    }
    if (output.statusCode == 404) {
      return "NotFound";
    }
  }, "loadQueryErrorCode");
  var AssumeRoleCommand = class extends import_smithy_client42.Command.classBuilder().ep(import_EndpointParameters7.commonParams).m(function(Command2, cs2, config5, o3) {
    return [
      (0, import_middleware_serde7.getSerdePlugin)(config5, this.serialize, this.deserialize),
      (0, import_middleware_endpoint8.getEndpointPlugin)(config5, Command2.getEndpointParameterInstructions())
    ];
  }).s("AWSSecurityTokenServiceV20110615", "AssumeRole", {}).n("STSClient", "AssumeRoleCommand").f(undefined, AssumeRoleResponseFilterSensitiveLog).ser(se_AssumeRoleCommand).de(de_AssumeRoleCommand).build() {
    static {
      __name2(this, "AssumeRoleCommand");
    }
  };
  var import_middleware_endpoint22 = require_dist_cjs34();
  var import_middleware_serde22 = require_dist_cjs4();
  var import_smithy_client52 = require_dist_cjs19();
  var import_EndpointParameters22 = require_EndpointParameters();
  var AssumeRoleWithWebIdentityCommand = class extends import_smithy_client52.Command.classBuilder().ep(import_EndpointParameters22.commonParams).m(function(Command2, cs2, config5, o3) {
    return [
      (0, import_middleware_serde22.getSerdePlugin)(config5, this.serialize, this.deserialize),
      (0, import_middleware_endpoint22.getEndpointPlugin)(config5, Command2.getEndpointParameterInstructions())
    ];
  }).s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {}).n("STSClient", "AssumeRoleWithWebIdentityCommand").f(AssumeRoleWithWebIdentityRequestFilterSensitiveLog, AssumeRoleWithWebIdentityResponseFilterSensitiveLog).ser(se_AssumeRoleWithWebIdentityCommand).de(de_AssumeRoleWithWebIdentityCommand).build() {
    static {
      __name2(this, "AssumeRoleWithWebIdentityCommand");
    }
  };
  var import_STSClient = require_STSClient();
  var commands3 = {
    AssumeRoleCommand,
    AssumeRoleWithWebIdentityCommand
  };
  var STS = class extends import_STSClient.STSClient {
    static {
      __name2(this, "STS");
    }
  };
  (0, import_smithy_client62.createAggregatedClient)(commands3, STS);
  var import_EndpointParameters32 = require_EndpointParameters();
  var import_client5 = require_client();
  var ASSUME_ROLE_DEFAULT_REGION = "us-east-1";
  var getAccountIdFromAssumedRoleUser = /* @__PURE__ */ __name2((assumedRoleUser) => {
    if (typeof assumedRoleUser?.Arn === "string") {
      const arnComponents = assumedRoleUser.Arn.split(":");
      if (arnComponents.length > 4 && arnComponents[4] !== "") {
        return arnComponents[4];
      }
    }
    return;
  }, "getAccountIdFromAssumedRoleUser");
  var resolveRegion = /* @__PURE__ */ __name2(async (_region, _parentRegion, credentialProviderLogger) => {
    const region = typeof _region === "function" ? await _region() : _region;
    const parentRegion = typeof _parentRegion === "function" ? await _parentRegion() : _parentRegion;
    credentialProviderLogger?.debug?.("@aws-sdk/client-sts::resolveRegion", "accepting first of:", `${region} (provider)`, `${parentRegion} (parent client)`, `${ASSUME_ROLE_DEFAULT_REGION} (STS default)`);
    return region ?? parentRegion ?? ASSUME_ROLE_DEFAULT_REGION;
  }, "resolveRegion");
  var getDefaultRoleAssumer = /* @__PURE__ */ __name2((stsOptions, STSClient3) => {
    let stsClient;
    let closureSourceCreds;
    return async (sourceCreds, params) => {
      closureSourceCreds = sourceCreds;
      if (!stsClient) {
        const {
          logger: logger2 = stsOptions?.parentClientConfig?.logger,
          region,
          requestHandler = stsOptions?.parentClientConfig?.requestHandler,
          credentialProviderLogger
        } = stsOptions;
        const resolvedRegion = await resolveRegion(region, stsOptions?.parentClientConfig?.region, credentialProviderLogger);
        const isCompatibleRequestHandler = !isH2(requestHandler);
        stsClient = new STSClient3({
          profile: stsOptions?.parentClientConfig?.profile,
          credentialDefaultProvider: () => async () => closureSourceCreds,
          region: resolvedRegion,
          requestHandler: isCompatibleRequestHandler ? requestHandler : undefined,
          logger: logger2
        });
      }
      const { Credentials: Credentials2, AssumedRoleUser: AssumedRoleUser2 } = await stsClient.send(new AssumeRoleCommand(params));
      if (!Credentials2 || !Credentials2.AccessKeyId || !Credentials2.SecretAccessKey) {
        throw new Error(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
      }
      const accountId = getAccountIdFromAssumedRoleUser(AssumedRoleUser2);
      const credentials = {
        accessKeyId: Credentials2.AccessKeyId,
        secretAccessKey: Credentials2.SecretAccessKey,
        sessionToken: Credentials2.SessionToken,
        expiration: Credentials2.Expiration,
        ...Credentials2.CredentialScope && { credentialScope: Credentials2.CredentialScope },
        ...accountId && { accountId }
      };
      (0, import_client5.setCredentialFeature)(credentials, "CREDENTIALS_STS_ASSUME_ROLE", "i");
      return credentials;
    };
  }, "getDefaultRoleAssumer");
  var getDefaultRoleAssumerWithWebIdentity = /* @__PURE__ */ __name2((stsOptions, STSClient3) => {
    let stsClient;
    return async (params) => {
      if (!stsClient) {
        const {
          logger: logger2 = stsOptions?.parentClientConfig?.logger,
          region,
          requestHandler = stsOptions?.parentClientConfig?.requestHandler,
          credentialProviderLogger
        } = stsOptions;
        const resolvedRegion = await resolveRegion(region, stsOptions?.parentClientConfig?.region, credentialProviderLogger);
        const isCompatibleRequestHandler = !isH2(requestHandler);
        stsClient = new STSClient3({
          profile: stsOptions?.parentClientConfig?.profile,
          region: resolvedRegion,
          requestHandler: isCompatibleRequestHandler ? requestHandler : undefined,
          logger: logger2
        });
      }
      const { Credentials: Credentials2, AssumedRoleUser: AssumedRoleUser2 } = await stsClient.send(new AssumeRoleWithWebIdentityCommand(params));
      if (!Credentials2 || !Credentials2.AccessKeyId || !Credentials2.SecretAccessKey) {
        throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params.RoleArn}`);
      }
      const accountId = getAccountIdFromAssumedRoleUser(AssumedRoleUser2);
      const credentials = {
        accessKeyId: Credentials2.AccessKeyId,
        secretAccessKey: Credentials2.SecretAccessKey,
        sessionToken: Credentials2.SessionToken,
        expiration: Credentials2.Expiration,
        ...Credentials2.CredentialScope && { credentialScope: Credentials2.CredentialScope },
        ...accountId && { accountId }
      };
      if (accountId) {
        (0, import_client5.setCredentialFeature)(credentials, "RESOLVED_ACCOUNT_ID", "T");
      }
      (0, import_client5.setCredentialFeature)(credentials, "CREDENTIALS_STS_ASSUME_ROLE_WEB_ID", "k");
      return credentials;
    };
  }, "getDefaultRoleAssumerWithWebIdentity");
  var isH2 = /* @__PURE__ */ __name2((requestHandler) => {
    return requestHandler?.metadata?.handlerProtocol === "h2";
  }, "isH2");
  var import_STSClient2 = require_STSClient();
  var getCustomizableStsClientCtor = /* @__PURE__ */ __name2((baseCtor, customizations) => {
    if (!customizations)
      return baseCtor;
    else
      return class CustomizableSTSClient extends baseCtor {
        static {
          __name2(this, "CustomizableSTSClient");
        }
        constructor(config5) {
          super(config5);
          for (const customization of customizations) {
            this.middlewareStack.use(customization);
          }
        }
      };
  }, "getCustomizableStsClientCtor");
  var getDefaultRoleAssumer2 = /* @__PURE__ */ __name2((stsOptions = {}, stsPlugins) => getDefaultRoleAssumer(stsOptions, getCustomizableStsClientCtor(import_STSClient2.STSClient, stsPlugins)), "getDefaultRoleAssumer");
  var getDefaultRoleAssumerWithWebIdentity2 = /* @__PURE__ */ __name2((stsOptions = {}, stsPlugins) => getDefaultRoleAssumerWithWebIdentity(stsOptions, getCustomizableStsClientCtor(import_STSClient2.STSClient, stsPlugins)), "getDefaultRoleAssumerWithWebIdentity");
  var decorateDefaultCredentialProvider = /* @__PURE__ */ __name2((provider) => (input) => provider({
    roleAssumer: getDefaultRoleAssumer2(input),
    roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity2(input),
    ...input
  }), "decorateDefaultCredentialProvider");
});

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveAssumeRoleCredentials.js
var import_client5, import_property_provider24, isAssumeRoleProfile = (arg, { profile = "default", logger: logger2 } = {}) => {
  return Boolean(arg) && typeof arg === "object" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof arg.external_id) > -1 && ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1 && (isAssumeRoleWithSourceProfile(arg, { profile, logger: logger2 }) || isCredentialSourceProfile(arg, { profile, logger: logger2 }));
}, isAssumeRoleWithSourceProfile = (arg, { profile, logger: logger2 }) => {
  const withSourceProfile = typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined";
  if (withSourceProfile) {
    logger2?.debug?.(`    ${profile} isAssumeRoleWithSourceProfile source_profile=${arg.source_profile}`);
  }
  return withSourceProfile;
}, isCredentialSourceProfile = (arg, { profile, logger: logger2 }) => {
  const withProviderProfile = typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined";
  if (withProviderProfile) {
    logger2?.debug?.(`    ${profile} isCredentialSourceProfile credential_source=${arg.credential_source}`);
  }
  return withProviderProfile;
}, resolveAssumeRoleCredentials = async (profileName, profiles, options, visitedProfiles = {}) => {
  options.logger?.debug("@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)");
  const profileData = profiles[profileName];
  const { source_profile, region } = profileData;
  if (!options.roleAssumer) {
    const { getDefaultRoleAssumer } = await Promise.resolve().then(() => __toESM(require_sts(), 1));
    options.roleAssumer = getDefaultRoleAssumer({
      ...options.clientConfig,
      credentialProviderLogger: options.logger,
      parentClientConfig: {
        ...options?.parentClientConfig,
        region: region ?? options?.parentClientConfig?.region
      }
    }, options.clientPlugins);
  }
  if (source_profile && source_profile in visitedProfiles) {
    throw new import_property_provider24.CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile ${getProfileName(options)}. Profiles visited: ` + Object.keys(visitedProfiles).join(", "), { logger: options.logger });
  }
  options.logger?.debug(`@aws-sdk/credential-provider-ini - finding credential resolver using ${source_profile ? `source_profile=[${source_profile}]` : `profile=[${profileName}]`}`);
  const sourceCredsProvider = source_profile ? resolveProfileData(source_profile, profiles, options, {
    ...visitedProfiles,
    [source_profile]: true
  }, isCredentialSourceWithoutRoleArn(profiles[source_profile] ?? {})) : (await resolveCredentialSource(profileData.credential_source, profileName, options.logger)(options))();
  if (isCredentialSourceWithoutRoleArn(profileData)) {
    return sourceCredsProvider.then((creds) => import_client5.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
  } else {
    const params = {
      RoleArn: profileData.role_arn,
      RoleSessionName: profileData.role_session_name || `aws-sdk-js-${Date.now()}`,
      ExternalId: profileData.external_id,
      DurationSeconds: parseInt(profileData.duration_seconds || "3600", 10)
    };
    const { mfa_serial } = profileData;
    if (mfa_serial) {
      if (!options.mfaCodeProvider) {
        throw new import_property_provider24.CredentialsProviderError(`Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`, { logger: options.logger, tryNextLink: false });
      }
      params.SerialNumber = mfa_serial;
      params.TokenCode = await options.mfaCodeProvider(mfa_serial);
    }
    const sourceCreds = await sourceCredsProvider;
    return options.roleAssumer(sourceCreds, params).then((creds) => import_client5.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
  }
}, isCredentialSourceWithoutRoleArn = (section) => {
  return !section.role_arn && !!section.credential_source;
};
var init_resolveAssumeRoleCredentials = __esm(() => {
  import_client5 = __toESM(require_client(), 1);
  import_property_provider24 = __toESM(require_dist_cjs16(), 1);
  init_dist_es21();
  init_resolveCredentialSource();
  init_resolveProfileData();
});

// ../../node_modules/@aws-sdk/credential-provider-process/dist-es/getValidatedProcessCredentials.js
var import_client6, getValidatedProcessCredentials = (profileName, data, profiles) => {
  if (data.Version !== 1) {
    throw Error(`Profile ${profileName} credential_process did not return Version 1.`);
  }
  if (data.AccessKeyId === undefined || data.SecretAccessKey === undefined) {
    throw Error(`Profile ${profileName} credential_process returned invalid credentials.`);
  }
  if (data.Expiration) {
    const currentTime = new Date;
    const expireTime = new Date(data.Expiration);
    if (expireTime < currentTime) {
      throw Error(`Profile ${profileName} credential_process returned expired credentials.`);
    }
  }
  let accountId = data.AccountId;
  if (!accountId && profiles?.[profileName]?.aws_account_id) {
    accountId = profiles[profileName].aws_account_id;
  }
  const credentials = {
    accessKeyId: data.AccessKeyId,
    secretAccessKey: data.SecretAccessKey,
    ...data.SessionToken && { sessionToken: data.SessionToken },
    ...data.Expiration && { expiration: new Date(data.Expiration) },
    ...data.CredentialScope && { credentialScope: data.CredentialScope },
    ...accountId && { accountId }
  };
  import_client6.setCredentialFeature(credentials, "CREDENTIALS_PROCESS", "w");
  return credentials;
};
var init_getValidatedProcessCredentials = __esm(() => {
  import_client6 = __toESM(require_client(), 1);
});

// ../../node_modules/@aws-sdk/credential-provider-process/dist-es/resolveProcessCredentials.js
import { exec } from "child_process";
import { promisify } from "util";
var import_property_provider25, resolveProcessCredentials = async (profileName, profiles, logger2) => {
  const profile = profiles[profileName];
  if (profiles[profileName]) {
    const credentialProcess = profile["credential_process"];
    if (credentialProcess !== undefined) {
      const execPromise = promisify(exec);
      try {
        const { stdout: stdout2 } = await execPromise(credentialProcess);
        let data;
        try {
          data = JSON.parse(stdout2.trim());
        } catch {
          throw Error(`Profile ${profileName} credential_process returned invalid JSON.`);
        }
        return getValidatedProcessCredentials(profileName, data, profiles);
      } catch (error) {
        throw new import_property_provider25.CredentialsProviderError(error.message, { logger: logger2 });
      }
    } else {
      throw new import_property_provider25.CredentialsProviderError(`Profile ${profileName} did not contain credential_process.`, { logger: logger2 });
    }
  } else {
    throw new import_property_provider25.CredentialsProviderError(`Profile ${profileName} could not be found in shared credentials file.`, {
      logger: logger2
    });
  }
};
var init_resolveProcessCredentials = __esm(() => {
  import_property_provider25 = __toESM(require_dist_cjs16(), 1);
  init_getValidatedProcessCredentials();
});

// ../../node_modules/@aws-sdk/credential-provider-process/dist-es/fromProcess.js
var fromProcess = (init2 = {}) => async ({ callerClientConfig } = {}) => {
  init2.logger?.debug("@aws-sdk/credential-provider-process - fromProcess");
  const profiles = await parseKnownFiles(init2);
  return resolveProcessCredentials(getProfileName({
    profile: init2.profile ?? callerClientConfig?.profile
  }), profiles, init2.logger);
};
var init_fromProcess = __esm(() => {
  init_dist_es21();
  init_resolveProcessCredentials();
});

// ../../node_modules/@aws-sdk/credential-provider-process/dist-es/index.js
var exports_dist_es5 = {};
__export(exports_dist_es5, {
  fromProcess: () => fromProcess
});
var init_dist_es40 = __esm(() => {
  init_fromProcess();
});

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProcessCredentials.js
var import_client7, isProcessProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.credential_process === "string", resolveProcessCredentials2 = async (options, profile) => Promise.resolve().then(() => (init_dist_es40(), exports_dist_es5)).then(({ fromProcess: fromProcess3 }) => fromProcess3({
  ...options,
  profile
})().then((creds) => import_client7.setCredentialFeature(creds, "CREDENTIALS_PROFILE_PROCESS", "v")));
var init_resolveProcessCredentials2 = __esm(() => {
  import_client7 = __toESM(require_client(), 1);
});

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveSsoCredentials.js
var import_client8, resolveSsoCredentials = async (profile, profileData, options = {}) => {
  const { fromSSO: fromSSO3 } = await Promise.resolve().then(() => (init_dist_es39(), exports_dist_es4));
  return fromSSO3({
    profile,
    logger: options.logger,
    parentClientConfig: options.parentClientConfig,
    clientConfig: options.clientConfig
  })().then((creds) => {
    if (profileData.sso_session) {
      return import_client8.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SSO", "r");
    } else {
      return import_client8.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SSO_LEGACY", "t");
    }
  });
}, isSsoProfile3 = (arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string");
var init_resolveSsoCredentials = __esm(() => {
  import_client8 = __toESM(require_client(), 1);
});

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveStaticCredentials.js
var import_client9, isStaticCredsProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.aws_access_key_id === "string" && typeof arg.aws_secret_access_key === "string" && ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1 && ["undefined", "string"].indexOf(typeof arg.aws_account_id) > -1, resolveStaticCredentials = async (profile, options) => {
  options?.logger?.debug("@aws-sdk/credential-provider-ini - resolveStaticCredentials");
  const credentials = {
    accessKeyId: profile.aws_access_key_id,
    secretAccessKey: profile.aws_secret_access_key,
    sessionToken: profile.aws_session_token,
    ...profile.aws_credential_scope && { credentialScope: profile.aws_credential_scope },
    ...profile.aws_account_id && { accountId: profile.aws_account_id }
  };
  return import_client9.setCredentialFeature(credentials, "CREDENTIALS_PROFILE", "n");
};
var init_resolveStaticCredentials = __esm(() => {
  import_client9 = __toESM(require_client(), 1);
});

// ../../node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromWebToken.js
var fromWebToken = (init2) => async (awsIdentityProperties) => {
  init2.logger?.debug("@aws-sdk/credential-provider-web-identity - fromWebToken");
  const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy, durationSeconds } = init2;
  let { roleAssumerWithWebIdentity } = init2;
  if (!roleAssumerWithWebIdentity) {
    const { getDefaultRoleAssumerWithWebIdentity } = await Promise.resolve().then(() => __toESM(require_sts(), 1));
    roleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity({
      ...init2.clientConfig,
      credentialProviderLogger: init2.logger,
      parentClientConfig: {
        ...awsIdentityProperties?.callerClientConfig,
        ...init2.parentClientConfig
      }
    }, init2.clientPlugins);
  }
  return roleAssumerWithWebIdentity({
    RoleArn: roleArn,
    RoleSessionName: roleSessionName ?? `aws-sdk-js-session-${Date.now()}`,
    WebIdentityToken: webIdentityToken,
    ProviderId: providerId,
    PolicyArns: policyArns,
    Policy: policy,
    DurationSeconds: durationSeconds
  });
};

// ../../node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromTokenFile.js
import { readFileSync } from "fs";
var import_client10, import_property_provider26, ENV_TOKEN_FILE = "AWS_WEB_IDENTITY_TOKEN_FILE", ENV_ROLE_ARN = "AWS_ROLE_ARN", ENV_ROLE_SESSION_NAME = "AWS_ROLE_SESSION_NAME", fromTokenFile = (init2 = {}) => async () => {
  init2.logger?.debug("@aws-sdk/credential-provider-web-identity - fromTokenFile");
  const webIdentityTokenFile = init2?.webIdentityTokenFile ?? process.env[ENV_TOKEN_FILE];
  const roleArn = init2?.roleArn ?? process.env[ENV_ROLE_ARN];
  const roleSessionName = init2?.roleSessionName ?? process.env[ENV_ROLE_SESSION_NAME];
  if (!webIdentityTokenFile || !roleArn) {
    throw new import_property_provider26.CredentialsProviderError("Web identity configuration not specified", {
      logger: init2.logger
    });
  }
  const credentials = await fromWebToken({
    ...init2,
    webIdentityToken: readFileSync(webIdentityTokenFile, { encoding: "ascii" }),
    roleArn,
    roleSessionName
  })();
  if (webIdentityTokenFile === process.env[ENV_TOKEN_FILE]) {
    import_client10.setCredentialFeature(credentials, "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN", "h");
  }
  return credentials;
};
var init_fromTokenFile = __esm(() => {
  import_client10 = __toESM(require_client(), 1);
  import_property_provider26 = __toESM(require_dist_cjs16(), 1);
});

// ../../node_modules/@aws-sdk/credential-provider-web-identity/dist-es/index.js
var exports_dist_es6 = {};
__export(exports_dist_es6, {
  fromWebToken: () => fromWebToken,
  fromTokenFile: () => fromTokenFile
});
var init_dist_es41 = __esm(() => {
  init_fromTokenFile();
});

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveWebIdentityCredentials.js
var import_client11, isWebIdentityProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.web_identity_token_file === "string" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1, resolveWebIdentityCredentials = async (profile, options) => Promise.resolve().then(() => (init_dist_es41(), exports_dist_es6)).then(({ fromTokenFile: fromTokenFile3 }) => fromTokenFile3({
  webIdentityTokenFile: profile.web_identity_token_file,
  roleArn: profile.role_arn,
  roleSessionName: profile.role_session_name,
  roleAssumerWithWebIdentity: options.roleAssumerWithWebIdentity,
  logger: options.logger,
  parentClientConfig: options.parentClientConfig
})().then((creds) => import_client11.setCredentialFeature(creds, "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN", "q")));
var init_resolveWebIdentityCredentials = __esm(() => {
  import_client11 = __toESM(require_client(), 1);
});

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProfileData.js
var import_property_provider27, resolveProfileData = async (profileName, profiles, options, visitedProfiles = {}, isAssumeRoleRecursiveCall = false) => {
  const data = profiles[profileName];
  if (Object.keys(visitedProfiles).length > 0 && isStaticCredsProfile(data)) {
    return resolveStaticCredentials(data, options);
  }
  if (isAssumeRoleRecursiveCall || isAssumeRoleProfile(data, { profile: profileName, logger: options.logger })) {
    return resolveAssumeRoleCredentials(profileName, profiles, options, visitedProfiles);
  }
  if (isStaticCredsProfile(data)) {
    return resolveStaticCredentials(data, options);
  }
  if (isWebIdentityProfile(data)) {
    return resolveWebIdentityCredentials(data, options);
  }
  if (isProcessProfile(data)) {
    return resolveProcessCredentials2(options, profileName);
  }
  if (isSsoProfile3(data)) {
    return await resolveSsoCredentials(profileName, data, options);
  }
  throw new import_property_provider27.CredentialsProviderError(`Could not resolve credentials using profile: [${profileName}] in configuration/credentials file(s).`, { logger: options.logger });
};
var init_resolveProfileData = __esm(() => {
  import_property_provider27 = __toESM(require_dist_cjs16(), 1);
  init_resolveAssumeRoleCredentials();
  init_resolveProcessCredentials2();
  init_resolveSsoCredentials();
  init_resolveStaticCredentials();
  init_resolveWebIdentityCredentials();
});

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/fromIni.js
var fromIni = (_init = {}) => async ({ callerClientConfig } = {}) => {
  const init2 = {
    ..._init,
    parentClientConfig: {
      ...callerClientConfig,
      ..._init.parentClientConfig
    }
  };
  init2.logger?.debug("@aws-sdk/credential-provider-ini - fromIni");
  const profiles = await parseKnownFiles(init2);
  return resolveProfileData(getProfileName({
    profile: _init.profile ?? callerClientConfig?.profile
  }), profiles, init2);
};
var init_fromIni = __esm(() => {
  init_dist_es21();
  init_resolveProfileData();
});

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/index.js
var exports_dist_es7 = {};
__export(exports_dist_es7, {
  fromIni: () => fromIni
});
var init_dist_es42 = __esm(() => {
  init_fromIni();
});

// ../../node_modules/@prisma/client/runtime/library.js
var require_library = __commonJS((exports, module) => {
  var __dirname = "E:\\JS\\huginn-monorepo\\node_modules\\@prisma\\client\\runtime", __filename = "E:\\JS\\huginn-monorepo\\node_modules\\@prisma\\client\\runtime\\library.js";
  var ru = Object.create;
  var Fr = Object.defineProperty;
  var nu = Object.getOwnPropertyDescriptor;
  var iu = Object.getOwnPropertyNames;
  var ou = Object.getPrototypeOf;
  var su = Object.prototype.hasOwnProperty;
  var Z2 = (e4, t4) => () => (t4 || e4((t4 = { exports: {} }).exports, t4), t4.exports);
  var Bt = (e4, t4) => {
    for (var r5 in t4)
      Fr(e4, r5, { get: t4[r5], enumerable: true });
  };
  var wo = (e4, t4, r5, n4) => {
    if (t4 && typeof t4 == "object" || typeof t4 == "function")
      for (let i4 of iu(t4))
        !su.call(e4, i4) && i4 !== r5 && Fr(e4, i4, { get: () => t4[i4], enumerable: !(n4 = nu(t4, i4)) || n4.enumerable });
    return e4;
  };
  var D3 = (e4, t4, r5) => (r5 = e4 != null ? ru(ou(e4)) : {}, wo(t4 || !e4 || !e4.__esModule ? Fr(r5, "default", { value: e4, enumerable: true }) : r5, e4));
  var au2 = (e4) => wo(Fr({}, "__esModule", { value: true }), e4);
  var Qo = Z2((yf, ti) => {
    var v7 = ti.exports;
    ti.exports.default = v7;
    var _3 = "\x1B[", Ht = "\x1B]", mt = "\x07", Jr = ";", Uo = process.env.TERM_PROGRAM === "Apple_Terminal";
    v7.cursorTo = (e4, t4) => {
      if (typeof e4 != "number")
        throw new TypeError("The `x` argument is required");
      return typeof t4 != "number" ? _3 + (e4 + 1) + "G" : _3 + (t4 + 1) + ";" + (e4 + 1) + "H";
    };
    v7.cursorMove = (e4, t4) => {
      if (typeof e4 != "number")
        throw new TypeError("The `x` argument is required");
      let r5 = "";
      return e4 < 0 ? r5 += _3 + -e4 + "D" : e4 > 0 && (r5 += _3 + e4 + "C"), t4 < 0 ? r5 += _3 + -t4 + "A" : t4 > 0 && (r5 += _3 + t4 + "B"), r5;
    };
    v7.cursorUp = (e4 = 1) => _3 + e4 + "A";
    v7.cursorDown = (e4 = 1) => _3 + e4 + "B";
    v7.cursorForward = (e4 = 1) => _3 + e4 + "C";
    v7.cursorBackward = (e4 = 1) => _3 + e4 + "D";
    v7.cursorLeft = _3 + "G";
    v7.cursorSavePosition = Uo ? "\x1B7" : _3 + "s";
    v7.cursorRestorePosition = Uo ? "\x1B8" : _3 + "u";
    v7.cursorGetPosition = _3 + "6n";
    v7.cursorNextLine = _3 + "E";
    v7.cursorPrevLine = _3 + "F";
    v7.cursorHide = _3 + "?25l";
    v7.cursorShow = _3 + "?25h";
    v7.eraseLines = (e4) => {
      let t4 = "";
      for (let r5 = 0;r5 < e4; r5++)
        t4 += v7.eraseLine + (r5 < e4 - 1 ? v7.cursorUp() : "");
      return e4 && (t4 += v7.cursorLeft), t4;
    };
    v7.eraseEndLine = _3 + "K";
    v7.eraseStartLine = _3 + "1K";
    v7.eraseLine = _3 + "2K";
    v7.eraseDown = _3 + "J";
    v7.eraseUp = _3 + "1J";
    v7.eraseScreen = _3 + "2J";
    v7.scrollUp = _3 + "S";
    v7.scrollDown = _3 + "T";
    v7.clearScreen = "\x1Bc";
    v7.clearTerminal = process.platform === "win32" ? `${v7.eraseScreen}${_3}0f` : `${v7.eraseScreen}${_3}3J${_3}H`;
    v7.beep = mt;
    v7.link = (e4, t4) => [Ht, "8", Jr, Jr, t4, mt, e4, Ht, "8", Jr, Jr, mt].join("");
    v7.image = (e4, t4 = {}) => {
      let r5 = `${Ht}1337;File=inline=1`;
      return t4.width && (r5 += `;width=${t4.width}`), t4.height && (r5 += `;height=${t4.height}`), t4.preserveAspectRatio === false && (r5 += ";preserveAspectRatio=0"), r5 + ":" + e4.toString("base64") + mt;
    };
    v7.iTerm = { setCwd: (e4 = process.cwd()) => `${Ht}50;CurrentDir=${e4}${mt}`, annotation: (e4, t4 = {}) => {
      let r5 = `${Ht}1337;`, n4 = typeof t4.x < "u", i4 = typeof t4.y < "u";
      if ((n4 || i4) && !(n4 && i4 && typeof t4.length < "u"))
        throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
      return e4 = e4.replace(/\|/g, ""), r5 += t4.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=", t4.length > 0 ? r5 += (n4 ? [e4, t4.length, t4.x, t4.y] : [t4.length, e4]).join("|") : r5 += e4, r5 + mt;
    } };
  });
  var ri = Z2((Ef, Go) => {
    Go.exports = (e4, t4 = process.argv) => {
      let r5 = e4.startsWith("-") ? "" : e4.length === 1 ? "-" : "--", n4 = t4.indexOf(r5 + e4), i4 = t4.indexOf("--");
      return n4 !== -1 && (i4 === -1 || n4 < i4);
    };
  });
  var Wo = Z2((bf2, Ho) => {
    var Ju = __require("os"), Jo = __require("tty"), fe = ri(), { env: J3 } = process, Je;
    fe("no-color") || fe("no-colors") || fe("color=false") || fe("color=never") ? Je = 0 : (fe("color") || fe("colors") || fe("color=true") || fe("color=always")) && (Je = 1);
    "FORCE_COLOR" in J3 && (J3.FORCE_COLOR === "true" ? Je = 1 : J3.FORCE_COLOR === "false" ? Je = 0 : Je = J3.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(J3.FORCE_COLOR, 10), 3));
    function ni(e4) {
      return e4 === 0 ? false : { level: e4, hasBasic: true, has256: e4 >= 2, has16m: e4 >= 3 };
    }
    function ii(e4, t4) {
      if (Je === 0)
        return 0;
      if (fe("color=16m") || fe("color=full") || fe("color=truecolor"))
        return 3;
      if (fe("color=256"))
        return 2;
      if (e4 && !t4 && Je === undefined)
        return 0;
      let r5 = Je || 0;
      if (J3.TERM === "dumb")
        return r5;
      if (process.platform === "win32") {
        let n4 = Ju.release().split(".");
        return Number(n4[0]) >= 10 && Number(n4[2]) >= 10586 ? Number(n4[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in J3)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((n4) => (n4 in J3)) || J3.CI_NAME === "codeship" ? 1 : r5;
      if ("TEAMCITY_VERSION" in J3)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(J3.TEAMCITY_VERSION) ? 1 : 0;
      if (J3.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in J3) {
        let n4 = parseInt((J3.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (J3.TERM_PROGRAM) {
          case "iTerm.app":
            return n4 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(J3.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(J3.TERM) || ("COLORTERM" in J3) ? 1 : r5;
    }
    function Hu(e4) {
      let t4 = ii(e4, e4 && e4.isTTY);
      return ni(t4);
    }
    Ho.exports = { supportsColor: Hu, stdout: ni(ii(true, Jo.isatty(1))), stderr: ni(ii(true, Jo.isatty(2))) };
  });
  var zo = Z2((wf, Yo) => {
    var Wu = Wo(), ft = ri();
    function Ko(e4) {
      if (/^\d{3,4}$/.test(e4)) {
        let r5 = /(\d{1,2})(\d{2})/.exec(e4);
        return { major: 0, minor: parseInt(r5[1], 10), patch: parseInt(r5[2], 10) };
      }
      let t4 = (e4 || "").split(".").map((r5) => parseInt(r5, 10));
      return { major: t4[0], minor: t4[1], patch: t4[2] };
    }
    function oi(e4) {
      let { env: t4 } = process;
      if ("FORCE_HYPERLINK" in t4)
        return !(t4.FORCE_HYPERLINK.length > 0 && parseInt(t4.FORCE_HYPERLINK, 10) === 0);
      if (ft("no-hyperlink") || ft("no-hyperlinks") || ft("hyperlink=false") || ft("hyperlink=never"))
        return false;
      if (ft("hyperlink=true") || ft("hyperlink=always") || "NETLIFY" in t4)
        return true;
      if (!Wu.supportsColor(e4) || e4 && !e4.isTTY || process.platform === "win32" || "CI" in t4 || "TEAMCITY_VERSION" in t4)
        return false;
      if ("TERM_PROGRAM" in t4) {
        let r5 = Ko(t4.TERM_PROGRAM_VERSION);
        switch (t4.TERM_PROGRAM) {
          case "iTerm.app":
            return r5.major === 3 ? r5.minor >= 1 : r5.major > 3;
          case "WezTerm":
            return r5.major >= 20200620;
          case "vscode":
            return r5.major > 1 || r5.major === 1 && r5.minor >= 72;
        }
      }
      if ("VTE_VERSION" in t4) {
        if (t4.VTE_VERSION === "0.50.0")
          return false;
        let r5 = Ko(t4.VTE_VERSION);
        return r5.major > 0 || r5.minor >= 50;
      }
      return false;
    }
    Yo.exports = { supportsHyperlink: oi, stdout: oi(process.stdout), stderr: oi(process.stderr) };
  });
  var Xo = Z2((xf, Wt) => {
    var Ku = Qo(), si = zo(), Zo = (e4, t4, { target: r5 = "stdout", ...n4 } = {}) => si[r5] ? Ku.link(e4, t4) : n4.fallback === false ? e4 : typeof n4.fallback == "function" ? n4.fallback(e4, t4) : `${e4} (\u200B${t4}\u200B)`;
    Wt.exports = (e4, t4, r5 = {}) => Zo(e4, t4, r5);
    Wt.exports.stderr = (e4, t4, r5 = {}) => Zo(e4, t4, { target: "stderr", ...r5 });
    Wt.exports.isSupported = si.stdout;
    Wt.exports.stderr.isSupported = si.stderr;
  });
  var li = Z2((kf, Yu) => {
    Yu.exports = { name: "@prisma/engines-version", version: "6.2.0-14.4123509d24aa4dede1e864b46351bf2790323b69", main: "index.js", types: "index.d.ts", license: "Apache-2.0", author: "Tim Suchanek <suchanek@prisma.io>", prisma: { enginesVersion: "4123509d24aa4dede1e864b46351bf2790323b69" }, repository: { type: "git", url: "https://github.com/prisma/engines-wrapper.git", directory: "packages/engines-version" }, devDependencies: { "@types/node": "18.19.68", typescript: "4.9.5" }, files: ["index.js", "index.d.ts"], scripts: { build: "tsc -d" } };
  });
  var ui = Z2((Hr) => {
    Object.defineProperty(Hr, "__esModule", { value: true });
    Hr.enginesVersion = undefined;
    Hr.enginesVersion = li().prisma.enginesVersion;
  });
  var ns = Z2((Yf, Xu) => {
    Xu.exports = { name: "dotenv", version: "16.4.7", description: "Loads environment variables from .env file", main: "lib/main.js", types: "lib/main.d.ts", exports: { ".": { types: "./lib/main.d.ts", require: "./lib/main.js", default: "./lib/main.js" }, "./config": "./config.js", "./config.js": "./config.js", "./lib/env-options": "./lib/env-options.js", "./lib/env-options.js": "./lib/env-options.js", "./lib/cli-options": "./lib/cli-options.js", "./lib/cli-options.js": "./lib/cli-options.js", "./package.json": "./package.json" }, scripts: { "dts-check": "tsc --project tests/types/tsconfig.json", lint: "standard", pretest: "npm run lint && npm run dts-check", test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000", "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov", prerelease: "npm test", release: "standard-version" }, repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" }, funding: "https://dotenvx.com", keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"], readmeFilename: "README.md", license: "BSD-2-Clause", devDependencies: { "@types/node": "^18.11.3", decache: "^4.6.2", sinon: "^14.0.1", standard: "^17.0.0", "standard-version": "^9.5.0", tap: "^19.2.0", typescript: "^4.8.4" }, engines: { node: ">=12" }, browser: { fs: false } };
  });
  var as2 = Z2((zf, Le) => {
    var mi = __require("fs"), fi = __require("path"), ec = __require("os"), tc = __require("crypto"), rc = ns(), gi = rc.version, nc = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function ic(e4) {
      let t4 = {}, r5 = e4.toString();
      r5 = r5.replace(/\r\n?/mg, `
`);
      let n4;
      for (;(n4 = nc.exec(r5)) != null; ) {
        let i4 = n4[1], o3 = n4[2] || "";
        o3 = o3.trim();
        let s5 = o3[0];
        o3 = o3.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), s5 === '"' && (o3 = o3.replace(/\\n/g, `
`), o3 = o3.replace(/\\r/g, "\r")), t4[i4] = o3;
      }
      return t4;
    }
    function oc(e4) {
      let t4 = ss(e4), r5 = Q3.configDotenv({ path: t4 });
      if (!r5.parsed) {
        let s5 = new Error(`MISSING_DATA: Cannot parse ${t4} for an unknown reason`);
        throw s5.code = "MISSING_DATA", s5;
      }
      let n4 = os(e4).split(","), i4 = n4.length, o3;
      for (let s5 = 0;s5 < i4; s5++)
        try {
          let a5 = n4[s5].trim(), l4 = lc(r5, a5);
          o3 = Q3.decrypt(l4.ciphertext, l4.key);
          break;
        } catch (a5) {
          if (s5 + 1 >= i4)
            throw a5;
        }
      return Q3.parse(o3);
    }
    function sc(e4) {
      console.log(`[dotenv@${gi}][INFO] ${e4}`);
    }
    function ac2(e4) {
      console.log(`[dotenv@${gi}][WARN] ${e4}`);
    }
    function Wr(e4) {
      console.log(`[dotenv@${gi}][DEBUG] ${e4}`);
    }
    function os(e4) {
      return e4 && e4.DOTENV_KEY && e4.DOTENV_KEY.length > 0 ? e4.DOTENV_KEY : process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0 ? process.env.DOTENV_KEY : "";
    }
    function lc(e4, t4) {
      let r5;
      try {
        r5 = new URL(t4);
      } catch (a5) {
        if (a5.code === "ERR_INVALID_URL") {
          let l4 = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
          throw l4.code = "INVALID_DOTENV_KEY", l4;
        }
        throw a5;
      }
      let n4 = r5.password;
      if (!n4) {
        let a5 = new Error("INVALID_DOTENV_KEY: Missing key part");
        throw a5.code = "INVALID_DOTENV_KEY", a5;
      }
      let i4 = r5.searchParams.get("environment");
      if (!i4) {
        let a5 = new Error("INVALID_DOTENV_KEY: Missing environment part");
        throw a5.code = "INVALID_DOTENV_KEY", a5;
      }
      let o3 = `DOTENV_VAULT_${i4.toUpperCase()}`, s5 = e4.parsed[o3];
      if (!s5) {
        let a5 = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${o3} in your .env.vault file.`);
        throw a5.code = "NOT_FOUND_DOTENV_ENVIRONMENT", a5;
      }
      return { ciphertext: s5, key: n4 };
    }
    function ss(e4) {
      let t4 = null;
      if (e4 && e4.path && e4.path.length > 0)
        if (Array.isArray(e4.path))
          for (let r5 of e4.path)
            mi.existsSync(r5) && (t4 = r5.endsWith(".vault") ? r5 : `${r5}.vault`);
        else
          t4 = e4.path.endsWith(".vault") ? e4.path : `${e4.path}.vault`;
      else
        t4 = fi.resolve(process.cwd(), ".env.vault");
      return mi.existsSync(t4) ? t4 : null;
    }
    function is(e4) {
      return e4[0] === "~" ? fi.join(ec.homedir(), e4.slice(1)) : e4;
    }
    function uc(e4) {
      sc("Loading env from encrypted .env.vault");
      let t4 = Q3._parseVault(e4), r5 = process.env;
      return e4 && e4.processEnv != null && (r5 = e4.processEnv), Q3.populate(r5, t4, e4), { parsed: t4 };
    }
    function cc2(e4) {
      let t4 = fi.resolve(process.cwd(), ".env"), r5 = "utf8", n4 = !!(e4 && e4.debug);
      e4 && e4.encoding ? r5 = e4.encoding : n4 && Wr("No encoding is specified. UTF-8 is used by default");
      let i4 = [t4];
      if (e4 && e4.path)
        if (!Array.isArray(e4.path))
          i4 = [is(e4.path)];
        else {
          i4 = [];
          for (let l4 of e4.path)
            i4.push(is(l4));
        }
      let o3, s5 = {};
      for (let l4 of i4)
        try {
          let u5 = Q3.parse(mi.readFileSync(l4, { encoding: r5 }));
          Q3.populate(s5, u5, e4);
        } catch (u5) {
          n4 && Wr(`Failed to load ${l4} ${u5.message}`), o3 = u5;
        }
      let a5 = process.env;
      return e4 && e4.processEnv != null && (a5 = e4.processEnv), Q3.populate(a5, s5, e4), o3 ? { parsed: s5, error: o3 } : { parsed: s5 };
    }
    function pc(e4) {
      if (os(e4).length === 0)
        return Q3.configDotenv(e4);
      let t4 = ss(e4);
      return t4 ? Q3._configVault(e4) : (ac2(`You set DOTENV_KEY but you are missing a .env.vault file at ${t4}. Did you forget to build it?`), Q3.configDotenv(e4));
    }
    function dc(e4, t4) {
      let r5 = Buffer.from(t4.slice(-64), "hex"), n4 = Buffer.from(e4, "base64"), i4 = n4.subarray(0, 12), o3 = n4.subarray(-16);
      n4 = n4.subarray(12, -16);
      try {
        let s5 = tc.createDecipheriv("aes-256-gcm", r5, i4);
        return s5.setAuthTag(o3), `${s5.update(n4)}${s5.final()}`;
      } catch (s5) {
        let a5 = s5 instanceof RangeError, l4 = s5.message === "Invalid key length", u5 = s5.message === "Unsupported state or unable to authenticate data";
        if (a5 || l4) {
          let c5 = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          throw c5.code = "INVALID_DOTENV_KEY", c5;
        } else if (u5) {
          let c5 = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          throw c5.code = "DECRYPTION_FAILED", c5;
        } else
          throw s5;
      }
    }
    function mc(e4, t4, r5 = {}) {
      let n4 = !!(r5 && r5.debug), i4 = !!(r5 && r5.override);
      if (typeof t4 != "object") {
        let o3 = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        throw o3.code = "OBJECT_REQUIRED", o3;
      }
      for (let o3 of Object.keys(t4))
        Object.prototype.hasOwnProperty.call(e4, o3) ? (i4 === true && (e4[o3] = t4[o3]), n4 && Wr(i4 === true ? `"${o3}" is already defined and WAS overwritten` : `"${o3}" is already defined and was NOT overwritten`)) : e4[o3] = t4[o3];
    }
    var Q3 = { configDotenv: cc2, _configVault: uc, _parseVault: oc, config: pc, decrypt: dc, parse: ic, populate: mc };
    Le.exports.configDotenv = Q3.configDotenv;
    Le.exports._configVault = Q3._configVault;
    Le.exports._parseVault = Q3._parseVault;
    Le.exports.config = Q3.config;
    Le.exports.decrypt = Q3.decrypt;
    Le.exports.parse = Q3.parse;
    Le.exports.populate = Q3.populate;
    Le.exports = Q3;
  });
  var ms = Z2((ig, ds) => {
    ds.exports = (e4) => {
      let t4 = e4.match(/^[ \t]*(?=\S)/gm);
      return t4 ? t4.reduce((r5, n4) => Math.min(r5, n4.length), 1 / 0) : 0;
    };
  });
  var gs = Z2((og, fs3) => {
    var yc = ms();
    fs3.exports = (e4) => {
      let t4 = yc(e4);
      if (t4 === 0)
        return e4;
      let r5 = new RegExp(`^[ \\t]{${t4}}`, "gm");
      return e4.replace(r5, "");
    };
  });
  var bi2 = Z2((pg, hs) => {
    hs.exports = (e4, t4 = 1, r5) => {
      if (r5 = { indent: " ", includeEmptyLines: false, ...r5 }, typeof e4 != "string")
        throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e4}\``);
      if (typeof t4 != "number")
        throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t4}\``);
      if (typeof r5.indent != "string")
        throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r5.indent}\``);
      if (t4 === 0)
        return e4;
      let n4 = r5.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return e4.replace(n4, r5.indent.repeat(t4));
    };
  });
  var ws = Z2((fg, bs2) => {
    bs2.exports = ({ onlyFirst: e4 = false } = {}) => {
      let t4 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
      return new RegExp(t4, e4 ? undefined : "g");
    };
  });
  var Pi = Z2((gg, xs) => {
    var Rc = ws();
    xs.exports = (e4) => typeof e4 == "string" ? e4.replace(Rc(), "") : e4;
  });
  var vs = Z2((Eg, zr) => {
    zr.exports = (e4 = {}) => {
      let t4;
      if (e4.repoUrl)
        t4 = e4.repoUrl;
      else if (e4.user && e4.repo)
        t4 = `https://github.com/${e4.user}/${e4.repo}`;
      else
        throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
      let r5 = new URL(`${t4}/issues/new`), n4 = ["body", "title", "labels", "template", "milestone", "assignee", "projects"];
      for (let i4 of n4) {
        let o3 = e4[i4];
        if (o3 !== undefined) {
          if (i4 === "labels" || i4 === "projects") {
            if (!Array.isArray(o3))
              throw new TypeError(`The \`${i4}\` option should be an array`);
            o3 = o3.join(",");
          }
          r5.searchParams.set(i4, o3);
        }
      }
      return r5.toString();
    };
    zr.exports.default = zr.exports;
  });
  var _i = Z2((Sh, Qs) => {
    Qs.exports = function() {
      function e4(t4, r5, n4, i4, o3) {
        return t4 < r5 || n4 < r5 ? t4 > n4 ? n4 + 1 : t4 + 1 : i4 === o3 ? r5 : r5 + 1;
      }
      return function(t4, r5) {
        if (t4 === r5)
          return 0;
        if (t4.length > r5.length) {
          var n4 = t4;
          t4 = r5, r5 = n4;
        }
        for (var i4 = t4.length, o3 = r5.length;i4 > 0 && t4.charCodeAt(i4 - 1) === r5.charCodeAt(o3 - 1); )
          i4--, o3--;
        for (var s5 = 0;s5 < i4 && t4.charCodeAt(s5) === r5.charCodeAt(s5); )
          s5++;
        if (i4 -= s5, o3 -= s5, i4 === 0 || o3 < 3)
          return o3;
        var a5 = 0, l4, u5, c5, p5, d4, f4, g3, h4, O4, P4, C3, R4, k4 = [];
        for (l4 = 0;l4 < i4; l4++)
          k4.push(l4 + 1), k4.push(t4.charCodeAt(s5 + l4));
        for (var A4 = k4.length - 1;a5 < o3 - 3; )
          for (O4 = r5.charCodeAt(s5 + (u5 = a5)), P4 = r5.charCodeAt(s5 + (c5 = a5 + 1)), C3 = r5.charCodeAt(s5 + (p5 = a5 + 2)), R4 = r5.charCodeAt(s5 + (d4 = a5 + 3)), f4 = a5 += 4, l4 = 0;l4 < A4; l4 += 2)
            g3 = k4[l4], h4 = k4[l4 + 1], u5 = e4(g3, u5, c5, O4, h4), c5 = e4(u5, c5, p5, P4, h4), p5 = e4(c5, p5, d4, C3, h4), f4 = e4(p5, d4, f4, R4, h4), k4[l4] = f4, d4 = p5, p5 = c5, c5 = u5, u5 = g3;
        for (;a5 < o3; )
          for (O4 = r5.charCodeAt(s5 + (u5 = a5)), f4 = ++a5, l4 = 0;l4 < A4; l4 += 2)
            g3 = k4[l4], k4[l4] = f4 = e4(g3, u5, f4, O4, k4[l4 + 1]), u5 = g3;
        return f4;
      };
    }();
  });
  var Bm = {};
  Bt(Bm, { Debug: () => Jn, Decimal: () => ve, Extensions: () => Bn, MetricsClient: () => Ot, PrismaClientInitializationError: () => T4, PrismaClientKnownRequestError: () => ee2, PrismaClientRustPanicError: () => ce2, PrismaClientUnknownRequestError: () => B4, PrismaClientValidationError: () => te, Public: () => Un, Sql: () => ae2, defineDmmfProperty: () => ga, deserializeJsonResponse: () => bt2, deserializeRawResult: () => qn, dmmfToRuntimeDataModel: () => fa, empty: () => ba2, getPrismaClient: () => Xl, getRuntime: () => In, join: () => Ea, makeStrictEnum: () => eu, makeTypedQueryFactory: () => ha, objectEnumValues: () => yn, raw: () => Gi, serializeJsonQuery: () => Pn, skip: () => vn, sqltag: () => Ji, warnEnvConflicts: () => tu, warnOnce: () => tr });
  module.exports = au2(Bm);
  var Bn = {};
  Bt(Bn, { defineExtension: () => xo, getExtensionContext: () => vo });
  function xo(e4) {
    return typeof e4 == "function" ? e4 : (t4) => t4.$extends(e4);
  }
  function vo(e4) {
    return e4;
  }
  var Un = {};
  Bt(Un, { validator: () => Po });
  function Po(...e4) {
    return (t4) => t4;
  }
  var Mr = {};
  Bt(Mr, { $: () => Ao, bgBlack: () => yu, bgBlue: () => xu, bgCyan: () => Pu, bgGreen: () => bu2, bgMagenta: () => vu, bgRed: () => Eu, bgWhite: () => Tu, bgYellow: () => wu, black: () => mu, blue: () => rt, bold: () => W3, cyan: () => _e2, dim: () => ke, gray: () => Ut, green: () => Ve, grey: () => hu, hidden: () => pu, inverse: () => cu2, italic: () => uu, magenta: () => fu, red: () => de2, reset: () => lu, strikethrough: () => du, underline: () => X3, white: () => gu, yellow: () => De });
  var Qn;
  var To;
  var Ro;
  var Co;
  var So = true;
  typeof process < "u" && ({ FORCE_COLOR: Qn, NODE_DISABLE_COLORS: To, NO_COLOR: Ro, TERM: Co } = process.env || {}, So = process.stdout && process.stdout.isTTY);
  var Ao = { enabled: !To && Ro == null && Co !== "dumb" && (Qn != null && Qn !== "0" || So) };
  function $(e4, t4) {
    let r5 = new RegExp(`\\x1b\\[${t4}m`, "g"), n4 = `\x1B[${e4}m`, i4 = `\x1B[${t4}m`;
    return function(o3) {
      return !Ao.enabled || o3 == null ? o3 : n4 + (~("" + o3).indexOf(i4) ? o3.replace(r5, i4 + n4) : o3) + i4;
    };
  }
  var lu = $(0, 0);
  var W3 = $(1, 22);
  var ke = $(2, 22);
  var uu = $(3, 23);
  var X3 = $(4, 24);
  var cu2 = $(7, 27);
  var pu = $(8, 28);
  var du = $(9, 29);
  var mu = $(30, 39);
  var de2 = $(31, 39);
  var Ve = $(32, 39);
  var De = $(33, 39);
  var rt = $(34, 39);
  var fu = $(35, 39);
  var _e2 = $(36, 39);
  var gu = $(37, 39);
  var Ut = $(90, 39);
  var hu = $(90, 39);
  var yu = $(40, 49);
  var Eu = $(41, 49);
  var bu2 = $(42, 49);
  var wu = $(43, 49);
  var xu = $(44, 49);
  var vu = $(45, 49);
  var Pu = $(46, 49);
  var Tu = $(47, 49);
  var Ru = 100;
  var Io = ["green", "yellow", "blue", "magenta", "cyan", "red"];
  var Qt = [];
  var Oo = Date.now();
  var Cu = 0;
  var Gn = typeof process < "u" ? process.env : {};
  globalThis.DEBUG ??= Gn.DEBUG ?? "";
  globalThis.DEBUG_COLORS ??= Gn.DEBUG_COLORS ? Gn.DEBUG_COLORS === "true" : true;
  var Gt = { enable(e4) {
    typeof e4 == "string" && (globalThis.DEBUG = e4);
  }, disable() {
    let e4 = globalThis.DEBUG;
    return globalThis.DEBUG = "", e4;
  }, enabled(e4) {
    let t4 = globalThis.DEBUG.split(",").map((i4) => i4.replace(/[.+?^${}()|[\]\\]/g, "\\$&")), r5 = t4.some((i4) => i4 === "" || i4[0] === "-" ? false : e4.match(RegExp(i4.split("*").join(".*") + "$"))), n4 = t4.some((i4) => i4 === "" || i4[0] !== "-" ? false : e4.match(RegExp(i4.slice(1).split("*").join(".*") + "$")));
    return r5 && !n4;
  }, log: (...e4) => {
    let [t4, r5, ...n4] = e4;
    (console.warn ?? console.log)(`${t4} ${r5}`, ...n4);
  }, formatters: {} };
  function Su(e4) {
    let t4 = { color: Io[Cu++ % Io.length], enabled: Gt.enabled(e4), namespace: e4, log: Gt.log, extend: () => {
    } }, r5 = (...n4) => {
      let { enabled: i4, namespace: o3, color: s5, log: a5 } = t4;
      if (n4.length !== 0 && Qt.push([o3, ...n4]), Qt.length > Ru && Qt.shift(), Gt.enabled(o3) || i4) {
        let l4 = n4.map((c5) => typeof c5 == "string" ? c5 : Au(c5)), u5 = `+${Date.now() - Oo}ms`;
        Oo = Date.now(), globalThis.DEBUG_COLORS ? a5(Mr[s5](W3(o3)), ...l4, Mr[s5](u5)) : a5(o3, ...l4, u5);
      }
    };
    return new Proxy(r5, { get: (n4, i4) => t4[i4], set: (n4, i4, o3) => t4[i4] = o3 });
  }
  var Jn = new Proxy(Su, { get: (e4, t4) => Gt[t4], set: (e4, t4, r5) => Gt[t4] = r5 });
  function Au(e4, t4 = 2) {
    let r5 = new Set;
    return JSON.stringify(e4, (n4, i4) => {
      if (typeof i4 == "object" && i4 !== null) {
        if (r5.has(i4))
          return "[Circular *]";
        r5.add(i4);
      } else if (typeof i4 == "bigint")
        return i4.toString();
      return i4;
    }, t4);
  }
  function ko(e4 = 7500) {
    let t4 = Qt.map(([r5, ...n4]) => `${r5} ${n4.map((i4) => typeof i4 == "string" ? i4 : JSON.stringify(i4)).join(" ")}`).join(`
`);
    return t4.length < e4 ? t4 : t4.slice(-e4);
  }
  function Do() {
    Qt.length = 0;
  }
  var F3 = Jn;
  var _o = D3(__require("fs"));
  function Hn() {
    let e4 = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
    if (!(e4 && _o.default.existsSync(e4)) && process.arch === "ia32")
      throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)');
  }
  var Wn = ["darwin", "darwin-arm64", "debian-openssl-1.0.x", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x", "rhel-openssl-3.0.x", "linux-arm64-openssl-1.1.x", "linux-arm64-openssl-1.0.x", "linux-arm64-openssl-3.0.x", "linux-arm-openssl-1.1.x", "linux-arm-openssl-1.0.x", "linux-arm-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-1.1.x", "linux-musl-arm64-openssl-3.0.x", "linux-nixos", "linux-static-x64", "linux-static-arm64", "windows", "freebsd11", "freebsd12", "freebsd13", "freebsd14", "freebsd15", "openbsd", "netbsd", "arm"];
  var $r = "libquery_engine";
  function qr(e4, t4) {
    let r5 = t4 === "url";
    return e4.includes("windows") ? r5 ? "query_engine.dll.node" : `query_engine-${e4}.dll.node` : e4.includes("darwin") ? r5 ? `${$r}.dylib.node` : `${$r}-${e4}.dylib.node` : r5 ? `${$r}.so.node` : `${$r}-${e4}.so.node`;
  }
  var Mo = D3(__require("child_process"));
  var Xn = D3(__require("fs/promises"));
  var Qr = D3(__require("os"));
  var Ne = Symbol.for("@ts-pattern/matcher");
  var Iu = Symbol.for("@ts-pattern/isVariadic");
  var jr = "@ts-pattern/anonymous-select-key";
  var Kn = (e4) => !!(e4 && typeof e4 == "object");
  var Vr = (e4) => e4 && !!e4[Ne];
  var we = (e4, t4, r5) => {
    if (Vr(e4)) {
      let n4 = e4[Ne](), { matched: i4, selections: o3 } = n4.match(t4);
      return i4 && o3 && Object.keys(o3).forEach((s5) => r5(s5, o3[s5])), i4;
    }
    if (Kn(e4)) {
      if (!Kn(t4))
        return false;
      if (Array.isArray(e4)) {
        if (!Array.isArray(t4))
          return false;
        let n4 = [], i4 = [], o3 = [];
        for (let s5 of e4.keys()) {
          let a5 = e4[s5];
          Vr(a5) && a5[Iu] ? o3.push(a5) : o3.length ? i4.push(a5) : n4.push(a5);
        }
        if (o3.length) {
          if (o3.length > 1)
            throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");
          if (t4.length < n4.length + i4.length)
            return false;
          let s5 = t4.slice(0, n4.length), a5 = i4.length === 0 ? [] : t4.slice(-i4.length), l4 = t4.slice(n4.length, i4.length === 0 ? 1 / 0 : -i4.length);
          return n4.every((u5, c5) => we(u5, s5[c5], r5)) && i4.every((u5, c5) => we(u5, a5[c5], r5)) && (o3.length === 0 || we(o3[0], l4, r5));
        }
        return e4.length === t4.length && e4.every((s5, a5) => we(s5, t4[a5], r5));
      }
      return Reflect.ownKeys(e4).every((n4) => {
        let i4 = e4[n4];
        return ((n4 in t4) || Vr(o3 = i4) && o3[Ne]().matcherType === "optional") && we(i4, t4[n4], r5);
        var o3;
      });
    }
    return Object.is(t4, e4);
  };
  var Ge = (e4) => {
    var t4, r5, n4;
    return Kn(e4) ? Vr(e4) ? (t4 = (r5 = (n4 = e4[Ne]()).getSelectionKeys) == null ? undefined : r5.call(n4)) != null ? t4 : [] : Array.isArray(e4) ? Jt(e4, Ge) : Jt(Object.values(e4), Ge) : [];
  };
  var Jt = (e4, t4) => e4.reduce((r5, n4) => r5.concat(t4(n4)), []);
  function me2(e4) {
    return Object.assign(e4, { optional: () => Ou(e4), and: (t4) => j4(e4, t4), or: (t4) => ku(e4, t4), select: (t4) => t4 === undefined ? No(e4) : No(t4, e4) });
  }
  function Ou(e4) {
    return me2({ [Ne]: () => ({ match: (t4) => {
      let r5 = {}, n4 = (i4, o3) => {
        r5[i4] = o3;
      };
      return t4 === undefined ? (Ge(e4).forEach((i4) => n4(i4, undefined)), { matched: true, selections: r5 }) : { matched: we(e4, t4, n4), selections: r5 };
    }, getSelectionKeys: () => Ge(e4), matcherType: "optional" }) });
  }
  function j4(...e4) {
    return me2({ [Ne]: () => ({ match: (t4) => {
      let r5 = {}, n4 = (i4, o3) => {
        r5[i4] = o3;
      };
      return { matched: e4.every((i4) => we(i4, t4, n4)), selections: r5 };
    }, getSelectionKeys: () => Jt(e4, Ge), matcherType: "and" }) });
  }
  function ku(...e4) {
    return me2({ [Ne]: () => ({ match: (t4) => {
      let r5 = {}, n4 = (i4, o3) => {
        r5[i4] = o3;
      };
      return Jt(e4, Ge).forEach((i4) => n4(i4, undefined)), { matched: e4.some((i4) => we(i4, t4, n4)), selections: r5 };
    }, getSelectionKeys: () => Jt(e4, Ge), matcherType: "or" }) });
  }
  function I4(e4) {
    return { [Ne]: () => ({ match: (t4) => ({ matched: !!e4(t4) }) }) };
  }
  function No(...e4) {
    let t4 = typeof e4[0] == "string" ? e4[0] : undefined, r5 = e4.length === 2 ? e4[1] : typeof e4[0] == "string" ? undefined : e4[0];
    return me2({ [Ne]: () => ({ match: (n4) => {
      let i4 = { [t4 ?? jr]: n4 };
      return { matched: r5 === undefined || we(r5, n4, (o3, s5) => {
        i4[o3] = s5;
      }), selections: i4 };
    }, getSelectionKeys: () => [t4 ?? jr].concat(r5 === undefined ? [] : Ge(r5)) }) });
  }
  function Ee(e4) {
    return typeof e4 == "number";
  }
  function je(e4) {
    return typeof e4 == "string";
  }
  function Be(e4) {
    return typeof e4 == "bigint";
  }
  var tf = me2(I4(function(e4) {
    return true;
  }));
  var Ue = (e4) => Object.assign(me2(e4), { startsWith: (t4) => {
    return Ue(j4(e4, (r5 = t4, I4((n4) => je(n4) && n4.startsWith(r5)))));
    var r5;
  }, endsWith: (t4) => {
    return Ue(j4(e4, (r5 = t4, I4((n4) => je(n4) && n4.endsWith(r5)))));
    var r5;
  }, minLength: (t4) => Ue(j4(e4, ((r5) => I4((n4) => je(n4) && n4.length >= r5))(t4))), length: (t4) => Ue(j4(e4, ((r5) => I4((n4) => je(n4) && n4.length === r5))(t4))), maxLength: (t4) => Ue(j4(e4, ((r5) => I4((n4) => je(n4) && n4.length <= r5))(t4))), includes: (t4) => {
    return Ue(j4(e4, (r5 = t4, I4((n4) => je(n4) && n4.includes(r5)))));
    var r5;
  }, regex: (t4) => {
    return Ue(j4(e4, (r5 = t4, I4((n4) => je(n4) && !!n4.match(r5)))));
    var r5;
  } });
  var rf = Ue(I4(je));
  var be2 = (e4) => Object.assign(me2(e4), { between: (t4, r5) => be2(j4(e4, ((n4, i4) => I4((o3) => Ee(o3) && n4 <= o3 && i4 >= o3))(t4, r5))), lt: (t4) => be2(j4(e4, ((r5) => I4((n4) => Ee(n4) && n4 < r5))(t4))), gt: (t4) => be2(j4(e4, ((r5) => I4((n4) => Ee(n4) && n4 > r5))(t4))), lte: (t4) => be2(j4(e4, ((r5) => I4((n4) => Ee(n4) && n4 <= r5))(t4))), gte: (t4) => be2(j4(e4, ((r5) => I4((n4) => Ee(n4) && n4 >= r5))(t4))), int: () => be2(j4(e4, I4((t4) => Ee(t4) && Number.isInteger(t4)))), finite: () => be2(j4(e4, I4((t4) => Ee(t4) && Number.isFinite(t4)))), positive: () => be2(j4(e4, I4((t4) => Ee(t4) && t4 > 0))), negative: () => be2(j4(e4, I4((t4) => Ee(t4) && t4 < 0))) });
  var nf = be2(I4(Ee));
  var Qe = (e4) => Object.assign(me2(e4), { between: (t4, r5) => Qe(j4(e4, ((n4, i4) => I4((o3) => Be(o3) && n4 <= o3 && i4 >= o3))(t4, r5))), lt: (t4) => Qe(j4(e4, ((r5) => I4((n4) => Be(n4) && n4 < r5))(t4))), gt: (t4) => Qe(j4(e4, ((r5) => I4((n4) => Be(n4) && n4 > r5))(t4))), lte: (t4) => Qe(j4(e4, ((r5) => I4((n4) => Be(n4) && n4 <= r5))(t4))), gte: (t4) => Qe(j4(e4, ((r5) => I4((n4) => Be(n4) && n4 >= r5))(t4))), positive: () => Qe(j4(e4, I4((t4) => Be(t4) && t4 > 0))), negative: () => Qe(j4(e4, I4((t4) => Be(t4) && t4 < 0))) });
  var of = Qe(I4(Be));
  var sf = me2(I4(function(e4) {
    return typeof e4 == "boolean";
  }));
  var af2 = me2(I4(function(e4) {
    return typeof e4 == "symbol";
  }));
  var lf = me2(I4(function(e4) {
    return e4 == null;
  }));
  var uf = me2(I4(function(e4) {
    return e4 != null;
  }));
  var Yn = class extends Error {
    constructor(t4) {
      let r5;
      try {
        r5 = JSON.stringify(t4);
      } catch {
        r5 = t4;
      }
      super(`Pattern matching error: no pattern matches value ${r5}`), this.input = undefined, this.input = t4;
    }
  };
  var zn = { matched: false, value: undefined };
  function dt(e4) {
    return new Zn(e4, zn);
  }
  var Zn = class e4 {
    constructor(t4, r5) {
      this.input = undefined, this.state = undefined, this.input = t4, this.state = r5;
    }
    with(...t4) {
      if (this.state.matched)
        return this;
      let r5 = t4[t4.length - 1], n4 = [t4[0]], i4;
      t4.length === 3 && typeof t4[1] == "function" ? i4 = t4[1] : t4.length > 2 && n4.push(...t4.slice(1, t4.length - 1));
      let o3 = false, s5 = {}, a5 = (u5, c5) => {
        o3 = true, s5[u5] = c5;
      }, l4 = !n4.some((u5) => we(u5, this.input, a5)) || i4 && !i4(this.input) ? zn : { matched: true, value: r5(o3 ? jr in s5 ? s5[jr] : s5 : this.input, this.input) };
      return new e4(this.input, l4);
    }
    when(t4, r5) {
      if (this.state.matched)
        return this;
      let n4 = !!t4(this.input);
      return new e4(this.input, n4 ? { matched: true, value: r5(this.input, this.input) } : zn);
    }
    otherwise(t4) {
      return this.state.matched ? this.state.value : t4(this.input);
    }
    exhaustive() {
      if (this.state.matched)
        return this.state.value;
      throw new Yn(this.input);
    }
    run() {
      return this.exhaustive();
    }
    returnType() {
      return this;
    }
  };
  var $o = __require("util");
  var Du = { warn: De("prisma:warn") };
  var _u = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  function Br(e4, ...t4) {
    _u.warn() && console.warn(`${Du.warn} ${e4}`, ...t4);
  }
  var Nu = (0, $o.promisify)(Mo.default.exec);
  var ne = F3("prisma:get-platform");
  var Lu = ["1.0.x", "1.1.x", "3.0.x"];
  async function qo() {
    let e4 = Qr.default.platform(), t4 = process.arch;
    if (e4 === "freebsd") {
      let s5 = await Gr("freebsd-version");
      if (s5 && s5.trim().length > 0) {
        let l4 = /^(\d+)\.?/.exec(s5);
        if (l4)
          return { platform: "freebsd", targetDistro: `freebsd${l4[1]}`, arch: t4 };
      }
    }
    if (e4 !== "linux")
      return { platform: e4, arch: t4 };
    let r5 = await Mu(), n4 = await Gu(), i4 = qu({ arch: t4, archFromUname: n4, familyDistro: r5.familyDistro }), { libssl: o3 } = await Vu(i4);
    return { platform: "linux", libssl: o3, arch: t4, archFromUname: n4, ...r5 };
  }
  function Fu(e4) {
    let t4 = /^ID="?([^"\n]*)"?$/im, r5 = /^ID_LIKE="?([^"\n]*)"?$/im, n4 = t4.exec(e4), i4 = n4 && n4[1] && n4[1].toLowerCase() || "", o3 = r5.exec(e4), s5 = o3 && o3[1] && o3[1].toLowerCase() || "", a5 = dt({ id: i4, idLike: s5 }).with({ id: "alpine" }, ({ id: l4 }) => ({ targetDistro: "musl", familyDistro: l4, originalDistro: l4 })).with({ id: "raspbian" }, ({ id: l4 }) => ({ targetDistro: "arm", familyDistro: "debian", originalDistro: l4 })).with({ id: "nixos" }, ({ id: l4 }) => ({ targetDistro: "nixos", originalDistro: l4, familyDistro: "nixos" })).with({ id: "debian" }, { id: "ubuntu" }, ({ id: l4 }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l4 })).with({ id: "rhel" }, { id: "centos" }, { id: "fedora" }, ({ id: l4 }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l4 })).when(({ idLike: l4 }) => l4.includes("debian") || l4.includes("ubuntu"), ({ id: l4 }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l4 })).when(({ idLike: l4 }) => i4 === "arch" || l4.includes("arch"), ({ id: l4 }) => ({ targetDistro: "debian", familyDistro: "arch", originalDistro: l4 })).when(({ idLike: l4 }) => l4.includes("centos") || l4.includes("fedora") || l4.includes("rhel") || l4.includes("suse"), ({ id: l4 }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l4 })).otherwise(({ id: l4 }) => ({ targetDistro: undefined, familyDistro: undefined, originalDistro: l4 }));
    return ne(`Found distro info:
${JSON.stringify(a5, null, 2)}`), a5;
  }
  async function Mu() {
    let e4 = "/etc/os-release";
    try {
      let t4 = await Xn.default.readFile(e4, { encoding: "utf-8" });
      return Fu(t4);
    } catch {
      return { targetDistro: undefined, familyDistro: undefined, originalDistro: undefined };
    }
  }
  function $u(e4) {
    let t4 = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e4);
    if (t4) {
      let r5 = `${t4[1]}.x`;
      return Vo(r5);
    }
  }
  function Lo(e4) {
    let t4 = /libssl\.so\.(\d)(\.\d)?/.exec(e4);
    if (t4) {
      let r5 = `${t4[1]}${t4[2] ?? ".0"}.x`;
      return Vo(r5);
    }
  }
  function Vo(e4) {
    let t4 = (() => {
      if (Bo(e4))
        return e4;
      let r5 = e4.split(".");
      return r5[1] = "0", r5.join(".");
    })();
    if (Lu.includes(t4))
      return t4;
  }
  function qu(e4) {
    return dt(e4).with({ familyDistro: "musl" }, () => (ne('Trying platform-specific paths for "alpine"'), ["/lib", "/usr/lib"])).with({ familyDistro: "debian" }, ({ archFromUname: t4 }) => (ne('Trying platform-specific paths for "debian" (and "ubuntu")'), [`/usr/lib/${t4}-linux-gnu`, `/lib/${t4}-linux-gnu`])).with({ familyDistro: "rhel" }, () => (ne('Trying platform-specific paths for "rhel"'), ["/lib64", "/usr/lib64"])).otherwise(({ familyDistro: t4, arch: r5, archFromUname: n4 }) => (ne(`Don't know any platform-specific paths for "${t4}" on ${r5} (${n4})`), []));
  }
  async function Vu(e4) {
    let t4 = 'grep -v "libssl.so.0"', r5 = await Fo(e4);
    if (r5) {
      ne(`Found libssl.so file using platform-specific paths: ${r5}`);
      let o3 = Lo(r5);
      if (ne(`The parsed libssl version is: ${o3}`), o3)
        return { libssl: o3, strategy: "libssl-specific-path" };
    }
    ne('Falling back to "ldconfig" and other generic paths');
    let n4 = await Gr(`ldconfig -p | sed "s/.*=>s*//" | sed "s|.*/||" | grep libssl | sort | ${t4}`);
    if (n4 || (n4 = await Fo(["/lib64", "/usr/lib64", "/lib", "/usr/lib"])), n4) {
      ne(`Found libssl.so file using "ldconfig" or other generic paths: ${n4}`);
      let o3 = Lo(n4);
      if (ne(`The parsed libssl version is: ${o3}`), o3)
        return { libssl: o3, strategy: "ldconfig" };
    }
    let i4 = await Gr("openssl version -v");
    if (i4) {
      ne(`Found openssl binary with version: ${i4}`);
      let o3 = $u(i4);
      if (ne(`The parsed openssl version is: ${o3}`), o3)
        return { libssl: o3, strategy: "openssl-binary" };
    }
    return ne("Couldn't find any version of libssl or OpenSSL in the system"), {};
  }
  async function Fo(e4) {
    for (let t4 of e4) {
      let r5 = await ju(t4);
      if (r5)
        return r5;
    }
  }
  async function ju(e4) {
    try {
      return (await Xn.default.readdir(e4)).find((r5) => r5.startsWith("libssl.so.") && !r5.startsWith("libssl.so.0"));
    } catch (t4) {
      if (t4.code === "ENOENT")
        return;
      throw t4;
    }
  }
  async function nt() {
    let { binaryTarget: e4 } = await jo();
    return e4;
  }
  function Bu(e4) {
    return e4.binaryTarget !== undefined;
  }
  async function ei() {
    let { memoized: e4, ...t4 } = await jo();
    return t4;
  }
  var Ur = {};
  async function jo() {
    if (Bu(Ur))
      return Promise.resolve({ ...Ur, memoized: true });
    let e4 = await qo(), t4 = Uu(e4);
    return Ur = { ...e4, binaryTarget: t4 }, { ...Ur, memoized: false };
  }
  function Uu(e4) {
    let { platform: t4, arch: r5, archFromUname: n4, libssl: i4, targetDistro: o3, familyDistro: s5, originalDistro: a5 } = e4;
    t4 === "linux" && !["x64", "arm64"].includes(r5) && Br(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures (detected "${r5}" instead). If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n4}".`);
    let l4 = "1.1.x";
    if (t4 === "linux" && i4 === undefined) {
      let c5 = dt({ familyDistro: s5 }).with({ familyDistro: "debian" }, () => "Please manually install OpenSSL via `apt-get update -y && apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(() => "Please manually install OpenSSL and try installing Prisma again.");
      Br(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l4}".
${c5}`);
    }
    let u5 = "debian";
    if (t4 === "linux" && o3 === undefined && ne(`Distro is "${a5}". Falling back to Prisma engines built for "${u5}".`), t4 === "darwin" && r5 === "arm64")
      return "darwin-arm64";
    if (t4 === "darwin")
      return "darwin";
    if (t4 === "win32")
      return "windows";
    if (t4 === "freebsd")
      return o3;
    if (t4 === "openbsd")
      return "openbsd";
    if (t4 === "netbsd")
      return "netbsd";
    if (t4 === "linux" && o3 === "nixos")
      return "linux-nixos";
    if (t4 === "linux" && r5 === "arm64")
      return `${o3 === "musl" ? "linux-musl-arm64" : "linux-arm64"}-openssl-${i4 || l4}`;
    if (t4 === "linux" && r5 === "arm")
      return `linux-arm-openssl-${i4 || l4}`;
    if (t4 === "linux" && o3 === "musl") {
      let c5 = "linux-musl";
      return !i4 || Bo(i4) ? c5 : `${c5}-openssl-${i4}`;
    }
    return t4 === "linux" && o3 && i4 ? `${o3}-openssl-${i4}` : (t4 !== "linux" && Br(`Prisma detected unknown OS "${t4}" and may not work as expected. Defaulting to "linux".`), i4 ? `${u5}-openssl-${i4}` : o3 ? `${o3}-openssl-${l4}` : `${u5}-openssl-${l4}`);
  }
  async function Qu(e4) {
    try {
      return await e4();
    } catch {
      return;
    }
  }
  function Gr(e4) {
    return Qu(async () => {
      let t4 = await Nu(e4);
      return ne(`Command "${e4}" successfully returned "${t4.stdout}"`), t4.stdout;
    });
  }
  async function Gu() {
    return typeof Qr.default.machine == "function" ? Qr.default.machine() : (await Gr("uname -m"))?.trim();
  }
  function Bo(e4) {
    return e4.startsWith("1.");
  }
  var es = D3(Xo());
  function ai2(e4) {
    return (0, es.default)(e4, e4, { fallback: X3 });
  }
  var zu = D3(ui());
  var q4 = D3(__require("path"));
  var Zu = D3(ui());
  var jf = F3("prisma:engines");
  function ts() {
    return q4.default.join(__dirname, "../");
  }
  var Bf = "libquery-engine";
  q4.default.join(__dirname, "../query-engine-darwin");
  q4.default.join(__dirname, "../query-engine-darwin-arm64");
  q4.default.join(__dirname, "../query-engine-debian-openssl-1.0.x");
  q4.default.join(__dirname, "../query-engine-debian-openssl-1.1.x");
  q4.default.join(__dirname, "../query-engine-debian-openssl-3.0.x");
  q4.default.join(__dirname, "../query-engine-linux-static-x64");
  q4.default.join(__dirname, "../query-engine-linux-static-arm64");
  q4.default.join(__dirname, "../query-engine-rhel-openssl-1.0.x");
  q4.default.join(__dirname, "../query-engine-rhel-openssl-1.1.x");
  q4.default.join(__dirname, "../query-engine-rhel-openssl-3.0.x");
  q4.default.join(__dirname, "../libquery_engine-darwin.dylib.node");
  q4.default.join(__dirname, "../libquery_engine-darwin-arm64.dylib.node");
  q4.default.join(__dirname, "../libquery_engine-debian-openssl-1.0.x.so.node");
  q4.default.join(__dirname, "../libquery_engine-debian-openssl-1.1.x.so.node");
  q4.default.join(__dirname, "../libquery_engine-debian-openssl-3.0.x.so.node");
  q4.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.0.x.so.node");
  q4.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.1.x.so.node");
  q4.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-3.0.x.so.node");
  q4.default.join(__dirname, "../libquery_engine-linux-musl.so.node");
  q4.default.join(__dirname, "../libquery_engine-linux-musl-openssl-3.0.x.so.node");
  q4.default.join(__dirname, "../libquery_engine-rhel-openssl-1.0.x.so.node");
  q4.default.join(__dirname, "../libquery_engine-rhel-openssl-1.1.x.so.node");
  q4.default.join(__dirname, "../libquery_engine-rhel-openssl-3.0.x.so.node");
  q4.default.join(__dirname, "../query_engine-windows.dll.node");
  var ci2 = D3(__require("fs"));
  var rs = F3("chmodPlusX");
  function pi(e4) {
    if (process.platform === "win32")
      return;
    let t4 = ci2.default.statSync(e4), r5 = t4.mode | 64 | 8 | 1;
    if (t4.mode === r5) {
      rs(`Execution permissions of ${e4} are fine`);
      return;
    }
    let n4 = r5.toString(8).slice(-3);
    rs(`Have to call chmodPlusX on ${e4}`), ci2.default.chmodSync(e4, n4);
  }
  function di(e4) {
    let t4 = e4.e, r5 = (a5) => `Prisma cannot find the required \`${a5}\` system library in your system`, n4 = t4.message.includes("cannot open shared object file"), i4 = `Please refer to the documentation about Prisma's system requirements: ${ai2("https://pris.ly/d/system-requirements")}`, o3 = `Unable to require(\`${ke(e4.id)}\`).`, s5 = dt({ message: t4.message, code: t4.code }).with({ code: "ENOENT" }, () => "File does not exist.").when(({ message: a5 }) => n4 && a5.includes("libz"), () => `${r5("libz")}. Please install it and try again.`).when(({ message: a5 }) => n4 && a5.includes("libgcc_s"), () => `${r5("libgcc_s")}. Please install it and try again.`).when(({ message: a5 }) => n4 && a5.includes("libssl"), () => {
      let a5 = e4.platformInfo.libssl ? `openssl-${e4.platformInfo.libssl}` : "openssl";
      return `${r5("libssl")}. Please install ${a5} and try again.`;
    }).when(({ message: a5 }) => a5.includes("GLIBC"), () => `Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i4}`).when(({ message: a5 }) => e4.platformInfo.platform === "linux" && a5.includes("symbol not found"), () => `The Prisma engines are not compatible with your system ${e4.platformInfo.originalDistro} on (${e4.platformInfo.archFromUname}) which uses the \`${e4.platformInfo.binaryTarget}\` binaryTarget by default. ${i4}`).otherwise(() => `The Prisma engines do not seem to be compatible with your system. ${i4}`);
    return `${o3}
${s5}

Details: ${t4.message}`;
  }
  var yi = D3(as2());
  var Kr = D3(__require("fs"));
  var gt = D3(__require("path"));
  function ls(e4) {
    let t4 = e4.ignoreProcessEnv ? {} : process.env, r5 = (n4) => n4.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(function(o3, s5) {
      let a5 = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s5);
      if (!a5)
        return o3;
      let l4 = a5[1], u5, c5;
      if (l4 === "\\")
        c5 = a5[0], u5 = c5.replace("\\$", "$");
      else {
        let p5 = a5[2];
        c5 = a5[0].substring(l4.length), u5 = Object.hasOwnProperty.call(t4, p5) ? t4[p5] : e4.parsed[p5] || "", u5 = r5(u5);
      }
      return o3.replace(c5, u5);
    }, n4) ?? n4;
    for (let n4 in e4.parsed) {
      let i4 = Object.hasOwnProperty.call(t4, n4) ? t4[n4] : e4.parsed[n4];
      e4.parsed[n4] = r5(i4);
    }
    for (let n4 in e4.parsed)
      t4[n4] = e4.parsed[n4];
    return e4;
  }
  var hi = F3("prisma:tryLoadEnv");
  function Kt({ rootEnvPath: e4, schemaEnvPath: t4 }, r5 = { conflictCheck: "none" }) {
    let n4 = us(e4);
    r5.conflictCheck !== "none" && fc(n4, t4, r5.conflictCheck);
    let i4 = null;
    return cs2(n4?.path, t4) || (i4 = us(t4)), !n4 && !i4 && hi("No Environment variables loaded"), i4?.dotenvResult.error ? console.error(de2(W3("Schema Env Error: ")) + i4.dotenvResult.error) : { message: [n4?.message, i4?.message].filter(Boolean).join(`
`), parsed: { ...n4?.dotenvResult?.parsed, ...i4?.dotenvResult?.parsed } };
  }
  function fc(e4, t4, r5) {
    let n4 = e4?.dotenvResult.parsed, i4 = !cs2(e4?.path, t4);
    if (n4 && t4 && i4 && Kr.default.existsSync(t4)) {
      let o3 = yi.default.parse(Kr.default.readFileSync(t4)), s5 = [];
      for (let a5 in o3)
        n4[a5] === o3[a5] && s5.push(a5);
      if (s5.length > 0) {
        let a5 = gt.default.relative(process.cwd(), e4.path), l4 = gt.default.relative(process.cwd(), t4);
        if (r5 === "error") {
          let u5 = `There is a conflict between env var${s5.length > 1 ? "s" : ""} in ${X3(a5)} and ${X3(l4)}
Conflicting env vars:
${s5.map((c5) => `  ${W3(c5)}`).join(`
`)}

We suggest to move the contents of ${X3(l4)} to ${X3(a5)} to consolidate your env vars.
`;
          throw new Error(u5);
        } else if (r5 === "warn") {
          let u5 = `Conflict for env var${s5.length > 1 ? "s" : ""} ${s5.map((c5) => W3(c5)).join(", ")} in ${X3(a5)} and ${X3(l4)}
Env vars from ${X3(l4)} overwrite the ones from ${X3(a5)}
      `;
          console.warn(`${De("warn(prisma)")} ${u5}`);
        }
      }
    }
  }
  function us(e4) {
    if (gc(e4)) {
      hi(`Environment variables loaded from ${e4}`);
      let t4 = yi.default.config({ path: e4, debug: process.env.DOTENV_CONFIG_DEBUG ? true : undefined });
      return { dotenvResult: ls(t4), message: ke(`Environment variables loaded from ${gt.default.relative(process.cwd(), e4)}`), path: e4 };
    } else
      hi(`Environment variables not found at ${e4}`);
    return null;
  }
  function cs2(e4, t4) {
    return e4 && t4 && gt.default.resolve(e4) === gt.default.resolve(t4);
  }
  function gc(e4) {
    return !!(e4 && Kr.default.existsSync(e4));
  }
  var ps = "library";
  function Yt(e4) {
    let t4 = hc();
    return t4 || (e4?.config.engineType === "library" ? "library" : e4?.config.engineType === "binary" ? "binary" : ps);
  }
  function hc() {
    let e4 = process.env.PRISMA_CLIENT_ENGINE_TYPE;
    return e4 === "library" ? "library" : e4 === "binary" ? "binary" : undefined;
  }
  var zt;
  ((t4) => {
    let e4;
    ((A4) => (A4.findUnique = "findUnique", A4.findUniqueOrThrow = "findUniqueOrThrow", A4.findFirst = "findFirst", A4.findFirstOrThrow = "findFirstOrThrow", A4.findMany = "findMany", A4.create = "create", A4.createMany = "createMany", A4.createManyAndReturn = "createManyAndReturn", A4.update = "update", A4.updateMany = "updateMany", A4.updateManyAndReturn = "updateManyAndReturn", A4.upsert = "upsert", A4.delete = "delete", A4.deleteMany = "deleteMany", A4.groupBy = "groupBy", A4.count = "count", A4.aggregate = "aggregate", A4.findRaw = "findRaw", A4.aggregateRaw = "aggregateRaw"))(e4 = t4.ModelAction ||= {});
  })(zt ||= {});
  var Zt = D3(__require("path"));
  function Ei(e4) {
    return Zt.default.sep === Zt.default.posix.sep ? e4 : e4.split(Zt.default.sep).join(Zt.default.posix.sep);
  }
  var ys = D3(bi2());
  function xi(e4) {
    return String(new wi(e4));
  }
  var wi = class {
    constructor(t4) {
      this.config = t4;
    }
    toString() {
      let { config: t4 } = this, r5 = t4.provider.fromEnvVar ? `env("${t4.provider.fromEnvVar}")` : t4.provider.value, n4 = JSON.parse(JSON.stringify({ provider: r5, binaryTargets: Ec(t4.binaryTargets) }));
      return `generator ${t4.name} {
${(0, ys.default)(bc2(n4), 2)}
}`;
    }
  };
  function Ec(e4) {
    let t4;
    if (e4.length > 0) {
      let r5 = e4.find((n4) => n4.fromEnvVar !== null);
      r5 ? t4 = `env("${r5.fromEnvVar}")` : t4 = e4.map((n4) => n4.native ? "native" : n4.value);
    } else
      t4 = undefined;
    return t4;
  }
  function bc2(e4) {
    let t4 = Object.keys(e4).reduce((r5, n4) => Math.max(r5, n4.length), 0);
    return Object.entries(e4).map(([r5, n4]) => `${r5.padEnd(t4)} = ${wc(n4)}`).join(`
`);
  }
  function wc(e4) {
    return JSON.parse(JSON.stringify(e4, (t4, r5) => Array.isArray(r5) ? `[${r5.map((n4) => JSON.stringify(n4)).join(", ")}]` : JSON.stringify(r5)));
  }
  var er = {};
  Bt(er, { error: () => Pc, info: () => vc, log: () => xc, query: () => Tc, should: () => Es, tags: () => Xt, warn: () => vi });
  var Xt = { error: de2("prisma:error"), warn: De("prisma:warn"), info: _e2("prisma:info"), query: rt("prisma:query") };
  var Es = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  function xc(...e4) {
    console.log(...e4);
  }
  function vi(e4, ...t4) {
    Es.warn() && console.warn(`${Xt.warn} ${e4}`, ...t4);
  }
  function vc(e4, ...t4) {
    console.info(`${Xt.info} ${e4}`, ...t4);
  }
  function Pc(e4, ...t4) {
    console.error(`${Xt.error} ${e4}`, ...t4);
  }
  function Tc(e4, ...t4) {
    console.log(`${Xt.query} ${e4}`, ...t4);
  }
  function Yr(e4, t4) {
    if (!e4)
      throw new Error(`${t4}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`);
  }
  function Fe(e4, t4) {
    throw new Error(t4);
  }
  function Ti(e4, t4) {
    return Object.prototype.hasOwnProperty.call(e4, t4);
  }
  var Ri = (e4, t4) => e4.reduce((r5, n4) => (r5[t4(n4)] = n4, r5), {});
  function ht(e4, t4) {
    let r5 = {};
    for (let n4 of Object.keys(e4))
      r5[n4] = t4(e4[n4], n4);
    return r5;
  }
  function Ci(e4, t4) {
    if (e4.length === 0)
      return;
    let r5 = e4[0];
    for (let n4 = 1;n4 < e4.length; n4++)
      t4(r5, e4[n4]) < 0 && (r5 = e4[n4]);
    return r5;
  }
  function w4(e4, t4) {
    Object.defineProperty(e4, "name", { value: t4, configurable: true });
  }
  var Ps = new Set;
  var tr = (e4, t4, ...r5) => {
    Ps.has(e4) || (Ps.add(e4), vi(t4, ...r5));
  };
  var T4 = class e4 extends Error {
    constructor(t4, r5, n4) {
      super(t4), this.name = "PrismaClientInitializationError", this.clientVersion = r5, this.errorCode = n4, Error.captureStackTrace(e4);
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientInitializationError";
    }
  };
  w4(T4, "PrismaClientInitializationError");
  var ee2 = class extends Error {
    constructor(t4, { code: r5, clientVersion: n4, meta: i4, batchRequestIdx: o3 }) {
      super(t4), this.name = "PrismaClientKnownRequestError", this.code = r5, this.clientVersion = n4, this.meta = i4, Object.defineProperty(this, "batchRequestIdx", { value: o3, enumerable: false, writable: true });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientKnownRequestError";
    }
  };
  w4(ee2, "PrismaClientKnownRequestError");
  var ce2 = class extends Error {
    constructor(t4, r5) {
      super(t4), this.name = "PrismaClientRustPanicError", this.clientVersion = r5;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientRustPanicError";
    }
  };
  w4(ce2, "PrismaClientRustPanicError");
  var B4 = class extends Error {
    constructor(t4, { clientVersion: r5, batchRequestIdx: n4 }) {
      super(t4), this.name = "PrismaClientUnknownRequestError", this.clientVersion = r5, Object.defineProperty(this, "batchRequestIdx", { value: n4, writable: true, enumerable: false });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientUnknownRequestError";
    }
  };
  w4(B4, "PrismaClientUnknownRequestError");
  var te = class extends Error {
    constructor(r5, { clientVersion: n4 }) {
      super(r5);
      this.name = "PrismaClientValidationError";
      this.clientVersion = n4;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientValidationError";
    }
  };
  w4(te, "PrismaClientValidationError");
  var yt = 9000000000000000;
  var Ye = 1e9;
  var Si = "0123456789abcdef";
  var en = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
  var tn = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
  var Ai = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -yt, maxE: yt, crypto: false };
  var Ss;
  var Me;
  var b3 = true;
  var nn = "[DecimalError] ";
  var Ke = nn + "Invalid argument: ";
  var As = nn + "Precision limit exceeded";
  var Is = nn + "crypto unavailable";
  var Os = "[object Decimal]";
  var re = Math.floor;
  var G4 = Math.pow;
  var Cc = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
  var Sc = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
  var Ac = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
  var ks = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  var he = 1e7;
  var E3 = 7;
  var Ic = 9007199254740991;
  var Oc = en.length - 1;
  var Ii = tn.length - 1;
  var m4 = { toStringTag: Os };
  m4.absoluteValue = m4.abs = function() {
    var e4 = new this.constructor(this);
    return e4.s < 0 && (e4.s = 1), y4(e4);
  };
  m4.ceil = function() {
    return y4(new this.constructor(this), this.e + 1, 2);
  };
  m4.clampedTo = m4.clamp = function(e4, t4) {
    var r5, n4 = this, i4 = n4.constructor;
    if (e4 = new i4(e4), t4 = new i4(t4), !e4.s || !t4.s)
      return new i4(NaN);
    if (e4.gt(t4))
      throw Error(Ke + t4);
    return r5 = n4.cmp(e4), r5 < 0 ? e4 : n4.cmp(t4) > 0 ? t4 : new i4(n4);
  };
  m4.comparedTo = m4.cmp = function(e4) {
    var t4, r5, n4, i4, o3 = this, s5 = o3.d, a5 = (e4 = new o3.constructor(e4)).d, l4 = o3.s, u5 = e4.s;
    if (!s5 || !a5)
      return !l4 || !u5 ? NaN : l4 !== u5 ? l4 : s5 === a5 ? 0 : !s5 ^ l4 < 0 ? 1 : -1;
    if (!s5[0] || !a5[0])
      return s5[0] ? l4 : a5[0] ? -u5 : 0;
    if (l4 !== u5)
      return l4;
    if (o3.e !== e4.e)
      return o3.e > e4.e ^ l4 < 0 ? 1 : -1;
    for (n4 = s5.length, i4 = a5.length, t4 = 0, r5 = n4 < i4 ? n4 : i4;t4 < r5; ++t4)
      if (s5[t4] !== a5[t4])
        return s5[t4] > a5[t4] ^ l4 < 0 ? 1 : -1;
    return n4 === i4 ? 0 : n4 > i4 ^ l4 < 0 ? 1 : -1;
  };
  m4.cosine = m4.cos = function() {
    var e4, t4, r5 = this, n4 = r5.constructor;
    return r5.d ? r5.d[0] ? (e4 = n4.precision, t4 = n4.rounding, n4.precision = e4 + Math.max(r5.e, r5.sd()) + E3, n4.rounding = 1, r5 = kc(n4, Fs(n4, r5)), n4.precision = e4, n4.rounding = t4, y4(Me == 2 || Me == 3 ? r5.neg() : r5, e4, t4, true)) : new n4(1) : new n4(NaN);
  };
  m4.cubeRoot = m4.cbrt = function() {
    var e4, t4, r5, n4, i4, o3, s5, a5, l4, u5, c5 = this, p5 = c5.constructor;
    if (!c5.isFinite() || c5.isZero())
      return new p5(c5);
    for (b3 = false, o3 = c5.s * G4(c5.s * c5, 1 / 3), !o3 || Math.abs(o3) == 1 / 0 ? (r5 = K2(c5.d), e4 = c5.e, (o3 = (e4 - r5.length + 1) % 3) && (r5 += o3 == 1 || o3 == -2 ? "0" : "00"), o3 = G4(r5, 1 / 3), e4 = re((e4 + 1) / 3) - (e4 % 3 == (e4 < 0 ? -1 : 2)), o3 == 1 / 0 ? r5 = "5e" + e4 : (r5 = o3.toExponential(), r5 = r5.slice(0, r5.indexOf("e") + 1) + e4), n4 = new p5(r5), n4.s = c5.s) : n4 = new p5(o3.toString()), s5 = (e4 = p5.precision) + 3;; )
      if (a5 = n4, l4 = a5.times(a5).times(a5), u5 = l4.plus(c5), n4 = M3(u5.plus(c5).times(a5), u5.plus(l4), s5 + 2, 1), K2(a5.d).slice(0, s5) === (r5 = K2(n4.d)).slice(0, s5))
        if (r5 = r5.slice(s5 - 3, s5 + 1), r5 == "9999" || !i4 && r5 == "4999") {
          if (!i4 && (y4(a5, e4 + 1, 0), a5.times(a5).times(a5).eq(c5))) {
            n4 = a5;
            break;
          }
          s5 += 4, i4 = 1;
        } else {
          (!+r5 || !+r5.slice(1) && r5.charAt(0) == "5") && (y4(n4, e4 + 1, 1), t4 = !n4.times(n4).times(n4).eq(c5));
          break;
        }
    return b3 = true, y4(n4, e4, p5.rounding, t4);
  };
  m4.decimalPlaces = m4.dp = function() {
    var e4, t4 = this.d, r5 = NaN;
    if (t4) {
      if (e4 = t4.length - 1, r5 = (e4 - re(this.e / E3)) * E3, e4 = t4[e4], e4)
        for (;e4 % 10 == 0; e4 /= 10)
          r5--;
      r5 < 0 && (r5 = 0);
    }
    return r5;
  };
  m4.dividedBy = m4.div = function(e4) {
    return M3(this, new this.constructor(e4));
  };
  m4.dividedToIntegerBy = m4.divToInt = function(e4) {
    var t4 = this, r5 = t4.constructor;
    return y4(M3(t4, new r5(e4), 0, 1, 1), r5.precision, r5.rounding);
  };
  m4.equals = m4.eq = function(e4) {
    return this.cmp(e4) === 0;
  };
  m4.floor = function() {
    return y4(new this.constructor(this), this.e + 1, 3);
  };
  m4.greaterThan = m4.gt = function(e4) {
    return this.cmp(e4) > 0;
  };
  m4.greaterThanOrEqualTo = m4.gte = function(e4) {
    var t4 = this.cmp(e4);
    return t4 == 1 || t4 === 0;
  };
  m4.hyperbolicCosine = m4.cosh = function() {
    var e4, t4, r5, n4, i4, o3 = this, s5 = o3.constructor, a5 = new s5(1);
    if (!o3.isFinite())
      return new s5(o3.s ? 1 / 0 : NaN);
    if (o3.isZero())
      return a5;
    r5 = s5.precision, n4 = s5.rounding, s5.precision = r5 + Math.max(o3.e, o3.sd()) + 4, s5.rounding = 1, i4 = o3.d.length, i4 < 32 ? (e4 = Math.ceil(i4 / 3), t4 = (1 / sn(4, e4)).toString()) : (e4 = 16, t4 = "2.3283064365386962890625e-10"), o3 = Et(s5, 1, o3.times(t4), new s5(1), true);
    for (var l4, u5 = e4, c5 = new s5(8);u5--; )
      l4 = o3.times(o3), o3 = a5.minus(l4.times(c5.minus(l4.times(c5))));
    return y4(o3, s5.precision = r5, s5.rounding = n4, true);
  };
  m4.hyperbolicSine = m4.sinh = function() {
    var e4, t4, r5, n4, i4 = this, o3 = i4.constructor;
    if (!i4.isFinite() || i4.isZero())
      return new o3(i4);
    if (t4 = o3.precision, r5 = o3.rounding, o3.precision = t4 + Math.max(i4.e, i4.sd()) + 4, o3.rounding = 1, n4 = i4.d.length, n4 < 3)
      i4 = Et(o3, 2, i4, i4, true);
    else {
      e4 = 1.4 * Math.sqrt(n4), e4 = e4 > 16 ? 16 : e4 | 0, i4 = i4.times(1 / sn(5, e4)), i4 = Et(o3, 2, i4, i4, true);
      for (var s5, a5 = new o3(5), l4 = new o3(16), u5 = new o3(20);e4--; )
        s5 = i4.times(i4), i4 = i4.times(a5.plus(s5.times(l4.times(s5).plus(u5))));
    }
    return o3.precision = t4, o3.rounding = r5, y4(i4, t4, r5, true);
  };
  m4.hyperbolicTangent = m4.tanh = function() {
    var e4, t4, r5 = this, n4 = r5.constructor;
    return r5.isFinite() ? r5.isZero() ? new n4(r5) : (e4 = n4.precision, t4 = n4.rounding, n4.precision = e4 + 7, n4.rounding = 1, M3(r5.sinh(), r5.cosh(), n4.precision = e4, n4.rounding = t4)) : new n4(r5.s);
  };
  m4.inverseCosine = m4.acos = function() {
    var e4, t4 = this, r5 = t4.constructor, n4 = t4.abs().cmp(1), i4 = r5.precision, o3 = r5.rounding;
    return n4 !== -1 ? n4 === 0 ? t4.isNeg() ? ge(r5, i4, o3) : new r5(0) : new r5(NaN) : t4.isZero() ? ge(r5, i4 + 4, o3).times(0.5) : (r5.precision = i4 + 6, r5.rounding = 1, t4 = t4.asin(), e4 = ge(r5, i4 + 4, o3).times(0.5), r5.precision = i4, r5.rounding = o3, e4.minus(t4));
  };
  m4.inverseHyperbolicCosine = m4.acosh = function() {
    var e4, t4, r5 = this, n4 = r5.constructor;
    return r5.lte(1) ? new n4(r5.eq(1) ? 0 : NaN) : r5.isFinite() ? (e4 = n4.precision, t4 = n4.rounding, n4.precision = e4 + Math.max(Math.abs(r5.e), r5.sd()) + 4, n4.rounding = 1, b3 = false, r5 = r5.times(r5).minus(1).sqrt().plus(r5), b3 = true, n4.precision = e4, n4.rounding = t4, r5.ln()) : new n4(r5);
  };
  m4.inverseHyperbolicSine = m4.asinh = function() {
    var e4, t4, r5 = this, n4 = r5.constructor;
    return !r5.isFinite() || r5.isZero() ? new n4(r5) : (e4 = n4.precision, t4 = n4.rounding, n4.precision = e4 + 2 * Math.max(Math.abs(r5.e), r5.sd()) + 6, n4.rounding = 1, b3 = false, r5 = r5.times(r5).plus(1).sqrt().plus(r5), b3 = true, n4.precision = e4, n4.rounding = t4, r5.ln());
  };
  m4.inverseHyperbolicTangent = m4.atanh = function() {
    var e4, t4, r5, n4, i4 = this, o3 = i4.constructor;
    return i4.isFinite() ? i4.e >= 0 ? new o3(i4.abs().eq(1) ? i4.s / 0 : i4.isZero() ? i4 : NaN) : (e4 = o3.precision, t4 = o3.rounding, n4 = i4.sd(), Math.max(n4, e4) < 2 * -i4.e - 1 ? y4(new o3(i4), e4, t4, true) : (o3.precision = r5 = n4 - i4.e, i4 = M3(i4.plus(1), new o3(1).minus(i4), r5 + e4, 1), o3.precision = e4 + 4, o3.rounding = 1, i4 = i4.ln(), o3.precision = e4, o3.rounding = t4, i4.times(0.5))) : new o3(NaN);
  };
  m4.inverseSine = m4.asin = function() {
    var e4, t4, r5, n4, i4 = this, o3 = i4.constructor;
    return i4.isZero() ? new o3(i4) : (t4 = i4.abs().cmp(1), r5 = o3.precision, n4 = o3.rounding, t4 !== -1 ? t4 === 0 ? (e4 = ge(o3, r5 + 4, n4).times(0.5), e4.s = i4.s, e4) : new o3(NaN) : (o3.precision = r5 + 6, o3.rounding = 1, i4 = i4.div(new o3(1).minus(i4.times(i4)).sqrt().plus(1)).atan(), o3.precision = r5, o3.rounding = n4, i4.times(2)));
  };
  m4.inverseTangent = m4.atan = function() {
    var e4, t4, r5, n4, i4, o3, s5, a5, l4, u5 = this, c5 = u5.constructor, p5 = c5.precision, d4 = c5.rounding;
    if (u5.isFinite()) {
      if (u5.isZero())
        return new c5(u5);
      if (u5.abs().eq(1) && p5 + 4 <= Ii)
        return s5 = ge(c5, p5 + 4, d4).times(0.25), s5.s = u5.s, s5;
    } else {
      if (!u5.s)
        return new c5(NaN);
      if (p5 + 4 <= Ii)
        return s5 = ge(c5, p5 + 4, d4).times(0.5), s5.s = u5.s, s5;
    }
    for (c5.precision = a5 = p5 + 10, c5.rounding = 1, r5 = Math.min(28, a5 / E3 + 2 | 0), e4 = r5;e4; --e4)
      u5 = u5.div(u5.times(u5).plus(1).sqrt().plus(1));
    for (b3 = false, t4 = Math.ceil(a5 / E3), n4 = 1, l4 = u5.times(u5), s5 = new c5(u5), i4 = u5;e4 !== -1; )
      if (i4 = i4.times(l4), o3 = s5.minus(i4.div(n4 += 2)), i4 = i4.times(l4), s5 = o3.plus(i4.div(n4 += 2)), s5.d[t4] !== undefined)
        for (e4 = t4;s5.d[e4] === o3.d[e4] && e4--; )
          ;
    return r5 && (s5 = s5.times(2 << r5 - 1)), b3 = true, y4(s5, c5.precision = p5, c5.rounding = d4, true);
  };
  m4.isFinite = function() {
    return !!this.d;
  };
  m4.isInteger = m4.isInt = function() {
    return !!this.d && re(this.e / E3) > this.d.length - 2;
  };
  m4.isNaN = function() {
    return !this.s;
  };
  m4.isNegative = m4.isNeg = function() {
    return this.s < 0;
  };
  m4.isPositive = m4.isPos = function() {
    return this.s > 0;
  };
  m4.isZero = function() {
    return !!this.d && this.d[0] === 0;
  };
  m4.lessThan = m4.lt = function(e4) {
    return this.cmp(e4) < 0;
  };
  m4.lessThanOrEqualTo = m4.lte = function(e4) {
    return this.cmp(e4) < 1;
  };
  m4.logarithm = m4.log = function(e4) {
    var t4, r5, n4, i4, o3, s5, a5, l4, u5 = this, c5 = u5.constructor, p5 = c5.precision, d4 = c5.rounding, f4 = 5;
    if (e4 == null)
      e4 = new c5(10), t4 = true;
    else {
      if (e4 = new c5(e4), r5 = e4.d, e4.s < 0 || !r5 || !r5[0] || e4.eq(1))
        return new c5(NaN);
      t4 = e4.eq(10);
    }
    if (r5 = u5.d, u5.s < 0 || !r5 || !r5[0] || u5.eq(1))
      return new c5(r5 && !r5[0] ? -1 / 0 : u5.s != 1 ? NaN : r5 ? 0 : 1 / 0);
    if (t4)
      if (r5.length > 1)
        o3 = true;
      else {
        for (i4 = r5[0];i4 % 10 === 0; )
          i4 /= 10;
        o3 = i4 !== 1;
      }
    if (b3 = false, a5 = p5 + f4, s5 = We(u5, a5), n4 = t4 ? rn(c5, a5 + 10) : We(e4, a5), l4 = M3(s5, n4, a5, 1), rr(l4.d, i4 = p5, d4))
      do
        if (a5 += 10, s5 = We(u5, a5), n4 = t4 ? rn(c5, a5 + 10) : We(e4, a5), l4 = M3(s5, n4, a5, 1), !o3) {
          +K2(l4.d).slice(i4 + 1, i4 + 15) + 1 == 100000000000000 && (l4 = y4(l4, p5 + 1, 0));
          break;
        }
      while (rr(l4.d, i4 += 10, d4));
    return b3 = true, y4(l4, p5, d4);
  };
  m4.minus = m4.sub = function(e4) {
    var t4, r5, n4, i4, o3, s5, a5, l4, u5, c5, p5, d4, f4 = this, g3 = f4.constructor;
    if (e4 = new g3(e4), !f4.d || !e4.d)
      return !f4.s || !e4.s ? e4 = new g3(NaN) : f4.d ? e4.s = -e4.s : e4 = new g3(e4.d || f4.s !== e4.s ? f4 : NaN), e4;
    if (f4.s != e4.s)
      return e4.s = -e4.s, f4.plus(e4);
    if (u5 = f4.d, d4 = e4.d, a5 = g3.precision, l4 = g3.rounding, !u5[0] || !d4[0]) {
      if (d4[0])
        e4.s = -e4.s;
      else if (u5[0])
        e4 = new g3(f4);
      else
        return new g3(l4 === 3 ? -0 : 0);
      return b3 ? y4(e4, a5, l4) : e4;
    }
    if (r5 = re(e4.e / E3), c5 = re(f4.e / E3), u5 = u5.slice(), o3 = c5 - r5, o3) {
      for (p5 = o3 < 0, p5 ? (t4 = u5, o3 = -o3, s5 = d4.length) : (t4 = d4, r5 = c5, s5 = u5.length), n4 = Math.max(Math.ceil(a5 / E3), s5) + 2, o3 > n4 && (o3 = n4, t4.length = 1), t4.reverse(), n4 = o3;n4--; )
        t4.push(0);
      t4.reverse();
    } else {
      for (n4 = u5.length, s5 = d4.length, p5 = n4 < s5, p5 && (s5 = n4), n4 = 0;n4 < s5; n4++)
        if (u5[n4] != d4[n4]) {
          p5 = u5[n4] < d4[n4];
          break;
        }
      o3 = 0;
    }
    for (p5 && (t4 = u5, u5 = d4, d4 = t4, e4.s = -e4.s), s5 = u5.length, n4 = d4.length - s5;n4 > 0; --n4)
      u5[s5++] = 0;
    for (n4 = d4.length;n4 > o3; ) {
      if (u5[--n4] < d4[n4]) {
        for (i4 = n4;i4 && u5[--i4] === 0; )
          u5[i4] = he - 1;
        --u5[i4], u5[n4] += he;
      }
      u5[n4] -= d4[n4];
    }
    for (;u5[--s5] === 0; )
      u5.pop();
    for (;u5[0] === 0; u5.shift())
      --r5;
    return u5[0] ? (e4.d = u5, e4.e = on(u5, r5), b3 ? y4(e4, a5, l4) : e4) : new g3(l4 === 3 ? -0 : 0);
  };
  m4.modulo = m4.mod = function(e4) {
    var t4, r5 = this, n4 = r5.constructor;
    return e4 = new n4(e4), !r5.d || !e4.s || e4.d && !e4.d[0] ? new n4(NaN) : !e4.d || r5.d && !r5.d[0] ? y4(new n4(r5), n4.precision, n4.rounding) : (b3 = false, n4.modulo == 9 ? (t4 = M3(r5, e4.abs(), 0, 3, 1), t4.s *= e4.s) : t4 = M3(r5, e4, 0, n4.modulo, 1), t4 = t4.times(e4), b3 = true, r5.minus(t4));
  };
  m4.naturalExponential = m4.exp = function() {
    return Oi(this);
  };
  m4.naturalLogarithm = m4.ln = function() {
    return We(this);
  };
  m4.negated = m4.neg = function() {
    var e4 = new this.constructor(this);
    return e4.s = -e4.s, y4(e4);
  };
  m4.plus = m4.add = function(e4) {
    var t4, r5, n4, i4, o3, s5, a5, l4, u5, c5, p5 = this, d4 = p5.constructor;
    if (e4 = new d4(e4), !p5.d || !e4.d)
      return !p5.s || !e4.s ? e4 = new d4(NaN) : p5.d || (e4 = new d4(e4.d || p5.s === e4.s ? p5 : NaN)), e4;
    if (p5.s != e4.s)
      return e4.s = -e4.s, p5.minus(e4);
    if (u5 = p5.d, c5 = e4.d, a5 = d4.precision, l4 = d4.rounding, !u5[0] || !c5[0])
      return c5[0] || (e4 = new d4(p5)), b3 ? y4(e4, a5, l4) : e4;
    if (o3 = re(p5.e / E3), n4 = re(e4.e / E3), u5 = u5.slice(), i4 = o3 - n4, i4) {
      for (i4 < 0 ? (r5 = u5, i4 = -i4, s5 = c5.length) : (r5 = c5, n4 = o3, s5 = u5.length), o3 = Math.ceil(a5 / E3), s5 = o3 > s5 ? o3 + 1 : s5 + 1, i4 > s5 && (i4 = s5, r5.length = 1), r5.reverse();i4--; )
        r5.push(0);
      r5.reverse();
    }
    for (s5 = u5.length, i4 = c5.length, s5 - i4 < 0 && (i4 = s5, r5 = c5, c5 = u5, u5 = r5), t4 = 0;i4; )
      t4 = (u5[--i4] = u5[i4] + c5[i4] + t4) / he | 0, u5[i4] %= he;
    for (t4 && (u5.unshift(t4), ++n4), s5 = u5.length;u5[--s5] == 0; )
      u5.pop();
    return e4.d = u5, e4.e = on(u5, n4), b3 ? y4(e4, a5, l4) : e4;
  };
  m4.precision = m4.sd = function(e4) {
    var t4, r5 = this;
    if (e4 !== undefined && e4 !== !!e4 && e4 !== 1 && e4 !== 0)
      throw Error(Ke + e4);
    return r5.d ? (t4 = Ds(r5.d), e4 && r5.e + 1 > t4 && (t4 = r5.e + 1)) : t4 = NaN, t4;
  };
  m4.round = function() {
    var e4 = this, t4 = e4.constructor;
    return y4(new t4(e4), e4.e + 1, t4.rounding);
  };
  m4.sine = m4.sin = function() {
    var e4, t4, r5 = this, n4 = r5.constructor;
    return r5.isFinite() ? r5.isZero() ? new n4(r5) : (e4 = n4.precision, t4 = n4.rounding, n4.precision = e4 + Math.max(r5.e, r5.sd()) + E3, n4.rounding = 1, r5 = _c2(n4, Fs(n4, r5)), n4.precision = e4, n4.rounding = t4, y4(Me > 2 ? r5.neg() : r5, e4, t4, true)) : new n4(NaN);
  };
  m4.squareRoot = m4.sqrt = function() {
    var e4, t4, r5, n4, i4, o3, s5 = this, a5 = s5.d, l4 = s5.e, u5 = s5.s, c5 = s5.constructor;
    if (u5 !== 1 || !a5 || !a5[0])
      return new c5(!u5 || u5 < 0 && (!a5 || a5[0]) ? NaN : a5 ? s5 : 1 / 0);
    for (b3 = false, u5 = Math.sqrt(+s5), u5 == 0 || u5 == 1 / 0 ? (t4 = K2(a5), (t4.length + l4) % 2 == 0 && (t4 += "0"), u5 = Math.sqrt(t4), l4 = re((l4 + 1) / 2) - (l4 < 0 || l4 % 2), u5 == 1 / 0 ? t4 = "5e" + l4 : (t4 = u5.toExponential(), t4 = t4.slice(0, t4.indexOf("e") + 1) + l4), n4 = new c5(t4)) : n4 = new c5(u5.toString()), r5 = (l4 = c5.precision) + 3;; )
      if (o3 = n4, n4 = o3.plus(M3(s5, o3, r5 + 2, 1)).times(0.5), K2(o3.d).slice(0, r5) === (t4 = K2(n4.d)).slice(0, r5))
        if (t4 = t4.slice(r5 - 3, r5 + 1), t4 == "9999" || !i4 && t4 == "4999") {
          if (!i4 && (y4(o3, l4 + 1, 0), o3.times(o3).eq(s5))) {
            n4 = o3;
            break;
          }
          r5 += 4, i4 = 1;
        } else {
          (!+t4 || !+t4.slice(1) && t4.charAt(0) == "5") && (y4(n4, l4 + 1, 1), e4 = !n4.times(n4).eq(s5));
          break;
        }
    return b3 = true, y4(n4, l4, c5.rounding, e4);
  };
  m4.tangent = m4.tan = function() {
    var e4, t4, r5 = this, n4 = r5.constructor;
    return r5.isFinite() ? r5.isZero() ? new n4(r5) : (e4 = n4.precision, t4 = n4.rounding, n4.precision = e4 + 10, n4.rounding = 1, r5 = r5.sin(), r5.s = 1, r5 = M3(r5, new n4(1).minus(r5.times(r5)).sqrt(), e4 + 10, 0), n4.precision = e4, n4.rounding = t4, y4(Me == 2 || Me == 4 ? r5.neg() : r5, e4, t4, true)) : new n4(NaN);
  };
  m4.times = m4.mul = function(e4) {
    var t4, r5, n4, i4, o3, s5, a5, l4, u5, c5 = this, p5 = c5.constructor, d4 = c5.d, f4 = (e4 = new p5(e4)).d;
    if (e4.s *= c5.s, !d4 || !d4[0] || !f4 || !f4[0])
      return new p5(!e4.s || d4 && !d4[0] && !f4 || f4 && !f4[0] && !d4 ? NaN : !d4 || !f4 ? e4.s / 0 : e4.s * 0);
    for (r5 = re(c5.e / E3) + re(e4.e / E3), l4 = d4.length, u5 = f4.length, l4 < u5 && (o3 = d4, d4 = f4, f4 = o3, s5 = l4, l4 = u5, u5 = s5), o3 = [], s5 = l4 + u5, n4 = s5;n4--; )
      o3.push(0);
    for (n4 = u5;--n4 >= 0; ) {
      for (t4 = 0, i4 = l4 + n4;i4 > n4; )
        a5 = o3[i4] + f4[n4] * d4[i4 - n4 - 1] + t4, o3[i4--] = a5 % he | 0, t4 = a5 / he | 0;
      o3[i4] = (o3[i4] + t4) % he | 0;
    }
    for (;!o3[--s5]; )
      o3.pop();
    return t4 ? ++r5 : o3.shift(), e4.d = o3, e4.e = on(o3, r5), b3 ? y4(e4, p5.precision, p5.rounding) : e4;
  };
  m4.toBinary = function(e4, t4) {
    return Di(this, 2, e4, t4);
  };
  m4.toDecimalPlaces = m4.toDP = function(e4, t4) {
    var r5 = this, n4 = r5.constructor;
    return r5 = new n4(r5), e4 === undefined ? r5 : (se(e4, 0, Ye), t4 === undefined ? t4 = n4.rounding : se(t4, 0, 8), y4(r5, e4 + r5.e + 1, t4));
  };
  m4.toExponential = function(e4, t4) {
    var r5, n4 = this, i4 = n4.constructor;
    return e4 === undefined ? r5 = xe(n4, true) : (se(e4, 0, Ye), t4 === undefined ? t4 = i4.rounding : se(t4, 0, 8), n4 = y4(new i4(n4), e4 + 1, t4), r5 = xe(n4, true, e4 + 1)), n4.isNeg() && !n4.isZero() ? "-" + r5 : r5;
  };
  m4.toFixed = function(e4, t4) {
    var r5, n4, i4 = this, o3 = i4.constructor;
    return e4 === undefined ? r5 = xe(i4) : (se(e4, 0, Ye), t4 === undefined ? t4 = o3.rounding : se(t4, 0, 8), n4 = y4(new o3(i4), e4 + i4.e + 1, t4), r5 = xe(n4, false, e4 + n4.e + 1)), i4.isNeg() && !i4.isZero() ? "-" + r5 : r5;
  };
  m4.toFraction = function(e4) {
    var t4, r5, n4, i4, o3, s5, a5, l4, u5, c5, p5, d4, f4 = this, g3 = f4.d, h4 = f4.constructor;
    if (!g3)
      return new h4(f4);
    if (u5 = r5 = new h4(1), n4 = l4 = new h4(0), t4 = new h4(n4), o3 = t4.e = Ds(g3) - f4.e - 1, s5 = o3 % E3, t4.d[0] = G4(10, s5 < 0 ? E3 + s5 : s5), e4 == null)
      e4 = o3 > 0 ? t4 : u5;
    else {
      if (a5 = new h4(e4), !a5.isInt() || a5.lt(u5))
        throw Error(Ke + a5);
      e4 = a5.gt(t4) ? o3 > 0 ? t4 : u5 : a5;
    }
    for (b3 = false, a5 = new h4(K2(g3)), c5 = h4.precision, h4.precision = o3 = g3.length * E3 * 2;p5 = M3(a5, t4, 0, 1, 1), i4 = r5.plus(p5.times(n4)), i4.cmp(e4) != 1; )
      r5 = n4, n4 = i4, i4 = u5, u5 = l4.plus(p5.times(i4)), l4 = i4, i4 = t4, t4 = a5.minus(p5.times(i4)), a5 = i4;
    return i4 = M3(e4.minus(r5), n4, 0, 1, 1), l4 = l4.plus(i4.times(u5)), r5 = r5.plus(i4.times(n4)), l4.s = u5.s = f4.s, d4 = M3(u5, n4, o3, 1).minus(f4).abs().cmp(M3(l4, r5, o3, 1).minus(f4).abs()) < 1 ? [u5, n4] : [l4, r5], h4.precision = c5, b3 = true, d4;
  };
  m4.toHexadecimal = m4.toHex = function(e4, t4) {
    return Di(this, 16, e4, t4);
  };
  m4.toNearest = function(e4, t4) {
    var r5 = this, n4 = r5.constructor;
    if (r5 = new n4(r5), e4 == null) {
      if (!r5.d)
        return r5;
      e4 = new n4(1), t4 = n4.rounding;
    } else {
      if (e4 = new n4(e4), t4 === undefined ? t4 = n4.rounding : se(t4, 0, 8), !r5.d)
        return e4.s ? r5 : e4;
      if (!e4.d)
        return e4.s && (e4.s = r5.s), e4;
    }
    return e4.d[0] ? (b3 = false, r5 = M3(r5, e4, 0, t4, 1).times(e4), b3 = true, y4(r5)) : (e4.s = r5.s, r5 = e4), r5;
  };
  m4.toNumber = function() {
    return +this;
  };
  m4.toOctal = function(e4, t4) {
    return Di(this, 8, e4, t4);
  };
  m4.toPower = m4.pow = function(e4) {
    var t4, r5, n4, i4, o3, s5, a5 = this, l4 = a5.constructor, u5 = +(e4 = new l4(e4));
    if (!a5.d || !e4.d || !a5.d[0] || !e4.d[0])
      return new l4(G4(+a5, u5));
    if (a5 = new l4(a5), a5.eq(1))
      return a5;
    if (n4 = l4.precision, o3 = l4.rounding, e4.eq(1))
      return y4(a5, n4, o3);
    if (t4 = re(e4.e / E3), t4 >= e4.d.length - 1 && (r5 = u5 < 0 ? -u5 : u5) <= Ic)
      return i4 = _s2(l4, a5, r5, n4), e4.s < 0 ? new l4(1).div(i4) : y4(i4, n4, o3);
    if (s5 = a5.s, s5 < 0) {
      if (t4 < e4.d.length - 1)
        return new l4(NaN);
      if (e4.d[t4] & 1 || (s5 = 1), a5.e == 0 && a5.d[0] == 1 && a5.d.length == 1)
        return a5.s = s5, a5;
    }
    return r5 = G4(+a5, u5), t4 = r5 == 0 || !isFinite(r5) ? re(u5 * (Math.log("0." + K2(a5.d)) / Math.LN10 + a5.e + 1)) : new l4(r5 + "").e, t4 > l4.maxE + 1 || t4 < l4.minE - 1 ? new l4(t4 > 0 ? s5 / 0 : 0) : (b3 = false, l4.rounding = a5.s = 1, r5 = Math.min(12, (t4 + "").length), i4 = Oi(e4.times(We(a5, n4 + r5)), n4), i4.d && (i4 = y4(i4, n4 + 5, 1), rr(i4.d, n4, o3) && (t4 = n4 + 10, i4 = y4(Oi(e4.times(We(a5, t4 + r5)), t4), t4 + 5, 1), +K2(i4.d).slice(n4 + 1, n4 + 15) + 1 == 100000000000000 && (i4 = y4(i4, n4 + 1, 0)))), i4.s = s5, b3 = true, l4.rounding = o3, y4(i4, n4, o3));
  };
  m4.toPrecision = function(e4, t4) {
    var r5, n4 = this, i4 = n4.constructor;
    return e4 === undefined ? r5 = xe(n4, n4.e <= i4.toExpNeg || n4.e >= i4.toExpPos) : (se(e4, 1, Ye), t4 === undefined ? t4 = i4.rounding : se(t4, 0, 8), n4 = y4(new i4(n4), e4, t4), r5 = xe(n4, e4 <= n4.e || n4.e <= i4.toExpNeg, e4)), n4.isNeg() && !n4.isZero() ? "-" + r5 : r5;
  };
  m4.toSignificantDigits = m4.toSD = function(e4, t4) {
    var r5 = this, n4 = r5.constructor;
    return e4 === undefined ? (e4 = n4.precision, t4 = n4.rounding) : (se(e4, 1, Ye), t4 === undefined ? t4 = n4.rounding : se(t4, 0, 8)), y4(new n4(r5), e4, t4);
  };
  m4.toString = function() {
    var e4 = this, t4 = e4.constructor, r5 = xe(e4, e4.e <= t4.toExpNeg || e4.e >= t4.toExpPos);
    return e4.isNeg() && !e4.isZero() ? "-" + r5 : r5;
  };
  m4.truncated = m4.trunc = function() {
    return y4(new this.constructor(this), this.e + 1, 1);
  };
  m4.valueOf = m4.toJSON = function() {
    var e4 = this, t4 = e4.constructor, r5 = xe(e4, e4.e <= t4.toExpNeg || e4.e >= t4.toExpPos);
    return e4.isNeg() ? "-" + r5 : r5;
  };
  function K2(e4) {
    var t4, r5, n4, i4 = e4.length - 1, o3 = "", s5 = e4[0];
    if (i4 > 0) {
      for (o3 += s5, t4 = 1;t4 < i4; t4++)
        n4 = e4[t4] + "", r5 = E3 - n4.length, r5 && (o3 += He(r5)), o3 += n4;
      s5 = e4[t4], n4 = s5 + "", r5 = E3 - n4.length, r5 && (o3 += He(r5));
    } else if (s5 === 0)
      return "0";
    for (;s5 % 10 === 0; )
      s5 /= 10;
    return o3 + s5;
  }
  function se(e4, t4, r5) {
    if (e4 !== ~~e4 || e4 < t4 || e4 > r5)
      throw Error(Ke + e4);
  }
  function rr(e4, t4, r5, n4) {
    var i4, o3, s5, a5;
    for (o3 = e4[0];o3 >= 10; o3 /= 10)
      --t4;
    return --t4 < 0 ? (t4 += E3, i4 = 0) : (i4 = Math.ceil((t4 + 1) / E3), t4 %= E3), o3 = G4(10, E3 - t4), a5 = e4[i4] % o3 | 0, n4 == null ? t4 < 3 ? (t4 == 0 ? a5 = a5 / 100 | 0 : t4 == 1 && (a5 = a5 / 10 | 0), s5 = r5 < 4 && a5 == 99999 || r5 > 3 && a5 == 49999 || a5 == 50000 || a5 == 0) : s5 = (r5 < 4 && a5 + 1 == o3 || r5 > 3 && a5 + 1 == o3 / 2) && (e4[i4 + 1] / o3 / 100 | 0) == G4(10, t4 - 2) - 1 || (a5 == o3 / 2 || a5 == 0) && (e4[i4 + 1] / o3 / 100 | 0) == 0 : t4 < 4 ? (t4 == 0 ? a5 = a5 / 1000 | 0 : t4 == 1 ? a5 = a5 / 100 | 0 : t4 == 2 && (a5 = a5 / 10 | 0), s5 = (n4 || r5 < 4) && a5 == 9999 || !n4 && r5 > 3 && a5 == 4999) : s5 = ((n4 || r5 < 4) && a5 + 1 == o3 || !n4 && r5 > 3 && a5 + 1 == o3 / 2) && (e4[i4 + 1] / o3 / 1000 | 0) == G4(10, t4 - 3) - 1, s5;
  }
  function Xr(e4, t4, r5) {
    for (var n4, i4 = [0], o3, s5 = 0, a5 = e4.length;s5 < a5; ) {
      for (o3 = i4.length;o3--; )
        i4[o3] *= t4;
      for (i4[0] += Si.indexOf(e4.charAt(s5++)), n4 = 0;n4 < i4.length; n4++)
        i4[n4] > r5 - 1 && (i4[n4 + 1] === undefined && (i4[n4 + 1] = 0), i4[n4 + 1] += i4[n4] / r5 | 0, i4[n4] %= r5);
    }
    return i4.reverse();
  }
  function kc(e4, t4) {
    var r5, n4, i4;
    if (t4.isZero())
      return t4;
    n4 = t4.d.length, n4 < 32 ? (r5 = Math.ceil(n4 / 3), i4 = (1 / sn(4, r5)).toString()) : (r5 = 16, i4 = "2.3283064365386962890625e-10"), e4.precision += r5, t4 = Et(e4, 1, t4.times(i4), new e4(1));
    for (var o3 = r5;o3--; ) {
      var s5 = t4.times(t4);
      t4 = s5.times(s5).minus(s5).times(8).plus(1);
    }
    return e4.precision -= r5, t4;
  }
  var M3 = function() {
    function e4(n4, i4, o3) {
      var s5, a5 = 0, l4 = n4.length;
      for (n4 = n4.slice();l4--; )
        s5 = n4[l4] * i4 + a5, n4[l4] = s5 % o3 | 0, a5 = s5 / o3 | 0;
      return a5 && n4.unshift(a5), n4;
    }
    function t4(n4, i4, o3, s5) {
      var a5, l4;
      if (o3 != s5)
        l4 = o3 > s5 ? 1 : -1;
      else
        for (a5 = l4 = 0;a5 < o3; a5++)
          if (n4[a5] != i4[a5]) {
            l4 = n4[a5] > i4[a5] ? 1 : -1;
            break;
          }
      return l4;
    }
    function r5(n4, i4, o3, s5) {
      for (var a5 = 0;o3--; )
        n4[o3] -= a5, a5 = n4[o3] < i4[o3] ? 1 : 0, n4[o3] = a5 * s5 + n4[o3] - i4[o3];
      for (;!n4[0] && n4.length > 1; )
        n4.shift();
    }
    return function(n4, i4, o3, s5, a5, l4) {
      var u5, c5, p5, d4, f4, g3, h4, O4, P4, C3, R4, k4, A4, ue2, jt, U3, oe, Oe, Y3, pt, Lr = n4.constructor, jn = n4.s == i4.s ? 1 : -1, z3 = n4.d, N4 = i4.d;
      if (!z3 || !z3[0] || !N4 || !N4[0])
        return new Lr(!n4.s || !i4.s || (z3 ? N4 && z3[0] == N4[0] : !N4) ? NaN : z3 && z3[0] == 0 || !N4 ? jn * 0 : jn / 0);
      for (l4 ? (f4 = 1, c5 = n4.e - i4.e) : (l4 = he, f4 = E3, c5 = re(n4.e / f4) - re(i4.e / f4)), Y3 = N4.length, oe = z3.length, P4 = new Lr(jn), C3 = P4.d = [], p5 = 0;N4[p5] == (z3[p5] || 0); p5++)
        ;
      if (N4[p5] > (z3[p5] || 0) && c5--, o3 == null ? (ue2 = o3 = Lr.precision, s5 = Lr.rounding) : a5 ? ue2 = o3 + (n4.e - i4.e) + 1 : ue2 = o3, ue2 < 0)
        C3.push(1), g3 = true;
      else {
        if (ue2 = ue2 / f4 + 2 | 0, p5 = 0, Y3 == 1) {
          for (d4 = 0, N4 = N4[0], ue2++;(p5 < oe || d4) && ue2--; p5++)
            jt = d4 * l4 + (z3[p5] || 0), C3[p5] = jt / N4 | 0, d4 = jt % N4 | 0;
          g3 = d4 || p5 < oe;
        } else {
          for (d4 = l4 / (N4[0] + 1) | 0, d4 > 1 && (N4 = e4(N4, d4, l4), z3 = e4(z3, d4, l4), Y3 = N4.length, oe = z3.length), U3 = Y3, R4 = z3.slice(0, Y3), k4 = R4.length;k4 < Y3; )
            R4[k4++] = 0;
          pt = N4.slice(), pt.unshift(0), Oe = N4[0], N4[1] >= l4 / 2 && ++Oe;
          do
            d4 = 0, u5 = t4(N4, R4, Y3, k4), u5 < 0 ? (A4 = R4[0], Y3 != k4 && (A4 = A4 * l4 + (R4[1] || 0)), d4 = A4 / Oe | 0, d4 > 1 ? (d4 >= l4 && (d4 = l4 - 1), h4 = e4(N4, d4, l4), O4 = h4.length, k4 = R4.length, u5 = t4(h4, R4, O4, k4), u5 == 1 && (d4--, r5(h4, Y3 < O4 ? pt : N4, O4, l4))) : (d4 == 0 && (u5 = d4 = 1), h4 = N4.slice()), O4 = h4.length, O4 < k4 && h4.unshift(0), r5(R4, h4, k4, l4), u5 == -1 && (k4 = R4.length, u5 = t4(N4, R4, Y3, k4), u5 < 1 && (d4++, r5(R4, Y3 < k4 ? pt : N4, k4, l4))), k4 = R4.length) : u5 === 0 && (d4++, R4 = [0]), C3[p5++] = d4, u5 && R4[0] ? R4[k4++] = z3[U3] || 0 : (R4 = [z3[U3]], k4 = 1);
          while ((U3++ < oe || R4[0] !== undefined) && ue2--);
          g3 = R4[0] !== undefined;
        }
        C3[0] || C3.shift();
      }
      if (f4 == 1)
        P4.e = c5, Ss = g3;
      else {
        for (p5 = 1, d4 = C3[0];d4 >= 10; d4 /= 10)
          p5++;
        P4.e = p5 + c5 * f4 - 1, y4(P4, a5 ? o3 + P4.e + 1 : o3, s5, g3);
      }
      return P4;
    };
  }();
  function y4(e4, t4, r5, n4) {
    var i4, o3, s5, a5, l4, u5, c5, p5, d4, f4 = e4.constructor;
    e:
      if (t4 != null) {
        if (p5 = e4.d, !p5)
          return e4;
        for (i4 = 1, a5 = p5[0];a5 >= 10; a5 /= 10)
          i4++;
        if (o3 = t4 - i4, o3 < 0)
          o3 += E3, s5 = t4, c5 = p5[d4 = 0], l4 = c5 / G4(10, i4 - s5 - 1) % 10 | 0;
        else if (d4 = Math.ceil((o3 + 1) / E3), a5 = p5.length, d4 >= a5)
          if (n4) {
            for (;a5++ <= d4; )
              p5.push(0);
            c5 = l4 = 0, i4 = 1, o3 %= E3, s5 = o3 - E3 + 1;
          } else
            break e;
        else {
          for (c5 = a5 = p5[d4], i4 = 1;a5 >= 10; a5 /= 10)
            i4++;
          o3 %= E3, s5 = o3 - E3 + i4, l4 = s5 < 0 ? 0 : c5 / G4(10, i4 - s5 - 1) % 10 | 0;
        }
        if (n4 = n4 || t4 < 0 || p5[d4 + 1] !== undefined || (s5 < 0 ? c5 : c5 % G4(10, i4 - s5 - 1)), u5 = r5 < 4 ? (l4 || n4) && (r5 == 0 || r5 == (e4.s < 0 ? 3 : 2)) : l4 > 5 || l4 == 5 && (r5 == 4 || n4 || r5 == 6 && (o3 > 0 ? s5 > 0 ? c5 / G4(10, i4 - s5) : 0 : p5[d4 - 1]) % 10 & 1 || r5 == (e4.s < 0 ? 8 : 7)), t4 < 1 || !p5[0])
          return p5.length = 0, u5 ? (t4 -= e4.e + 1, p5[0] = G4(10, (E3 - t4 % E3) % E3), e4.e = -t4 || 0) : p5[0] = e4.e = 0, e4;
        if (o3 == 0 ? (p5.length = d4, a5 = 1, d4--) : (p5.length = d4 + 1, a5 = G4(10, E3 - o3), p5[d4] = s5 > 0 ? (c5 / G4(10, i4 - s5) % G4(10, s5) | 0) * a5 : 0), u5)
          for (;; )
            if (d4 == 0) {
              for (o3 = 1, s5 = p5[0];s5 >= 10; s5 /= 10)
                o3++;
              for (s5 = p5[0] += a5, a5 = 1;s5 >= 10; s5 /= 10)
                a5++;
              o3 != a5 && (e4.e++, p5[0] == he && (p5[0] = 1));
              break;
            } else {
              if (p5[d4] += a5, p5[d4] != he)
                break;
              p5[d4--] = 0, a5 = 1;
            }
        for (o3 = p5.length;p5[--o3] === 0; )
          p5.pop();
      }
    return b3 && (e4.e > f4.maxE ? (e4.d = null, e4.e = NaN) : e4.e < f4.minE && (e4.e = 0, e4.d = [0])), e4;
  }
  function xe(e4, t4, r5) {
    if (!e4.isFinite())
      return Ls(e4);
    var n4, i4 = e4.e, o3 = K2(e4.d), s5 = o3.length;
    return t4 ? (r5 && (n4 = r5 - s5) > 0 ? o3 = o3.charAt(0) + "." + o3.slice(1) + He(n4) : s5 > 1 && (o3 = o3.charAt(0) + "." + o3.slice(1)), o3 = o3 + (e4.e < 0 ? "e" : "e+") + e4.e) : i4 < 0 ? (o3 = "0." + He(-i4 - 1) + o3, r5 && (n4 = r5 - s5) > 0 && (o3 += He(n4))) : i4 >= s5 ? (o3 += He(i4 + 1 - s5), r5 && (n4 = r5 - i4 - 1) > 0 && (o3 = o3 + "." + He(n4))) : ((n4 = i4 + 1) < s5 && (o3 = o3.slice(0, n4) + "." + o3.slice(n4)), r5 && (n4 = r5 - s5) > 0 && (i4 + 1 === s5 && (o3 += "."), o3 += He(n4))), o3;
  }
  function on(e4, t4) {
    var r5 = e4[0];
    for (t4 *= E3;r5 >= 10; r5 /= 10)
      t4++;
    return t4;
  }
  function rn(e4, t4, r5) {
    if (t4 > Oc)
      throw b3 = true, r5 && (e4.precision = r5), Error(As);
    return y4(new e4(en), t4, 1, true);
  }
  function ge(e4, t4, r5) {
    if (t4 > Ii)
      throw Error(As);
    return y4(new e4(tn), t4, r5, true);
  }
  function Ds(e4) {
    var t4 = e4.length - 1, r5 = t4 * E3 + 1;
    if (t4 = e4[t4], t4) {
      for (;t4 % 10 == 0; t4 /= 10)
        r5--;
      for (t4 = e4[0];t4 >= 10; t4 /= 10)
        r5++;
    }
    return r5;
  }
  function He(e4) {
    for (var t4 = "";e4--; )
      t4 += "0";
    return t4;
  }
  function _s2(e4, t4, r5, n4) {
    var i4, o3 = new e4(1), s5 = Math.ceil(n4 / E3 + 4);
    for (b3 = false;; ) {
      if (r5 % 2 && (o3 = o3.times(t4), Rs(o3.d, s5) && (i4 = true)), r5 = re(r5 / 2), r5 === 0) {
        r5 = o3.d.length - 1, i4 && o3.d[r5] === 0 && ++o3.d[r5];
        break;
      }
      t4 = t4.times(t4), Rs(t4.d, s5);
    }
    return b3 = true, o3;
  }
  function Ts(e4) {
    return e4.d[e4.d.length - 1] & 1;
  }
  function Ns(e4, t4, r5) {
    for (var n4, i4 = new e4(t4[0]), o3 = 0;++o3 < t4.length; )
      if (n4 = new e4(t4[o3]), n4.s)
        i4[r5](n4) && (i4 = n4);
      else {
        i4 = n4;
        break;
      }
    return i4;
  }
  function Oi(e4, t4) {
    var r5, n4, i4, o3, s5, a5, l4, u5 = 0, c5 = 0, p5 = 0, d4 = e4.constructor, f4 = d4.rounding, g3 = d4.precision;
    if (!e4.d || !e4.d[0] || e4.e > 17)
      return new d4(e4.d ? e4.d[0] ? e4.s < 0 ? 0 : 1 / 0 : 1 : e4.s ? e4.s < 0 ? 0 : e4 : NaN);
    for (t4 == null ? (b3 = false, l4 = g3) : l4 = t4, a5 = new d4(0.03125);e4.e > -2; )
      e4 = e4.times(a5), p5 += 5;
    for (n4 = Math.log(G4(2, p5)) / Math.LN10 * 2 + 5 | 0, l4 += n4, r5 = o3 = s5 = new d4(1), d4.precision = l4;; ) {
      if (o3 = y4(o3.times(e4), l4, 1), r5 = r5.times(++c5), a5 = s5.plus(M3(o3, r5, l4, 1)), K2(a5.d).slice(0, l4) === K2(s5.d).slice(0, l4)) {
        for (i4 = p5;i4--; )
          s5 = y4(s5.times(s5), l4, 1);
        if (t4 == null)
          if (u5 < 3 && rr(s5.d, l4 - n4, f4, u5))
            d4.precision = l4 += 10, r5 = o3 = a5 = new d4(1), c5 = 0, u5++;
          else
            return y4(s5, d4.precision = g3, f4, b3 = true);
        else
          return d4.precision = g3, s5;
      }
      s5 = a5;
    }
  }
  function We(e4, t4) {
    var r5, n4, i4, o3, s5, a5, l4, u5, c5, p5, d4, f4 = 1, g3 = 10, h4 = e4, O4 = h4.d, P4 = h4.constructor, C3 = P4.rounding, R4 = P4.precision;
    if (h4.s < 0 || !O4 || !O4[0] || !h4.e && O4[0] == 1 && O4.length == 1)
      return new P4(O4 && !O4[0] ? -1 / 0 : h4.s != 1 ? NaN : O4 ? 0 : h4);
    if (t4 == null ? (b3 = false, c5 = R4) : c5 = t4, P4.precision = c5 += g3, r5 = K2(O4), n4 = r5.charAt(0), Math.abs(o3 = h4.e) < 1500000000000000) {
      for (;n4 < 7 && n4 != 1 || n4 == 1 && r5.charAt(1) > 3; )
        h4 = h4.times(e4), r5 = K2(h4.d), n4 = r5.charAt(0), f4++;
      o3 = h4.e, n4 > 1 ? (h4 = new P4("0." + r5), o3++) : h4 = new P4(n4 + "." + r5.slice(1));
    } else
      return u5 = rn(P4, c5 + 2, R4).times(o3 + ""), h4 = We(new P4(n4 + "." + r5.slice(1)), c5 - g3).plus(u5), P4.precision = R4, t4 == null ? y4(h4, R4, C3, b3 = true) : h4;
    for (p5 = h4, l4 = s5 = h4 = M3(h4.minus(1), h4.plus(1), c5, 1), d4 = y4(h4.times(h4), c5, 1), i4 = 3;; ) {
      if (s5 = y4(s5.times(d4), c5, 1), u5 = l4.plus(M3(s5, new P4(i4), c5, 1)), K2(u5.d).slice(0, c5) === K2(l4.d).slice(0, c5))
        if (l4 = l4.times(2), o3 !== 0 && (l4 = l4.plus(rn(P4, c5 + 2, R4).times(o3 + ""))), l4 = M3(l4, new P4(f4), c5, 1), t4 == null)
          if (rr(l4.d, c5 - g3, C3, a5))
            P4.precision = c5 += g3, u5 = s5 = h4 = M3(p5.minus(1), p5.plus(1), c5, 1), d4 = y4(h4.times(h4), c5, 1), i4 = a5 = 1;
          else
            return y4(l4, P4.precision = R4, C3, b3 = true);
        else
          return P4.precision = R4, l4;
      l4 = u5, i4 += 2;
    }
  }
  function Ls(e4) {
    return String(e4.s * e4.s / 0);
  }
  function ki(e4, t4) {
    var r5, n4, i4;
    for ((r5 = t4.indexOf(".")) > -1 && (t4 = t4.replace(".", "")), (n4 = t4.search(/e/i)) > 0 ? (r5 < 0 && (r5 = n4), r5 += +t4.slice(n4 + 1), t4 = t4.substring(0, n4)) : r5 < 0 && (r5 = t4.length), n4 = 0;t4.charCodeAt(n4) === 48; n4++)
      ;
    for (i4 = t4.length;t4.charCodeAt(i4 - 1) === 48; --i4)
      ;
    if (t4 = t4.slice(n4, i4), t4) {
      if (i4 -= n4, e4.e = r5 = r5 - n4 - 1, e4.d = [], n4 = (r5 + 1) % E3, r5 < 0 && (n4 += E3), n4 < i4) {
        for (n4 && e4.d.push(+t4.slice(0, n4)), i4 -= E3;n4 < i4; )
          e4.d.push(+t4.slice(n4, n4 += E3));
        t4 = t4.slice(n4), n4 = E3 - t4.length;
      } else
        n4 -= i4;
      for (;n4--; )
        t4 += "0";
      e4.d.push(+t4), b3 && (e4.e > e4.constructor.maxE ? (e4.d = null, e4.e = NaN) : e4.e < e4.constructor.minE && (e4.e = 0, e4.d = [0]));
    } else
      e4.e = 0, e4.d = [0];
    return e4;
  }
  function Dc(e4, t4) {
    var r5, n4, i4, o3, s5, a5, l4, u5, c5;
    if (t4.indexOf("_") > -1) {
      if (t4 = t4.replace(/(\d)_(?=\d)/g, "$1"), ks.test(t4))
        return ki(e4, t4);
    } else if (t4 === "Infinity" || t4 === "NaN")
      return +t4 || (e4.s = NaN), e4.e = NaN, e4.d = null, e4;
    if (Sc.test(t4))
      r5 = 16, t4 = t4.toLowerCase();
    else if (Cc.test(t4))
      r5 = 2;
    else if (Ac.test(t4))
      r5 = 8;
    else
      throw Error(Ke + t4);
    for (o3 = t4.search(/p/i), o3 > 0 ? (l4 = +t4.slice(o3 + 1), t4 = t4.substring(2, o3)) : t4 = t4.slice(2), o3 = t4.indexOf("."), s5 = o3 >= 0, n4 = e4.constructor, s5 && (t4 = t4.replace(".", ""), a5 = t4.length, o3 = a5 - o3, i4 = _s2(n4, new n4(r5), o3, o3 * 2)), u5 = Xr(t4, r5, he), c5 = u5.length - 1, o3 = c5;u5[o3] === 0; --o3)
      u5.pop();
    return o3 < 0 ? new n4(e4.s * 0) : (e4.e = on(u5, c5), e4.d = u5, b3 = false, s5 && (e4 = M3(e4, i4, a5 * 4)), l4 && (e4 = e4.times(Math.abs(l4) < 54 ? G4(2, l4) : it.pow(2, l4))), b3 = true, e4);
  }
  function _c2(e4, t4) {
    var r5, n4 = t4.d.length;
    if (n4 < 3)
      return t4.isZero() ? t4 : Et(e4, 2, t4, t4);
    r5 = 1.4 * Math.sqrt(n4), r5 = r5 > 16 ? 16 : r5 | 0, t4 = t4.times(1 / sn(5, r5)), t4 = Et(e4, 2, t4, t4);
    for (var i4, o3 = new e4(5), s5 = new e4(16), a5 = new e4(20);r5--; )
      i4 = t4.times(t4), t4 = t4.times(o3.plus(i4.times(s5.times(i4).minus(a5))));
    return t4;
  }
  function Et(e4, t4, r5, n4, i4) {
    var o3, s5, a5, l4, u5 = 1, c5 = e4.precision, p5 = Math.ceil(c5 / E3);
    for (b3 = false, l4 = r5.times(r5), a5 = new e4(n4);; ) {
      if (s5 = M3(a5.times(l4), new e4(t4++ * t4++), c5, 1), a5 = i4 ? n4.plus(s5) : n4.minus(s5), n4 = M3(s5.times(l4), new e4(t4++ * t4++), c5, 1), s5 = a5.plus(n4), s5.d[p5] !== undefined) {
        for (o3 = p5;s5.d[o3] === a5.d[o3] && o3--; )
          ;
        if (o3 == -1)
          break;
      }
      o3 = a5, a5 = n4, n4 = s5, s5 = o3, u5++;
    }
    return b3 = true, s5.d.length = p5 + 1, s5;
  }
  function sn(e4, t4) {
    for (var r5 = e4;--t4; )
      r5 *= e4;
    return r5;
  }
  function Fs(e4, t4) {
    var r5, n4 = t4.s < 0, i4 = ge(e4, e4.precision, 1), o3 = i4.times(0.5);
    if (t4 = t4.abs(), t4.lte(o3))
      return Me = n4 ? 4 : 1, t4;
    if (r5 = t4.divToInt(i4), r5.isZero())
      Me = n4 ? 3 : 2;
    else {
      if (t4 = t4.minus(r5.times(i4)), t4.lte(o3))
        return Me = Ts(r5) ? n4 ? 2 : 3 : n4 ? 4 : 1, t4;
      Me = Ts(r5) ? n4 ? 1 : 4 : n4 ? 3 : 2;
    }
    return t4.minus(i4).abs();
  }
  function Di(e4, t4, r5, n4) {
    var i4, o3, s5, a5, l4, u5, c5, p5, d4, f4 = e4.constructor, g3 = r5 !== undefined;
    if (g3 ? (se(r5, 1, Ye), n4 === undefined ? n4 = f4.rounding : se(n4, 0, 8)) : (r5 = f4.precision, n4 = f4.rounding), !e4.isFinite())
      c5 = Ls(e4);
    else {
      for (c5 = xe(e4), s5 = c5.indexOf("."), g3 ? (i4 = 2, t4 == 16 ? r5 = r5 * 4 - 3 : t4 == 8 && (r5 = r5 * 3 - 2)) : i4 = t4, s5 >= 0 && (c5 = c5.replace(".", ""), d4 = new f4(1), d4.e = c5.length - s5, d4.d = Xr(xe(d4), 10, i4), d4.e = d4.d.length), p5 = Xr(c5, 10, i4), o3 = l4 = p5.length;p5[--l4] == 0; )
        p5.pop();
      if (!p5[0])
        c5 = g3 ? "0p+0" : "0";
      else {
        if (s5 < 0 ? o3-- : (e4 = new f4(e4), e4.d = p5, e4.e = o3, e4 = M3(e4, d4, r5, n4, 0, i4), p5 = e4.d, o3 = e4.e, u5 = Ss), s5 = p5[r5], a5 = i4 / 2, u5 = u5 || p5[r5 + 1] !== undefined, u5 = n4 < 4 ? (s5 !== undefined || u5) && (n4 === 0 || n4 === (e4.s < 0 ? 3 : 2)) : s5 > a5 || s5 === a5 && (n4 === 4 || u5 || n4 === 6 && p5[r5 - 1] & 1 || n4 === (e4.s < 0 ? 8 : 7)), p5.length = r5, u5)
          for (;++p5[--r5] > i4 - 1; )
            p5[r5] = 0, r5 || (++o3, p5.unshift(1));
        for (l4 = p5.length;!p5[l4 - 1]; --l4)
          ;
        for (s5 = 0, c5 = "";s5 < l4; s5++)
          c5 += Si.charAt(p5[s5]);
        if (g3) {
          if (l4 > 1)
            if (t4 == 16 || t4 == 8) {
              for (s5 = t4 == 16 ? 4 : 3, --l4;l4 % s5; l4++)
                c5 += "0";
              for (p5 = Xr(c5, i4, t4), l4 = p5.length;!p5[l4 - 1]; --l4)
                ;
              for (s5 = 1, c5 = "1.";s5 < l4; s5++)
                c5 += Si.charAt(p5[s5]);
            } else
              c5 = c5.charAt(0) + "." + c5.slice(1);
          c5 = c5 + (o3 < 0 ? "p" : "p+") + o3;
        } else if (o3 < 0) {
          for (;++o3; )
            c5 = "0" + c5;
          c5 = "0." + c5;
        } else if (++o3 > l4)
          for (o3 -= l4;o3--; )
            c5 += "0";
        else
          o3 < l4 && (c5 = c5.slice(0, o3) + "." + c5.slice(o3));
      }
      c5 = (t4 == 16 ? "0x" : t4 == 2 ? "0b" : t4 == 8 ? "0o" : "") + c5;
    }
    return e4.s < 0 ? "-" + c5 : c5;
  }
  function Rs(e4, t4) {
    if (e4.length > t4)
      return e4.length = t4, true;
  }
  function Nc(e4) {
    return new this(e4).abs();
  }
  function Lc(e4) {
    return new this(e4).acos();
  }
  function Fc(e4) {
    return new this(e4).acosh();
  }
  function Mc(e4, t4) {
    return new this(e4).plus(t4);
  }
  function $c(e4) {
    return new this(e4).asin();
  }
  function qc(e4) {
    return new this(e4).asinh();
  }
  function Vc(e4) {
    return new this(e4).atan();
  }
  function jc(e4) {
    return new this(e4).atanh();
  }
  function Bc(e4, t4) {
    e4 = new this(e4), t4 = new this(t4);
    var r5, n4 = this.precision, i4 = this.rounding, o3 = n4 + 4;
    return !e4.s || !t4.s ? r5 = new this(NaN) : !e4.d && !t4.d ? (r5 = ge(this, o3, 1).times(t4.s > 0 ? 0.25 : 0.75), r5.s = e4.s) : !t4.d || e4.isZero() ? (r5 = t4.s < 0 ? ge(this, n4, i4) : new this(0), r5.s = e4.s) : !e4.d || t4.isZero() ? (r5 = ge(this, o3, 1).times(0.5), r5.s = e4.s) : t4.s < 0 ? (this.precision = o3, this.rounding = 1, r5 = this.atan(M3(e4, t4, o3, 1)), t4 = ge(this, o3, 1), this.precision = n4, this.rounding = i4, r5 = e4.s < 0 ? r5.minus(t4) : r5.plus(t4)) : r5 = this.atan(M3(e4, t4, o3, 1)), r5;
  }
  function Uc(e4) {
    return new this(e4).cbrt();
  }
  function Qc(e4) {
    return y4(e4 = new this(e4), e4.e + 1, 2);
  }
  function Gc(e4, t4, r5) {
    return new this(e4).clamp(t4, r5);
  }
  function Jc(e4) {
    if (!e4 || typeof e4 != "object")
      throw Error(nn + "Object expected");
    var t4, r5, n4, i4 = e4.defaults === true, o3 = ["precision", 1, Ye, "rounding", 0, 8, "toExpNeg", -yt, 0, "toExpPos", 0, yt, "maxE", 0, yt, "minE", -yt, 0, "modulo", 0, 9];
    for (t4 = 0;t4 < o3.length; t4 += 3)
      if (r5 = o3[t4], i4 && (this[r5] = Ai[r5]), (n4 = e4[r5]) !== undefined)
        if (re(n4) === n4 && n4 >= o3[t4 + 1] && n4 <= o3[t4 + 2])
          this[r5] = n4;
        else
          throw Error(Ke + r5 + ": " + n4);
    if (r5 = "crypto", i4 && (this[r5] = Ai[r5]), (n4 = e4[r5]) !== undefined)
      if (n4 === true || n4 === false || n4 === 0 || n4 === 1)
        if (n4)
          if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
            this[r5] = true;
          else
            throw Error(Is);
        else
          this[r5] = false;
      else
        throw Error(Ke + r5 + ": " + n4);
    return this;
  }
  function Hc(e4) {
    return new this(e4).cos();
  }
  function Wc(e4) {
    return new this(e4).cosh();
  }
  function Ms(e4) {
    var t4, r5, n4;
    function i4(o3) {
      var s5, a5, l4, u5 = this;
      if (!(u5 instanceof i4))
        return new i4(o3);
      if (u5.constructor = i4, Cs(o3)) {
        u5.s = o3.s, b3 ? !o3.d || o3.e > i4.maxE ? (u5.e = NaN, u5.d = null) : o3.e < i4.minE ? (u5.e = 0, u5.d = [0]) : (u5.e = o3.e, u5.d = o3.d.slice()) : (u5.e = o3.e, u5.d = o3.d ? o3.d.slice() : o3.d);
        return;
      }
      if (l4 = typeof o3, l4 === "number") {
        if (o3 === 0) {
          u5.s = 1 / o3 < 0 ? -1 : 1, u5.e = 0, u5.d = [0];
          return;
        }
        if (o3 < 0 ? (o3 = -o3, u5.s = -1) : u5.s = 1, o3 === ~~o3 && o3 < 1e7) {
          for (s5 = 0, a5 = o3;a5 >= 10; a5 /= 10)
            s5++;
          b3 ? s5 > i4.maxE ? (u5.e = NaN, u5.d = null) : s5 < i4.minE ? (u5.e = 0, u5.d = [0]) : (u5.e = s5, u5.d = [o3]) : (u5.e = s5, u5.d = [o3]);
          return;
        } else if (o3 * 0 !== 0) {
          o3 || (u5.s = NaN), u5.e = NaN, u5.d = null;
          return;
        }
        return ki(u5, o3.toString());
      } else if (l4 !== "string")
        throw Error(Ke + o3);
      return (a5 = o3.charCodeAt(0)) === 45 ? (o3 = o3.slice(1), u5.s = -1) : (a5 === 43 && (o3 = o3.slice(1)), u5.s = 1), ks.test(o3) ? ki(u5, o3) : Dc(u5, o3);
    }
    if (i4.prototype = m4, i4.ROUND_UP = 0, i4.ROUND_DOWN = 1, i4.ROUND_CEIL = 2, i4.ROUND_FLOOR = 3, i4.ROUND_HALF_UP = 4, i4.ROUND_HALF_DOWN = 5, i4.ROUND_HALF_EVEN = 6, i4.ROUND_HALF_CEIL = 7, i4.ROUND_HALF_FLOOR = 8, i4.EUCLID = 9, i4.config = i4.set = Jc, i4.clone = Ms, i4.isDecimal = Cs, i4.abs = Nc, i4.acos = Lc, i4.acosh = Fc, i4.add = Mc, i4.asin = $c, i4.asinh = qc, i4.atan = Vc, i4.atanh = jc, i4.atan2 = Bc, i4.cbrt = Uc, i4.ceil = Qc, i4.clamp = Gc, i4.cos = Hc, i4.cosh = Wc, i4.div = Kc, i4.exp = Yc, i4.floor = zc, i4.hypot = Zc, i4.ln = Xc, i4.log = ep, i4.log10 = rp, i4.log2 = tp, i4.max = np, i4.min = ip, i4.mod = op, i4.mul = sp, i4.pow = ap2, i4.random = lp, i4.round = up, i4.sign = cp2, i4.sin = pp, i4.sinh = dp, i4.sqrt = mp, i4.sub = fp, i4.sum = gp, i4.tan = hp, i4.tanh = yp, i4.trunc = Ep, e4 === undefined && (e4 = {}), e4 && e4.defaults !== true)
      for (n4 = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t4 = 0;t4 < n4.length; )
        e4.hasOwnProperty(r5 = n4[t4++]) || (e4[r5] = this[r5]);
    return i4.config(e4), i4;
  }
  function Kc(e4, t4) {
    return new this(e4).div(t4);
  }
  function Yc(e4) {
    return new this(e4).exp();
  }
  function zc(e4) {
    return y4(e4 = new this(e4), e4.e + 1, 3);
  }
  function Zc() {
    var e4, t4, r5 = new this(0);
    for (b3 = false, e4 = 0;e4 < arguments.length; )
      if (t4 = new this(arguments[e4++]), t4.d)
        r5.d && (r5 = r5.plus(t4.times(t4)));
      else {
        if (t4.s)
          return b3 = true, new this(1 / 0);
        r5 = t4;
      }
    return b3 = true, r5.sqrt();
  }
  function Cs(e4) {
    return e4 instanceof it || e4 && e4.toStringTag === Os || false;
  }
  function Xc(e4) {
    return new this(e4).ln();
  }
  function ep(e4, t4) {
    return new this(e4).log(t4);
  }
  function tp(e4) {
    return new this(e4).log(2);
  }
  function rp(e4) {
    return new this(e4).log(10);
  }
  function np() {
    return Ns(this, arguments, "lt");
  }
  function ip() {
    return Ns(this, arguments, "gt");
  }
  function op(e4, t4) {
    return new this(e4).mod(t4);
  }
  function sp(e4, t4) {
    return new this(e4).mul(t4);
  }
  function ap2(e4, t4) {
    return new this(e4).pow(t4);
  }
  function lp(e4) {
    var t4, r5, n4, i4, o3 = 0, s5 = new this(1), a5 = [];
    if (e4 === undefined ? e4 = this.precision : se(e4, 1, Ye), n4 = Math.ceil(e4 / E3), this.crypto)
      if (crypto.getRandomValues)
        for (t4 = crypto.getRandomValues(new Uint32Array(n4));o3 < n4; )
          i4 = t4[o3], i4 >= 4290000000 ? t4[o3] = crypto.getRandomValues(new Uint32Array(1))[0] : a5[o3++] = i4 % 1e7;
      else if (crypto.randomBytes) {
        for (t4 = crypto.randomBytes(n4 *= 4);o3 < n4; )
          i4 = t4[o3] + (t4[o3 + 1] << 8) + (t4[o3 + 2] << 16) + ((t4[o3 + 3] & 127) << 24), i4 >= 2140000000 ? crypto.randomBytes(4).copy(t4, o3) : (a5.push(i4 % 1e7), o3 += 4);
        o3 = n4 / 4;
      } else
        throw Error(Is);
    else
      for (;o3 < n4; )
        a5[o3++] = Math.random() * 1e7 | 0;
    for (n4 = a5[--o3], e4 %= E3, n4 && e4 && (i4 = G4(10, E3 - e4), a5[o3] = (n4 / i4 | 0) * i4);a5[o3] === 0; o3--)
      a5.pop();
    if (o3 < 0)
      r5 = 0, a5 = [0];
    else {
      for (r5 = -1;a5[0] === 0; r5 -= E3)
        a5.shift();
      for (n4 = 1, i4 = a5[0];i4 >= 10; i4 /= 10)
        n4++;
      n4 < E3 && (r5 -= E3 - n4);
    }
    return s5.e = r5, s5.d = a5, s5;
  }
  function up(e4) {
    return y4(e4 = new this(e4), e4.e + 1, this.rounding);
  }
  function cp2(e4) {
    return e4 = new this(e4), e4.d ? e4.d[0] ? e4.s : 0 * e4.s : e4.s || NaN;
  }
  function pp(e4) {
    return new this(e4).sin();
  }
  function dp(e4) {
    return new this(e4).sinh();
  }
  function mp(e4) {
    return new this(e4).sqrt();
  }
  function fp(e4, t4) {
    return new this(e4).sub(t4);
  }
  function gp() {
    var e4 = 0, t4 = arguments, r5 = new this(t4[e4]);
    for (b3 = false;r5.s && ++e4 < t4.length; )
      r5 = r5.plus(t4[e4]);
    return b3 = true, y4(r5, this.precision, this.rounding);
  }
  function hp(e4) {
    return new this(e4).tan();
  }
  function yp(e4) {
    return new this(e4).tanh();
  }
  function Ep(e4) {
    return y4(e4 = new this(e4), e4.e + 1, 1);
  }
  m4[Symbol.for("nodejs.util.inspect.custom")] = m4.toString;
  m4[Symbol.toStringTag] = "Decimal";
  var it = m4.constructor = Ms(Ai);
  en = new it(en);
  tn = new it(tn);
  var ve = it;
  function bt2(e4) {
    return e4 === null ? e4 : Array.isArray(e4) ? e4.map(bt2) : typeof e4 == "object" ? bp2(e4) ? wp(e4) : ht(e4, bt2) : e4;
  }
  function bp2(e4) {
    return e4 !== null && typeof e4 == "object" && typeof e4.$type == "string";
  }
  function wp({ $type: e4, value: t4 }) {
    switch (e4) {
      case "BigInt":
        return BigInt(t4);
      case "Bytes": {
        let { buffer: r5, byteOffset: n4, byteLength: i4 } = Buffer.from(t4, "base64");
        return new Uint8Array(r5, n4, i4);
      }
      case "DateTime":
        return new Date(t4);
      case "Decimal":
        return new ve(t4);
      case "Json":
        return JSON.parse(t4);
      default:
        Fe(t4, "Unknown tagged value");
    }
  }
  function wt(e4) {
    return e4.substring(0, 1).toLowerCase() + e4.substring(1);
  }
  function xt(e4) {
    return e4 instanceof Date || Object.prototype.toString.call(e4) === "[object Date]";
  }
  function an2(e4) {
    return e4.toString() !== "Invalid Date";
  }
  function vt(e4) {
    return it.isDecimal(e4) ? true : e4 !== null && typeof e4 == "object" && typeof e4.s == "number" && typeof e4.e == "number" && typeof e4.toFixed == "function" && Array.isArray(e4.d);
  }
  var Us = D3(bi2());
  var Bs = D3(__require("fs"));
  var $s = { keyword: _e2, entity: _e2, value: (e4) => W3(rt(e4)), punctuation: rt, directive: _e2, function: _e2, variable: (e4) => W3(rt(e4)), string: (e4) => W3(Ve(e4)), boolean: De, number: _e2, comment: Ut };
  var xp = (e4) => e4;
  var ln = {};
  var vp = 0;
  var x4 = { manual: ln.Prism && ln.Prism.manual, disableWorkerMessageHandler: ln.Prism && ln.Prism.disableWorkerMessageHandler, util: { encode: function(e4) {
    if (e4 instanceof ye) {
      let t4 = e4;
      return new ye(t4.type, x4.util.encode(t4.content), t4.alias);
    } else
      return Array.isArray(e4) ? e4.map(x4.util.encode) : e4.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
  }, type: function(e4) {
    return Object.prototype.toString.call(e4).slice(8, -1);
  }, objId: function(e4) {
    return e4.__id || Object.defineProperty(e4, "__id", { value: ++vp }), e4.__id;
  }, clone: function e(t4, r5) {
    let n4, i4, o3 = x4.util.type(t4);
    switch (r5 = r5 || {}, o3) {
      case "Object":
        if (i4 = x4.util.objId(t4), r5[i4])
          return r5[i4];
        n4 = {}, r5[i4] = n4;
        for (let s5 in t4)
          t4.hasOwnProperty(s5) && (n4[s5] = e(t4[s5], r5));
        return n4;
      case "Array":
        return i4 = x4.util.objId(t4), r5[i4] ? r5[i4] : (n4 = [], r5[i4] = n4, t4.forEach(function(s5, a5) {
          n4[a5] = e(s5, r5);
        }), n4);
      default:
        return t4;
    }
  } }, languages: { extend: function(e4, t4) {
    let r5 = x4.util.clone(x4.languages[e4]);
    for (let n4 in t4)
      r5[n4] = t4[n4];
    return r5;
  }, insertBefore: function(e4, t4, r5, n4) {
    n4 = n4 || x4.languages;
    let i4 = n4[e4], o3 = {};
    for (let a5 in i4)
      if (i4.hasOwnProperty(a5)) {
        if (a5 == t4)
          for (let l4 in r5)
            r5.hasOwnProperty(l4) && (o3[l4] = r5[l4]);
        r5.hasOwnProperty(a5) || (o3[a5] = i4[a5]);
      }
    let s5 = n4[e4];
    return n4[e4] = o3, x4.languages.DFS(x4.languages, function(a5, l4) {
      l4 === s5 && a5 != e4 && (this[a5] = o3);
    }), o3;
  }, DFS: function e(t4, r5, n4, i4) {
    i4 = i4 || {};
    let o3 = x4.util.objId;
    for (let s5 in t4)
      if (t4.hasOwnProperty(s5)) {
        r5.call(t4, s5, t4[s5], n4 || s5);
        let a5 = t4[s5], l4 = x4.util.type(a5);
        l4 === "Object" && !i4[o3(a5)] ? (i4[o3(a5)] = true, e(a5, r5, null, i4)) : l4 === "Array" && !i4[o3(a5)] && (i4[o3(a5)] = true, e(a5, r5, s5, i4));
      }
  } }, plugins: {}, highlight: function(e4, t4, r5) {
    let n4 = { code: e4, grammar: t4, language: r5 };
    return x4.hooks.run("before-tokenize", n4), n4.tokens = x4.tokenize(n4.code, n4.grammar), x4.hooks.run("after-tokenize", n4), ye.stringify(x4.util.encode(n4.tokens), n4.language);
  }, matchGrammar: function(e4, t4, r5, n4, i4, o3, s5) {
    for (let h4 in r5) {
      if (!r5.hasOwnProperty(h4) || !r5[h4])
        continue;
      if (h4 == s5)
        return;
      let O4 = r5[h4];
      O4 = x4.util.type(O4) === "Array" ? O4 : [O4];
      for (let P4 = 0;P4 < O4.length; ++P4) {
        let C3 = O4[P4], R4 = C3.inside, k4 = !!C3.lookbehind, A4 = !!C3.greedy, ue2 = 0, jt = C3.alias;
        if (A4 && !C3.pattern.global) {
          let U3 = C3.pattern.toString().match(/[imuy]*$/)[0];
          C3.pattern = RegExp(C3.pattern.source, U3 + "g");
        }
        C3 = C3.pattern || C3;
        for (let U3 = n4, oe = i4;U3 < t4.length; oe += t4[U3].length, ++U3) {
          let Oe = t4[U3];
          if (t4.length > e4.length)
            return;
          if (Oe instanceof ye)
            continue;
          if (A4 && U3 != t4.length - 1) {
            C3.lastIndex = oe;
            var p5 = C3.exec(e4);
            if (!p5)
              break;
            var c5 = p5.index + (k4 ? p5[1].length : 0), d4 = p5.index + p5[0].length, a5 = U3, l4 = oe;
            for (let N4 = t4.length;a5 < N4 && (l4 < d4 || !t4[a5].type && !t4[a5 - 1].greedy); ++a5)
              l4 += t4[a5].length, c5 >= l4 && (++U3, oe = l4);
            if (t4[U3] instanceof ye)
              continue;
            u5 = a5 - U3, Oe = e4.slice(oe, l4), p5.index -= oe;
          } else {
            C3.lastIndex = 0;
            var p5 = C3.exec(Oe), u5 = 1;
          }
          if (!p5) {
            if (o3)
              break;
            continue;
          }
          k4 && (ue2 = p5[1] ? p5[1].length : 0);
          var c5 = p5.index + ue2, p5 = p5[0].slice(ue2), d4 = c5 + p5.length, f4 = Oe.slice(0, c5), g3 = Oe.slice(d4);
          let Y3 = [U3, u5];
          f4 && (++U3, oe += f4.length, Y3.push(f4));
          let pt = new ye(h4, R4 ? x4.tokenize(p5, R4) : p5, jt, p5, A4);
          if (Y3.push(pt), g3 && Y3.push(g3), Array.prototype.splice.apply(t4, Y3), u5 != 1 && x4.matchGrammar(e4, t4, r5, U3, oe, true, h4), o3)
            break;
        }
      }
    }
  }, tokenize: function(e4, t4) {
    let r5 = [e4], n4 = t4.rest;
    if (n4) {
      for (let i4 in n4)
        t4[i4] = n4[i4];
      delete t4.rest;
    }
    return x4.matchGrammar(e4, r5, t4, 0, 0, false), r5;
  }, hooks: { all: {}, add: function(e4, t4) {
    let r5 = x4.hooks.all;
    r5[e4] = r5[e4] || [], r5[e4].push(t4);
  }, run: function(e4, t4) {
    let r5 = x4.hooks.all[e4];
    if (!(!r5 || !r5.length))
      for (var n4 = 0, i4;i4 = r5[n4++]; )
        i4(t4);
  } }, Token: ye };
  x4.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
  x4.languages.javascript = x4.languages.extend("clike", { "class-name": [x4.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: true }, { pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ });
  x4.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
  x4.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: true, greedy: true }, "function-variable": { pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: true, inside: x4.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: x4.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: true, inside: x4.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: true, inside: x4.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
  x4.languages.markup && x4.languages.markup.tag.addInlined("script", "javascript");
  x4.languages.js = x4.languages.javascript;
  x4.languages.typescript = x4.languages.extend("javascript", { keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ });
  x4.languages.ts = x4.languages.typescript;
  function ye(e4, t4, r5, n4, i4) {
    this.type = e4, this.content = t4, this.alias = r5, this.length = (n4 || "").length | 0, this.greedy = !!i4;
  }
  ye.stringify = function(e4, t4) {
    return typeof e4 == "string" ? e4 : Array.isArray(e4) ? e4.map(function(r5) {
      return ye.stringify(r5, t4);
    }).join("") : Pp(e4.type)(e4.content);
  };
  function Pp(e4) {
    return $s[e4] || xp;
  }
  function qs(e4) {
    return Tp(e4, x4.languages.javascript);
  }
  function Tp(e4, t4) {
    return x4.tokenize(e4, t4).map((n4) => ye.stringify(n4)).join("");
  }
  var Vs = D3(gs());
  function js(e4) {
    return (0, Vs.default)(e4);
  }
  var un = class e4 {
    static read(t4) {
      let r5;
      try {
        r5 = Bs.default.readFileSync(t4, "utf-8");
      } catch {
        return null;
      }
      return e4.fromContent(r5);
    }
    static fromContent(t4) {
      let r5 = t4.split(/\r?\n/);
      return new e4(1, r5);
    }
    constructor(t4, r5) {
      this.firstLineNumber = t4, this.lines = r5;
    }
    get lastLineNumber() {
      return this.firstLineNumber + this.lines.length - 1;
    }
    mapLineAt(t4, r5) {
      if (t4 < this.firstLineNumber || t4 > this.lines.length + this.firstLineNumber)
        return this;
      let n4 = t4 - this.firstLineNumber, i4 = [...this.lines];
      return i4[n4] = r5(i4[n4]), new e4(this.firstLineNumber, i4);
    }
    mapLines(t4) {
      return new e4(this.firstLineNumber, this.lines.map((r5, n4) => t4(r5, this.firstLineNumber + n4)));
    }
    lineAt(t4) {
      return this.lines[t4 - this.firstLineNumber];
    }
    prependSymbolAt(t4, r5) {
      return this.mapLines((n4, i4) => i4 === t4 ? `${r5} ${n4}` : `  ${n4}`);
    }
    slice(t4, r5) {
      let n4 = this.lines.slice(t4 - 1, r5).join(`
`);
      return new e4(t4, js(n4).split(`
`));
    }
    highlight() {
      let t4 = qs(this.toString());
      return new e4(this.firstLineNumber, t4.split(`
`));
    }
    toString() {
      return this.lines.join(`
`);
    }
  };
  var Rp = { red: de2, gray: Ut, dim: ke, bold: W3, underline: X3, highlightSource: (e4) => e4.highlight() };
  var Cp = { red: (e4) => e4, gray: (e4) => e4, dim: (e4) => e4, bold: (e4) => e4, underline: (e4) => e4, highlightSource: (e4) => e4 };
  function Sp({ message: e4, originalMethod: t4, isPanic: r5, callArguments: n4 }) {
    return { functionName: `prisma.${t4}()`, message: e4, isPanic: r5 ?? false, callArguments: n4 };
  }
  function Ap({ callsite: e4, message: t4, originalMethod: r5, isPanic: n4, callArguments: i4 }, o3) {
    let s5 = Sp({ message: t4, originalMethod: r5, isPanic: n4, callArguments: i4 });
    if (!e4 || typeof window < "u" || false)
      return s5;
    let a5 = e4.getLocation();
    if (!a5 || !a5.lineNumber || !a5.columnNumber)
      return s5;
    let l4 = Math.max(1, a5.lineNumber - 3), u5 = un.read(a5.fileName)?.slice(l4, a5.lineNumber), c5 = u5?.lineAt(a5.lineNumber);
    if (u5 && c5) {
      let p5 = Op(c5), d4 = Ip(c5);
      if (!d4)
        return s5;
      s5.functionName = `${d4.code})`, s5.location = a5, n4 || (u5 = u5.mapLineAt(a5.lineNumber, (g3) => g3.slice(0, d4.openingBraceIndex))), u5 = o3.highlightSource(u5);
      let f4 = String(u5.lastLineNumber).length;
      if (s5.contextLines = u5.mapLines((g3, h4) => o3.gray(String(h4).padStart(f4)) + " " + g3).mapLines((g3) => o3.dim(g3)).prependSymbolAt(a5.lineNumber, o3.bold(o3.red("\u2192"))), i4) {
        let g3 = p5 + f4 + 1;
        g3 += 2, s5.callArguments = (0, Us.default)(i4, g3).slice(g3);
      }
    }
    return s5;
  }
  function Ip(e4) {
    let t4 = Object.keys(zt.ModelAction).join("|"), n4 = new RegExp(String.raw`\.(${t4})\(`).exec(e4);
    if (n4) {
      let i4 = n4.index + n4[0].length, o3 = e4.lastIndexOf(" ", n4.index) + 1;
      return { code: e4.slice(o3, i4), openingBraceIndex: i4 };
    }
    return null;
  }
  function Op(e4) {
    let t4 = 0;
    for (let r5 = 0;r5 < e4.length; r5++) {
      if (e4.charAt(r5) !== " ")
        return t4;
      t4++;
    }
    return t4;
  }
  function kp({ functionName: e4, location: t4, message: r5, isPanic: n4, contextLines: i4, callArguments: o3 }, s5) {
    let a5 = [""], l4 = t4 ? " in" : ":";
    if (n4 ? (a5.push(s5.red(`Oops, an unknown error occurred! This is ${s5.bold("on us")}, you did nothing wrong.`)), a5.push(s5.red(`It occurred in the ${s5.bold(`\`${e4}\``)} invocation${l4}`))) : a5.push(s5.red(`Invalid ${s5.bold(`\`${e4}\``)} invocation${l4}`)), t4 && a5.push(s5.underline(Dp(t4))), i4) {
      a5.push("");
      let u5 = [i4.toString()];
      o3 && (u5.push(o3), u5.push(s5.dim(")"))), a5.push(u5.join("")), o3 && a5.push("");
    } else
      a5.push(""), o3 && a5.push(o3), a5.push("");
    return a5.push(r5), a5.join(`
`);
  }
  function Dp(e4) {
    let t4 = [e4.fileName];
    return e4.lineNumber && t4.push(String(e4.lineNumber)), e4.columnNumber && t4.push(String(e4.columnNumber)), t4.join(":");
  }
  function cn2(e4) {
    let t4 = e4.showColors ? Rp : Cp, r5;
    return r5 = Ap(e4, t4), kp(r5, t4);
  }
  var Ys = D3(_i());
  function Hs(e4, t4, r5) {
    let n4 = Ws(e4), i4 = _p(n4), o3 = Lp(i4);
    o3 ? pn(o3, t4, r5) : t4.addErrorMessage(() => "Unknown error");
  }
  function Ws(e4) {
    return e4.errors.flatMap((t4) => t4.kind === "Union" ? Ws(t4) : [t4]);
  }
  function _p(e4) {
    let t4 = new Map, r5 = [];
    for (let n4 of e4) {
      if (n4.kind !== "InvalidArgumentType") {
        r5.push(n4);
        continue;
      }
      let i4 = `${n4.selectionPath.join(".")}:${n4.argumentPath.join(".")}`, o3 = t4.get(i4);
      o3 ? t4.set(i4, { ...n4, argument: { ...n4.argument, typeNames: Np(o3.argument.typeNames, n4.argument.typeNames) } }) : t4.set(i4, n4);
    }
    return r5.push(...t4.values()), r5;
  }
  function Np(e4, t4) {
    return [...new Set(e4.concat(t4))];
  }
  function Lp(e4) {
    return Ci(e4, (t4, r5) => {
      let n4 = Gs(t4), i4 = Gs(r5);
      return n4 !== i4 ? n4 - i4 : Js(t4) - Js(r5);
    });
  }
  function Gs(e4) {
    let t4 = 0;
    return Array.isArray(e4.selectionPath) && (t4 += e4.selectionPath.length), Array.isArray(e4.argumentPath) && (t4 += e4.argumentPath.length), t4;
  }
  function Js(e4) {
    switch (e4.kind) {
      case "InvalidArgumentValue":
      case "ValueTooLarge":
        return 20;
      case "InvalidArgumentType":
        return 10;
      case "RequiredArgumentMissing":
        return -10;
      default:
        return 0;
    }
  }
  var pe2 = class {
    constructor(t4, r5) {
      this.name = t4;
      this.value = r5;
      this.isRequired = false;
    }
    makeRequired() {
      return this.isRequired = true, this;
    }
    write(t4) {
      let { colors: { green: r5 } } = t4.context;
      t4.addMarginSymbol(r5(this.isRequired ? "+" : "?")), t4.write(r5(this.name)), this.isRequired || t4.write(r5("?")), t4.write(r5(": ")), typeof this.value == "string" ? t4.write(r5(this.value)) : t4.write(this.value);
    }
  };
  var Pt = class {
    constructor(t4 = 0, r5) {
      this.context = r5;
      this.lines = [];
      this.currentLine = "";
      this.currentIndent = 0;
      this.currentIndent = t4;
    }
    write(t4) {
      return typeof t4 == "string" ? this.currentLine += t4 : t4.write(this), this;
    }
    writeJoined(t4, r5, n4 = (i4, o3) => o3.write(i4)) {
      let i4 = r5.length - 1;
      for (let o3 = 0;o3 < r5.length; o3++)
        n4(r5[o3], this), o3 !== i4 && this.write(t4);
      return this;
    }
    writeLine(t4) {
      return this.write(t4).newLine();
    }
    newLine() {
      this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = undefined;
      let t4 = this.afterNextNewLineCallback;
      return this.afterNextNewLineCallback = undefined, t4?.(), this;
    }
    withIndent(t4) {
      return this.indent(), t4(this), this.unindent(), this;
    }
    afterNextNewline(t4) {
      return this.afterNextNewLineCallback = t4, this;
    }
    indent() {
      return this.currentIndent++, this;
    }
    unindent() {
      return this.currentIndent > 0 && this.currentIndent--, this;
    }
    addMarginSymbol(t4) {
      return this.marginSymbol = t4, this;
    }
    toString() {
      return this.lines.concat(this.indentedCurrentLine()).join(`
`);
    }
    getCurrentLineLength() {
      return this.currentLine.length;
    }
    indentedCurrentLine() {
      let t4 = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
      return this.marginSymbol ? this.marginSymbol + t4.slice(1) : t4;
    }
  };
  var dn = class {
    constructor(t4) {
      this.value = t4;
    }
    write(t4) {
      t4.write(this.value);
    }
    markAsError() {
      this.value.markAsError();
    }
  };
  var mn = (e4) => e4;
  var fn = { bold: mn, red: mn, green: mn, dim: mn, enabled: false };
  var Ks = { bold: W3, red: de2, green: Ve, dim: ke, enabled: true };
  var Tt = { write(e4) {
    e4.writeLine(",");
  } };
  var Pe = class {
    constructor(t4) {
      this.contents = t4;
      this.isUnderlined = false;
      this.color = (t5) => t5;
    }
    underline() {
      return this.isUnderlined = true, this;
    }
    setColor(t4) {
      return this.color = t4, this;
    }
    write(t4) {
      let r5 = t4.getCurrentLineLength();
      t4.write(this.color(this.contents)), this.isUnderlined && t4.afterNextNewline(() => {
        t4.write(" ".repeat(r5)).writeLine(this.color("~".repeat(this.contents.length)));
      });
    }
  };
  var ze = class {
    constructor() {
      this.hasError = false;
    }
    markAsError() {
      return this.hasError = true, this;
    }
  };
  var Rt = class extends ze {
    constructor() {
      super(...arguments);
      this.items = [];
    }
    addItem(r5) {
      return this.items.push(new dn(r5)), this;
    }
    getField(r5) {
      return this.items[r5];
    }
    getPrintWidth() {
      return this.items.length === 0 ? 2 : Math.max(...this.items.map((n4) => n4.value.getPrintWidth())) + 2;
    }
    write(r5) {
      if (this.items.length === 0) {
        this.writeEmpty(r5);
        return;
      }
      this.writeWithItems(r5);
    }
    writeEmpty(r5) {
      let n4 = new Pe("[]");
      this.hasError && n4.setColor(r5.context.colors.red).underline(), r5.write(n4);
    }
    writeWithItems(r5) {
      let { colors: n4 } = r5.context;
      r5.writeLine("[").withIndent(() => r5.writeJoined(Tt, this.items).newLine()).write("]"), this.hasError && r5.afterNextNewline(() => {
        r5.writeLine(n4.red("~".repeat(this.getPrintWidth())));
      });
    }
    asObject() {
    }
  };
  var Ct = class e4 extends ze {
    constructor() {
      super(...arguments);
      this.fields = {};
      this.suggestions = [];
    }
    addField(r5) {
      this.fields[r5.name] = r5;
    }
    addSuggestion(r5) {
      this.suggestions.push(r5);
    }
    getField(r5) {
      return this.fields[r5];
    }
    getDeepField(r5) {
      let [n4, ...i4] = r5, o3 = this.getField(n4);
      if (!o3)
        return;
      let s5 = o3;
      for (let a5 of i4) {
        let l4;
        if (s5.value instanceof e4 ? l4 = s5.value.getField(a5) : s5.value instanceof Rt && (l4 = s5.value.getField(Number(a5))), !l4)
          return;
        s5 = l4;
      }
      return s5;
    }
    getDeepFieldValue(r5) {
      return r5.length === 0 ? this : this.getDeepField(r5)?.value;
    }
    hasField(r5) {
      return !!this.getField(r5);
    }
    removeAllFields() {
      this.fields = {};
    }
    removeField(r5) {
      delete this.fields[r5];
    }
    getFields() {
      return this.fields;
    }
    isEmpty() {
      return Object.keys(this.fields).length === 0;
    }
    getFieldValue(r5) {
      return this.getField(r5)?.value;
    }
    getDeepSubSelectionValue(r5) {
      let n4 = this;
      for (let i4 of r5) {
        if (!(n4 instanceof e4))
          return;
        let o3 = n4.getSubSelectionValue(i4);
        if (!o3)
          return;
        n4 = o3;
      }
      return n4;
    }
    getDeepSelectionParent(r5) {
      let n4 = this.getSelectionParent();
      if (!n4)
        return;
      let i4 = n4;
      for (let o3 of r5) {
        let s5 = i4.value.getFieldValue(o3);
        if (!s5 || !(s5 instanceof e4))
          return;
        let a5 = s5.getSelectionParent();
        if (!a5)
          return;
        i4 = a5;
      }
      return i4;
    }
    getSelectionParent() {
      let r5 = this.getField("select")?.value.asObject();
      if (r5)
        return { kind: "select", value: r5 };
      let n4 = this.getField("include")?.value.asObject();
      if (n4)
        return { kind: "include", value: n4 };
    }
    getSubSelectionValue(r5) {
      return this.getSelectionParent()?.value.fields[r5].value;
    }
    getPrintWidth() {
      let r5 = Object.values(this.fields);
      return r5.length == 0 ? 2 : Math.max(...r5.map((i4) => i4.getPrintWidth())) + 2;
    }
    write(r5) {
      let n4 = Object.values(this.fields);
      if (n4.length === 0 && this.suggestions.length === 0) {
        this.writeEmpty(r5);
        return;
      }
      this.writeWithContents(r5, n4);
    }
    asObject() {
      return this;
    }
    writeEmpty(r5) {
      let n4 = new Pe("{}");
      this.hasError && n4.setColor(r5.context.colors.red).underline(), r5.write(n4);
    }
    writeWithContents(r5, n4) {
      r5.writeLine("{").withIndent(() => {
        r5.writeJoined(Tt, [...n4, ...this.suggestions]).newLine();
      }), r5.write("}"), this.hasError && r5.afterNextNewline(() => {
        r5.writeLine(r5.context.colors.red("~".repeat(this.getPrintWidth())));
      });
    }
  };
  var H2 = class extends ze {
    constructor(r5) {
      super();
      this.text = r5;
    }
    getPrintWidth() {
      return this.text.length;
    }
    write(r5) {
      let n4 = new Pe(this.text);
      this.hasError && n4.underline().setColor(r5.context.colors.red), r5.write(n4);
    }
    asObject() {
    }
  };
  var nr = class {
    constructor() {
      this.fields = [];
    }
    addField(t4, r5) {
      return this.fields.push({ write(n4) {
        let { green: i4, dim: o3 } = n4.context.colors;
        n4.write(i4(o3(`${t4}: ${r5}`))).addMarginSymbol(i4(o3("+")));
      } }), this;
    }
    write(t4) {
      let { colors: { green: r5 } } = t4.context;
      t4.writeLine(r5("{")).withIndent(() => {
        t4.writeJoined(Tt, this.fields).newLine();
      }).write(r5("}")).addMarginSymbol(r5("+"));
    }
  };
  function pn(e4, t4, r5) {
    switch (e4.kind) {
      case "MutuallyExclusiveFields":
        Mp(e4, t4);
        break;
      case "IncludeOnScalar":
        $p(e4, t4);
        break;
      case "EmptySelection":
        qp(e4, t4, r5);
        break;
      case "UnknownSelectionField":
        Up(e4, t4);
        break;
      case "InvalidSelectionValue":
        Qp(e4, t4);
        break;
      case "UnknownArgument":
        Gp(e4, t4);
        break;
      case "UnknownInputField":
        Jp(e4, t4);
        break;
      case "RequiredArgumentMissing":
        Hp(e4, t4);
        break;
      case "InvalidArgumentType":
        Wp(e4, t4);
        break;
      case "InvalidArgumentValue":
        Kp(e4, t4);
        break;
      case "ValueTooLarge":
        Yp(e4, t4);
        break;
      case "SomeFieldsMissing":
        zp(e4, t4);
        break;
      case "TooManyFieldsGiven":
        Zp(e4, t4);
        break;
      case "Union":
        Hs(e4, t4, r5);
        break;
      default:
        throw new Error("not implemented: " + e4.kind);
    }
  }
  function Mp(e4, t4) {
    let r5 = t4.arguments.getDeepSubSelectionValue(e4.selectionPath)?.asObject();
    r5 && (r5.getField(e4.firstField)?.markAsError(), r5.getField(e4.secondField)?.markAsError()), t4.addErrorMessage((n4) => `Please ${n4.bold("either")} use ${n4.green(`\`${e4.firstField}\``)} or ${n4.green(`\`${e4.secondField}\``)}, but ${n4.red("not both")} at the same time.`);
  }
  function $p(e4, t4) {
    let [r5, n4] = ir(e4.selectionPath), i4 = e4.outputType, o3 = t4.arguments.getDeepSelectionParent(r5)?.value;
    if (o3 && (o3.getField(n4)?.markAsError(), i4))
      for (let s5 of i4.fields)
        s5.isRelation && o3.addSuggestion(new pe2(s5.name, "true"));
    t4.addErrorMessage((s5) => {
      let a5 = `Invalid scalar field ${s5.red(`\`${n4}\``)} for ${s5.bold("include")} statement`;
      return i4 ? a5 += ` on model ${s5.bold(i4.name)}. ${or(s5)}` : a5 += ".", a5 += `
Note that ${s5.bold("include")} statements only accept relation fields.`, a5;
    });
  }
  function qp(e4, t4, r5) {
    let n4 = t4.arguments.getDeepSubSelectionValue(e4.selectionPath)?.asObject();
    if (n4) {
      let i4 = n4.getField("omit")?.value.asObject();
      if (i4) {
        Vp(e4, t4, i4);
        return;
      }
      if (n4.hasField("select")) {
        jp(e4, t4);
        return;
      }
    }
    if (r5?.[wt(e4.outputType.name)]) {
      Bp(e4, t4);
      return;
    }
    t4.addErrorMessage(() => `Unknown field at "${e4.selectionPath.join(".")} selection"`);
  }
  function Vp(e4, t4, r5) {
    r5.removeAllFields();
    for (let n4 of e4.outputType.fields)
      r5.addSuggestion(new pe2(n4.name, "false"));
    t4.addErrorMessage((n4) => `The ${n4.red("omit")} statement includes every field of the model ${n4.bold(e4.outputType.name)}. At least one field must be included in the result`);
  }
  function jp(e4, t4) {
    let r5 = e4.outputType, n4 = t4.arguments.getDeepSelectionParent(e4.selectionPath)?.value, i4 = n4?.isEmpty() ?? false;
    n4 && (n4.removeAllFields(), Xs(n4, r5)), t4.addErrorMessage((o3) => i4 ? `The ${o3.red("`select`")} statement for type ${o3.bold(r5.name)} must not be empty. ${or(o3)}` : `The ${o3.red("`select`")} statement for type ${o3.bold(r5.name)} needs ${o3.bold("at least one truthy value")}.`);
  }
  function Bp(e4, t4) {
    let r5 = new nr;
    for (let i4 of e4.outputType.fields)
      i4.isRelation || r5.addField(i4.name, "false");
    let n4 = new pe2("omit", r5).makeRequired();
    if (e4.selectionPath.length === 0)
      t4.arguments.addSuggestion(n4);
    else {
      let [i4, o3] = ir(e4.selectionPath), a5 = t4.arguments.getDeepSelectionParent(i4)?.value.asObject()?.getField(o3);
      if (a5) {
        let l4 = a5?.value.asObject() ?? new Ct;
        l4.addSuggestion(n4), a5.value = l4;
      }
    }
    t4.addErrorMessage((i4) => `The global ${i4.red("omit")} configuration excludes every field of the model ${i4.bold(e4.outputType.name)}. At least one field must be included in the result`);
  }
  function Up(e4, t4) {
    let r5 = ea(e4.selectionPath, t4);
    if (r5.parentKind !== "unknown") {
      r5.field.markAsError();
      let n4 = r5.parent;
      switch (r5.parentKind) {
        case "select":
          Xs(n4, e4.outputType);
          break;
        case "include":
          Xp(n4, e4.outputType);
          break;
        case "omit":
          ed(n4, e4.outputType);
          break;
      }
    }
    t4.addErrorMessage((n4) => {
      let i4 = [`Unknown field ${n4.red(`\`${r5.fieldName}\``)}`];
      return r5.parentKind !== "unknown" && i4.push(`for ${n4.bold(r5.parentKind)} statement`), i4.push(`on model ${n4.bold(`\`${e4.outputType.name}\``)}.`), i4.push(or(n4)), i4.join(" ");
    });
  }
  function Qp(e4, t4) {
    let r5 = ea(e4.selectionPath, t4);
    r5.parentKind !== "unknown" && r5.field.value.markAsError(), t4.addErrorMessage((n4) => `Invalid value for selection field \`${n4.red(r5.fieldName)}\`: ${e4.underlyingError}`);
  }
  function Gp(e4, t4) {
    let r5 = e4.argumentPath[0], n4 = t4.arguments.getDeepSubSelectionValue(e4.selectionPath)?.asObject();
    n4 && (n4.getField(r5)?.markAsError(), td(n4, e4.arguments)), t4.addErrorMessage((i4) => zs(i4, r5, e4.arguments.map((o3) => o3.name)));
  }
  function Jp(e4, t4) {
    let [r5, n4] = ir(e4.argumentPath), i4 = t4.arguments.getDeepSubSelectionValue(e4.selectionPath)?.asObject();
    if (i4) {
      i4.getDeepField(e4.argumentPath)?.markAsError();
      let o3 = i4.getDeepFieldValue(r5)?.asObject();
      o3 && ta(o3, e4.inputType);
    }
    t4.addErrorMessage((o3) => zs(o3, n4, e4.inputType.fields.map((s5) => s5.name)));
  }
  function zs(e4, t4, r5) {
    let n4 = [`Unknown argument \`${e4.red(t4)}\`.`], i4 = nd(t4, r5);
    return i4 && n4.push(`Did you mean \`${e4.green(i4)}\`?`), r5.length > 0 && n4.push(or(e4)), n4.join(" ");
  }
  function Hp(e4, t4) {
    let r5;
    t4.addErrorMessage((l4) => r5?.value instanceof H2 && r5.value.text === "null" ? `Argument \`${l4.green(o3)}\` must not be ${l4.red("null")}.` : `Argument \`${l4.green(o3)}\` is missing.`);
    let n4 = t4.arguments.getDeepSubSelectionValue(e4.selectionPath)?.asObject();
    if (!n4)
      return;
    let [i4, o3] = ir(e4.argumentPath), s5 = new nr, a5 = n4.getDeepFieldValue(i4)?.asObject();
    if (a5)
      if (r5 = a5.getField(o3), r5 && a5.removeField(o3), e4.inputTypes.length === 1 && e4.inputTypes[0].kind === "object") {
        for (let l4 of e4.inputTypes[0].fields)
          s5.addField(l4.name, l4.typeNames.join(" | "));
        a5.addSuggestion(new pe2(o3, s5).makeRequired());
      } else {
        let l4 = e4.inputTypes.map(Zs).join(" | ");
        a5.addSuggestion(new pe2(o3, l4).makeRequired());
      }
  }
  function Zs(e4) {
    return e4.kind === "list" ? `${Zs(e4.elementType)}[]` : e4.name;
  }
  function Wp(e4, t4) {
    let r5 = e4.argument.name, n4 = t4.arguments.getDeepSubSelectionValue(e4.selectionPath)?.asObject();
    n4 && n4.getDeepFieldValue(e4.argumentPath)?.markAsError(), t4.addErrorMessage((i4) => {
      let o3 = gn("or", e4.argument.typeNames.map((s5) => i4.green(s5)));
      return `Argument \`${i4.bold(r5)}\`: Invalid value provided. Expected ${o3}, provided ${i4.red(e4.inferredType)}.`;
    });
  }
  function Kp(e4, t4) {
    let r5 = e4.argument.name, n4 = t4.arguments.getDeepSubSelectionValue(e4.selectionPath)?.asObject();
    n4 && n4.getDeepFieldValue(e4.argumentPath)?.markAsError(), t4.addErrorMessage((i4) => {
      let o3 = [`Invalid value for argument \`${i4.bold(r5)}\``];
      if (e4.underlyingError && o3.push(`: ${e4.underlyingError}`), o3.push("."), e4.argument.typeNames.length > 0) {
        let s5 = gn("or", e4.argument.typeNames.map((a5) => i4.green(a5)));
        o3.push(` Expected ${s5}.`);
      }
      return o3.join("");
    });
  }
  function Yp(e4, t4) {
    let r5 = e4.argument.name, n4 = t4.arguments.getDeepSubSelectionValue(e4.selectionPath)?.asObject(), i4;
    if (n4) {
      let s5 = n4.getDeepField(e4.argumentPath)?.value;
      s5?.markAsError(), s5 instanceof H2 && (i4 = s5.text);
    }
    t4.addErrorMessage((o3) => {
      let s5 = ["Unable to fit value"];
      return i4 && s5.push(o3.red(i4)), s5.push(`into a 64-bit signed integer for field \`${o3.bold(r5)}\``), s5.join(" ");
    });
  }
  function zp(e4, t4) {
    let r5 = e4.argumentPath[e4.argumentPath.length - 1], n4 = t4.arguments.getDeepSubSelectionValue(e4.selectionPath)?.asObject();
    if (n4) {
      let i4 = n4.getDeepFieldValue(e4.argumentPath)?.asObject();
      i4 && ta(i4, e4.inputType);
    }
    t4.addErrorMessage((i4) => {
      let o3 = [`Argument \`${i4.bold(r5)}\` of type ${i4.bold(e4.inputType.name)} needs`];
      return e4.constraints.minFieldCount === 1 ? e4.constraints.requiredFields ? o3.push(`${i4.green("at least one of")} ${gn("or", e4.constraints.requiredFields.map((s5) => `\`${i4.bold(s5)}\``))} arguments.`) : o3.push(`${i4.green("at least one")} argument.`) : o3.push(`${i4.green(`at least ${e4.constraints.minFieldCount}`)} arguments.`), o3.push(or(i4)), o3.join(" ");
    });
  }
  function Zp(e4, t4) {
    let r5 = e4.argumentPath[e4.argumentPath.length - 1], n4 = t4.arguments.getDeepSubSelectionValue(e4.selectionPath)?.asObject(), i4 = [];
    if (n4) {
      let o3 = n4.getDeepFieldValue(e4.argumentPath)?.asObject();
      o3 && (o3.markAsError(), i4 = Object.keys(o3.getFields()));
    }
    t4.addErrorMessage((o3) => {
      let s5 = [`Argument \`${o3.bold(r5)}\` of type ${o3.bold(e4.inputType.name)} needs`];
      return e4.constraints.minFieldCount === 1 && e4.constraints.maxFieldCount == 1 ? s5.push(`${o3.green("exactly one")} argument,`) : e4.constraints.maxFieldCount == 1 ? s5.push(`${o3.green("at most one")} argument,`) : s5.push(`${o3.green(`at most ${e4.constraints.maxFieldCount}`)} arguments,`), s5.push(`but you provided ${gn("and", i4.map((a5) => o3.red(a5)))}. Please choose`), e4.constraints.maxFieldCount === 1 ? s5.push("one.") : s5.push(`${e4.constraints.maxFieldCount}.`), s5.join(" ");
    });
  }
  function Xs(e4, t4) {
    for (let r5 of t4.fields)
      e4.hasField(r5.name) || e4.addSuggestion(new pe2(r5.name, "true"));
  }
  function Xp(e4, t4) {
    for (let r5 of t4.fields)
      r5.isRelation && !e4.hasField(r5.name) && e4.addSuggestion(new pe2(r5.name, "true"));
  }
  function ed(e4, t4) {
    for (let r5 of t4.fields)
      !e4.hasField(r5.name) && !r5.isRelation && e4.addSuggestion(new pe2(r5.name, "true"));
  }
  function td(e4, t4) {
    for (let r5 of t4)
      e4.hasField(r5.name) || e4.addSuggestion(new pe2(r5.name, r5.typeNames.join(" | ")));
  }
  function ea(e4, t4) {
    let [r5, n4] = ir(e4), i4 = t4.arguments.getDeepSubSelectionValue(r5)?.asObject();
    if (!i4)
      return { parentKind: "unknown", fieldName: n4 };
    let o3 = i4.getFieldValue("select")?.asObject(), s5 = i4.getFieldValue("include")?.asObject(), a5 = i4.getFieldValue("omit")?.asObject(), l4 = o3?.getField(n4);
    return o3 && l4 ? { parentKind: "select", parent: o3, field: l4, fieldName: n4 } : (l4 = s5?.getField(n4), s5 && l4 ? { parentKind: "include", field: l4, parent: s5, fieldName: n4 } : (l4 = a5?.getField(n4), a5 && l4 ? { parentKind: "omit", field: l4, parent: a5, fieldName: n4 } : { parentKind: "unknown", fieldName: n4 }));
  }
  function ta(e4, t4) {
    if (t4.kind === "object")
      for (let r5 of t4.fields)
        e4.hasField(r5.name) || e4.addSuggestion(new pe2(r5.name, r5.typeNames.join(" | ")));
  }
  function ir(e4) {
    let t4 = [...e4], r5 = t4.pop();
    if (!r5)
      throw new Error("unexpected empty path");
    return [t4, r5];
  }
  function or({ green: e4, enabled: t4 }) {
    return "Available options are " + (t4 ? `listed in ${e4("green")}` : "marked with ?") + ".";
  }
  function gn(e4, t4) {
    if (t4.length === 1)
      return t4[0];
    let r5 = [...t4], n4 = r5.pop();
    return `${r5.join(", ")} ${e4} ${n4}`;
  }
  var rd = 3;
  function nd(e4, t4) {
    let r5 = 1 / 0, n4;
    for (let i4 of t4) {
      let o3 = (0, Ys.default)(e4, i4);
      o3 > rd || o3 < r5 && (r5 = o3, n4 = i4);
    }
    return n4;
  }
  function ra(e4) {
    return e4.substring(0, 1).toLowerCase() + e4.substring(1);
  }
  var sr = class {
    constructor(t4, r5, n4, i4, o3) {
      this.modelName = t4, this.name = r5, this.typeName = n4, this.isList = i4, this.isEnum = o3;
    }
    _toGraphQLInputType() {
      let t4 = this.isList ? "List" : "", r5 = this.isEnum ? "Enum" : "";
      return `${t4}${r5}${this.typeName}FieldRefInput<${this.modelName}>`;
    }
  };
  function St(e4) {
    return e4 instanceof sr;
  }
  var hn = Symbol();
  var Ni = new WeakMap;
  var $e = class {
    constructor(t4) {
      t4 === hn ? Ni.set(this, `Prisma.${this._getName()}`) : Ni.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
    }
    _getName() {
      return this.constructor.name;
    }
    toString() {
      return Ni.get(this);
    }
  };
  var ar2 = class extends $e {
    _getNamespace() {
      return "NullTypes";
    }
  };
  var lr = class extends ar2 {
  };
  Li(lr, "DbNull");
  var ur = class extends ar2 {
  };
  Li(ur, "JsonNull");
  var cr2 = class extends ar2 {
  };
  Li(cr2, "AnyNull");
  var yn = { classes: { DbNull: lr, JsonNull: ur, AnyNull: cr2 }, instances: { DbNull: new lr(hn), JsonNull: new ur(hn), AnyNull: new cr2(hn) } };
  function Li(e4, t4) {
    Object.defineProperty(e4, "name", { value: t4, configurable: true });
  }
  var na = ": ";
  var En = class {
    constructor(t4, r5) {
      this.name = t4;
      this.value = r5;
      this.hasError = false;
    }
    markAsError() {
      this.hasError = true;
    }
    getPrintWidth() {
      return this.name.length + this.value.getPrintWidth() + na.length;
    }
    write(t4) {
      let r5 = new Pe(this.name);
      this.hasError && r5.underline().setColor(t4.context.colors.red), t4.write(r5).write(na).write(this.value);
    }
  };
  var Fi = class {
    constructor(t4) {
      this.errorMessages = [];
      this.arguments = t4;
    }
    write(t4) {
      t4.write(this.arguments);
    }
    addErrorMessage(t4) {
      this.errorMessages.push(t4);
    }
    renderAllMessages(t4) {
      return this.errorMessages.map((r5) => r5(t4)).join(`
`);
    }
  };
  function At(e4) {
    return new Fi(ia(e4));
  }
  function ia(e4) {
    let t4 = new Ct;
    for (let [r5, n4] of Object.entries(e4)) {
      let i4 = new En(r5, oa(n4));
      t4.addField(i4);
    }
    return t4;
  }
  function oa(e4) {
    if (typeof e4 == "string")
      return new H2(JSON.stringify(e4));
    if (typeof e4 == "number" || typeof e4 == "boolean")
      return new H2(String(e4));
    if (typeof e4 == "bigint")
      return new H2(`${e4}n`);
    if (e4 === null)
      return new H2("null");
    if (e4 === undefined)
      return new H2("undefined");
    if (vt(e4))
      return new H2(`new Prisma.Decimal("${e4.toFixed()}")`);
    if (e4 instanceof Uint8Array)
      return Buffer.isBuffer(e4) ? new H2(`Buffer.alloc(${e4.byteLength})`) : new H2(`new Uint8Array(${e4.byteLength})`);
    if (e4 instanceof Date) {
      let t4 = an2(e4) ? e4.toISOString() : "Invalid Date";
      return new H2(`new Date("${t4}")`);
    }
    return e4 instanceof $e ? new H2(`Prisma.${e4._getName()}`) : St(e4) ? new H2(`prisma.${ra(e4.modelName)}.$fields.${e4.name}`) : Array.isArray(e4) ? id(e4) : typeof e4 == "object" ? ia(e4) : new H2(Object.prototype.toString.call(e4));
  }
  function id(e4) {
    let t4 = new Rt;
    for (let r5 of e4)
      t4.addItem(oa(r5));
    return t4;
  }
  function bn2(e4, t4) {
    let r5 = t4 === "pretty" ? Ks : fn, n4 = e4.renderAllMessages(r5), i4 = new Pt(0, { colors: r5 }).write(e4).toString();
    return { message: n4, args: i4 };
  }
  function wn({ args: e4, errors: t4, errorFormat: r5, callsite: n4, originalMethod: i4, clientVersion: o3, globalOmit: s5 }) {
    let a5 = At(e4);
    for (let p5 of t4)
      pn(p5, a5, s5);
    let { message: l4, args: u5 } = bn2(a5, r5), c5 = cn2({ message: l4, callsite: n4, originalMethod: i4, showColors: r5 === "pretty", callArguments: u5 });
    throw new te(c5, { clientVersion: o3 });
  }
  var Te = class {
    constructor() {
      this._map = new Map;
    }
    get(t4) {
      return this._map.get(t4)?.value;
    }
    set(t4, r5) {
      this._map.set(t4, { value: r5 });
    }
    getOrCreate(t4, r5) {
      let n4 = this._map.get(t4);
      if (n4)
        return n4.value;
      let i4 = r5();
      return this.set(t4, i4), i4;
    }
  };
  function pr(e4) {
    let t4;
    return { get() {
      return t4 || (t4 = { value: e4() }), t4.value;
    } };
  }
  function Re(e4) {
    return e4.replace(/^./, (t4) => t4.toLowerCase());
  }
  function aa2(e4, t4, r5) {
    let n4 = Re(r5);
    return !t4.result || !(t4.result.$allModels || t4.result[n4]) ? e4 : od({ ...e4, ...sa(t4.name, e4, t4.result.$allModels), ...sa(t4.name, e4, t4.result[n4]) });
  }
  function od(e4) {
    let t4 = new Te, r5 = (n4, i4) => t4.getOrCreate(n4, () => i4.has(n4) ? [n4] : (i4.add(n4), e4[n4] ? e4[n4].needs.flatMap((o3) => r5(o3, i4)) : [n4]));
    return ht(e4, (n4) => ({ ...n4, needs: r5(n4.name, new Set) }));
  }
  function sa(e4, t4, r5) {
    return r5 ? ht(r5, ({ needs: n4, compute: i4 }, o3) => ({ name: o3, needs: n4 ? Object.keys(n4).filter((s5) => n4[s5]) : [], compute: sd(t4, o3, i4) })) : {};
  }
  function sd(e4, t4, r5) {
    let n4 = e4?.[t4]?.compute;
    return n4 ? (i4) => r5({ ...i4, [t4]: n4(i4) }) : r5;
  }
  function la(e4, t4) {
    if (!t4)
      return e4;
    let r5 = { ...e4 };
    for (let n4 of Object.values(t4))
      if (e4[n4.name])
        for (let i4 of n4.needs)
          r5[i4] = true;
    return r5;
  }
  function ua(e4, t4) {
    if (!t4)
      return e4;
    let r5 = { ...e4 };
    for (let n4 of Object.values(t4))
      if (!e4[n4.name])
        for (let i4 of n4.needs)
          delete r5[i4];
    return r5;
  }
  var xn = class {
    constructor(t4, r5) {
      this.extension = t4;
      this.previous = r5;
      this.computedFieldsCache = new Te;
      this.modelExtensionsCache = new Te;
      this.queryCallbacksCache = new Te;
      this.clientExtensions = pr(() => this.extension.client ? { ...this.previous?.getAllClientExtensions(), ...this.extension.client } : this.previous?.getAllClientExtensions());
      this.batchCallbacks = pr(() => {
        let t5 = this.previous?.getAllBatchQueryCallbacks() ?? [], r6 = this.extension.query?.$__internalBatch;
        return r6 ? t5.concat(r6) : t5;
      });
    }
    getAllComputedFields(t4) {
      return this.computedFieldsCache.getOrCreate(t4, () => aa2(this.previous?.getAllComputedFields(t4), this.extension, t4));
    }
    getAllClientExtensions() {
      return this.clientExtensions.get();
    }
    getAllModelExtensions(t4) {
      return this.modelExtensionsCache.getOrCreate(t4, () => {
        let r5 = Re(t4);
        return !this.extension.model || !(this.extension.model[r5] || this.extension.model.$allModels) ? this.previous?.getAllModelExtensions(t4) : { ...this.previous?.getAllModelExtensions(t4), ...this.extension.model.$allModels, ...this.extension.model[r5] };
      });
    }
    getAllQueryCallbacks(t4, r5) {
      return this.queryCallbacksCache.getOrCreate(`${t4}:${r5}`, () => {
        let n4 = this.previous?.getAllQueryCallbacks(t4, r5) ?? [], i4 = [], o3 = this.extension.query;
        return !o3 || !(o3[t4] || o3.$allModels || o3[r5] || o3.$allOperations) ? n4 : (o3[t4] !== undefined && (o3[t4][r5] !== undefined && i4.push(o3[t4][r5]), o3[t4].$allOperations !== undefined && i4.push(o3[t4].$allOperations)), t4 !== "$none" && o3.$allModels !== undefined && (o3.$allModels[r5] !== undefined && i4.push(o3.$allModels[r5]), o3.$allModels.$allOperations !== undefined && i4.push(o3.$allModels.$allOperations)), o3[r5] !== undefined && i4.push(o3[r5]), o3.$allOperations !== undefined && i4.push(o3.$allOperations), n4.concat(i4));
      });
    }
    getAllBatchQueryCallbacks() {
      return this.batchCallbacks.get();
    }
  };
  var It = class e4 {
    constructor(t4) {
      this.head = t4;
    }
    static empty() {
      return new e4;
    }
    static single(t4) {
      return new e4(new xn(t4));
    }
    isEmpty() {
      return this.head === undefined;
    }
    append(t4) {
      return new e4(new xn(t4, this.head));
    }
    getAllComputedFields(t4) {
      return this.head?.getAllComputedFields(t4);
    }
    getAllClientExtensions() {
      return this.head?.getAllClientExtensions();
    }
    getAllModelExtensions(t4) {
      return this.head?.getAllModelExtensions(t4);
    }
    getAllQueryCallbacks(t4, r5) {
      return this.head?.getAllQueryCallbacks(t4, r5) ?? [];
    }
    getAllBatchQueryCallbacks() {
      return this.head?.getAllBatchQueryCallbacks() ?? [];
    }
  };
  var ca2 = Symbol();
  var dr = class {
    constructor(t4) {
      if (t4 !== ca2)
        throw new Error("Skip instance can not be constructed directly");
    }
    ifUndefined(t4) {
      return t4 === undefined ? vn : t4;
    }
  };
  var vn = new dr(ca2);
  function Ce(e4) {
    return e4 instanceof dr;
  }
  var ad2 = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", createManyAndReturn: "createManyAndReturn", update: "updateOne", updateMany: "updateMany", updateManyAndReturn: "updateManyAndReturn", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
  var pa = "explicitly `undefined` values are not allowed";
  function Pn({ modelName: e4, action: t4, args: r5, runtimeDataModel: n4, extensions: i4 = It.empty(), callsite: o3, clientMethod: s5, errorFormat: a5, clientVersion: l4, previewFeatures: u5, globalOmit: c5 }) {
    let p5 = new Mi({ runtimeDataModel: n4, modelName: e4, action: t4, rootArgs: r5, callsite: o3, extensions: i4, selectionPath: [], argumentPath: [], originalMethod: s5, errorFormat: a5, clientVersion: l4, previewFeatures: u5, globalOmit: c5 });
    return { modelName: e4, action: ad2[t4], query: mr(r5, p5) };
  }
  function mr({ select: e4, include: t4, ...r5 } = {}, n4) {
    let i4 = r5.omit;
    return delete r5.omit, { arguments: ma(r5, n4), selection: ld(e4, t4, i4, n4) };
  }
  function ld(e4, t4, r5, n4) {
    return e4 ? (t4 ? n4.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "include", secondField: "select", selectionPath: n4.getSelectionPath() }) : r5 && n4.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "omit", secondField: "select", selectionPath: n4.getSelectionPath() }), dd(e4, n4)) : ud(n4, t4, r5);
  }
  function ud(e4, t4, r5) {
    let n4 = {};
    return e4.modelOrType && !e4.isRawAction() && (n4.$composites = true, n4.$scalars = true), t4 && cd2(n4, t4, e4), pd(n4, r5, e4), n4;
  }
  function cd2(e4, t4, r5) {
    for (let [n4, i4] of Object.entries(t4)) {
      if (Ce(i4))
        continue;
      let o3 = r5.nestSelection(n4);
      if ($i(i4, o3), i4 === false || i4 === undefined) {
        e4[n4] = false;
        continue;
      }
      let s5 = r5.findField(n4);
      if (s5 && s5.kind !== "object" && r5.throwValidationError({ kind: "IncludeOnScalar", selectionPath: r5.getSelectionPath().concat(n4), outputType: r5.getOutputTypeDescription() }), s5) {
        e4[n4] = mr(i4 === true ? {} : i4, o3);
        continue;
      }
      if (i4 === true) {
        e4[n4] = true;
        continue;
      }
      e4[n4] = mr(i4, o3);
    }
  }
  function pd(e4, t4, r5) {
    let n4 = r5.getComputedFields(), i4 = { ...r5.getGlobalOmit(), ...t4 }, o3 = ua(i4, n4);
    for (let [s5, a5] of Object.entries(o3)) {
      if (Ce(a5))
        continue;
      $i(a5, r5.nestSelection(s5));
      let l4 = r5.findField(s5);
      n4?.[s5] && !l4 || (e4[s5] = !a5);
    }
  }
  function dd(e4, t4) {
    let r5 = {}, n4 = t4.getComputedFields(), i4 = la(e4, n4);
    for (let [o3, s5] of Object.entries(i4)) {
      if (Ce(s5))
        continue;
      let a5 = t4.nestSelection(o3);
      $i(s5, a5);
      let l4 = t4.findField(o3);
      if (!(n4?.[o3] && !l4)) {
        if (s5 === false || s5 === undefined || Ce(s5)) {
          r5[o3] = false;
          continue;
        }
        if (s5 === true) {
          l4?.kind === "object" ? r5[o3] = mr({}, a5) : r5[o3] = true;
          continue;
        }
        r5[o3] = mr(s5, a5);
      }
    }
    return r5;
  }
  function da(e4, t4) {
    if (e4 === null)
      return null;
    if (typeof e4 == "string" || typeof e4 == "number" || typeof e4 == "boolean")
      return e4;
    if (typeof e4 == "bigint")
      return { $type: "BigInt", value: String(e4) };
    if (xt(e4)) {
      if (an2(e4))
        return { $type: "DateTime", value: e4.toISOString() };
      t4.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t4.getSelectionPath(), argumentPath: t4.getArgumentPath(), argument: { name: t4.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
    }
    if (St(e4))
      return { $type: "FieldRef", value: { _ref: e4.name, _container: e4.modelName } };
    if (Array.isArray(e4))
      return md(e4, t4);
    if (ArrayBuffer.isView(e4)) {
      let { buffer: r5, byteOffset: n4, byteLength: i4 } = e4;
      return { $type: "Bytes", value: Buffer.from(r5, n4, i4).toString("base64") };
    }
    if (fd(e4))
      return e4.values;
    if (vt(e4))
      return { $type: "Decimal", value: e4.toFixed() };
    if (e4 instanceof $e) {
      if (e4 !== yn.instances[e4._getName()])
        throw new Error("Invalid ObjectEnumValue");
      return { $type: "Enum", value: e4._getName() };
    }
    if (gd(e4))
      return e4.toJSON();
    if (typeof e4 == "object")
      return ma(e4, t4);
    t4.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t4.getSelectionPath(), argumentPath: t4.getArgumentPath(), argument: { name: t4.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(e4)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
  }
  function ma(e4, t4) {
    if (e4.$type)
      return { $type: "Raw", value: e4 };
    let r5 = {};
    for (let n4 in e4) {
      let i4 = e4[n4], o3 = t4.nestArgument(n4);
      Ce(i4) || (i4 !== undefined ? r5[n4] = da(i4, o3) : t4.isPreviewFeatureOn("strictUndefinedChecks") && t4.throwValidationError({ kind: "InvalidArgumentValue", argumentPath: o3.getArgumentPath(), selectionPath: t4.getSelectionPath(), argument: { name: t4.getArgumentName(), typeNames: [] }, underlyingError: pa }));
    }
    return r5;
  }
  function md(e4, t4) {
    let r5 = [];
    for (let n4 = 0;n4 < e4.length; n4++) {
      let i4 = t4.nestArgument(String(n4)), o3 = e4[n4];
      if (o3 === undefined || Ce(o3)) {
        let s5 = o3 === undefined ? "undefined" : "Prisma.skip";
        t4.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: i4.getSelectionPath(), argumentPath: i4.getArgumentPath(), argument: { name: `${t4.getArgumentName()}[${n4}]`, typeNames: [] }, underlyingError: `Can not use \`${s5}\` value within array. Use \`null\` or filter out \`${s5}\` values` });
      }
      r5.push(da(o3, i4));
    }
    return r5;
  }
  function fd(e4) {
    return typeof e4 == "object" && e4 !== null && e4.__prismaRawParameters__ === true;
  }
  function gd(e4) {
    return typeof e4 == "object" && e4 !== null && typeof e4.toJSON == "function";
  }
  function $i(e4, t4) {
    e4 === undefined && t4.isPreviewFeatureOn("strictUndefinedChecks") && t4.throwValidationError({ kind: "InvalidSelectionValue", selectionPath: t4.getSelectionPath(), underlyingError: pa });
  }
  var Mi = class e4 {
    constructor(t4) {
      this.params = t4;
      this.params.modelName && (this.modelOrType = this.params.runtimeDataModel.models[this.params.modelName] ?? this.params.runtimeDataModel.types[this.params.modelName]);
    }
    throwValidationError(t4) {
      wn({ errors: [t4], originalMethod: this.params.originalMethod, args: this.params.rootArgs ?? {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion, globalOmit: this.params.globalOmit });
    }
    getSelectionPath() {
      return this.params.selectionPath;
    }
    getArgumentPath() {
      return this.params.argumentPath;
    }
    getArgumentName() {
      return this.params.argumentPath[this.params.argumentPath.length - 1];
    }
    getOutputTypeDescription() {
      if (!(!this.params.modelName || !this.modelOrType))
        return { name: this.params.modelName, fields: this.modelOrType.fields.map((t4) => ({ name: t4.name, typeName: "boolean", isRelation: t4.kind === "object" })) };
    }
    isRawAction() {
      return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
    }
    isPreviewFeatureOn(t4) {
      return this.params.previewFeatures.includes(t4);
    }
    getComputedFields() {
      if (this.params.modelName)
        return this.params.extensions.getAllComputedFields(this.params.modelName);
    }
    findField(t4) {
      return this.modelOrType?.fields.find((r5) => r5.name === t4);
    }
    nestSelection(t4) {
      let r5 = this.findField(t4), n4 = r5?.kind === "object" ? r5.type : undefined;
      return new e4({ ...this.params, modelName: n4, selectionPath: this.params.selectionPath.concat(t4) });
    }
    getGlobalOmit() {
      return this.params.modelName && this.shouldApplyGlobalOmit() ? this.params.globalOmit?.[wt(this.params.modelName)] ?? {} : {};
    }
    shouldApplyGlobalOmit() {
      switch (this.params.action) {
        case "findFirst":
        case "findFirstOrThrow":
        case "findUniqueOrThrow":
        case "findMany":
        case "upsert":
        case "findUnique":
        case "createManyAndReturn":
        case "create":
        case "update":
        case "updateManyAndReturn":
        case "delete":
          return true;
        case "executeRaw":
        case "aggregateRaw":
        case "runCommandRaw":
        case "findRaw":
        case "createMany":
        case "deleteMany":
        case "groupBy":
        case "updateMany":
        case "count":
        case "aggregate":
        case "queryRaw":
          return false;
        default:
          Fe(this.params.action, "Unknown action");
      }
    }
    nestArgument(t4) {
      return new e4({ ...this.params, argumentPath: this.params.argumentPath.concat(t4) });
    }
  };
  var Ot = class {
    constructor(t4) {
      this._engine = t4;
    }
    prometheus(t4) {
      return this._engine.metrics({ format: "prometheus", ...t4 });
    }
    json(t4) {
      return this._engine.metrics({ format: "json", ...t4 });
    }
  };
  function fa(e4) {
    return { models: qi(e4.models), enums: qi(e4.enums), types: qi(e4.types) };
  }
  function qi(e4) {
    let t4 = {};
    for (let { name: r5, ...n4 } of e4)
      t4[r5] = n4;
    return t4;
  }
  function ga(e4, t4) {
    let r5 = pr(() => hd(t4));
    Object.defineProperty(e4, "dmmf", { get: () => r5.get() });
  }
  function hd(e4) {
    return { datamodel: { models: Vi(e4.models), enums: Vi(e4.enums), types: Vi(e4.types) } };
  }
  function Vi(e4) {
    return Object.entries(e4).map(([t4, r5]) => ({ name: t4, ...r5 }));
  }
  var ji = new WeakMap;
  var Tn = "$$PrismaTypedSql";
  var Bi = class {
    constructor(t4, r5) {
      ji.set(this, { sql: t4, values: r5 }), Object.defineProperty(this, Tn, { value: Tn });
    }
    get sql() {
      return ji.get(this).sql;
    }
    get values() {
      return ji.get(this).values;
    }
  };
  function ha(e4) {
    return (...t4) => new Bi(e4, t4);
  }
  function ya(e4) {
    return e4 != null && e4[Tn] === Tn;
  }
  function fr(e4) {
    return { ok: false, error: e4, map() {
      return fr(e4);
    }, flatMap() {
      return fr(e4);
    } };
  }
  var Ui = class {
    constructor() {
      this.registeredErrors = [];
    }
    consumeError(t4) {
      return this.registeredErrors[t4];
    }
    registerNewError(t4) {
      let r5 = 0;
      for (;this.registeredErrors[r5] !== undefined; )
        r5++;
      return this.registeredErrors[r5] = { error: t4 }, r5;
    }
  };
  var Qi = (e4) => {
    let t4 = new Ui, r5 = Se(t4, e4.transactionContext.bind(e4)), n4 = { adapterName: e4.adapterName, errorRegistry: t4, queryRaw: Se(t4, e4.queryRaw.bind(e4)), executeRaw: Se(t4, e4.executeRaw.bind(e4)), provider: e4.provider, transactionContext: async (...i4) => (await r5(...i4)).map((s5) => yd(t4, s5)) };
    return e4.getConnectionInfo && (n4.getConnectionInfo = bd2(t4, e4.getConnectionInfo.bind(e4))), n4;
  };
  var yd = (e4, t4) => {
    let r5 = Se(e4, t4.startTransaction.bind(t4));
    return { adapterName: t4.adapterName, provider: t4.provider, queryRaw: Se(e4, t4.queryRaw.bind(t4)), executeRaw: Se(e4, t4.executeRaw.bind(t4)), startTransaction: async (...n4) => (await r5(...n4)).map((o3) => Ed(e4, o3)) };
  };
  var Ed = (e4, t4) => ({ adapterName: t4.adapterName, provider: t4.provider, options: t4.options, queryRaw: Se(e4, t4.queryRaw.bind(t4)), executeRaw: Se(e4, t4.executeRaw.bind(t4)), commit: Se(e4, t4.commit.bind(t4)), rollback: Se(e4, t4.rollback.bind(t4)) });
  function Se(e4, t4) {
    return async (...r5) => {
      try {
        return await t4(...r5);
      } catch (n4) {
        let i4 = e4.registerNewError(n4);
        return fr({ kind: "GenericJs", id: i4 });
      }
    };
  }
  function bd2(e4, t4) {
    return (...r5) => {
      try {
        return t4(...r5);
      } catch (n4) {
        let i4 = e4.registerNewError(n4);
        return fr({ kind: "GenericJs", id: i4 });
      }
    };
  }
  var Kl = D3(li());
  var Yl = __require("async_hooks");
  var zl = __require("events");
  var Zl = D3(__require("fs"));
  var Nr = D3(__require("path"));
  var ae2 = class e4 {
    constructor(t4, r5) {
      if (t4.length - 1 !== r5.length)
        throw t4.length === 0 ? new TypeError("Expected at least 1 string") : new TypeError(`Expected ${t4.length} strings to have ${t4.length - 1} values`);
      let n4 = r5.reduce((s5, a5) => s5 + (a5 instanceof e4 ? a5.values.length : 1), 0);
      this.values = new Array(n4), this.strings = new Array(n4 + 1), this.strings[0] = t4[0];
      let i4 = 0, o3 = 0;
      for (;i4 < r5.length; ) {
        let s5 = r5[i4++], a5 = t4[i4];
        if (s5 instanceof e4) {
          this.strings[o3] += s5.strings[0];
          let l4 = 0;
          for (;l4 < s5.values.length; )
            this.values[o3++] = s5.values[l4++], this.strings[o3] = s5.strings[l4];
          this.strings[o3] += a5;
        } else
          this.values[o3++] = s5, this.strings[o3] = a5;
      }
    }
    get sql() {
      let t4 = this.strings.length, r5 = 1, n4 = this.strings[0];
      for (;r5 < t4; )
        n4 += `?${this.strings[r5++]}`;
      return n4;
    }
    get statement() {
      let t4 = this.strings.length, r5 = 1, n4 = this.strings[0];
      for (;r5 < t4; )
        n4 += `:${r5}${this.strings[r5++]}`;
      return n4;
    }
    get text() {
      let t4 = this.strings.length, r5 = 1, n4 = this.strings[0];
      for (;r5 < t4; )
        n4 += `$${r5}${this.strings[r5++]}`;
      return n4;
    }
    inspect() {
      return { sql: this.sql, statement: this.statement, text: this.text, values: this.values };
    }
  };
  function Ea(e4, t4 = ",", r5 = "", n4 = "") {
    if (e4.length === 0)
      throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
    return new ae2([r5, ...Array(e4.length - 1).fill(t4), n4], e4);
  }
  function Gi(e4) {
    return new ae2([e4], []);
  }
  var ba2 = Gi("");
  function Ji(e4, ...t4) {
    return new ae2(e4, t4);
  }
  function gr(e4) {
    return { getKeys() {
      return Object.keys(e4);
    }, getPropertyValue(t4) {
      return e4[t4];
    } };
  }
  function ie(e4, t4) {
    return { getKeys() {
      return [e4];
    }, getPropertyValue() {
      return t4();
    } };
  }
  function ot(e4) {
    let t4 = new Te;
    return { getKeys() {
      return e4.getKeys();
    }, getPropertyValue(r5) {
      return t4.getOrCreate(r5, () => e4.getPropertyValue(r5));
    }, getPropertyDescriptor(r5) {
      return e4.getPropertyDescriptor?.(r5);
    } };
  }
  var Rn = { enumerable: true, configurable: true, writable: true };
  function Cn(e4) {
    let t4 = new Set(e4);
    return { getPrototypeOf: () => Object.prototype, getOwnPropertyDescriptor: () => Rn, has: (r5, n4) => t4.has(n4), set: (r5, n4, i4) => t4.add(n4) && Reflect.set(r5, n4, i4), ownKeys: () => [...t4] };
  }
  var wa = Symbol.for("nodejs.util.inspect.custom");
  function Ae(e4, t4) {
    let r5 = wd(t4), n4 = new Set, i4 = new Proxy(e4, { get(o3, s5) {
      if (n4.has(s5))
        return o3[s5];
      let a5 = r5.get(s5);
      return a5 ? a5.getPropertyValue(s5) : o3[s5];
    }, has(o3, s5) {
      if (n4.has(s5))
        return true;
      let a5 = r5.get(s5);
      return a5 ? a5.has?.(s5) ?? true : Reflect.has(o3, s5);
    }, ownKeys(o3) {
      let s5 = xa(Reflect.ownKeys(o3), r5), a5 = xa(Array.from(r5.keys()), r5);
      return [...new Set([...s5, ...a5, ...n4])];
    }, set(o3, s5, a5) {
      return r5.get(s5)?.getPropertyDescriptor?.(s5)?.writable === false ? false : (n4.add(s5), Reflect.set(o3, s5, a5));
    }, getOwnPropertyDescriptor(o3, s5) {
      let a5 = Reflect.getOwnPropertyDescriptor(o3, s5);
      if (a5 && !a5.configurable)
        return a5;
      let l4 = r5.get(s5);
      return l4 ? l4.getPropertyDescriptor ? { ...Rn, ...l4?.getPropertyDescriptor(s5) } : Rn : a5;
    }, defineProperty(o3, s5, a5) {
      return n4.add(s5), Reflect.defineProperty(o3, s5, a5);
    }, getPrototypeOf: () => Object.prototype });
    return i4[wa] = function() {
      let o3 = { ...this };
      return delete o3[wa], o3;
    }, i4;
  }
  function wd(e4) {
    let t4 = new Map;
    for (let r5 of e4) {
      let n4 = r5.getKeys();
      for (let i4 of n4)
        t4.set(i4, r5);
    }
    return t4;
  }
  function xa(e4, t4) {
    return e4.filter((r5) => t4.get(r5)?.has?.(r5) ?? true);
  }
  function kt(e4) {
    return { getKeys() {
      return e4;
    }, has() {
      return false;
    }, getPropertyValue() {
    } };
  }
  function Dt(e4, t4) {
    return { batch: e4, transaction: t4?.kind === "batch" ? { isolationLevel: t4.options.isolationLevel } : undefined };
  }
  function va(e4) {
    if (e4 === undefined)
      return "";
    let t4 = At(e4);
    return new Pt(0, { colors: fn }).write(t4).toString();
  }
  var xd = "P2037";
  function _t({ error: e4, user_facing_error: t4 }, r5, n4) {
    return t4.error_code ? new ee2(vd(t4, n4), { code: t4.error_code, clientVersion: r5, meta: t4.meta, batchRequestIdx: t4.batch_request_idx }) : new B4(e4, { clientVersion: r5, batchRequestIdx: t4.batch_request_idx });
  }
  function vd(e4, t4) {
    let r5 = e4.message;
    return (t4 === "postgresql" || t4 === "postgres" || t4 === "mysql") && e4.error_code === xd && (r5 += `
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`), r5;
  }
  var hr = "<unknown>";
  function Pa(e4) {
    var t4 = e4.split(`
`);
    return t4.reduce(function(r5, n4) {
      var i4 = Rd(n4) || Sd(n4) || Od(n4) || Nd(n4) || Dd(n4);
      return i4 && r5.push(i4), r5;
    }, []);
  }
  var Pd = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var Td = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  function Rd(e4) {
    var t4 = Pd.exec(e4);
    if (!t4)
      return null;
    var r5 = t4[2] && t4[2].indexOf("native") === 0, n4 = t4[2] && t4[2].indexOf("eval") === 0, i4 = Td.exec(t4[2]);
    return n4 && i4 != null && (t4[2] = i4[1], t4[3] = i4[2], t4[4] = i4[3]), { file: r5 ? null : t4[2], methodName: t4[1] || hr, arguments: r5 ? [t4[2]] : [], lineNumber: t4[3] ? +t4[3] : null, column: t4[4] ? +t4[4] : null };
  }
  var Cd = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  function Sd(e4) {
    var t4 = Cd.exec(e4);
    return t4 ? { file: t4[2], methodName: t4[1] || hr, arguments: [], lineNumber: +t4[3], column: t4[4] ? +t4[4] : null } : null;
  }
  var Ad = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
  var Id = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  function Od(e4) {
    var t4 = Ad.exec(e4);
    if (!t4)
      return null;
    var r5 = t4[3] && t4[3].indexOf(" > eval") > -1, n4 = Id.exec(t4[3]);
    return r5 && n4 != null && (t4[3] = n4[1], t4[4] = n4[2], t4[5] = null), { file: t4[3], methodName: t4[1] || hr, arguments: t4[2] ? t4[2].split(",") : [], lineNumber: t4[4] ? +t4[4] : null, column: t4[5] ? +t4[5] : null };
  }
  var kd = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
  function Dd(e4) {
    var t4 = kd.exec(e4);
    return t4 ? { file: t4[3], methodName: t4[1] || hr, arguments: [], lineNumber: +t4[4], column: t4[5] ? +t4[5] : null } : null;
  }
  var _d2 = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  function Nd(e4) {
    var t4 = _d2.exec(e4);
    return t4 ? { file: t4[2], methodName: t4[1] || hr, arguments: [], lineNumber: +t4[3], column: t4[4] ? +t4[4] : null } : null;
  }
  var Hi = class {
    getLocation() {
      return null;
    }
  };
  var Wi = class {
    constructor() {
      this._error = new Error;
    }
    getLocation() {
      let t4 = this._error.stack;
      if (!t4)
        return null;
      let n4 = Pa(t4).find((i4) => {
        if (!i4.file)
          return false;
        let o3 = Ei(i4.file);
        return o3 !== "<anonymous>" && !o3.includes("@prisma") && !o3.includes("/packages/client/src/runtime/") && !o3.endsWith("/runtime/binary.js") && !o3.endsWith("/runtime/library.js") && !o3.endsWith("/runtime/edge.js") && !o3.endsWith("/runtime/edge-esm.js") && !o3.startsWith("internal/") && !i4.methodName.includes("new ") && !i4.methodName.includes("getCallSite") && !i4.methodName.includes("Proxy.") && i4.methodName.split(".").length < 4;
      });
      return !n4 || !n4.file ? null : { fileName: n4.file, lineNumber: n4.lineNumber, columnNumber: n4.column };
    }
  };
  function Ze(e4) {
    return e4 === "minimal" ? typeof $EnabledCallSite == "function" && e4 !== "minimal" ? new $EnabledCallSite : new Hi : new Wi;
  }
  var Ta = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
  function Nt(e4 = {}) {
    let t4 = Fd(e4);
    return Object.entries(t4).reduce((n4, [i4, o3]) => (Ta[i4] !== undefined ? n4.select[i4] = { select: o3 } : n4[i4] = o3, n4), { select: {} });
  }
  function Fd(e4 = {}) {
    return typeof e4._count == "boolean" ? { ...e4, _count: { _all: e4._count } } : e4;
  }
  function Sn(e4 = {}) {
    return (t4) => (typeof e4._count == "boolean" && (t4._count = t4._count._all), t4);
  }
  function Ra(e4, t4) {
    let r5 = Sn(e4);
    return t4({ action: "aggregate", unpacker: r5, argsMapper: Nt })(e4);
  }
  function Md(e4 = {}) {
    let { select: t4, ...r5 } = e4;
    return typeof t4 == "object" ? Nt({ ...r5, _count: t4 }) : Nt({ ...r5, _count: { _all: true } });
  }
  function $d(e4 = {}) {
    return typeof e4.select == "object" ? (t4) => Sn(e4)(t4)._count : (t4) => Sn(e4)(t4)._count._all;
  }
  function Ca(e4, t4) {
    return t4({ action: "count", unpacker: $d(e4), argsMapper: Md })(e4);
  }
  function qd(e4 = {}) {
    let t4 = Nt(e4);
    if (Array.isArray(t4.by))
      for (let r5 of t4.by)
        typeof r5 == "string" && (t4.select[r5] = true);
    else
      typeof t4.by == "string" && (t4.select[t4.by] = true);
    return t4;
  }
  function Vd(e4 = {}) {
    return (t4) => (typeof e4?._count == "boolean" && t4.forEach((r5) => {
      r5._count = r5._count._all;
    }), t4);
  }
  function Sa(e4, t4) {
    return t4({ action: "groupBy", unpacker: Vd(e4), argsMapper: qd })(e4);
  }
  function Aa(e4, t4, r5) {
    if (t4 === "aggregate")
      return (n4) => Ra(n4, r5);
    if (t4 === "count")
      return (n4) => Ca(n4, r5);
    if (t4 === "groupBy")
      return (n4) => Sa(n4, r5);
  }
  function Ia(e4, t4) {
    let r5 = t4.fields.filter((i4) => !i4.relationName), n4 = Ri(r5, (i4) => i4.name);
    return new Proxy({}, { get(i4, o3) {
      if (o3 in i4 || typeof o3 == "symbol")
        return i4[o3];
      let s5 = n4[o3];
      if (s5)
        return new sr(e4, o3, s5.type, s5.isList, s5.kind === "enum");
    }, ...Cn(Object.keys(n4)) });
  }
  var Oa = (e4) => Array.isArray(e4) ? e4 : e4.split(".");
  var Ki = (e4, t4) => Oa(t4).reduce((r5, n4) => r5 && r5[n4], e4);
  var ka = (e4, t4, r5) => Oa(t4).reduceRight((n4, i4, o3, s5) => Object.assign({}, Ki(e4, s5.slice(0, o3)), { [i4]: n4 }), r5);
  function jd(e4, t4) {
    return e4 === undefined || t4 === undefined ? [] : [...t4, "select", e4];
  }
  function Bd(e4, t4, r5) {
    return t4 === undefined ? e4 ?? {} : ka(t4, r5, e4 || true);
  }
  function Yi(e4, t4, r5, n4, i4, o3) {
    let a5 = e4._runtimeDataModel.models[t4].fields.reduce((l4, u5) => ({ ...l4, [u5.name]: u5 }), {});
    return (l4) => {
      let u5 = Ze(e4._errorFormat), c5 = jd(n4, i4), p5 = Bd(l4, o3, c5), d4 = r5({ dataPath: c5, callsite: u5 })(p5), f4 = Ud(e4, t4);
      return new Proxy(d4, { get(g3, h4) {
        if (!f4.includes(h4))
          return g3[h4];
        let P4 = [a5[h4].type, r5, h4], C3 = [c5, p5];
        return Yi(e4, ...P4, ...C3);
      }, ...Cn([...f4, ...Object.getOwnPropertyNames(d4)]) });
    };
  }
  function Ud(e4, t4) {
    return e4._runtimeDataModel.models[t4].fields.filter((r5) => r5.kind === "object").map((r5) => r5.name);
  }
  var Qd = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
  var Gd = ["aggregate", "count", "groupBy"];
  function zi(e4, t4) {
    let r5 = e4._extensions.getAllModelExtensions(t4) ?? {}, n4 = [Jd(e4, t4), Wd(e4, t4), gr(r5), ie("name", () => t4), ie("$name", () => t4), ie("$parent", () => e4._appliedParent)];
    return Ae({}, n4);
  }
  function Jd(e4, t4) {
    let r5 = Re(t4), n4 = Object.keys(zt.ModelAction).concat("count");
    return { getKeys() {
      return n4;
    }, getPropertyValue(i4) {
      let o3 = i4, s5 = (a5) => (l4) => {
        let u5 = Ze(e4._errorFormat);
        return e4._createPrismaPromise((c5) => {
          let p5 = { args: l4, dataPath: [], action: o3, model: t4, clientMethod: `${r5}.${i4}`, jsModelName: r5, transaction: c5, callsite: u5 };
          return e4._request({ ...p5, ...a5 });
        });
      };
      return Qd.includes(o3) ? Yi(e4, t4, s5) : Hd(i4) ? Aa(e4, i4, s5) : s5({});
    } };
  }
  function Hd(e4) {
    return Gd.includes(e4);
  }
  function Wd(e4, t4) {
    return ot(ie("fields", () => {
      let r5 = e4._runtimeDataModel.models[t4];
      return Ia(t4, r5);
    }));
  }
  function Da(e4) {
    return e4.replace(/^./, (t4) => t4.toUpperCase());
  }
  var Zi = Symbol();
  function yr(e4) {
    let t4 = [Kd(e4), ie(Zi, () => e4), ie("$parent", () => e4._appliedParent)], r5 = e4._extensions.getAllClientExtensions();
    return r5 && t4.push(gr(r5)), Ae(e4, t4);
  }
  function Kd(e4) {
    let t4 = Object.keys(e4._runtimeDataModel.models), r5 = t4.map(Re), n4 = [...new Set(t4.concat(r5))];
    return ot({ getKeys() {
      return n4;
    }, getPropertyValue(i4) {
      let o3 = Da(i4);
      if (e4._runtimeDataModel.models[o3] !== undefined)
        return zi(e4, o3);
      if (e4._runtimeDataModel.models[i4] !== undefined)
        return zi(e4, i4);
    }, getPropertyDescriptor(i4) {
      if (!r5.includes(i4))
        return { enumerable: false };
    } });
  }
  function _a2(e4) {
    return e4[Zi] ? e4[Zi] : e4;
  }
  function Na(e4) {
    if (typeof e4 == "function")
      return e4(this);
    if (e4.client?.__AccelerateEngine) {
      let r5 = e4.client.__AccelerateEngine;
      this._originalClient._engine = new r5(this._originalClient._accelerateEngineConfig);
    }
    let t4 = Object.create(this._originalClient, { _extensions: { value: this._extensions.append(e4) }, _appliedParent: { value: this, configurable: true }, $use: { value: undefined }, $on: { value: undefined } });
    return yr(t4);
  }
  function La({ result: e4, modelName: t4, select: r5, omit: n4, extensions: i4 }) {
    let o3 = i4.getAllComputedFields(t4);
    if (!o3)
      return e4;
    let s5 = [], a5 = [];
    for (let l4 of Object.values(o3)) {
      if (n4) {
        if (n4[l4.name])
          continue;
        let u5 = l4.needs.filter((c5) => n4[c5]);
        u5.length > 0 && a5.push(kt(u5));
      } else if (r5) {
        if (!r5[l4.name])
          continue;
        let u5 = l4.needs.filter((c5) => !r5[c5]);
        u5.length > 0 && a5.push(kt(u5));
      }
      Yd(e4, l4.needs) && s5.push(zd(l4, Ae(e4, s5)));
    }
    return s5.length > 0 || a5.length > 0 ? Ae(e4, [...s5, ...a5]) : e4;
  }
  function Yd(e4, t4) {
    return t4.every((r5) => Ti(e4, r5));
  }
  function zd(e4, t4) {
    return ot(ie(e4.name, () => e4.compute(t4)));
  }
  function An({ visitor: e4, result: t4, args: r5, runtimeDataModel: n4, modelName: i4 }) {
    if (Array.isArray(t4)) {
      for (let s5 = 0;s5 < t4.length; s5++)
        t4[s5] = An({ result: t4[s5], args: r5, modelName: i4, runtimeDataModel: n4, visitor: e4 });
      return t4;
    }
    let o3 = e4(t4, i4, r5) ?? t4;
    return r5.include && Fa({ includeOrSelect: r5.include, result: o3, parentModelName: i4, runtimeDataModel: n4, visitor: e4 }), r5.select && Fa({ includeOrSelect: r5.select, result: o3, parentModelName: i4, runtimeDataModel: n4, visitor: e4 }), o3;
  }
  function Fa({ includeOrSelect: e4, result: t4, parentModelName: r5, runtimeDataModel: n4, visitor: i4 }) {
    for (let [o3, s5] of Object.entries(e4)) {
      if (!s5 || t4[o3] == null || Ce(s5))
        continue;
      let l4 = n4.models[r5].fields.find((c5) => c5.name === o3);
      if (!l4 || l4.kind !== "object" || !l4.relationName)
        continue;
      let u5 = typeof s5 == "object" ? s5 : {};
      t4[o3] = An({ visitor: i4, result: t4[o3], args: u5, modelName: l4.type, runtimeDataModel: n4 });
    }
  }
  function Ma({ result: e4, modelName: t4, args: r5, extensions: n4, runtimeDataModel: i4, globalOmit: o3 }) {
    return n4.isEmpty() || e4 == null || typeof e4 != "object" || !i4.models[t4] ? e4 : An({ result: e4, args: r5 ?? {}, modelName: t4, runtimeDataModel: i4, visitor: (a5, l4, u5) => {
      let c5 = Re(l4);
      return La({ result: a5, modelName: c5, select: u5.select, omit: u5.select ? undefined : { ...o3?.[c5], ...u5.omit }, extensions: n4 });
    } });
  }
  function $a(e4) {
    if (e4 instanceof ae2)
      return Zd(e4);
    if (Array.isArray(e4)) {
      let r5 = [e4[0]];
      for (let n4 = 1;n4 < e4.length; n4++)
        r5[n4] = Er(e4[n4]);
      return r5;
    }
    let t4 = {};
    for (let r5 in e4)
      t4[r5] = Er(e4[r5]);
    return t4;
  }
  function Zd(e4) {
    return new ae2(e4.strings, e4.values);
  }
  function Er(e4) {
    if (typeof e4 != "object" || e4 == null || e4 instanceof $e || St(e4))
      return e4;
    if (vt(e4))
      return new ve(e4.toFixed());
    if (xt(e4))
      return new Date(+e4);
    if (ArrayBuffer.isView(e4))
      return e4.slice(0);
    if (Array.isArray(e4)) {
      let t4 = e4.length, r5;
      for (r5 = Array(t4);t4--; )
        r5[t4] = Er(e4[t4]);
      return r5;
    }
    if (typeof e4 == "object") {
      let t4 = {};
      for (let r5 in e4)
        r5 === "__proto__" ? Object.defineProperty(t4, r5, { value: Er(e4[r5]), configurable: true, enumerable: true, writable: true }) : t4[r5] = Er(e4[r5]);
      return t4;
    }
    Fe(e4, "Unknown value");
  }
  function Va(e4, t4, r5, n4 = 0) {
    return e4._createPrismaPromise((i4) => {
      let o3 = t4.customDataProxyFetch;
      return "transaction" in t4 && i4 !== undefined && (t4.transaction?.kind === "batch" && t4.transaction.lock.then(), t4.transaction = i4), n4 === r5.length ? e4._executeRequest(t4) : r5[n4]({ model: t4.model, operation: t4.model ? t4.action : t4.clientMethod, args: $a(t4.args ?? {}), __internalParams: t4, query: (s5, a5 = t4) => {
        let l4 = a5.customDataProxyFetch;
        return a5.customDataProxyFetch = Qa(o3, l4), a5.args = s5, Va(e4, a5, r5, n4 + 1);
      } });
    });
  }
  function ja(e4, t4) {
    let { jsModelName: r5, action: n4, clientMethod: i4 } = t4, o3 = r5 ? n4 : i4;
    if (e4._extensions.isEmpty())
      return e4._executeRequest(t4);
    let s5 = e4._extensions.getAllQueryCallbacks(r5 ?? "$none", o3);
    return Va(e4, t4, s5);
  }
  function Ba(e4) {
    return (t4) => {
      let r5 = { requests: t4 }, n4 = t4[0].extensions.getAllBatchQueryCallbacks();
      return n4.length ? Ua(r5, n4, 0, e4) : e4(r5);
    };
  }
  function Ua(e4, t4, r5, n4) {
    if (r5 === t4.length)
      return n4(e4);
    let i4 = e4.customDataProxyFetch, o3 = e4.requests[0].transaction;
    return t4[r5]({ args: { queries: e4.requests.map((s5) => ({ model: s5.modelName, operation: s5.action, args: s5.args })), transaction: o3 ? { isolationLevel: o3.kind === "batch" ? o3.isolationLevel : undefined } : undefined }, __internalParams: e4, query(s5, a5 = e4) {
      let l4 = a5.customDataProxyFetch;
      return a5.customDataProxyFetch = Qa(i4, l4), Ua(a5, t4, r5 + 1, n4);
    } });
  }
  var qa = (e4) => e4;
  function Qa(e4 = qa, t4 = qa) {
    return (r5) => e4(t4(r5));
  }
  var Ga = F3("prisma:client");
  var Ja = { Vercel: "vercel", "Netlify CI": "netlify" };
  function Ha({ postinstall: e4, ciName: t4, clientVersion: r5 }) {
    if (Ga("checkPlatformCaching:postinstall", e4), Ga("checkPlatformCaching:ciName", t4), e4 === true && t4 && t4 in Ja) {
      let n4 = `Prisma has detected that this project was built on ${t4}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${Ja[t4]}-build`;
      throw console.error(n4), new T4(n4, r5);
    }
  }
  function Wa(e4, t4) {
    return e4 ? e4.datasources ? e4.datasources : e4.datasourceUrl ? { [t4[0]]: { url: e4.datasourceUrl } } : {} : {};
  }
  var Xd = "Cloudflare-Workers";
  var em = "node";
  function Ka() {
    return typeof Netlify == "object" ? "netlify" : typeof EdgeRuntime == "string" ? "edge-light" : globalThis.navigator?.userAgent === Xd ? "workerd" : globalThis.Deno ? "deno" : globalThis.__lagon__ ? "lagon" : globalThis.process?.release?.name === em ? "node" : globalThis.Bun ? "bun" : globalThis.fastly ? "fastly" : "unknown";
  }
  var tm = { node: "Node.js", workerd: "Cloudflare Workers", deno: "Deno and Deno Deploy", netlify: "Netlify Edge Functions", "edge-light": "Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)" };
  function In() {
    let e4 = Ka();
    return { id: e4, prettyName: tm[e4] || e4, isEdge: ["workerd", "deno", "netlify", "edge-light"].includes(e4) };
  }
  var el = D3(__require("fs"));
  var br2 = D3(__require("path"));
  function On(e4) {
    let { runtimeBinaryTarget: t4 } = e4;
    return `Add "${t4}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:

${rm(e4)}`;
  }
  function rm(e4) {
    let { generator: t4, generatorBinaryTargets: r5, runtimeBinaryTarget: n4 } = e4, i4 = { fromEnvVar: null, value: n4 }, o3 = [...r5, i4];
    return xi({ ...t4, binaryTargets: o3 });
  }
  function Xe(e4) {
    let { runtimeBinaryTarget: t4 } = e4;
    return `Prisma Client could not locate the Query Engine for runtime "${t4}".`;
  }
  function et(e4) {
    let { searchedLocations: t4 } = e4;
    return `The following locations have been searched:
${[...new Set(t4)].map((i4) => `  ${i4}`).join(`
`)}`;
  }
  function Ya(e4) {
    let { runtimeBinaryTarget: t4 } = e4;
    return `${Xe(e4)}

This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${t4}".
${On(e4)}

${et(e4)}`;
  }
  function kn(e4) {
    return `We would appreciate if you could take the time to share some information with us.
Please help us by answering a few questions: https://pris.ly/${e4}`;
  }
  function Dn(e4) {
    let { errorStack: t4 } = e4;
    return t4?.match(/\/\.next|\/next@|\/next\//) ? `

We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.` : "";
  }
  function za(e4) {
    let { queryEngineName: t4 } = e4;
    return `${Xe(e4)}${Dn(e4)}

This is likely caused by a bundler that has not copied "${t4}" next to the resulting bundle.
Ensure that "${t4}" has been copied next to the bundle or in "${e4.expectedLocation}".

${kn("engine-not-found-bundler-investigation")}

${et(e4)}`;
  }
  function Za(e4) {
    let { runtimeBinaryTarget: t4, generatorBinaryTargets: r5 } = e4, n4 = r5.find((i4) => i4.native);
    return `${Xe(e4)}

This happened because Prisma Client was generated for "${n4?.value ?? "unknown"}", but the actual deployment required "${t4}".
${On(e4)}

${et(e4)}`;
  }
  function Xa(e4) {
    let { queryEngineName: t4 } = e4;
    return `${Xe(e4)}${Dn(e4)}

This is likely caused by tooling that has not copied "${t4}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${t4}" has been copied to "${e4.expectedLocation}".

${kn("engine-not-found-tooling-investigation")}

${et(e4)}`;
  }
  var nm = F3("prisma:client:engines:resolveEnginePath");
  var im = () => new RegExp("runtime[\\\\/]library\\.m?js$");
  async function tl(e4, t4) {
    let r5 = { binary: process.env.PRISMA_QUERY_ENGINE_BINARY, library: process.env.PRISMA_QUERY_ENGINE_LIBRARY }[e4] ?? t4.prismaPath;
    if (r5 !== undefined)
      return r5;
    let { enginePath: n4, searchedLocations: i4 } = await om(e4, t4);
    if (nm("enginePath", n4), n4 !== undefined && e4 === "binary" && pi(n4), n4 !== undefined)
      return t4.prismaPath = n4;
    let o3 = await nt(), s5 = t4.generator?.binaryTargets ?? [], a5 = s5.some((d4) => d4.native), l4 = !s5.some((d4) => d4.value === o3), u5 = __filename.match(im()) === null, c5 = { searchedLocations: i4, generatorBinaryTargets: s5, generator: t4.generator, runtimeBinaryTarget: o3, queryEngineName: rl(e4, o3), expectedLocation: br2.default.relative(process.cwd(), t4.dirname), errorStack: new Error().stack }, p5;
    throw a5 && l4 ? p5 = Za(c5) : l4 ? p5 = Ya(c5) : u5 ? p5 = za(c5) : p5 = Xa(c5), new T4(p5, t4.clientVersion);
  }
  async function om(engineType, config) {
    let binaryTarget = await nt(), searchedLocations = [], dirname = eval("__dirname"), searchLocations = [config.dirname, br2.default.resolve(dirname, ".."), config.generator?.output?.value ?? dirname, br2.default.resolve(dirname, "../../../.prisma/client"), "/tmp/prisma-engines", config.cwd];
    __filename.includes("resolveEnginePath") && searchLocations.push(ts());
    for (let e4 of searchLocations) {
      let t4 = rl(engineType, binaryTarget), r5 = br2.default.join(e4, t4);
      if (searchedLocations.push(e4), el.default.existsSync(r5))
        return { enginePath: r5, searchedLocations };
    }
    return { enginePath: undefined, searchedLocations };
  }
  function rl(e4, t4) {
    return e4 === "library" ? qr(t4, "fs") : `query-engine-${t4}${t4 === "windows" ? ".exe" : ""}`;
  }
  var Xi = D3(Pi());
  function nl(e4) {
    return e4 ? e4.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (t4) => `${t4[0]}5`) : "";
  }
  function il(e4) {
    return e4.split(`
`).map((t4) => t4.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "")).join(`
`);
  }
  var ol = D3(vs());
  function sl({ title: e4, user: t4 = "prisma", repo: r5 = "prisma", template: n4 = "bug_report.yml", body: i4 }) {
    return (0, ol.default)({ user: t4, repo: r5, template: n4, title: e4, body: i4 });
  }
  function al2({ version: e4, binaryTarget: t4, title: r5, description: n4, engineVersion: i4, database: o3, query: s5 }) {
    let a5 = ko(6000 - (s5?.length ?? 0)), l4 = il((0, Xi.default)(a5)), u5 = n4 ? `# Description
\`\`\`
${n4}
\`\`\`` : "", c5 = (0, Xi.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${t4?.padEnd(19)}|
| Prisma Client   | ${e4?.padEnd(19)}|
| Query Engine    | ${i4?.padEnd(19)}|
| Database        | ${o3?.padEnd(19)}|

${u5}

## Logs
\`\`\`
${l4}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s5 ? nl(s5) : ""}
\`\`\`
`), p5 = sl({ title: r5, body: c5 });
    return `${r5}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${X3(p5)}

If you want the Prisma team to look into it, please open the link above \uD83D\uDE4F
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
  }
  function Lt({ inlineDatasources: e4, overrideDatasources: t4, env: r5, clientVersion: n4 }) {
    let i4, o3 = Object.keys(e4)[0], s5 = e4[o3]?.url, a5 = t4[o3]?.url;
    if (o3 === undefined ? i4 = undefined : a5 ? i4 = a5 : s5?.value ? i4 = s5.value : s5?.fromEnvVar && (i4 = r5[s5.fromEnvVar]), s5?.fromEnvVar !== undefined && i4 === undefined)
      throw new T4(`error: Environment variable not found: ${s5.fromEnvVar}.`, n4);
    if (i4 === undefined)
      throw new T4("error: Missing URL environment variable, value, or override.", n4);
    return i4;
  }
  var _n = class extends Error {
    constructor(t4, r5) {
      super(t4), this.clientVersion = r5.clientVersion, this.cause = r5.cause;
    }
    get [Symbol.toStringTag]() {
      return this.name;
    }
  };
  var le = class extends _n {
    constructor(t4, r5) {
      super(t4, r5), this.isRetryable = r5.isRetryable ?? true;
    }
  };
  function S4(e4, t4) {
    return { ...e4, isRetryable: t4 };
  }
  var Ft = class extends le {
    constructor(r5) {
      super("This request must be retried", S4(r5, true));
      this.name = "ForcedRetryError";
      this.code = "P5001";
    }
  };
  w4(Ft, "ForcedRetryError");
  var st = class extends le {
    constructor(r5, n4) {
      super(r5, S4(n4, false));
      this.name = "InvalidDatasourceError";
      this.code = "P6001";
    }
  };
  w4(st, "InvalidDatasourceError");
  var at2 = class extends le {
    constructor(r5, n4) {
      super(r5, S4(n4, false));
      this.name = "NotImplementedYetError";
      this.code = "P5004";
    }
  };
  w4(at2, "NotImplementedYetError");
  var V3 = class extends le {
    constructor(t4, r5) {
      super(t4, r5), this.response = r5.response;
      let n4 = this.response.headers.get("prisma-request-id");
      if (n4) {
        let i4 = `(The request id was: ${n4})`;
        this.message = this.message + " " + i4;
      }
    }
  };
  var lt = class extends V3 {
    constructor(r5) {
      super("Schema needs to be uploaded", S4(r5, true));
      this.name = "SchemaMissingError";
      this.code = "P5005";
    }
  };
  w4(lt, "SchemaMissingError");
  var eo = "This request could not be understood by the server";
  var wr = class extends V3 {
    constructor(r5, n4, i4) {
      super(n4 || eo, S4(r5, false));
      this.name = "BadRequestError";
      this.code = "P5000";
      i4 && (this.code = i4);
    }
  };
  w4(wr, "BadRequestError");
  var xr = class extends V3 {
    constructor(r5, n4) {
      super("Engine not started: healthcheck timeout", S4(r5, true));
      this.name = "HealthcheckTimeoutError";
      this.code = "P5013";
      this.logs = n4;
    }
  };
  w4(xr, "HealthcheckTimeoutError");
  var vr = class extends V3 {
    constructor(r5, n4, i4) {
      super(n4, S4(r5, true));
      this.name = "EngineStartupError";
      this.code = "P5014";
      this.logs = i4;
    }
  };
  w4(vr, "EngineStartupError");
  var Pr = class extends V3 {
    constructor(r5) {
      super("Engine version is not supported", S4(r5, false));
      this.name = "EngineVersionNotSupportedError";
      this.code = "P5012";
    }
  };
  w4(Pr, "EngineVersionNotSupportedError");
  var to = "Request timed out";
  var Tr = class extends V3 {
    constructor(r5, n4 = to) {
      super(n4, S4(r5, false));
      this.name = "GatewayTimeoutError";
      this.code = "P5009";
    }
  };
  w4(Tr, "GatewayTimeoutError");
  var sm = "Interactive transaction error";
  var Rr = class extends V3 {
    constructor(r5, n4 = sm) {
      super(n4, S4(r5, false));
      this.name = "InteractiveTransactionError";
      this.code = "P5015";
    }
  };
  w4(Rr, "InteractiveTransactionError");
  var am2 = "Request parameters are invalid";
  var Cr = class extends V3 {
    constructor(r5, n4 = am2) {
      super(n4, S4(r5, false));
      this.name = "InvalidRequestError";
      this.code = "P5011";
    }
  };
  w4(Cr, "InvalidRequestError");
  var ro = "Requested resource does not exist";
  var Sr = class extends V3 {
    constructor(r5, n4 = ro) {
      super(n4, S4(r5, false));
      this.name = "NotFoundError";
      this.code = "P5003";
    }
  };
  w4(Sr, "NotFoundError");
  var no = "Unknown server error";
  var Mt = class extends V3 {
    constructor(r5, n4, i4) {
      super(n4 || no, S4(r5, true));
      this.name = "ServerError";
      this.code = "P5006";
      this.logs = i4;
    }
  };
  w4(Mt, "ServerError");
  var io = "Unauthorized, check your connection string";
  var Ar = class extends V3 {
    constructor(r5, n4 = io) {
      super(n4, S4(r5, false));
      this.name = "UnauthorizedError";
      this.code = "P5007";
    }
  };
  w4(Ar, "UnauthorizedError");
  var oo = "Usage exceeded, retry again later";
  var Ir = class extends V3 {
    constructor(r5, n4 = oo) {
      super(n4, S4(r5, true));
      this.name = "UsageExceededError";
      this.code = "P5008";
    }
  };
  w4(Ir, "UsageExceededError");
  async function lm(e4) {
    let t4;
    try {
      t4 = await e4.text();
    } catch {
      return { type: "EmptyError" };
    }
    try {
      let r5 = JSON.parse(t4);
      if (typeof r5 == "string")
        switch (r5) {
          case "InternalDataProxyError":
            return { type: "DataProxyError", body: r5 };
          default:
            return { type: "UnknownTextError", body: r5 };
        }
      if (typeof r5 == "object" && r5 !== null) {
        if ("is_panic" in r5 && "message" in r5 && "error_code" in r5)
          return { type: "QueryEngineError", body: r5 };
        if ("EngineNotStarted" in r5 || "InteractiveTransactionMisrouted" in r5 || "InvalidRequestError" in r5) {
          let n4 = Object.values(r5)[0].reason;
          return typeof n4 == "string" && !["SchemaMissing", "EngineVersionNotSupported"].includes(n4) ? { type: "UnknownJsonError", body: r5 } : { type: "DataProxyError", body: r5 };
        }
      }
      return { type: "UnknownJsonError", body: r5 };
    } catch {
      return t4 === "" ? { type: "EmptyError" } : { type: "UnknownTextError", body: t4 };
    }
  }
  async function Or(e4, t4) {
    if (e4.ok)
      return;
    let r5 = { clientVersion: t4, response: e4 }, n4 = await lm(e4);
    if (n4.type === "QueryEngineError")
      throw new ee2(n4.body.message, { code: n4.body.error_code, clientVersion: t4 });
    if (n4.type === "DataProxyError") {
      if (n4.body === "InternalDataProxyError")
        throw new Mt(r5, "Internal Data Proxy error");
      if ("EngineNotStarted" in n4.body) {
        if (n4.body.EngineNotStarted.reason === "SchemaMissing")
          return new lt(r5);
        if (n4.body.EngineNotStarted.reason === "EngineVersionNotSupported")
          throw new Pr(r5);
        if ("EngineStartupError" in n4.body.EngineNotStarted.reason) {
          let { msg: i4, logs: o3 } = n4.body.EngineNotStarted.reason.EngineStartupError;
          throw new vr(r5, i4, o3);
        }
        if ("KnownEngineStartupError" in n4.body.EngineNotStarted.reason) {
          let { msg: i4, error_code: o3 } = n4.body.EngineNotStarted.reason.KnownEngineStartupError;
          throw new T4(i4, t4, o3);
        }
        if ("HealthcheckTimeout" in n4.body.EngineNotStarted.reason) {
          let { logs: i4 } = n4.body.EngineNotStarted.reason.HealthcheckTimeout;
          throw new xr(r5, i4);
        }
      }
      if ("InteractiveTransactionMisrouted" in n4.body) {
        let i4 = { IDParseError: "Could not parse interactive transaction ID", NoQueryEngineFoundError: "Could not find Query Engine for the specified host and transaction ID", TransactionStartError: "Could not start interactive transaction" };
        throw new Rr(r5, i4[n4.body.InteractiveTransactionMisrouted.reason]);
      }
      if ("InvalidRequestError" in n4.body)
        throw new Cr(r5, n4.body.InvalidRequestError.reason);
    }
    if (e4.status === 401 || e4.status === 403)
      throw new Ar(r5, $t(io, n4));
    if (e4.status === 404)
      return new Sr(r5, $t(ro, n4));
    if (e4.status === 429)
      throw new Ir(r5, $t(oo, n4));
    if (e4.status === 504)
      throw new Tr(r5, $t(to, n4));
    if (e4.status >= 500)
      throw new Mt(r5, $t(no, n4));
    if (e4.status >= 400)
      throw new wr(r5, $t(eo, n4));
  }
  function $t(e4, t4) {
    return t4.type === "EmptyError" ? e4 : `${e4}: ${JSON.stringify(t4)}`;
  }
  function ll(e4) {
    let t4 = Math.pow(2, e4) * 50, r5 = Math.ceil(Math.random() * t4) - Math.ceil(t4 / 2), n4 = t4 + r5;
    return new Promise((i4) => setTimeout(() => i4(n4), n4));
  }
  var qe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  function ul(e4) {
    let t4 = new TextEncoder().encode(e4), r5 = "", n4 = t4.byteLength, i4 = n4 % 3, o3 = n4 - i4, s5, a5, l4, u5, c5;
    for (let p5 = 0;p5 < o3; p5 = p5 + 3)
      c5 = t4[p5] << 16 | t4[p5 + 1] << 8 | t4[p5 + 2], s5 = (c5 & 16515072) >> 18, a5 = (c5 & 258048) >> 12, l4 = (c5 & 4032) >> 6, u5 = c5 & 63, r5 += qe[s5] + qe[a5] + qe[l4] + qe[u5];
    return i4 == 1 ? (c5 = t4[o3], s5 = (c5 & 252) >> 2, a5 = (c5 & 3) << 4, r5 += qe[s5] + qe[a5] + "==") : i4 == 2 && (c5 = t4[o3] << 8 | t4[o3 + 1], s5 = (c5 & 64512) >> 10, a5 = (c5 & 1008) >> 4, l4 = (c5 & 15) << 2, r5 += qe[s5] + qe[a5] + qe[l4] + "="), r5;
  }
  function cl2(e4) {
    if (!!e4.generator?.previewFeatures.some((r5) => r5.toLowerCase().includes("metrics")))
      throw new T4("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate", e4.clientVersion);
  }
  function um(e4) {
    return e4[0] * 1000 + e4[1] / 1e6;
  }
  function so(e4) {
    return new Date(um(e4));
  }
  var pl = { "@prisma/debug": "workspace:*", "@prisma/engines-version": "6.2.0-14.4123509d24aa4dede1e864b46351bf2790323b69", "@prisma/fetch-engine": "workspace:*", "@prisma/get-platform": "workspace:*" };
  var kr = class extends le {
    constructor(r5, n4) {
      super(`Cannot fetch data from service:
${r5}`, S4(n4, true));
      this.name = "RequestError";
      this.code = "P5010";
    }
  };
  w4(kr, "RequestError");
  async function ut(e4, t4, r5 = (n4) => n4) {
    let { clientVersion: n4, ...i4 } = t4, o3 = r5(fetch);
    try {
      return await o3(e4, i4);
    } catch (s5) {
      let a5 = s5.message ?? "Unknown error";
      throw new kr(a5, { clientVersion: n4, cause: s5 });
    }
  }
  var pm = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
  var dl = F3("prisma:client:dataproxyEngine");
  async function dm(e4, t4) {
    let r5 = pl["@prisma/engines-version"], n4 = t4.clientVersion ?? "unknown";
    if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)
      return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
    if (e4.includes("accelerate") && n4 !== "0.0.0" && n4 !== "in-memory")
      return n4;
    let [i4, o3] = n4?.split("-") ?? [];
    if (o3 === undefined && pm.test(i4))
      return i4;
    if (o3 !== undefined || n4 === "0.0.0" || n4 === "in-memory") {
      if (e4.startsWith("localhost") || e4.startsWith("127.0.0.1"))
        return "0.0.0";
      let [s5] = r5.split("-") ?? [], [a5, l4, u5] = s5.split("."), c5 = mm(`<=${a5}.${l4}.${u5}`), p5 = await ut(c5, { clientVersion: n4 });
      if (!p5.ok)
        throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p5.status} ${p5.statusText}, response body: ${await p5.text() || "<empty body>"}`);
      let d4 = await p5.text();
      dl("length of body fetched from unpkg.com", d4.length);
      let f4;
      try {
        f4 = JSON.parse(d4);
      } catch (g3) {
        throw console.error("JSON.parse error: body fetched from unpkg.com: ", d4), g3;
      }
      return f4.version;
    }
    throw new at2("Only `major.minor.patch` versions are supported by Accelerate.", { clientVersion: n4 });
  }
  async function ml(e4, t4) {
    let r5 = await dm(e4, t4);
    return dl("version", r5), r5;
  }
  function mm(e4) {
    return encodeURI(`https://unpkg.com/prisma@${e4}/package.json`);
  }
  var fl = 3;
  var Nn = F3("prisma:client:dataproxyEngine");
  var ao2 = class {
    constructor({ apiKey: t4, tracingHelper: r5, logLevel: n4, logQueries: i4, engineHash: o3 }) {
      this.apiKey = t4, this.tracingHelper = r5, this.logLevel = n4, this.logQueries = i4, this.engineHash = o3;
    }
    build({ traceparent: t4, interactiveTransaction: r5 } = {}) {
      let n4 = { Authorization: `Bearer ${this.apiKey}`, "Prisma-Engine-Hash": this.engineHash };
      this.tracingHelper.isEnabled() && (n4.traceparent = t4 ?? this.tracingHelper.getTraceParent()), r5 && (n4["X-transaction-id"] = r5.id);
      let i4 = this.buildCaptureSettings();
      return i4.length > 0 && (n4["X-capture-telemetry"] = i4.join(", ")), n4;
    }
    buildCaptureSettings() {
      let t4 = [];
      return this.tracingHelper.isEnabled() && t4.push("tracing"), this.logLevel && t4.push(this.logLevel), this.logQueries && t4.push("query"), t4;
    }
  };
  var Dr = class {
    constructor(t4) {
      this.name = "DataProxyEngine";
      cl2(t4), this.config = t4, this.env = { ...t4.env, ...typeof process < "u" ? process.env : {} }, this.inlineSchema = ul(t4.inlineSchema), this.inlineDatasources = t4.inlineDatasources, this.inlineSchemaHash = t4.inlineSchemaHash, this.clientVersion = t4.clientVersion, this.engineHash = t4.engineVersion, this.logEmitter = t4.logEmitter, this.tracingHelper = t4.tracingHelper;
    }
    apiKey() {
      return this.headerBuilder.apiKey;
    }
    version() {
      return this.engineHash;
    }
    async start() {
      this.startPromise !== undefined && await this.startPromise, this.startPromise = (async () => {
        let [t4, r5] = this.extractHostAndApiKey();
        this.host = t4, this.headerBuilder = new ao2({ apiKey: r5, tracingHelper: this.tracingHelper, logLevel: this.config.logLevel, logQueries: this.config.logQueries, engineHash: this.engineHash }), this.remoteClientVersion = await ml(t4, this.config), Nn("host", this.host);
      })(), await this.startPromise;
    }
    async stop() {
    }
    propagateResponseExtensions(t4) {
      t4?.logs?.length && t4.logs.forEach((r5) => {
        switch (r5.level) {
          case "debug":
          case "trace":
            Nn(r5);
            break;
          case "error":
          case "warn":
          case "info": {
            this.logEmitter.emit(r5.level, { timestamp: so(r5.timestamp), message: r5.attributes.message ?? "", target: r5.target });
            break;
          }
          case "query": {
            this.logEmitter.emit("query", { query: r5.attributes.query ?? "", timestamp: so(r5.timestamp), duration: r5.attributes.duration_ms ?? 0, params: r5.attributes.params ?? "", target: r5.target });
            break;
          }
          default:
            r5.level;
        }
      }), t4?.traces?.length && this.tracingHelper.dispatchEngineSpans(t4.traces);
    }
    onBeforeExit() {
      throw new Error('"beforeExit" hook is not applicable to the remote query engine');
    }
    async url(t4) {
      return await this.start(), `https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${t4}`;
    }
    async uploadSchema() {
      let t4 = { name: "schemaUpload", internal: true };
      return this.tracingHelper.runInChildSpan(t4, async () => {
        let r5 = await ut(await this.url("schema"), { method: "PUT", headers: this.headerBuilder.build(), body: this.inlineSchema, clientVersion: this.clientVersion });
        r5.ok || Nn("schema response status", r5.status);
        let n4 = await Or(r5, this.clientVersion);
        if (n4)
          throw this.logEmitter.emit("warn", { message: `Error while uploading schema: ${n4.message}`, timestamp: new Date, target: "" }), n4;
        this.logEmitter.emit("info", { message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})`, timestamp: new Date, target: "" });
      });
    }
    request(t4, { traceparent: r5, interactiveTransaction: n4, customDataProxyFetch: i4 }) {
      return this.requestInternal({ body: t4, traceparent: r5, interactiveTransaction: n4, customDataProxyFetch: i4 });
    }
    async requestBatch(t4, { traceparent: r5, transaction: n4, customDataProxyFetch: i4 }) {
      let o3 = n4?.kind === "itx" ? n4.options : undefined, s5 = Dt(t4, n4);
      return (await this.requestInternal({ body: s5, customDataProxyFetch: i4, interactiveTransaction: o3, traceparent: r5 })).map((l4) => (l4.extensions && this.propagateResponseExtensions(l4.extensions), ("errors" in l4) ? this.convertProtocolErrorsToClientError(l4.errors) : l4));
    }
    requestInternal({ body: t4, traceparent: r5, customDataProxyFetch: n4, interactiveTransaction: i4 }) {
      return this.withRetry({ actionGerund: "querying", callback: async ({ logHttpCall: o3 }) => {
        let s5 = i4 ? `${i4.payload.endpoint}/graphql` : await this.url("graphql");
        o3(s5);
        let a5 = await ut(s5, { method: "POST", headers: this.headerBuilder.build({ traceparent: r5, interactiveTransaction: i4 }), body: JSON.stringify(t4), clientVersion: this.clientVersion }, n4);
        a5.ok || Nn("graphql response status", a5.status), await this.handleError(await Or(a5, this.clientVersion));
        let l4 = await a5.json();
        if (l4.extensions && this.propagateResponseExtensions(l4.extensions), "errors" in l4)
          throw this.convertProtocolErrorsToClientError(l4.errors);
        return "batchResult" in l4 ? l4.batchResult : l4;
      } });
    }
    async transaction(t4, r5, n4) {
      let i4 = { start: "starting", commit: "committing", rollback: "rolling back" };
      return this.withRetry({ actionGerund: `${i4[t4]} transaction`, callback: async ({ logHttpCall: o3 }) => {
        if (t4 === "start") {
          let s5 = JSON.stringify({ max_wait: n4.maxWait, timeout: n4.timeout, isolation_level: n4.isolationLevel }), a5 = await this.url("transaction/start");
          o3(a5);
          let l4 = await ut(a5, { method: "POST", headers: this.headerBuilder.build({ traceparent: r5.traceparent }), body: s5, clientVersion: this.clientVersion });
          await this.handleError(await Or(l4, this.clientVersion));
          let u5 = await l4.json(), { extensions: c5 } = u5;
          c5 && this.propagateResponseExtensions(c5);
          let p5 = u5.id, d4 = u5["data-proxy"].endpoint;
          return { id: p5, payload: { endpoint: d4 } };
        } else {
          let s5 = `${n4.payload.endpoint}/${t4}`;
          o3(s5);
          let a5 = await ut(s5, { method: "POST", headers: this.headerBuilder.build({ traceparent: r5.traceparent }), clientVersion: this.clientVersion });
          await this.handleError(await Or(a5, this.clientVersion));
          let l4 = await a5.json(), { extensions: u5 } = l4;
          u5 && this.propagateResponseExtensions(u5);
          return;
        }
      } });
    }
    extractHostAndApiKey() {
      let t4 = { clientVersion: this.clientVersion }, r5 = Object.keys(this.inlineDatasources)[0], n4 = Lt({ inlineDatasources: this.inlineDatasources, overrideDatasources: this.config.overrideDatasources, clientVersion: this.clientVersion, env: this.env }), i4;
      try {
        i4 = new URL(n4);
      } catch {
        throw new st(`Error validating datasource \`${r5}\`: the URL must start with the protocol \`prisma://\``, t4);
      }
      let { protocol: o3, host: s5, searchParams: a5 } = i4;
      if (o3 !== "prisma:" && o3 !== "prisma+postgres:")
        throw new st(`Error validating datasource \`${r5}\`: the URL must start with the protocol \`prisma://\``, t4);
      let l4 = a5.get("api_key");
      if (l4 === null || l4.length < 1)
        throw new st(`Error validating datasource \`${r5}\`: the URL must contain a valid API key`, t4);
      return [s5, l4];
    }
    metrics() {
      throw new at2("Metrics are not yet supported for Accelerate", { clientVersion: this.clientVersion });
    }
    async withRetry(t4) {
      for (let r5 = 0;; r5++) {
        let n4 = (i4) => {
          this.logEmitter.emit("info", { message: `Calling ${i4} (n=${r5})`, timestamp: new Date, target: "" });
        };
        try {
          return await t4.callback({ logHttpCall: n4 });
        } catch (i4) {
          if (!(i4 instanceof le) || !i4.isRetryable)
            throw i4;
          if (r5 >= fl)
            throw i4 instanceof Ft ? i4.cause : i4;
          this.logEmitter.emit("warn", { message: `Attempt ${r5 + 1}/${fl} failed for ${t4.actionGerund}: ${i4.message ?? "(unknown)"}`, timestamp: new Date, target: "" });
          let o3 = await ll(r5);
          this.logEmitter.emit("warn", { message: `Retrying after ${o3}ms`, timestamp: new Date, target: "" });
        }
      }
    }
    async handleError(t4) {
      if (t4 instanceof lt)
        throw await this.uploadSchema(), new Ft({ clientVersion: this.clientVersion, cause: t4 });
      if (t4)
        throw t4;
    }
    convertProtocolErrorsToClientError(t4) {
      return t4.length === 1 ? _t(t4[0], this.config.clientVersion, this.config.activeProvider) : new B4(JSON.stringify(t4), { clientVersion: this.config.clientVersion });
    }
    applyPendingMigrations() {
      throw new Error("Method not implemented.");
    }
  };
  function gl(e4) {
    if (e4?.kind === "itx")
      return e4.options.id;
  }
  var uo = D3(__require("os"));
  var hl = D3(__require("path"));
  var lo = Symbol("PrismaLibraryEngineCache");
  function fm() {
    let e4 = globalThis;
    return e4[lo] === undefined && (e4[lo] = {}), e4[lo];
  }
  function gm(e4) {
    let t4 = fm();
    if (t4[e4] !== undefined)
      return t4[e4];
    let r5 = hl.default.toNamespacedPath(e4), n4 = { exports: {} }, i4 = 0;
    return process.platform !== "win32" && (i4 = uo.default.constants.dlopen.RTLD_LAZY | uo.default.constants.dlopen.RTLD_DEEPBIND), process.dlopen(n4, r5, i4), t4[e4] = n4.exports, n4.exports;
  }
  var yl = { async loadLibrary(e4) {
    let t4 = await ei(), r5 = await tl("library", e4);
    try {
      return e4.tracingHelper.runInChildSpan({ name: "loadLibrary", internal: true }, () => gm(r5));
    } catch (n4) {
      let i4 = di({ e: n4, platformInfo: t4, id: r5 });
      throw new T4(i4, e4.clientVersion);
    }
  } };
  var co2;
  var El = { async loadLibrary(e4) {
    let { clientVersion: t4, adapter: r5, engineWasm: n4 } = e4;
    if (r5 === undefined)
      throw new T4(`The \`adapter\` option for \`PrismaClient\` is required in this context (${In().prettyName})`, t4);
    if (n4 === undefined)
      throw new T4("WASM engine was unexpectedly `undefined`", t4);
    co2 === undefined && (co2 = (async () => {
      let o3 = n4.getRuntime(), s5 = await n4.getQueryEngineWasmModule();
      if (s5 == null)
        throw new T4("The loaded wasm module was unexpectedly `undefined` or `null` once loaded", t4);
      let a5 = { "./query_engine_bg.js": o3 }, l4 = new WebAssembly.Instance(s5, a5);
      return o3.__wbg_set_wasm(l4.exports), o3.QueryEngine;
    })());
    let i4 = await co2;
    return { debugPanic() {
      return Promise.reject("{}");
    }, dmmf() {
      return Promise.resolve("{}");
    }, version() {
      return { commit: "unknown", version: "unknown" };
    }, QueryEngine: i4 };
  } };
  var hm = "P2036";
  var Ie = F3("prisma:client:libraryEngine");
  function ym(e4) {
    return e4.item_type === "query" && "query" in e4;
  }
  function Em(e4) {
    return "level" in e4 ? e4.level === "error" && e4.message === "PANIC" : false;
  }
  var bl2 = [...Wn, "native"];
  var bm2 = 0xffffffffffffffffn;
  var po = 1n;
  function wm() {
    let e4 = po++;
    return po > bm2 && (po = 1n), e4;
  }
  var _r = class {
    constructor(t4, r5) {
      this.name = "LibraryEngine";
      this.libraryLoader = r5 ?? yl, t4.engineWasm !== undefined && (this.libraryLoader = r5 ?? El), this.config = t4, this.libraryStarted = false, this.logQueries = t4.logQueries ?? false, this.logLevel = t4.logLevel ?? "error", this.logEmitter = t4.logEmitter, this.datamodel = t4.inlineSchema, this.tracingHelper = t4.tracingHelper, t4.enableDebugLogs && (this.logLevel = "debug");
      let n4 = Object.keys(t4.overrideDatasources)[0], i4 = t4.overrideDatasources[n4]?.url;
      n4 !== undefined && i4 !== undefined && (this.datasourceOverrides = { [n4]: i4 }), this.libraryInstantiationPromise = this.instantiateLibrary();
    }
    wrapEngine(t4) {
      return { applyPendingMigrations: t4.applyPendingMigrations?.bind(t4), commitTransaction: this.withRequestId(t4.commitTransaction.bind(t4)), connect: this.withRequestId(t4.connect.bind(t4)), disconnect: this.withRequestId(t4.disconnect.bind(t4)), metrics: t4.metrics?.bind(t4), query: this.withRequestId(t4.query.bind(t4)), rollbackTransaction: this.withRequestId(t4.rollbackTransaction.bind(t4)), sdlSchema: t4.sdlSchema?.bind(t4), startTransaction: this.withRequestId(t4.startTransaction.bind(t4)), trace: t4.trace.bind(t4) };
    }
    withRequestId(t4) {
      return async (...r5) => {
        let n4 = wm().toString();
        try {
          return await t4(...r5, n4);
        } finally {
          if (this.tracingHelper.isEnabled()) {
            let i4 = await this.engine?.trace(n4);
            if (i4) {
              let o3 = JSON.parse(i4);
              this.tracingHelper.dispatchEngineSpans(o3.spans);
            }
          }
        }
      };
    }
    async applyPendingMigrations() {
      throw new Error("Cannot call this method from this type of engine instance");
    }
    async transaction(t4, r5, n4) {
      await this.start();
      let i4 = JSON.stringify(r5), o3;
      if (t4 === "start") {
        let a5 = JSON.stringify({ max_wait: n4.maxWait, timeout: n4.timeout, isolation_level: n4.isolationLevel });
        o3 = await this.engine?.startTransaction(a5, i4);
      } else
        t4 === "commit" ? o3 = await this.engine?.commitTransaction(n4.id, i4) : t4 === "rollback" && (o3 = await this.engine?.rollbackTransaction(n4.id, i4));
      let s5 = this.parseEngineResponse(o3);
      if (xm(s5)) {
        let a5 = this.getExternalAdapterError(s5);
        throw a5 ? a5.error : new ee2(s5.message, { code: s5.error_code, clientVersion: this.config.clientVersion, meta: s5.meta });
      }
      return s5;
    }
    async instantiateLibrary() {
      if (Ie("internalSetup"), this.libraryInstantiationPromise)
        return this.libraryInstantiationPromise;
      Hn(), this.binaryTarget = await this.getCurrentBinaryTarget(), await this.tracingHelper.runInChildSpan("load_engine", () => this.loadEngine()), this.version();
    }
    async getCurrentBinaryTarget() {
      {
        if (this.binaryTarget)
          return this.binaryTarget;
        let t4 = await this.tracingHelper.runInChildSpan("detect_platform", () => nt());
        if (!bl2.includes(t4))
          throw new T4(`Unknown ${de2("PRISMA_QUERY_ENGINE_LIBRARY")} ${de2(W3(t4))}. Possible binaryTargets: ${Ve(bl2.join(", "))} or a path to the query engine library.
You may have to run ${Ve("prisma generate")} for your changes to take effect.`, this.config.clientVersion);
        return t4;
      }
    }
    parseEngineResponse(t4) {
      if (!t4)
        throw new B4("Response from the Engine was empty", { clientVersion: this.config.clientVersion });
      try {
        return JSON.parse(t4);
      } catch {
        throw new B4("Unable to JSON.parse response from engine", { clientVersion: this.config.clientVersion });
      }
    }
    async loadEngine() {
      if (!this.engine) {
        this.QueryEngineConstructor || (this.library = await this.libraryLoader.loadLibrary(this.config), this.QueryEngineConstructor = this.library.QueryEngine);
        try {
          let t4 = new WeakRef(this), { adapter: r5 } = this.config;
          r5 && Ie("Using driver adapter: %O", r5), this.engine = this.wrapEngine(new this.QueryEngineConstructor({ datamodel: this.datamodel, env: process.env, logQueries: this.config.logQueries ?? false, ignoreEnvVarErrors: true, datasourceOverrides: this.datasourceOverrides ?? {}, logLevel: this.logLevel, configDir: this.config.cwd, engineProtocol: "json", enableTracing: this.tracingHelper.isEnabled() }, (n4) => {
            t4.deref()?.logger(n4);
          }, r5));
        } catch (t4) {
          let r5 = t4, n4 = this.parseInitError(r5.message);
          throw typeof n4 == "string" ? r5 : new T4(n4.message, this.config.clientVersion, n4.error_code);
        }
      }
    }
    logger(t4) {
      let r5 = this.parseEngineResponse(t4);
      r5 && (r5.level = r5?.level.toLowerCase() ?? "unknown", ym(r5) ? this.logEmitter.emit("query", { timestamp: new Date, query: r5.query, params: r5.params, duration: Number(r5.duration_ms), target: r5.module_path }) : Em(r5) ? this.loggerRustPanic = new ce2(mo(this, `${r5.message}: ${r5.reason} in ${r5.file}:${r5.line}:${r5.column}`), this.config.clientVersion) : this.logEmitter.emit(r5.level, { timestamp: new Date, message: r5.message, target: r5.module_path }));
    }
    parseInitError(t4) {
      try {
        return JSON.parse(t4);
      } catch {
      }
      return t4;
    }
    parseRequestError(t4) {
      try {
        return JSON.parse(t4);
      } catch {
      }
      return t4;
    }
    onBeforeExit() {
      throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.');
    }
    async start() {
      if (await this.libraryInstantiationPromise, await this.libraryStoppingPromise, this.libraryStartingPromise)
        return Ie(`library already starting, this.libraryStarted: ${this.libraryStarted}`), this.libraryStartingPromise;
      if (this.libraryStarted)
        return;
      let t4 = async () => {
        Ie("library starting");
        try {
          let r5 = { traceparent: this.tracingHelper.getTraceParent() };
          await this.engine?.connect(JSON.stringify(r5)), this.libraryStarted = true, Ie("library started");
        } catch (r5) {
          let n4 = this.parseInitError(r5.message);
          throw typeof n4 == "string" ? r5 : new T4(n4.message, this.config.clientVersion, n4.error_code);
        } finally {
          this.libraryStartingPromise = undefined;
        }
      };
      return this.libraryStartingPromise = this.tracingHelper.runInChildSpan("connect", t4), this.libraryStartingPromise;
    }
    async stop() {
      if (await this.libraryStartingPromise, await this.executingQueryPromise, this.libraryStoppingPromise)
        return Ie("library is already stopping"), this.libraryStoppingPromise;
      if (!this.libraryStarted)
        return;
      let t4 = async () => {
        await new Promise((n4) => setTimeout(n4, 5)), Ie("library stopping");
        let r5 = { traceparent: this.tracingHelper.getTraceParent() };
        await this.engine?.disconnect(JSON.stringify(r5)), this.libraryStarted = false, this.libraryStoppingPromise = undefined, Ie("library stopped");
      };
      return this.libraryStoppingPromise = this.tracingHelper.runInChildSpan("disconnect", t4), this.libraryStoppingPromise;
    }
    version() {
      return this.versionInfo = this.library?.version(), this.versionInfo?.version ?? "unknown";
    }
    debugPanic(t4) {
      return this.library?.debugPanic(t4);
    }
    async request(t4, { traceparent: r5, interactiveTransaction: n4 }) {
      Ie(`sending request, this.libraryStarted: ${this.libraryStarted}`);
      let i4 = JSON.stringify({ traceparent: r5 }), o3 = JSON.stringify(t4);
      try {
        await this.start(), this.executingQueryPromise = this.engine?.query(o3, i4, n4?.id), this.lastQuery = o3;
        let s5 = this.parseEngineResponse(await this.executingQueryPromise);
        if (s5.errors)
          throw s5.errors.length === 1 ? this.buildQueryError(s5.errors[0]) : new B4(JSON.stringify(s5.errors), { clientVersion: this.config.clientVersion });
        if (this.loggerRustPanic)
          throw this.loggerRustPanic;
        return { data: s5 };
      } catch (s5) {
        if (s5 instanceof T4)
          throw s5;
        if (s5.code === "GenericFailure" && s5.message?.startsWith("PANIC:"))
          throw new ce2(mo(this, s5.message), this.config.clientVersion);
        let a5 = this.parseRequestError(s5.message);
        throw typeof a5 == "string" ? s5 : new B4(`${a5.message}
${a5.backtrace}`, { clientVersion: this.config.clientVersion });
      }
    }
    async requestBatch(t4, { transaction: r5, traceparent: n4 }) {
      Ie("requestBatch");
      let i4 = Dt(t4, r5);
      await this.start(), this.lastQuery = JSON.stringify(i4), this.executingQueryPromise = this.engine.query(this.lastQuery, JSON.stringify({ traceparent: n4 }), gl(r5));
      let o3 = await this.executingQueryPromise, s5 = this.parseEngineResponse(o3);
      if (s5.errors)
        throw s5.errors.length === 1 ? this.buildQueryError(s5.errors[0]) : new B4(JSON.stringify(s5.errors), { clientVersion: this.config.clientVersion });
      let { batchResult: a5, errors: l4 } = s5;
      if (Array.isArray(a5))
        return a5.map((u5) => u5.errors && u5.errors.length > 0 ? this.loggerRustPanic ?? this.buildQueryError(u5.errors[0]) : { data: u5 });
      throw l4 && l4.length === 1 ? new Error(l4[0].error) : new Error(JSON.stringify(s5));
    }
    buildQueryError(t4) {
      if (t4.user_facing_error.is_panic)
        return new ce2(mo(this, t4.user_facing_error.message), this.config.clientVersion);
      let r5 = this.getExternalAdapterError(t4.user_facing_error);
      return r5 ? r5.error : _t(t4, this.config.clientVersion, this.config.activeProvider);
    }
    getExternalAdapterError(t4) {
      if (t4.error_code === hm && this.config.adapter) {
        let r5 = t4.meta?.id;
        Yr(typeof r5 == "number", "Malformed external JS error received from the engine");
        let n4 = this.config.adapter.errorRegistry.consumeError(r5);
        return Yr(n4, "External error with reported id was not registered"), n4;
      }
    }
    async metrics(t4) {
      await this.start();
      let r5 = await this.engine.metrics(JSON.stringify(t4));
      return t4.format === "prometheus" ? r5 : this.parseEngineResponse(r5);
    }
  };
  function xm(e4) {
    return typeof e4 == "object" && e4 !== null && e4.error_code !== undefined;
  }
  function mo(e4, t4) {
    return al2({ binaryTarget: e4.binaryTarget, title: t4, version: e4.config.clientVersion, engineVersion: e4.versionInfo?.commit, database: e4.config.activeProvider, query: e4.lastQuery });
  }
  function wl({ copyEngine: e4 = true }, t4) {
    let r5;
    try {
      r5 = Lt({ inlineDatasources: t4.inlineDatasources, overrideDatasources: t4.overrideDatasources, env: { ...t4.env, ...process.env }, clientVersion: t4.clientVersion });
    } catch {
    }
    let n4 = !!(r5?.startsWith("prisma://") || r5?.startsWith("prisma+postgres://"));
    e4 && n4 && tr("recommend--no-engine", "In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");
    let i4 = Yt(t4.generator), o3 = n4 || !e4, s5 = !!t4.adapter, a5 = i4 === "library", l4 = i4 === "binary";
    if (o3 && s5 || s5 && false) {
      let u5;
      throw e4 ? r5?.startsWith("prisma://") ? u5 = ["Prisma Client was configured to use the `adapter` option but the URL was a `prisma://` URL.", "Please either use the `prisma://` URL or remove the `adapter` from the Prisma Client constructor."] : u5 = ["Prisma Client was configured to use both the `adapter` and Accelerate, please chose one."] : u5 = ["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.", "Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."], new te(u5.join(`
`), { clientVersion: t4.clientVersion });
    }
    if (o3)
      return new Dr(t4);
    if (a5)
      return new _r(t4);
    throw new te("Invalid client engine type, please use `library` or `binary`", { clientVersion: t4.clientVersion });
  }
  function Ln({ generator: e4 }) {
    return e4?.previewFeatures ?? [];
  }
  var xl = (e4) => ({ command: e4 });
  var vl = (e4) => e4.strings.reduce((t4, r5, n4) => `${t4}@P${n4}${r5}`);
  function qt(e4) {
    try {
      return Pl(e4, "fast");
    } catch {
      return Pl(e4, "slow");
    }
  }
  function Pl(e4, t4) {
    return JSON.stringify(e4.map((r5) => Rl(r5, t4)));
  }
  function Rl(e4, t4) {
    if (Array.isArray(e4))
      return e4.map((r5) => Rl(r5, t4));
    if (typeof e4 == "bigint")
      return { prisma__type: "bigint", prisma__value: e4.toString() };
    if (xt(e4))
      return { prisma__type: "date", prisma__value: e4.toJSON() };
    if (ve.isDecimal(e4))
      return { prisma__type: "decimal", prisma__value: e4.toJSON() };
    if (Buffer.isBuffer(e4))
      return { prisma__type: "bytes", prisma__value: e4.toString("base64") };
    if (vm(e4))
      return { prisma__type: "bytes", prisma__value: Buffer.from(e4).toString("base64") };
    if (ArrayBuffer.isView(e4)) {
      let { buffer: r5, byteOffset: n4, byteLength: i4 } = e4;
      return { prisma__type: "bytes", prisma__value: Buffer.from(r5, n4, i4).toString("base64") };
    }
    return typeof e4 == "object" && t4 === "slow" ? Cl(e4) : e4;
  }
  function vm(e4) {
    return e4 instanceof ArrayBuffer || e4 instanceof SharedArrayBuffer ? true : typeof e4 == "object" && e4 !== null ? e4[Symbol.toStringTag] === "ArrayBuffer" || e4[Symbol.toStringTag] === "SharedArrayBuffer" : false;
  }
  function Cl(e4) {
    if (typeof e4 != "object" || e4 === null)
      return e4;
    if (typeof e4.toJSON == "function")
      return e4.toJSON();
    if (Array.isArray(e4))
      return e4.map(Tl);
    let t4 = {};
    for (let r5 of Object.keys(e4))
      t4[r5] = Tl(e4[r5]);
    return t4;
  }
  function Tl(e4) {
    return typeof e4 == "bigint" ? e4.toString() : Cl(e4);
  }
  var Pm = ["$connect", "$disconnect", "$on", "$transaction", "$use", "$extends"];
  var Sl = Pm;
  var Tm = /^(\s*alter\s)/i;
  var Al = F3("prisma:client");
  function fo(e4, t4, r5, n4) {
    if (!(e4 !== "postgresql" && e4 !== "cockroachdb") && r5.length > 0 && Tm.exec(t4))
      throw new Error(`Running ALTER using ${n4} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
  }
  var go = ({ clientMethod: e4, activeProvider: t4 }) => (r5) => {
    let n4 = "", i4;
    if (ya(r5))
      n4 = r5.sql, i4 = { values: qt(r5.values), __prismaRawParameters__: true };
    else if (Array.isArray(r5)) {
      let [o3, ...s5] = r5;
      n4 = o3, i4 = { values: qt(s5 || []), __prismaRawParameters__: true };
    } else
      switch (t4) {
        case "sqlite":
        case "mysql": {
          n4 = r5.sql, i4 = { values: qt(r5.values), __prismaRawParameters__: true };
          break;
        }
        case "cockroachdb":
        case "postgresql":
        case "postgres": {
          n4 = r5.text, i4 = { values: qt(r5.values), __prismaRawParameters__: true };
          break;
        }
        case "sqlserver": {
          n4 = vl(r5), i4 = { values: qt(r5.values), __prismaRawParameters__: true };
          break;
        }
        default:
          throw new Error(`The ${t4} provider does not support ${e4}`);
      }
    return i4?.values ? Al(`prisma.${e4}(${n4}, ${i4.values})`) : Al(`prisma.${e4}(${n4})`), { query: n4, parameters: i4 };
  };
  var Il = { requestArgsToMiddlewareArgs(e4) {
    return [e4.strings, ...e4.values];
  }, middlewareArgsToRequestArgs(e4) {
    let [t4, ...r5] = e4;
    return new ae2(t4, r5);
  } };
  var Ol = { requestArgsToMiddlewareArgs(e4) {
    return [e4];
  }, middlewareArgsToRequestArgs(e4) {
    return e4[0];
  } };
  function ho(e4) {
    return function(r5) {
      let n4, i4 = (o3 = e4) => {
        try {
          return o3 === undefined || o3?.kind === "itx" ? n4 ??= kl(r5(o3)) : kl(r5(o3));
        } catch (s5) {
          return Promise.reject(s5);
        }
      };
      return { then(o3, s5) {
        return i4().then(o3, s5);
      }, catch(o3) {
        return i4().catch(o3);
      }, finally(o3) {
        return i4().finally(o3);
      }, requestTransaction(o3) {
        let s5 = i4(o3);
        return s5.requestTransaction ? s5.requestTransaction(o3) : s5;
      }, [Symbol.toStringTag]: "PrismaPromise" };
    };
  }
  function kl(e4) {
    return typeof e4.then == "function" ? e4 : Promise.resolve(e4);
  }
  var Rm = { isEnabled() {
    return false;
  }, getTraceParent() {
    return "00-10-10-00";
  }, dispatchEngineSpans() {
  }, getActiveContext() {
  }, runInChildSpan(e4, t4) {
    return t4();
  } };
  var yo = class {
    isEnabled() {
      return this.getGlobalTracingHelper().isEnabled();
    }
    getTraceParent(t4) {
      return this.getGlobalTracingHelper().getTraceParent(t4);
    }
    dispatchEngineSpans(t4) {
      return this.getGlobalTracingHelper().dispatchEngineSpans(t4);
    }
    getActiveContext() {
      return this.getGlobalTracingHelper().getActiveContext();
    }
    runInChildSpan(t4, r5) {
      return this.getGlobalTracingHelper().runInChildSpan(t4, r5);
    }
    getGlobalTracingHelper() {
      return globalThis.PRISMA_INSTRUMENTATION?.helper ?? Rm;
    }
  };
  function Dl() {
    return new yo;
  }
  function _l(e4, t4 = () => {
  }) {
    let r5, n4 = new Promise((i4) => r5 = i4);
    return { then(i4) {
      return --e4 === 0 && r5(t4()), i4?.(n4);
    } };
  }
  function Nl(e4) {
    return typeof e4 == "string" ? e4 : e4.reduce((t4, r5) => {
      let n4 = typeof r5 == "string" ? r5 : r5.level;
      return n4 === "query" ? t4 : t4 && (r5 === "info" || t4 === "info") ? "info" : n4;
    }, undefined);
  }
  var Fn = class {
    constructor() {
      this._middlewares = [];
    }
    use(t4) {
      this._middlewares.push(t4);
    }
    get(t4) {
      return this._middlewares[t4];
    }
    has(t4) {
      return !!this._middlewares[t4];
    }
    length() {
      return this._middlewares.length;
    }
  };
  var Fl = D3(Pi());
  function Mn(e4) {
    return typeof e4.batchRequestIdx == "number";
  }
  function Ll(e4) {
    if (e4.action !== "findUnique" && e4.action !== "findUniqueOrThrow")
      return;
    let t4 = [];
    return e4.modelName && t4.push(e4.modelName), e4.query.arguments && t4.push(Eo(e4.query.arguments)), t4.push(Eo(e4.query.selection)), t4.join("");
  }
  function Eo(e4) {
    return `(${Object.keys(e4).sort().map((r5) => {
      let n4 = e4[r5];
      return typeof n4 == "object" && n4 !== null ? `(${r5} ${Eo(n4)})` : r5;
    }).join(" ")})`;
  }
  var Cm = { aggregate: false, aggregateRaw: false, createMany: true, createManyAndReturn: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateManyAndReturn: true, updateOne: true, upsertOne: true };
  function bo2(e4) {
    return Cm[e4];
  }
  var $n = class {
    constructor(t4) {
      this.options = t4;
      this.tickActive = false;
      this.batches = {};
    }
    request(t4) {
      let r5 = this.options.batchBy(t4);
      return r5 ? (this.batches[r5] || (this.batches[r5] = [], this.tickActive || (this.tickActive = true, process.nextTick(() => {
        this.dispatchBatches(), this.tickActive = false;
      }))), new Promise((n4, i4) => {
        this.batches[r5].push({ request: t4, resolve: n4, reject: i4 });
      })) : this.options.singleLoader(t4);
    }
    dispatchBatches() {
      for (let t4 in this.batches) {
        let r5 = this.batches[t4];
        delete this.batches[t4], r5.length === 1 ? this.options.singleLoader(r5[0].request).then((n4) => {
          n4 instanceof Error ? r5[0].reject(n4) : r5[0].resolve(n4);
        }).catch((n4) => {
          r5[0].reject(n4);
        }) : (r5.sort((n4, i4) => this.options.batchOrder(n4.request, i4.request)), this.options.batchLoader(r5.map((n4) => n4.request)).then((n4) => {
          if (n4 instanceof Error)
            for (let i4 = 0;i4 < r5.length; i4++)
              r5[i4].reject(n4);
          else
            for (let i4 = 0;i4 < r5.length; i4++) {
              let o3 = n4[i4];
              o3 instanceof Error ? r5[i4].reject(o3) : r5[i4].resolve(o3);
            }
        }).catch((n4) => {
          for (let i4 = 0;i4 < r5.length; i4++)
            r5[i4].reject(n4);
        }));
      }
    }
    get [Symbol.toStringTag]() {
      return "DataLoader";
    }
  };
  function ct2(e4, t4) {
    if (t4 === null)
      return t4;
    switch (e4) {
      case "bigint":
        return BigInt(t4);
      case "bytes": {
        let { buffer: r5, byteOffset: n4, byteLength: i4 } = Buffer.from(t4, "base64");
        return new Uint8Array(r5, n4, i4);
      }
      case "decimal":
        return new ve(t4);
      case "datetime":
      case "date":
        return new Date(t4);
      case "time":
        return new Date(`1970-01-01T${t4}Z`);
      case "bigint-array":
        return t4.map((r5) => ct2("bigint", r5));
      case "bytes-array":
        return t4.map((r5) => ct2("bytes", r5));
      case "decimal-array":
        return t4.map((r5) => ct2("decimal", r5));
      case "datetime-array":
        return t4.map((r5) => ct2("datetime", r5));
      case "date-array":
        return t4.map((r5) => ct2("date", r5));
      case "time-array":
        return t4.map((r5) => ct2("time", r5));
      default:
        return t4;
    }
  }
  function qn(e4) {
    let t4 = [], r5 = Sm(e4);
    for (let n4 = 0;n4 < e4.rows.length; n4++) {
      let i4 = e4.rows[n4], o3 = { ...r5 };
      for (let s5 = 0;s5 < i4.length; s5++)
        o3[e4.columns[s5]] = ct2(e4.types[s5], i4[s5]);
      t4.push(o3);
    }
    return t4;
  }
  function Sm(e4) {
    let t4 = {};
    for (let r5 = 0;r5 < e4.columns.length; r5++)
      t4[e4.columns[r5]] = null;
    return t4;
  }
  var Am = F3("prisma:client:request_handler");
  var Vn = class {
    constructor(t4, r5) {
      this.logEmitter = r5, this.client = t4, this.dataloader = new $n({ batchLoader: Ba(async ({ requests: n4, customDataProxyFetch: i4 }) => {
        let { transaction: o3, otelParentCtx: s5 } = n4[0], a5 = n4.map((p5) => p5.protocolQuery), l4 = this.client._tracingHelper.getTraceParent(s5), u5 = n4.some((p5) => bo2(p5.protocolQuery.action));
        return (await this.client._engine.requestBatch(a5, { traceparent: l4, transaction: Im(o3), containsWrite: u5, customDataProxyFetch: i4 })).map((p5, d4) => {
          if (p5 instanceof Error)
            return p5;
          try {
            return this.mapQueryEngineResult(n4[d4], p5);
          } catch (f4) {
            return f4;
          }
        });
      }), singleLoader: async (n4) => {
        let i4 = n4.transaction?.kind === "itx" ? Ml(n4.transaction) : undefined, o3 = await this.client._engine.request(n4.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: i4, isWrite: bo2(n4.protocolQuery.action), customDataProxyFetch: n4.customDataProxyFetch });
        return this.mapQueryEngineResult(n4, o3);
      }, batchBy: (n4) => n4.transaction?.id ? `transaction-${n4.transaction.id}` : Ll(n4.protocolQuery), batchOrder(n4, i4) {
        return n4.transaction?.kind === "batch" && i4.transaction?.kind === "batch" ? n4.transaction.index - i4.transaction.index : 0;
      } });
    }
    async request(t4) {
      try {
        return await this.dataloader.request(t4);
      } catch (r5) {
        let { clientMethod: n4, callsite: i4, transaction: o3, args: s5, modelName: a5 } = t4;
        this.handleAndLogRequestError({ error: r5, clientMethod: n4, callsite: i4, transaction: o3, args: s5, modelName: a5, globalOmit: t4.globalOmit });
      }
    }
    mapQueryEngineResult({ dataPath: t4, unpacker: r5 }, n4) {
      let i4 = n4?.data, o3 = this.unpack(i4, t4, r5);
      return process.env.PRISMA_CLIENT_GET_TIME ? { data: o3 } : o3;
    }
    handleAndLogRequestError(t4) {
      try {
        this.handleRequestError(t4);
      } catch (r5) {
        throw this.logEmitter && this.logEmitter.emit("error", { message: r5.message, target: t4.clientMethod, timestamp: new Date }), r5;
      }
    }
    handleRequestError({ error: t4, clientMethod: r5, callsite: n4, transaction: i4, args: o3, modelName: s5, globalOmit: a5 }) {
      if (Am(t4), Om(t4, i4))
        throw t4;
      if (t4 instanceof ee2 && km(t4)) {
        let u5 = $l(t4.meta);
        wn({ args: o3, errors: [u5], callsite: n4, errorFormat: this.client._errorFormat, originalMethod: r5, clientVersion: this.client._clientVersion, globalOmit: a5 });
      }
      let l4 = t4.message;
      if (n4 && (l4 = cn2({ callsite: n4, originalMethod: r5, isPanic: t4.isPanic, showColors: this.client._errorFormat === "pretty", message: l4 })), l4 = this.sanitizeMessage(l4), t4.code) {
        let u5 = s5 ? { modelName: s5, ...t4.meta } : t4.meta;
        throw new ee2(l4, { code: t4.code, clientVersion: this.client._clientVersion, meta: u5, batchRequestIdx: t4.batchRequestIdx });
      } else {
        if (t4.isPanic)
          throw new ce2(l4, this.client._clientVersion);
        if (t4 instanceof B4)
          throw new B4(l4, { clientVersion: this.client._clientVersion, batchRequestIdx: t4.batchRequestIdx });
        if (t4 instanceof T4)
          throw new T4(l4, this.client._clientVersion);
        if (t4 instanceof ce2)
          throw new ce2(l4, this.client._clientVersion);
      }
      throw t4.clientVersion = this.client._clientVersion, t4;
    }
    sanitizeMessage(t4) {
      return this.client._errorFormat && this.client._errorFormat !== "pretty" ? (0, Fl.default)(t4) : t4;
    }
    unpack(t4, r5, n4) {
      if (!t4 || (t4.data && (t4 = t4.data), !t4))
        return t4;
      let i4 = Object.keys(t4)[0], o3 = Object.values(t4)[0], s5 = r5.filter((u5) => u5 !== "select" && u5 !== "include"), a5 = Ki(o3, s5), l4 = i4 === "queryRaw" ? qn(a5) : bt2(a5);
      return n4 ? n4(l4) : l4;
    }
    get [Symbol.toStringTag]() {
      return "RequestHandler";
    }
  };
  function Im(e4) {
    if (e4) {
      if (e4.kind === "batch")
        return { kind: "batch", options: { isolationLevel: e4.isolationLevel } };
      if (e4.kind === "itx")
        return { kind: "itx", options: Ml(e4) };
      Fe(e4, "Unknown transaction kind");
    }
  }
  function Ml(e4) {
    return { id: e4.id, payload: e4.payload };
  }
  function Om(e4, t4) {
    return Mn(e4) && t4?.kind === "batch" && e4.batchRequestIdx !== t4.index;
  }
  function km(e4) {
    return e4.code === "P2009" || e4.code === "P2012";
  }
  function $l(e4) {
    if (e4.kind === "Union")
      return { kind: "Union", errors: e4.errors.map($l) };
    if (Array.isArray(e4.selectionPath)) {
      let [, ...t4] = e4.selectionPath;
      return { ...e4, selectionPath: t4 };
    }
    return e4;
  }
  var ql = "6.2.1";
  var Vl = ql;
  var Gl = D3(_i());
  var L4 = class extends Error {
    constructor(t4) {
      super(t4 + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientConstructorValidationError";
    }
  };
  w4(L4, "PrismaClientConstructorValidationError");
  var jl = ["datasources", "datasourceUrl", "errorFormat", "adapter", "log", "transactionOptions", "omit", "__internal"];
  var Bl = ["pretty", "colorless", "minimal"];
  var Ul = ["info", "query", "warn", "error"];
  var _m = { datasources: (e4, { datasourceNames: t4 }) => {
    if (e4) {
      if (typeof e4 != "object" || Array.isArray(e4))
        throw new L4(`Invalid value ${JSON.stringify(e4)} for "datasources" provided to PrismaClient constructor`);
      for (let [r5, n4] of Object.entries(e4)) {
        if (!t4.includes(r5)) {
          let i4 = Vt(r5, t4) || ` Available datasources: ${t4.join(", ")}`;
          throw new L4(`Unknown datasource ${r5} provided to PrismaClient constructor.${i4}`);
        }
        if (typeof n4 != "object" || Array.isArray(n4))
          throw new L4(`Invalid value ${JSON.stringify(e4)} for datasource "${r5}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
        if (n4 && typeof n4 == "object")
          for (let [i4, o3] of Object.entries(n4)) {
            if (i4 !== "url")
              throw new L4(`Invalid value ${JSON.stringify(e4)} for datasource "${r5}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            if (typeof o3 != "string")
              throw new L4(`Invalid value ${JSON.stringify(o3)} for datasource "${r5}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
      }
    }
  }, adapter: (e4, t4) => {
    if (e4 === null)
      return;
    if (e4 === undefined)
      throw new L4('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');
    if (!Ln(t4).includes("driverAdapters"))
      throw new L4('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');
    if (Yt() === "binary")
      throw new L4('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.');
  }, datasourceUrl: (e4) => {
    if (typeof e4 < "u" && typeof e4 != "string")
      throw new L4(`Invalid value ${JSON.stringify(e4)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`);
  }, errorFormat: (e4) => {
    if (e4) {
      if (typeof e4 != "string")
        throw new L4(`Invalid value ${JSON.stringify(e4)} for "errorFormat" provided to PrismaClient constructor.`);
      if (!Bl.includes(e4)) {
        let t4 = Vt(e4, Bl);
        throw new L4(`Invalid errorFormat ${e4} provided to PrismaClient constructor.${t4}`);
      }
    }
  }, log: (e4) => {
    if (!e4)
      return;
    if (!Array.isArray(e4))
      throw new L4(`Invalid value ${JSON.stringify(e4)} for "log" provided to PrismaClient constructor.`);
    function t4(r5) {
      if (typeof r5 == "string" && !Ul.includes(r5)) {
        let n4 = Vt(r5, Ul);
        throw new L4(`Invalid log level "${r5}" provided to PrismaClient constructor.${n4}`);
      }
    }
    for (let r5 of e4) {
      t4(r5);
      let n4 = { level: t4, emit: (i4) => {
        let o3 = ["stdout", "event"];
        if (!o3.includes(i4)) {
          let s5 = Vt(i4, o3);
          throw new L4(`Invalid value ${JSON.stringify(i4)} for "emit" in logLevel provided to PrismaClient constructor.${s5}`);
        }
      } };
      if (r5 && typeof r5 == "object")
        for (let [i4, o3] of Object.entries(r5))
          if (n4[i4])
            n4[i4](o3);
          else
            throw new L4(`Invalid property ${i4} for "log" provided to PrismaClient constructor`);
    }
  }, transactionOptions: (e4) => {
    if (!e4)
      return;
    let t4 = e4.maxWait;
    if (t4 != null && t4 <= 0)
      throw new L4(`Invalid value ${t4} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);
    let r5 = e4.timeout;
    if (r5 != null && r5 <= 0)
      throw new L4(`Invalid value ${r5} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`);
  }, omit: (e4, t4) => {
    if (typeof e4 != "object")
      throw new L4('"omit" option is expected to be an object.');
    if (e4 === null)
      throw new L4('"omit" option can not be `null`');
    let r5 = [];
    for (let [n4, i4] of Object.entries(e4)) {
      let o3 = Lm(n4, t4.runtimeDataModel);
      if (!o3) {
        r5.push({ kind: "UnknownModel", modelKey: n4 });
        continue;
      }
      for (let [s5, a5] of Object.entries(i4)) {
        let l4 = o3.fields.find((u5) => u5.name === s5);
        if (!l4) {
          r5.push({ kind: "UnknownField", modelKey: n4, fieldName: s5 });
          continue;
        }
        if (l4.relationName) {
          r5.push({ kind: "RelationInOmit", modelKey: n4, fieldName: s5 });
          continue;
        }
        typeof a5 != "boolean" && r5.push({ kind: "InvalidFieldValue", modelKey: n4, fieldName: s5 });
      }
    }
    if (r5.length > 0)
      throw new L4(Fm(e4, r5));
  }, __internal: (e4) => {
    if (!e4)
      return;
    let t4 = ["debug", "engine", "configOverride"];
    if (typeof e4 != "object")
      throw new L4(`Invalid value ${JSON.stringify(e4)} for "__internal" to PrismaClient constructor`);
    for (let [r5] of Object.entries(e4))
      if (!t4.includes(r5)) {
        let n4 = Vt(r5, t4);
        throw new L4(`Invalid property ${JSON.stringify(r5)} for "__internal" provided to PrismaClient constructor.${n4}`);
      }
  } };
  function Jl(e4, t4) {
    for (let [r5, n4] of Object.entries(e4)) {
      if (!jl.includes(r5)) {
        let i4 = Vt(r5, jl);
        throw new L4(`Unknown property ${r5} provided to PrismaClient constructor.${i4}`);
      }
      _m[r5](n4, t4);
    }
    if (e4.datasourceUrl && e4.datasources)
      throw new L4('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them');
  }
  function Vt(e4, t4) {
    if (t4.length === 0 || typeof e4 != "string")
      return "";
    let r5 = Nm(e4, t4);
    return r5 ? ` Did you mean "${r5}"?` : "";
  }
  function Nm(e4, t4) {
    if (t4.length === 0)
      return null;
    let r5 = t4.map((i4) => ({ value: i4, distance: (0, Gl.default)(e4, i4) }));
    r5.sort((i4, o3) => i4.distance < o3.distance ? -1 : 1);
    let n4 = r5[0];
    return n4.distance < 3 ? n4.value : null;
  }
  function Lm(e4, t4) {
    return Ql(t4.models, e4) ?? Ql(t4.types, e4);
  }
  function Ql(e4, t4) {
    let r5 = Object.keys(e4).find((n4) => wt(n4) === t4);
    if (r5)
      return e4[r5];
  }
  function Fm(e4, t4) {
    let r5 = At(e4);
    for (let o3 of t4)
      switch (o3.kind) {
        case "UnknownModel":
          r5.arguments.getField(o3.modelKey)?.markAsError(), r5.addErrorMessage(() => `Unknown model name: ${o3.modelKey}.`);
          break;
        case "UnknownField":
          r5.arguments.getDeepField([o3.modelKey, o3.fieldName])?.markAsError(), r5.addErrorMessage(() => `Model "${o3.modelKey}" does not have a field named "${o3.fieldName}".`);
          break;
        case "RelationInOmit":
          r5.arguments.getDeepField([o3.modelKey, o3.fieldName])?.markAsError(), r5.addErrorMessage(() => 'Relations are already excluded by default and can not be specified in "omit".');
          break;
        case "InvalidFieldValue":
          r5.arguments.getDeepFieldValue([o3.modelKey, o3.fieldName])?.markAsError(), r5.addErrorMessage(() => "Omit field option value must be a boolean.");
          break;
      }
    let { message: n4, args: i4 } = bn2(r5, "colorless");
    return `Error validating "omit" option:

${i4}

${n4}`;
  }
  function Hl(e4) {
    return e4.length === 0 ? Promise.resolve([]) : new Promise((t4, r5) => {
      let n4 = new Array(e4.length), i4 = null, o3 = false, s5 = 0, a5 = () => {
        o3 || (s5++, s5 === e4.length && (o3 = true, i4 ? r5(i4) : t4(n4)));
      }, l4 = (u5) => {
        o3 || (o3 = true, r5(u5));
      };
      for (let u5 = 0;u5 < e4.length; u5++)
        e4[u5].then((c5) => {
          n4[u5] = c5, a5();
        }, (c5) => {
          if (!Mn(c5)) {
            l4(c5);
            return;
          }
          c5.batchRequestIdx === u5 ? l4(c5) : (i4 || (i4 = c5), a5());
        });
    });
  }
  var tt = F3("prisma:client");
  typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
  var Mm = { requestArgsToMiddlewareArgs: (e4) => e4, middlewareArgsToRequestArgs: (e4) => e4 };
  var $m = Symbol.for("prisma.client.transaction.id");
  var qm = { id: 0, nextId() {
    return ++this.id;
  } };
  function Xl(e4) {

    class t4 {
      constructor(n4) {
        this._originalClient = this;
        this._middlewares = new Fn;
        this._createPrismaPromise = ho();
        this.$extends = Na;
        e4 = n4?.__internal?.configOverride?.(e4) ?? e4, Ha(e4), n4 && Jl(n4, e4);
        let i4 = new zl.EventEmitter().on("error", () => {
        });
        this._extensions = It.empty(), this._previewFeatures = Ln(e4), this._clientVersion = e4.clientVersion ?? Vl, this._activeProvider = e4.activeProvider, this._globalOmit = n4?.omit, this._tracingHelper = Dl();
        let o3 = { rootEnvPath: e4.relativeEnvPaths.rootEnvPath && Nr.default.resolve(e4.dirname, e4.relativeEnvPaths.rootEnvPath), schemaEnvPath: e4.relativeEnvPaths.schemaEnvPath && Nr.default.resolve(e4.dirname, e4.relativeEnvPaths.schemaEnvPath) }, s5;
        if (n4?.adapter) {
          s5 = Qi(n4.adapter);
          let l4 = e4.activeProvider === "postgresql" ? "postgres" : e4.activeProvider;
          if (s5.provider !== l4)
            throw new T4(`The Driver Adapter \`${s5.adapterName}\`, based on \`${s5.provider}\`, is not compatible with the provider \`${l4}\` specified in the Prisma schema.`, this._clientVersion);
          if (n4.datasources || n4.datasourceUrl !== undefined)
            throw new T4("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.", this._clientVersion);
        }
        let a5 = !s5 && Kt(o3, { conflictCheck: "none" }) || e4.injectableEdgeEnv?.();
        try {
          let l4 = n4 ?? {}, u5 = l4.__internal ?? {}, c5 = u5.debug === true;
          c5 && F3.enable("prisma:client");
          let p5 = Nr.default.resolve(e4.dirname, e4.relativePath);
          Zl.default.existsSync(p5) || (p5 = e4.dirname), tt("dirname", e4.dirname), tt("relativePath", e4.relativePath), tt("cwd", p5);
          let d4 = u5.engine || {};
          if (l4.errorFormat ? this._errorFormat = l4.errorFormat : process.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = e4.runtimeDataModel, this._engineConfig = { cwd: p5, dirname: e4.dirname, enableDebugLogs: c5, allowTriggerPanic: d4.allowTriggerPanic, datamodelPath: Nr.default.join(e4.dirname, e4.filename ?? "schema.prisma"), prismaPath: d4.binaryPath ?? undefined, engineEndpoint: d4.endpoint, generator: e4.generator, showColors: this._errorFormat === "pretty", logLevel: l4.log && Nl(l4.log), logQueries: l4.log && !!(typeof l4.log == "string" ? l4.log === "query" : l4.log.find((f4) => typeof f4 == "string" ? f4 === "query" : f4.level === "query")), env: a5?.parsed ?? {}, flags: [], engineWasm: e4.engineWasm, clientVersion: e4.clientVersion, engineVersion: e4.engineVersion, previewFeatures: this._previewFeatures, activeProvider: e4.activeProvider, inlineSchema: e4.inlineSchema, overrideDatasources: Wa(l4, e4.datasourceNames), inlineDatasources: e4.inlineDatasources, inlineSchemaHash: e4.inlineSchemaHash, tracingHelper: this._tracingHelper, transactionOptions: { maxWait: l4.transactionOptions?.maxWait ?? 2000, timeout: l4.transactionOptions?.timeout ?? 5000, isolationLevel: l4.transactionOptions?.isolationLevel }, logEmitter: i4, isBundled: e4.isBundled, adapter: s5 }, this._accelerateEngineConfig = { ...this._engineConfig, accelerateUtils: { resolveDatasourceUrl: Lt, getBatchRequestPayload: Dt, prismaGraphQLToJSError: _t, PrismaClientUnknownRequestError: B4, PrismaClientInitializationError: T4, PrismaClientKnownRequestError: ee2, debug: F3("prisma:client:accelerateEngine"), engineVersion: Kl.version, clientVersion: e4.clientVersion } }, tt("clientVersion", e4.clientVersion), this._engine = wl(e4, this._engineConfig), this._requestHandler = new Vn(this, i4), l4.log)
            for (let f4 of l4.log) {
              let g3 = typeof f4 == "string" ? f4 : f4.emit === "stdout" ? f4.level : null;
              g3 && this.$on(g3, (h4) => {
                er.log(`${er.tags[g3] ?? ""}`, h4.message || h4.query);
              });
            }
          this._metrics = new Ot(this._engine);
        } catch (l4) {
          throw l4.clientVersion = this._clientVersion, l4;
        }
        return this._appliedParent = yr(this);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClient";
      }
      $use(n4) {
        this._middlewares.use(n4);
      }
      $on(n4, i4) {
        n4 === "beforeExit" ? this._engine.onBeforeExit(i4) : n4 && this._engineConfig.logEmitter.on(n4, i4);
      }
      $connect() {
        try {
          return this._engine.start();
        } catch (n4) {
          throw n4.clientVersion = this._clientVersion, n4;
        }
      }
      async $disconnect() {
        try {
          await this._engine.stop();
        } catch (n4) {
          throw n4.clientVersion = this._clientVersion, n4;
        } finally {
          Do();
        }
      }
      $executeRawInternal(n4, i4, o3, s5) {
        let a5 = this._activeProvider;
        return this._request({ action: "executeRaw", args: o3, transaction: n4, clientMethod: i4, argsMapper: go({ clientMethod: i4, activeProvider: a5 }), callsite: Ze(this._errorFormat), dataPath: [], middlewareArgsMapper: s5 });
      }
      $executeRaw(n4, ...i4) {
        return this._createPrismaPromise((o3) => {
          if (n4.raw !== undefined || n4.sql !== undefined) {
            let [s5, a5] = Wl(n4, i4);
            return fo(this._activeProvider, s5.text, s5.values, Array.isArray(n4) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(o3, "$executeRaw", s5, a5);
          }
          throw new te("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
        });
      }
      $executeRawUnsafe(n4, ...i4) {
        return this._createPrismaPromise((o3) => (fo(this._activeProvider, n4, i4, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(o3, "$executeRawUnsafe", [n4, ...i4])));
      }
      $runCommandRaw(n4) {
        if (e4.activeProvider !== "mongodb")
          throw new te(`The ${e4.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
        return this._createPrismaPromise((i4) => this._request({ args: n4, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: xl, callsite: Ze(this._errorFormat), transaction: i4 }));
      }
      async $queryRawInternal(n4, i4, o3, s5) {
        let a5 = this._activeProvider;
        return this._request({ action: "queryRaw", args: o3, transaction: n4, clientMethod: i4, argsMapper: go({ clientMethod: i4, activeProvider: a5 }), callsite: Ze(this._errorFormat), dataPath: [], middlewareArgsMapper: s5 });
      }
      $queryRaw(n4, ...i4) {
        return this._createPrismaPromise((o3) => {
          if (n4.raw !== undefined || n4.sql !== undefined)
            return this.$queryRawInternal(o3, "$queryRaw", ...Wl(n4, i4));
          throw new te("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
        });
      }
      $queryRawTyped(n4) {
        return this._createPrismaPromise((i4) => {
          if (!this._hasPreviewFlag("typedSql"))
            throw new te("`typedSql` preview feature must be enabled in order to access $queryRawTyped API", { clientVersion: this._clientVersion });
          return this.$queryRawInternal(i4, "$queryRawTyped", n4);
        });
      }
      $queryRawUnsafe(n4, ...i4) {
        return this._createPrismaPromise((o3) => this.$queryRawInternal(o3, "$queryRawUnsafe", [n4, ...i4]));
      }
      _transactionWithArray({ promises: n4, options: i4 }) {
        let o3 = qm.nextId(), s5 = _l(n4.length), a5 = n4.map((l4, u5) => {
          if (l4?.[Symbol.toStringTag] !== "PrismaPromise")
            throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
          let c5 = i4?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel, p5 = { kind: "batch", id: o3, index: u5, isolationLevel: c5, lock: s5 };
          return l4.requestTransaction?.(p5) ?? l4;
        });
        return Hl(a5);
      }
      async _transactionWithCallback({ callback: n4, options: i4 }) {
        let o3 = { traceparent: this._tracingHelper.getTraceParent() }, s5 = { maxWait: i4?.maxWait ?? this._engineConfig.transactionOptions.maxWait, timeout: i4?.timeout ?? this._engineConfig.transactionOptions.timeout, isolationLevel: i4?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel }, a5 = await this._engine.transaction("start", o3, s5), l4;
        try {
          let u5 = { kind: "itx", ...a5 };
          l4 = await n4(this._createItxClient(u5)), await this._engine.transaction("commit", o3, a5);
        } catch (u5) {
          throw await this._engine.transaction("rollback", o3, a5).catch(() => {
          }), u5;
        }
        return l4;
      }
      _createItxClient(n4) {
        return yr(Ae(_a2(this), [ie("_appliedParent", () => this._appliedParent._createItxClient(n4)), ie("_createPrismaPromise", () => ho(n4)), ie($m, () => n4.id), kt(Sl)]));
      }
      $transaction(n4, i4) {
        let o3;
        typeof n4 == "function" ? this._engineConfig.adapter?.adapterName === "@prisma/adapter-d1" ? o3 = () => {
          throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.");
        } : o3 = () => this._transactionWithCallback({ callback: n4, options: i4 }) : o3 = () => this._transactionWithArray({ promises: n4, options: i4 });
        let s5 = { name: "transaction", attributes: { method: "$transaction" } };
        return this._tracingHelper.runInChildSpan(s5, o3);
      }
      _request(n4) {
        n4.otelParentCtx = this._tracingHelper.getActiveContext();
        let i4 = n4.middlewareArgsMapper ?? Mm, o3 = { args: i4.requestArgsToMiddlewareArgs(n4.args), dataPath: n4.dataPath, runInTransaction: !!n4.transaction, action: n4.action, model: n4.model }, s5 = { middleware: { name: "middleware", middleware: true, attributes: { method: "$use" }, active: false }, operation: { name: "operation", attributes: { method: o3.action, model: o3.model, name: o3.model ? `${o3.model}.${o3.action}` : o3.action } } }, a5 = -1, l4 = async (u5) => {
          let c5 = this._middlewares.get(++a5);
          if (c5)
            return this._tracingHelper.runInChildSpan(s5.middleware, (O4) => c5(u5, (P4) => (O4?.end(), l4(P4))));
          let { runInTransaction: p5, args: d4, ...f4 } = u5, g3 = { ...n4, ...f4 };
          d4 && (g3.args = i4.middlewareArgsToRequestArgs(d4)), n4.transaction !== undefined && p5 === false && delete g3.transaction;
          let h4 = await ja(this, g3);
          return g3.model ? Ma({ result: h4, modelName: g3.model, args: g3.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel, globalOmit: this._globalOmit }) : h4;
        };
        return this._tracingHelper.runInChildSpan(s5.operation, () => new Yl.AsyncResource("prisma-client-request").runInAsyncScope(() => l4(o3)));
      }
      async _executeRequest({ args: n4, clientMethod: i4, dataPath: o3, callsite: s5, action: a5, model: l4, argsMapper: u5, transaction: c5, unpacker: p5, otelParentCtx: d4, customDataProxyFetch: f4 }) {
        try {
          n4 = u5 ? u5(n4) : n4;
          let g3 = { name: "serialize" }, h4 = this._tracingHelper.runInChildSpan(g3, () => Pn({ modelName: l4, runtimeDataModel: this._runtimeDataModel, action: a5, args: n4, clientMethod: i4, callsite: s5, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion, previewFeatures: this._previewFeatures, globalOmit: this._globalOmit }));
          return F3.enabled("prisma:client") && (tt("Prisma Client call:"), tt(`prisma.${i4}(${va(n4)})`), tt("Generated request:"), tt(JSON.stringify(h4, null, 2) + `
`)), c5?.kind === "batch" && await c5.lock, this._requestHandler.request({ protocolQuery: h4, modelName: l4, action: a5, clientMethod: i4, dataPath: o3, callsite: s5, args: n4, extensions: this._extensions, transaction: c5, unpacker: p5, otelParentCtx: d4, otelChildCtx: this._tracingHelper.getActiveContext(), globalOmit: this._globalOmit, customDataProxyFetch: f4 });
        } catch (g3) {
          throw g3.clientVersion = this._clientVersion, g3;
        }
      }
      get $metrics() {
        if (!this._hasPreviewFlag("metrics"))
          throw new te("`metrics` preview feature must be enabled in order to access metrics API", { clientVersion: this._clientVersion });
        return this._metrics;
      }
      _hasPreviewFlag(n4) {
        return !!this._engineConfig.previewFeatures?.includes(n4);
      }
      $applyPendingMigrations() {
        return this._engine.applyPendingMigrations();
      }
    }
    return t4;
  }
  function Wl(e4, t4) {
    return Vm(e4) ? [new ae2(e4, t4), Il] : [e4, Ol];
  }
  function Vm(e4) {
    return Array.isArray(e4) && Array.isArray(e4.raw);
  }
  var jm = new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
  function eu(e4) {
    return new Proxy(e4, { get(t4, r5) {
      if (r5 in t4)
        return t4[r5];
      if (!jm.has(r5))
        throw new TypeError(`Invalid enum value: ${String(r5)}`);
    } });
  }
  function tu(e4) {
    Kt(e4, { conflictCheck: "warn" });
  }
  /*! Bundled license information:
  
  decimal.js/decimal.mjs:
    (*!
     *  decimal.js v10.4.3
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     *)
  */
});

// ../../node_modules/.prisma/client/index.js
var require_client2 = __commonJS((exports) => {
  var __dirname = "E:\\JS\\huginn-monorepo\\node_modules\\.prisma\\client";
  Object.defineProperty(exports, "__esModule", { value: true });
  var {
    PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
    PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
    PrismaClientRustPanicError: PrismaClientRustPanicError2,
    PrismaClientInitializationError: PrismaClientInitializationError2,
    PrismaClientValidationError: PrismaClientValidationError2,
    getPrismaClient: getPrismaClient2,
    sqltag: sqltag2,
    empty: empty2,
    join: join7,
    raw: raw3,
    skip: skip2,
    Decimal: Decimal2,
    Debug: Debug2,
    objectEnumValues: objectEnumValues2,
    makeStrictEnum: makeStrictEnum2,
    Extensions: Extensions2,
    warnOnce: warnOnce2,
    defineDmmfProperty: defineDmmfProperty2,
    Public: Public2,
    getRuntime: getRuntime2
  } = require_library();
  var Prisma = {};
  exports.Prisma = Prisma;
  exports.$Enums = {};
  Prisma.prismaVersion = {
    client: "6.2.1",
    engine: "4123509d24aa4dede1e864b46351bf2790323b69"
  };
  Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
  Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
  Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
  Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
  Prisma.PrismaClientValidationError = PrismaClientValidationError2;
  Prisma.Decimal = Decimal2;
  Prisma.sql = sqltag2;
  Prisma.empty = empty2;
  Prisma.join = join7;
  Prisma.raw = raw3;
  Prisma.validator = Public2.validator;
  Prisma.getExtensionContext = Extensions2.getExtensionContext;
  Prisma.defineExtension = Extensions2.defineExtension;
  Prisma.DbNull = objectEnumValues2.instances.DbNull;
  Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
  Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
  Prisma.NullTypes = {
    DbNull: objectEnumValues2.classes.DbNull,
    JsonNull: objectEnumValues2.classes.JsonNull,
    AnyNull: objectEnumValues2.classes.AnyNull
  };
  var path = __require("path");
  exports.Prisma.TransactionIsolationLevel = makeStrictEnum2({
    ReadUncommitted: "ReadUncommitted",
    ReadCommitted: "ReadCommitted",
    RepeatableRead: "RepeatableRead",
    Serializable: "Serializable"
  });
  exports.Prisma.UserScalarFieldEnum = {
    id: "id",
    username: "username",
    displayName: "displayName",
    email: "email",
    avatar: "avatar",
    password: "password",
    flags: "flags",
    system: "system"
  };
  exports.Prisma.RelationLoadStrategy = {
    query: "query",
    join: "join"
  };
  exports.Prisma.ChannelScalarFieldEnum = {
    id: "id",
    icon: "icon",
    lastMessageId: "lastMessageId",
    name: "name",
    ownerId: "ownerId",
    type: "type"
  };
  exports.Prisma.MessageScalarFieldEnum = {
    id: "id",
    authorId: "authorId",
    channelId: "channelId",
    content: "content",
    timestamp: "timestamp",
    editedTimestamp: "editedTimestamp",
    attachments: "attachments",
    reactions: "reactions",
    pinned: "pinned",
    type: "type",
    flags: "flags"
  };
  exports.Prisma.RelationshipScalarFieldEnum = {
    id: "id",
    type: "type",
    nickname: "nickname",
    since: "since",
    ownerId: "ownerId",
    userId: "userId"
  };
  exports.Prisma.IdentityProviderScalarFieldEnum = {
    id: "id",
    providerUserId: "providerUserId",
    userId: "userId",
    completed: "completed",
    providerType: "providerType",
    refreshToken: "refreshToken"
  };
  exports.Prisma.ReadStateScalarFieldEnum = {
    channelId: "channelId",
    userId: "userId",
    lastReadMessageId: "lastReadMessageId"
  };
  exports.Prisma.EmbedScalarFieldEnum = {
    id: "id",
    title: "title",
    type: "type",
    description: "description",
    url: "url",
    timestamp: "timestamp",
    messageId: "messageId"
  };
  exports.Prisma.ThumbnailScalarFieldEnum = {
    id: "id",
    width: "width",
    height: "height",
    url: "url",
    embedId: "embedId"
  };
  exports.Prisma.SortOrder = {
    asc: "asc",
    desc: "desc"
  };
  exports.Prisma.QueryMode = {
    default: "default",
    insensitive: "insensitive"
  };
  exports.Prisma.NullsOrder = {
    first: "first",
    last: "last"
  };
  exports.Prisma.ModelName = {
    User: "User",
    Channel: "Channel",
    Message: "Message",
    Relationship: "Relationship",
    IdentityProvider: "IdentityProvider",
    ReadState: "ReadState",
    Embed: "Embed",
    Thumbnail: "Thumbnail"
  };
  var config5 = {
    generator: {
      name: "client",
      provider: {
        fromEnvVar: null,
        value: "prisma-client-js"
      },
      output: {
        value: "E:\\JS\\huginn-monorepo\\node_modules\\@prisma\\client",
        fromEnvVar: null
      },
      config: {
        engineType: "library"
      },
      binaryTargets: [
        {
          fromEnvVar: null,
          value: "windows",
          native: true
        }
      ],
      previewFeatures: [
        "relationJoins",
        "omitApi"
      ],
      sourceFilePath: "E:\\JS\\huginn-monorepo\\packages\\huginn-server\\prisma\\schema.prisma"
    },
    relativeEnvPaths: {
      rootEnvPath: null,
      schemaEnvPath: "../../../packages/huginn-server/.env"
    },
    relativePath: "../../../packages/huginn-server/prisma",
    clientVersion: "6.2.1",
    engineVersion: "4123509d24aa4dede1e864b46351bf2790323b69",
    datasourceNames: [
      "db"
    ],
    activeProvider: "postgresql",
    postinstall: false,
    inlineDatasources: {
      db: {
        url: {
          fromEnvVar: "POSTGRESQL_URL",
          value: null
        }
      }
    },
    inlineSchema: `generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["omitApi", "relationJoins"]
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRESQL_URL")
  directUrl = env("POSTGRESQL_DIRECT_URL")
}

model User {
  id                   BigInt             @id
  username             String             @unique
  displayName          String?
  email                String             @unique
  avatar               String?
  password             String?
  flags                Int                @db.SmallInt
  system               Boolean            @default(false)
  includedChannels     Channel[]          @relation("channel_recipients")
  ownedChannels        Channel[]          @relation("channel_owner")
  tempDeletedChannels  Channel[]          @relation("channel_temp_deleted")
  messages             Message[]
  mentionedMessages    Message[]          @relation("message_mentions")
  relationships        Relationship[]     @relation("relation_owner")
  relatedRelationships Relationship[]     @relation("relation_user")
  identityProvider     IdentityProvider[]
  readStates           ReadState[]
}

model Channel {
  id                 BigInt      @id
  icon               String?
  lastMessageId      BigInt?
  lastMessage        Message?    @relation("channel_last_message", fields: [lastMessageId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  name               String?
  owner              User?       @relation("channel_owner", fields: [ownerId], references: [id])
  ownerId            BigInt?
  recipients         User[]      @relation("channel_recipients")
  messages           Message[]
  type               Int
  tempDeletedByUsers User[]      @relation("channel_temp_deleted")
  readStates         ReadState[]

  @@index([type])
}

model Message {
  id                  BigInt      @id
  author              User        @relation(fields: [authorId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  authorId            BigInt
  channel             Channel     @relation(fields: [channelId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  channelId           BigInt
  content             String
  timestamp           DateTime
  editedTimestamp     DateTime?
  mentions            User[]      @relation("message_mentions")
  embeds              Embed[]
  attachments         String[]
  reactions           String[]
  pinned              Boolean
  type                Int
  flags               Int?        @db.SmallInt
  lastReadMessages    ReadState[]
  lastMessageChannels Channel[]   @relation("channel_last_message")

  @@index([channelId])
}

model Relationship {
  id       BigInt    @id
  type     Int       @db.SmallInt
  nickname String
  since    DateTime?
  owner    User      @relation("relation_owner", fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId  BigInt
  user     User      @relation("relation_user", fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId   BigInt

  @@index([ownerId])
}

model IdentityProvider {
  id             BigInt  @id
  providerUserId String  @unique
  userId         BigInt?
  user           User?   @relation(fields: [userId], references: [id])
  completed      Boolean
  providerType   String
  refreshToken   String
}

model ReadState {
  channel           Channel  @relation(fields: [channelId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  channelId         BigInt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId            BigInt
  lastReadMessage   Message? @relation(fields: [lastReadMessageId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  lastReadMessageId BigInt?

  @@id([channelId, userId])
}

model Embed {
  id          BigInt     @id
  title       String?
  type        String?
  description String?
  url         String?
  timestamp   DateTime?
  message     Message?   @relation(fields: [messageId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  messageId   BigInt?
  thumbnail   Thumbnail?
}

model Thumbnail {
  id      BigInt @id
  width   Int
  height  Int
  url     String
  embed   Embed  @relation(fields: [embedId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  embedId BigInt @unique
}
`,
    inlineSchemaHash: "8e62b50aa19406426f9d3c39738033adbba7cc019ba79721b95279e9e3ad9725",
    copyEngine: true
  };
  var fs3 = __require("fs");
  config5.dirname = __dirname;
  if (!fs3.existsSync(path.join(__dirname, "schema.prisma"))) {
    const alternativePaths = [
      "../../node_modules/.prisma/client",
      "../node_modules/.prisma/client"
    ];
    const alternativePath = alternativePaths.find((altPath) => {
      return fs3.existsSync(path.join(process.cwd(), altPath, "schema.prisma"));
    }) ?? alternativePaths[0];
    config5.dirname = path.join(process.cwd(), alternativePath);
    config5.isBundled = true;
  }
  config5.runtimeDataModel = JSON.parse('{"models":{"User":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"BigInt","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"username","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"displayName","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"avatar","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"password","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"flags","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":["SmallInt",[]],"isGenerated":false,"isUpdatedAt":false},{"name":"system","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"includedChannels","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Channel","nativeType":null,"relationName":"channel_recipients","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"ownedChannels","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Channel","nativeType":null,"relationName":"channel_owner","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"tempDeletedChannels","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Channel","nativeType":null,"relationName":"channel_temp_deleted","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"messages","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Message","nativeType":null,"relationName":"MessageToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"mentionedMessages","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Message","nativeType":null,"relationName":"message_mentions","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"relationships","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Relationship","nativeType":null,"relationName":"relation_owner","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"relatedRelationships","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Relationship","nativeType":null,"relationName":"relation_user","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"identityProvider","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"IdentityProvider","nativeType":null,"relationName":"IdentityProviderToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"readStates","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ReadState","nativeType":null,"relationName":"ReadStateToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Channel":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"BigInt","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"icon","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"lastMessageId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"BigInt","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"lastMessage","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Message","nativeType":null,"relationName":"channel_last_message","relationFromFields":["lastMessageId"],"relationToFields":["id"],"relationOnDelete":"SetNull","isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"owner","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"channel_owner","relationFromFields":["ownerId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"ownerId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"BigInt","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"recipients","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"channel_recipients","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"messages","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Message","nativeType":null,"relationName":"ChannelToMessage","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"tempDeletedByUsers","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"channel_temp_deleted","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"readStates","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ReadState","nativeType":null,"relationName":"ChannelToReadState","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Message":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"BigInt","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"author","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"MessageToUser","relationFromFields":["authorId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"authorId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"BigInt","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"channel","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Channel","nativeType":null,"relationName":"ChannelToMessage","relationFromFields":["channelId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"channelId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"BigInt","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"content","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"timestamp","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"editedTimestamp","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"mentions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"message_mentions","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"embeds","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Embed","nativeType":null,"relationName":"EmbedToMessage","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"attachments","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"reactions","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"pinned","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Boolean","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"flags","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":["SmallInt",[]],"isGenerated":false,"isUpdatedAt":false},{"name":"lastReadMessages","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ReadState","nativeType":null,"relationName":"MessageToReadState","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"lastMessageChannels","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Channel","nativeType":null,"relationName":"channel_last_message","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Relationship":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"BigInt","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":["SmallInt",[]],"isGenerated":false,"isUpdatedAt":false},{"name":"nickname","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"since","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"owner","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"relation_owner","relationFromFields":["ownerId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"ownerId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"BigInt","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"relation_user","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"BigInt","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"IdentityProvider":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"BigInt","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"providerUserId","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"BigInt","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"IdentityProviderToUser","relationFromFields":["userId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"completed","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Boolean","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"providerType","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"refreshToken","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"ReadState":{"dbName":null,"schema":null,"fields":[{"name":"channel","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Channel","nativeType":null,"relationName":"ChannelToReadState","relationFromFields":["channelId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"channelId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"BigInt","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"ReadStateToUser","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"BigInt","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"lastReadMessage","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Message","nativeType":null,"relationName":"MessageToReadState","relationFromFields":["lastReadMessageId"],"relationToFields":["id"],"relationOnDelete":"SetNull","isGenerated":false,"isUpdatedAt":false},{"name":"lastReadMessageId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"BigInt","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":{"name":null,"fields":["channelId","userId"]},"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Embed":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"BigInt","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"title","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"url","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"timestamp","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"message","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Message","nativeType":null,"relationName":"EmbedToMessage","relationFromFields":["messageId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"messageId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"BigInt","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"thumbnail","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Thumbnail","nativeType":null,"relationName":"EmbedToThumbnail","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Thumbnail":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":false,"type":"BigInt","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"width","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"height","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"url","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"embed","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Embed","nativeType":null,"relationName":"EmbedToThumbnail","relationFromFields":["embedId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"embedId","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"BigInt","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false}},"enums":{},"types":{}}');
  defineDmmfProperty2(exports.Prisma, config5.runtimeDataModel);
  config5.engineWasm = undefined;
  var { warnEnvConflicts: warnEnvConflicts2 } = require_library();
  warnEnvConflicts2({
    rootEnvPath: config5.relativeEnvPaths.rootEnvPath && path.resolve(config5.dirname, config5.relativeEnvPaths.rootEnvPath),
    schemaEnvPath: config5.relativeEnvPaths.schemaEnvPath && path.resolve(config5.dirname, config5.relativeEnvPaths.schemaEnvPath)
  });
  var PrismaClient = getPrismaClient2(config5);
  exports.PrismaClient = PrismaClient;
  Object.assign(exports, Prisma);
  path.join(__dirname, "query_engine-windows.dll.node");
  path.join(process.cwd(), "../../node_modules/.prisma/client/query_engine-windows.dll.node");
  path.join(__dirname, "schema.prisma");
  path.join(process.cwd(), "../../node_modules/.prisma/client/schema.prisma");
});

// ../../node_modules/.prisma/client/default.js
var require_default = __commonJS((exports, module) => {
  module.exports = { ...require_client2() };
});

// ../../node_modules/@prisma/client/default.js
var require_default2 = __commonJS((exports, module) => {
  module.exports = {
    ...require_default()
  };
});

// ../../node_modules/@opentelemetry/api/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// ../../node_modules/@opentelemetry/api/build/src/platform/node/index.js
var require_node = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(require_globalThis(), exports);
});

// ../../node_modules/@opentelemetry/api/build/src/platform/index.js
var require_platform = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(require_node(), exports);
});

// ../../node_modules/@opentelemetry/api/build/src/version.js
var require_version2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "1.9.0";
});

// ../../node_modules/@opentelemetry/api/build/src/internal/semver.js
var require_semver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isCompatible = exports._makeCompatibilityCheck = undefined;
  var version_1 = require_version2();
  var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
  function _makeCompatibilityCheck(ownVersion) {
    const acceptedVersions = new Set([ownVersion]);
    const rejectedVersions = new Set;
    const myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) {
      return () => false;
    }
    const ownVersionParsed = {
      major: +myVersionMatch[1],
      minor: +myVersionMatch[2],
      patch: +myVersionMatch[3],
      prerelease: myVersionMatch[4]
    };
    if (ownVersionParsed.prerelease != null) {
      return function isExactmatch(globalVersion) {
        return globalVersion === ownVersion;
      };
    }
    function _reject(v7) {
      rejectedVersions.add(v7);
      return false;
    }
    function _accept(v7) {
      acceptedVersions.add(v7);
      return true;
    }
    return function isCompatible(globalVersion) {
      if (acceptedVersions.has(globalVersion)) {
        return true;
      }
      if (rejectedVersions.has(globalVersion)) {
        return false;
      }
      const globalVersionMatch = globalVersion.match(re);
      if (!globalVersionMatch) {
        return _reject(globalVersion);
      }
      const globalVersionParsed = {
        major: +globalVersionMatch[1],
        minor: +globalVersionMatch[2],
        patch: +globalVersionMatch[3],
        prerelease: globalVersionMatch[4]
      };
      if (globalVersionParsed.prerelease != null) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major !== globalVersionParsed.major) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major === 0) {
        if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      }
      if (ownVersionParsed.minor <= globalVersionParsed.minor) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    };
  }
  exports._makeCompatibilityCheck = _makeCompatibilityCheck;
  exports.isCompatible = _makeCompatibilityCheck(version_1.VERSION);
});

// ../../node_modules/@opentelemetry/api/build/src/internal/global-utils.js
var require_global_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unregisterGlobal = exports.getGlobal = exports.registerGlobal = undefined;
  var platform_1 = require_platform();
  var version_1 = require_version2();
  var semver_1 = require_semver();
  var major = version_1.VERSION.split(".")[0];
  var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`);
  var _global = platform_1._globalThis;
  function registerGlobal(type, instance, diag, allowOverride = false) {
    var _a2;
    const api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a2 !== undefined ? _a2 : {
      version: version_1.VERSION
    };
    if (!allowOverride && api[type]) {
      const err = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${type}`);
      diag.error(err.stack || err.message);
      return false;
    }
    if (api.version !== version_1.VERSION) {
      const err = new Error(`@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${version_1.VERSION}`);
      diag.error(err.stack || err.message);
      return false;
    }
    api[type] = instance;
    diag.debug(`@opentelemetry/api: Registered a global for ${type} v${version_1.VERSION}.`);
    return true;
  }
  exports.registerGlobal = registerGlobal;
  function getGlobal(type) {
    var _a2, _b2;
    const globalVersion = (_a2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a2 === undefined ? undefined : _a2.version;
    if (!globalVersion || !(0, semver_1.isCompatible)(globalVersion)) {
      return;
    }
    return (_b2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b2 === undefined ? undefined : _b2[type];
  }
  exports.getGlobal = getGlobal;
  function unregisterGlobal(type, diag) {
    diag.debug(`@opentelemetry/api: Unregistering a global for ${type} v${version_1.VERSION}.`);
    const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api) {
      delete api[type];
    }
  }
  exports.unregisterGlobal = unregisterGlobal;
});

// ../../node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js
var require_ComponentLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagComponentLogger = undefined;
  var global_utils_1 = require_global_utils();

  class DiagComponentLogger {
    constructor(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    debug(...args) {
      return logProxy("debug", this._namespace, args);
    }
    error(...args) {
      return logProxy("error", this._namespace, args);
    }
    info(...args) {
      return logProxy("info", this._namespace, args);
    }
    warn(...args) {
      return logProxy("warn", this._namespace, args);
    }
    verbose(...args) {
      return logProxy("verbose", this._namespace, args);
    }
  }
  exports.DiagComponentLogger = DiagComponentLogger;
  function logProxy(funcName, namespace, args) {
    const logger2 = (0, global_utils_1.getGlobal)("diag");
    if (!logger2) {
      return;
    }
    args.unshift(namespace);
    return logger2[funcName](...args);
  }
});

// ../../node_modules/@opentelemetry/api/build/src/diag/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagLogLevel = undefined;
  var DiagLogLevel;
  (function(DiagLogLevel2) {
    DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
    DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
    DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
    DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
    DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
    DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
    DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
  })(DiagLogLevel = exports.DiagLogLevel || (exports.DiagLogLevel = {}));
});

// ../../node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js
var require_logLevelLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createLogLevelDiagLogger = undefined;
  var types_1 = require_types();
  function createLogLevelDiagLogger(maxLevel, logger2) {
    if (maxLevel < types_1.DiagLogLevel.NONE) {
      maxLevel = types_1.DiagLogLevel.NONE;
    } else if (maxLevel > types_1.DiagLogLevel.ALL) {
      maxLevel = types_1.DiagLogLevel.ALL;
    }
    logger2 = logger2 || {};
    function _filterFunc(funcName, theLevel) {
      const theFunc = logger2[funcName];
      if (typeof theFunc === "function" && maxLevel >= theLevel) {
        return theFunc.bind(logger2);
      }
      return function() {
      };
    }
    return {
      error: _filterFunc("error", types_1.DiagLogLevel.ERROR),
      warn: _filterFunc("warn", types_1.DiagLogLevel.WARN),
      info: _filterFunc("info", types_1.DiagLogLevel.INFO),
      debug: _filterFunc("debug", types_1.DiagLogLevel.DEBUG),
      verbose: _filterFunc("verbose", types_1.DiagLogLevel.VERBOSE)
    };
  }
  exports.createLogLevelDiagLogger = createLogLevelDiagLogger;
});

// ../../node_modules/@opentelemetry/api/build/src/api/diag.js
var require_diag = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagAPI = undefined;
  var ComponentLogger_1 = require_ComponentLogger();
  var logLevelLogger_1 = require_logLevelLogger();
  var types_1 = require_types();
  var global_utils_1 = require_global_utils();
  var API_NAME = "diag";

  class DiagAPI {
    constructor() {
      function _logProxy(funcName) {
        return function(...args) {
          const logger2 = (0, global_utils_1.getGlobal)("diag");
          if (!logger2)
            return;
          return logger2[funcName](...args);
        };
      }
      const self2 = this;
      const setLogger = (logger2, optionsOrLogLevel = { logLevel: types_1.DiagLogLevel.INFO }) => {
        var _a2, _b2, _c2;
        if (logger2 === self2) {
          const err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self2.error((_a2 = err.stack) !== null && _a2 !== undefined ? _a2 : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        const oldLogger = (0, global_utils_1.getGlobal)("diag");
        const newLogger = (0, logLevelLogger_1.createLogLevelDiagLogger)((_b2 = optionsOrLogLevel.logLevel) !== null && _b2 !== undefined ? _b2 : types_1.DiagLogLevel.INFO, logger2);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          const stack = (_c2 = new Error().stack) !== null && _c2 !== undefined ? _c2 : "<failed to generate stacktrace>";
          oldLogger.warn(`Current logger will be overwritten from ${stack}`);
          newLogger.warn(`Current logger will overwrite one already registered from ${stack}`);
        }
        return (0, global_utils_1.registerGlobal)("diag", newLogger, self2, true);
      };
      self2.setLogger = setLogger;
      self2.disable = () => {
        (0, global_utils_1.unregisterGlobal)(API_NAME, self2);
      };
      self2.createComponentLogger = (options) => {
        return new ComponentLogger_1.DiagComponentLogger(options);
      };
      self2.verbose = _logProxy("verbose");
      self2.debug = _logProxy("debug");
      self2.info = _logProxy("info");
      self2.warn = _logProxy("warn");
      self2.error = _logProxy("error");
    }
    static instance() {
      if (!this._instance) {
        this._instance = new DiagAPI;
      }
      return this._instance;
    }
  }
  exports.DiagAPI = DiagAPI;
});

// ../../node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js
var require_baggage_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaggageImpl = undefined;

  class BaggageImpl {
    constructor(entries) {
      this._entries = entries ? new Map(entries) : new Map;
    }
    getEntry(key) {
      const entry = this._entries.get(key);
      if (!entry) {
        return;
      }
      return Object.assign({}, entry);
    }
    getAllEntries() {
      return Array.from(this._entries.entries()).map(([k4, v7]) => [k4, v7]);
    }
    setEntry(key, entry) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.set(key, entry);
      return newBaggage;
    }
    removeEntry(key) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.delete(key);
      return newBaggage;
    }
    removeEntries(...keys) {
      const newBaggage = new BaggageImpl(this._entries);
      for (const key of keys) {
        newBaggage._entries.delete(key);
      }
      return newBaggage;
    }
    clear() {
      return new BaggageImpl;
    }
  }
  exports.BaggageImpl = BaggageImpl;
});

// ../../node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js
var require_symbol = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataSymbol = undefined;
  exports.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
});

// ../../node_modules/@opentelemetry/api/build/src/baggage/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataFromString = exports.createBaggage = undefined;
  var diag_1 = require_diag();
  var baggage_impl_1 = require_baggage_impl();
  var symbol_1 = require_symbol();
  var diag = diag_1.DiagAPI.instance();
  function createBaggage(entries = {}) {
    return new baggage_impl_1.BaggageImpl(new Map(Object.entries(entries)));
  }
  exports.createBaggage = createBaggage;
  function baggageEntryMetadataFromString(str) {
    if (typeof str !== "string") {
      diag.error(`Cannot create baggage metadata from unknown type: ${typeof str}`);
      str = "";
    }
    return {
      __TYPE__: symbol_1.baggageEntryMetadataSymbol,
      toString() {
        return str;
      }
    };
  }
  exports.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
});

// ../../node_modules/@opentelemetry/api/build/src/context/context.js
var require_context = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ROOT_CONTEXT = exports.createContextKey = undefined;
  function createContextKey(description) {
    return Symbol.for(description);
  }
  exports.createContextKey = createContextKey;

  class BaseContext {
    constructor(parentContext) {
      const self2 = this;
      self2._currentContext = parentContext ? new Map(parentContext) : new Map;
      self2.getValue = (key) => self2._currentContext.get(key);
      self2.setValue = (key, value) => {
        const context = new BaseContext(self2._currentContext);
        context._currentContext.set(key, value);
        return context;
      };
      self2.deleteValue = (key) => {
        const context = new BaseContext(self2._currentContext);
        context._currentContext.delete(key);
        return context;
      };
    }
  }
  exports.ROOT_CONTEXT = new BaseContext;
});

// ../../node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js
var require_consoleLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagConsoleLogger = undefined;
  var consoleMap = [
    { n: "error", c: "error" },
    { n: "warn", c: "warn" },
    { n: "info", c: "info" },
    { n: "debug", c: "debug" },
    { n: "verbose", c: "trace" }
  ];

  class DiagConsoleLogger {
    constructor() {
      function _consoleFunc(funcName) {
        return function(...args) {
          if (console) {
            let theFunc = console[funcName];
            if (typeof theFunc !== "function") {
              theFunc = console.log;
            }
            if (typeof theFunc === "function") {
              return theFunc.apply(console, args);
            }
          }
        };
      }
      for (let i4 = 0;i4 < consoleMap.length; i4++) {
        this[consoleMap[i4].n] = _consoleFunc(consoleMap[i4].c);
      }
    }
  }
  exports.DiagConsoleLogger = DiagConsoleLogger;
});

// ../../node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js
var require_NoopMeter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createNoopMeter = exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = exports.NOOP_OBSERVABLE_GAUGE_METRIC = exports.NOOP_OBSERVABLE_COUNTER_METRIC = exports.NOOP_UP_DOWN_COUNTER_METRIC = exports.NOOP_HISTOGRAM_METRIC = exports.NOOP_GAUGE_METRIC = exports.NOOP_COUNTER_METRIC = exports.NOOP_METER = exports.NoopObservableUpDownCounterMetric = exports.NoopObservableGaugeMetric = exports.NoopObservableCounterMetric = exports.NoopObservableMetric = exports.NoopHistogramMetric = exports.NoopGaugeMetric = exports.NoopUpDownCounterMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = undefined;

  class NoopMeter {
    constructor() {
    }
    createGauge(_name, _options) {
      return exports.NOOP_GAUGE_METRIC;
    }
    createHistogram(_name, _options) {
      return exports.NOOP_HISTOGRAM_METRIC;
    }
    createCounter(_name, _options) {
      return exports.NOOP_COUNTER_METRIC;
    }
    createUpDownCounter(_name, _options) {
      return exports.NOOP_UP_DOWN_COUNTER_METRIC;
    }
    createObservableGauge(_name, _options) {
      return exports.NOOP_OBSERVABLE_GAUGE_METRIC;
    }
    createObservableCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_COUNTER_METRIC;
    }
    createObservableUpDownCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    }
    addBatchObservableCallback(_callback, _observables) {
    }
    removeBatchObservableCallback(_callback) {
    }
  }
  exports.NoopMeter = NoopMeter;

  class NoopMetric {
  }
  exports.NoopMetric = NoopMetric;

  class NoopCounterMetric extends NoopMetric {
    add(_value, _attributes) {
    }
  }
  exports.NoopCounterMetric = NoopCounterMetric;

  class NoopUpDownCounterMetric extends NoopMetric {
    add(_value, _attributes) {
    }
  }
  exports.NoopUpDownCounterMetric = NoopUpDownCounterMetric;

  class NoopGaugeMetric extends NoopMetric {
    record(_value, _attributes) {
    }
  }
  exports.NoopGaugeMetric = NoopGaugeMetric;

  class NoopHistogramMetric extends NoopMetric {
    record(_value, _attributes) {
    }
  }
  exports.NoopHistogramMetric = NoopHistogramMetric;

  class NoopObservableMetric {
    addCallback(_callback) {
    }
    removeCallback(_callback) {
    }
  }
  exports.NoopObservableMetric = NoopObservableMetric;

  class NoopObservableCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableCounterMetric = NoopObservableCounterMetric;

  class NoopObservableGaugeMetric extends NoopObservableMetric {
  }
  exports.NoopObservableGaugeMetric = NoopObservableGaugeMetric;

  class NoopObservableUpDownCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
  exports.NOOP_METER = new NoopMeter;
  exports.NOOP_COUNTER_METRIC = new NoopCounterMetric;
  exports.NOOP_GAUGE_METRIC = new NoopGaugeMetric;
  exports.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric;
  exports.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric;
  exports.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric;
  exports.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric;
  exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric;
  function createNoopMeter() {
    return exports.NOOP_METER;
  }
  exports.createNoopMeter = createNoopMeter;
});

// ../../node_modules/@opentelemetry/api/build/src/metrics/Metric.js
var require_Metric = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueType = undefined;
  var ValueType;
  (function(ValueType2) {
    ValueType2[ValueType2["INT"] = 0] = "INT";
    ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
  })(ValueType = exports.ValueType || (exports.ValueType = {}));
});

// ../../node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js
var require_TextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultTextMapSetter = exports.defaultTextMapGetter = undefined;
  exports.defaultTextMapGetter = {
    get(carrier, key) {
      if (carrier == null) {
        return;
      }
      return carrier[key];
    },
    keys(carrier) {
      if (carrier == null) {
        return [];
      }
      return Object.keys(carrier);
    }
  };
  exports.defaultTextMapSetter = {
    set(carrier, key, value) {
      if (carrier == null) {
        return;
      }
      carrier[key] = value;
    }
  };
});

// ../../node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js
var require_NoopContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopContextManager = undefined;
  var context_1 = require_context();

  class NoopContextManager {
    active() {
      return context_1.ROOT_CONTEXT;
    }
    with(_context, fn, thisArg, ...args) {
      return fn.call(thisArg, ...args);
    }
    bind(_context, target) {
      return target;
    }
    enable() {
      return this;
    }
    disable() {
      return this;
    }
  }
  exports.NoopContextManager = NoopContextManager;
});

// ../../node_modules/@opentelemetry/api/build/src/api/context.js
var require_context2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ContextAPI = undefined;
  var NoopContextManager_1 = require_NoopContextManager();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "context";
  var NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager;

  class ContextAPI {
    constructor() {
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new ContextAPI;
      }
      return this._instance;
    }
    setGlobalContextManager(contextManager) {
      return (0, global_utils_1.registerGlobal)(API_NAME, contextManager, diag_1.DiagAPI.instance());
    }
    active() {
      return this._getContextManager().active();
    }
    with(context, fn, thisArg, ...args) {
      return this._getContextManager().with(context, fn, thisArg, ...args);
    }
    bind(context, target) {
      return this._getContextManager().bind(context, target);
    }
    _getContextManager() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_CONTEXT_MANAGER;
    }
    disable() {
      this._getContextManager().disable();
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.ContextAPI = ContextAPI;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/trace_flags.js
var require_trace_flags = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceFlags = undefined;
  var TraceFlags;
  (function(TraceFlags2) {
    TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
    TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
  })(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));
});

// ../../node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js
var require_invalid_span_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = undefined;
  var trace_flags_1 = require_trace_flags();
  exports.INVALID_SPANID = "0000000000000000";
  exports.INVALID_TRACEID = "00000000000000000000000000000000";
  exports.INVALID_SPAN_CONTEXT = {
    traceId: exports.INVALID_TRACEID,
    spanId: exports.INVALID_SPANID,
    traceFlags: trace_flags_1.TraceFlags.NONE
  };
});

// ../../node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js
var require_NonRecordingSpan = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NonRecordingSpan = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();

  class NonRecordingSpan {
    constructor(_spanContext = invalid_span_constants_1.INVALID_SPAN_CONTEXT) {
      this._spanContext = _spanContext;
    }
    spanContext() {
      return this._spanContext;
    }
    setAttribute(_key, _value) {
      return this;
    }
    setAttributes(_attributes) {
      return this;
    }
    addEvent(_name, _attributes) {
      return this;
    }
    addLink(_link) {
      return this;
    }
    addLinks(_links) {
      return this;
    }
    setStatus(_status) {
      return this;
    }
    updateName(_name) {
      return this;
    }
    end(_endTime) {
    }
    isRecording() {
      return false;
    }
    recordException(_exception, _time) {
    }
  }
  exports.NonRecordingSpan = NonRecordingSpan;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/context-utils.js
var require_context_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSpanContext = exports.setSpanContext = exports.deleteSpan = exports.setSpan = exports.getActiveSpan = exports.getSpan = undefined;
  var context_1 = require_context();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var context_2 = require_context2();
  var SPAN_KEY = (0, context_1.createContextKey)("OpenTelemetry Context Key SPAN");
  function getSpan(context) {
    return context.getValue(SPAN_KEY) || undefined;
  }
  exports.getSpan = getSpan;
  function getActiveSpan() {
    return getSpan(context_2.ContextAPI.getInstance().active());
  }
  exports.getActiveSpan = getActiveSpan;
  function setSpan(context, span) {
    return context.setValue(SPAN_KEY, span);
  }
  exports.setSpan = setSpan;
  function deleteSpan(context) {
    return context.deleteValue(SPAN_KEY);
  }
  exports.deleteSpan = deleteSpan;
  function setSpanContext(context, spanContext) {
    return setSpan(context, new NonRecordingSpan_1.NonRecordingSpan(spanContext));
  }
  exports.setSpanContext = setSpanContext;
  function getSpanContext(context) {
    var _a2;
    return (_a2 = getSpan(context)) === null || _a2 === undefined ? undefined : _a2.spanContext();
  }
  exports.getSpanContext = getSpanContext;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js
var require_spancontext_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wrapSpanContext = exports.isSpanContextValid = exports.isValidSpanId = exports.isValidTraceId = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
  var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== invalid_span_constants_1.INVALID_TRACEID;
  }
  exports.isValidTraceId = isValidTraceId;
  function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== invalid_span_constants_1.INVALID_SPANID;
  }
  exports.isValidSpanId = isValidSpanId;
  function isSpanContextValid(spanContext) {
    return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
  }
  exports.isSpanContextValid = isSpanContextValid;
  function wrapSpanContext(spanContext) {
    return new NonRecordingSpan_1.NonRecordingSpan(spanContext);
  }
  exports.wrapSpanContext = wrapSpanContext;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js
var require_NoopTracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracer = undefined;
  var context_1 = require_context2();
  var context_utils_1 = require_context_utils();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var spancontext_utils_1 = require_spancontext_utils();
  var contextApi = context_1.ContextAPI.getInstance();

  class NoopTracer {
    startSpan(name, options, context = contextApi.active()) {
      const root = Boolean(options === null || options === undefined ? undefined : options.root);
      if (root) {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
      const parentFromContext = context && (0, context_utils_1.getSpanContext)(context);
      if (isSpanContext(parentFromContext) && (0, spancontext_utils_1.isSpanContextValid)(parentFromContext)) {
        return new NonRecordingSpan_1.NonRecordingSpan(parentFromContext);
      } else {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
    }
    startActiveSpan(name, arg2, arg3, arg4) {
      let opts;
      let ctx;
      let fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      const parentContext = ctx !== null && ctx !== undefined ? ctx : contextApi.active();
      const span = this.startSpan(name, opts, parentContext);
      const contextWithSpanSet = (0, context_utils_1.setSpan)(parentContext, span);
      return contextApi.with(contextWithSpanSet, fn, undefined, span);
    }
  }
  exports.NoopTracer = NoopTracer;
  function isSpanContext(spanContext) {
    return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
  }
});

// ../../node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js
var require_ProxyTracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracer = undefined;
  var NoopTracer_1 = require_NoopTracer();
  var NOOP_TRACER = new NoopTracer_1.NoopTracer;

  class ProxyTracer {
    constructor(_provider, name, version2, options) {
      this._provider = _provider;
      this.name = name;
      this.version = version2;
      this.options = options;
    }
    startSpan(name, options, context) {
      return this._getTracer().startSpan(name, options, context);
    }
    startActiveSpan(_name, _options, _context, _fn) {
      const tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    }
    _getTracer() {
      if (this._delegate) {
        return this._delegate;
      }
      const tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER;
      }
      this._delegate = tracer;
      return this._delegate;
    }
  }
  exports.ProxyTracer = ProxyTracer;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js
var require_NoopTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracerProvider = undefined;
  var NoopTracer_1 = require_NoopTracer();

  class NoopTracerProvider {
    getTracer(_name, _version, _options) {
      return new NoopTracer_1.NoopTracer;
    }
  }
  exports.NoopTracerProvider = NoopTracerProvider;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js
var require_ProxyTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracerProvider = undefined;
  var ProxyTracer_1 = require_ProxyTracer();
  var NoopTracerProvider_1 = require_NoopTracerProvider();
  var NOOP_TRACER_PROVIDER = new NoopTracerProvider_1.NoopTracerProvider;

  class ProxyTracerProvider {
    getTracer(name, version2, options) {
      var _a2;
      return (_a2 = this.getDelegateTracer(name, version2, options)) !== null && _a2 !== undefined ? _a2 : new ProxyTracer_1.ProxyTracer(this, name, version2, options);
    }
    getDelegate() {
      var _a2;
      return (_a2 = this._delegate) !== null && _a2 !== undefined ? _a2 : NOOP_TRACER_PROVIDER;
    }
    setDelegate(delegate) {
      this._delegate = delegate;
    }
    getDelegateTracer(name, version2, options) {
      var _a2;
      return (_a2 = this._delegate) === null || _a2 === undefined ? undefined : _a2.getTracer(name, version2, options);
    }
  }
  exports.ProxyTracerProvider = ProxyTracerProvider;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js
var require_SamplingResult = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SamplingDecision = undefined;
  var SamplingDecision;
  (function(SamplingDecision2) {
    SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
    SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
    SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
  })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
});

// ../../node_modules/@opentelemetry/api/build/src/trace/span_kind.js
var require_span_kind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanKind = undefined;
  var SpanKind;
  (function(SpanKind2) {
    SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
    SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
    SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
    SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
    SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
  })(SpanKind = exports.SpanKind || (exports.SpanKind = {}));
});

// ../../node_modules/@opentelemetry/api/build/src/trace/status.js
var require_status = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanStatusCode = undefined;
  var SpanStatusCode;
  (function(SpanStatusCode2) {
    SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
    SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
    SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
  })(SpanStatusCode = exports.SpanStatusCode || (exports.SpanStatusCode = {}));
});

// ../../node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js
var require_tracestate_validators = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateValue = exports.validateKey = undefined;
  var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
  var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
  var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
  var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);
  var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
  var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
  }
  exports.validateKey = validateKey;
  function validateValue(value) {
    return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
  }
  exports.validateValue = validateValue;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js
var require_tracestate_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceStateImpl = undefined;
  var tracestate_validators_1 = require_tracestate_validators();
  var MAX_TRACE_STATE_ITEMS = 32;
  var MAX_TRACE_STATE_LEN = 512;
  var LIST_MEMBERS_SEPARATOR = ",";
  var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";

  class TraceStateImpl {
    constructor(rawTraceState) {
      this._internalState = new Map;
      if (rawTraceState)
        this._parse(rawTraceState);
    }
    set(key, value) {
      const traceState = this._clone();
      if (traceState._internalState.has(key)) {
        traceState._internalState.delete(key);
      }
      traceState._internalState.set(key, value);
      return traceState;
    }
    unset(key) {
      const traceState = this._clone();
      traceState._internalState.delete(key);
      return traceState;
    }
    get(key) {
      return this._internalState.get(key);
    }
    serialize() {
      return this._keys().reduce((agg, key) => {
        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
        return agg;
      }, []).join(LIST_MEMBERS_SEPARATOR);
    }
    _parse(rawTraceState) {
      if (rawTraceState.length > MAX_TRACE_STATE_LEN)
        return;
      this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
        const listMember = part.trim();
        const i4 = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
        if (i4 !== -1) {
          const key = listMember.slice(0, i4);
          const value = listMember.slice(i4 + 1, part.length);
          if ((0, tracestate_validators_1.validateKey)(key) && (0, tracestate_validators_1.validateValue)(value)) {
            agg.set(key, value);
          } else {
          }
        }
        return agg;
      }, new Map);
      if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
      }
    }
    _keys() {
      return Array.from(this._internalState.keys()).reverse();
    }
    _clone() {
      const traceState = new TraceStateImpl;
      traceState._internalState = new Map(this._internalState);
      return traceState;
    }
  }
  exports.TraceStateImpl = TraceStateImpl;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/internal/utils.js
var require_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTraceState = undefined;
  var tracestate_impl_1 = require_tracestate_impl();
  function createTraceState(rawTraceState) {
    return new tracestate_impl_1.TraceStateImpl(rawTraceState);
  }
  exports.createTraceState = createTraceState;
});

// ../../node_modules/@opentelemetry/api/build/src/context-api.js
var require_context_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.context = undefined;
  var context_1 = require_context2();
  exports.context = context_1.ContextAPI.getInstance();
});

// ../../node_modules/@opentelemetry/api/build/src/diag-api.js
var require_diag_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.diag = undefined;
  var diag_1 = require_diag();
  exports.diag = diag_1.DiagAPI.instance();
});

// ../../node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js
var require_NoopMeterProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_METER_PROVIDER = exports.NoopMeterProvider = undefined;
  var NoopMeter_1 = require_NoopMeter();

  class NoopMeterProvider {
    getMeter(_name, _version, _options) {
      return NoopMeter_1.NOOP_METER;
    }
  }
  exports.NoopMeterProvider = NoopMeterProvider;
  exports.NOOP_METER_PROVIDER = new NoopMeterProvider;
});

// ../../node_modules/@opentelemetry/api/build/src/api/metrics.js
var require_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MetricsAPI = undefined;
  var NoopMeterProvider_1 = require_NoopMeterProvider();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "metrics";

  class MetricsAPI {
    constructor() {
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new MetricsAPI;
      }
      return this._instance;
    }
    setGlobalMeterProvider(provider3) {
      return (0, global_utils_1.registerGlobal)(API_NAME, provider3, diag_1.DiagAPI.instance());
    }
    getMeterProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NoopMeterProvider_1.NOOP_METER_PROVIDER;
    }
    getMeter(name, version2, options) {
      return this.getMeterProvider().getMeter(name, version2, options);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.MetricsAPI = MetricsAPI;
});

// ../../node_modules/@opentelemetry/api/build/src/metrics-api.js
var require_metrics_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.metrics = undefined;
  var metrics_1 = require_metrics();
  exports.metrics = metrics_1.MetricsAPI.getInstance();
});

// ../../node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js
var require_NoopTextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTextMapPropagator = undefined;

  class NoopTextMapPropagator {
    inject(_context, _carrier) {
    }
    extract(context, _carrier) {
      return context;
    }
    fields() {
      return [];
    }
  }
  exports.NoopTextMapPropagator = NoopTextMapPropagator;
});

// ../../node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js
var require_context_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deleteBaggage = exports.setBaggage = exports.getActiveBaggage = exports.getBaggage = undefined;
  var context_1 = require_context2();
  var context_2 = require_context();
  var BAGGAGE_KEY = (0, context_2.createContextKey)("OpenTelemetry Baggage Key");
  function getBaggage(context) {
    return context.getValue(BAGGAGE_KEY) || undefined;
  }
  exports.getBaggage = getBaggage;
  function getActiveBaggage() {
    return getBaggage(context_1.ContextAPI.getInstance().active());
  }
  exports.getActiveBaggage = getActiveBaggage;
  function setBaggage(context, baggage) {
    return context.setValue(BAGGAGE_KEY, baggage);
  }
  exports.setBaggage = setBaggage;
  function deleteBaggage(context) {
    return context.deleteValue(BAGGAGE_KEY);
  }
  exports.deleteBaggage = deleteBaggage;
});

// ../../node_modules/@opentelemetry/api/build/src/api/propagation.js
var require_propagation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PropagationAPI = undefined;
  var global_utils_1 = require_global_utils();
  var NoopTextMapPropagator_1 = require_NoopTextMapPropagator();
  var TextMapPropagator_1 = require_TextMapPropagator();
  var context_helpers_1 = require_context_helpers();
  var utils_1 = require_utils();
  var diag_1 = require_diag();
  var API_NAME = "propagation";
  var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator_1.NoopTextMapPropagator;

  class PropagationAPI {
    constructor() {
      this.createBaggage = utils_1.createBaggage;
      this.getBaggage = context_helpers_1.getBaggage;
      this.getActiveBaggage = context_helpers_1.getActiveBaggage;
      this.setBaggage = context_helpers_1.setBaggage;
      this.deleteBaggage = context_helpers_1.deleteBaggage;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new PropagationAPI;
      }
      return this._instance;
    }
    setGlobalPropagator(propagator) {
      return (0, global_utils_1.registerGlobal)(API_NAME, propagator, diag_1.DiagAPI.instance());
    }
    inject(context, carrier, setter = TextMapPropagator_1.defaultTextMapSetter) {
      return this._getGlobalPropagator().inject(context, carrier, setter);
    }
    extract(context, carrier, getter = TextMapPropagator_1.defaultTextMapGetter) {
      return this._getGlobalPropagator().extract(context, carrier, getter);
    }
    fields() {
      return this._getGlobalPropagator().fields();
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
    _getGlobalPropagator() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
    }
  }
  exports.PropagationAPI = PropagationAPI;
});

// ../../node_modules/@opentelemetry/api/build/src/propagation-api.js
var require_propagation_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.propagation = undefined;
  var propagation_1 = require_propagation();
  exports.propagation = propagation_1.PropagationAPI.getInstance();
});

// ../../node_modules/@opentelemetry/api/build/src/api/trace.js
var require_trace = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceAPI = undefined;
  var global_utils_1 = require_global_utils();
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  var spancontext_utils_1 = require_spancontext_utils();
  var context_utils_1 = require_context_utils();
  var diag_1 = require_diag();
  var API_NAME = "trace";

  class TraceAPI {
    constructor() {
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
      this.wrapSpanContext = spancontext_utils_1.wrapSpanContext;
      this.isSpanContextValid = spancontext_utils_1.isSpanContextValid;
      this.deleteSpan = context_utils_1.deleteSpan;
      this.getSpan = context_utils_1.getSpan;
      this.getActiveSpan = context_utils_1.getActiveSpan;
      this.getSpanContext = context_utils_1.getSpanContext;
      this.setSpan = context_utils_1.setSpan;
      this.setSpanContext = context_utils_1.setSpanContext;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new TraceAPI;
      }
      return this._instance;
    }
    setGlobalTracerProvider(provider3) {
      const success = (0, global_utils_1.registerGlobal)(API_NAME, this._proxyTracerProvider, diag_1.DiagAPI.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider3);
      }
      return success;
    }
    getTracerProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || this._proxyTracerProvider;
    }
    getTracer(name, version2) {
      return this.getTracerProvider().getTracer(name, version2);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
    }
  }
  exports.TraceAPI = TraceAPI;
});

// ../../node_modules/@opentelemetry/api/build/src/trace-api.js
var require_trace_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = undefined;
  var trace_1 = require_trace();
  exports.trace = trace_1.TraceAPI.getInstance();
});

// ../../node_modules/@opentelemetry/api/build/src/index.js
var require_src = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = exports.propagation = exports.metrics = exports.diag = exports.context = exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = exports.isValidSpanId = exports.isValidTraceId = exports.isSpanContextValid = exports.createTraceState = exports.TraceFlags = exports.SpanStatusCode = exports.SpanKind = exports.SamplingDecision = exports.ProxyTracerProvider = exports.ProxyTracer = exports.defaultTextMapSetter = exports.defaultTextMapGetter = exports.ValueType = exports.createNoopMeter = exports.DiagLogLevel = exports.DiagConsoleLogger = exports.ROOT_CONTEXT = exports.createContextKey = exports.baggageEntryMetadataFromString = undefined;
  var utils_1 = require_utils();
  Object.defineProperty(exports, "baggageEntryMetadataFromString", { enumerable: true, get: function() {
    return utils_1.baggageEntryMetadataFromString;
  } });
  var context_1 = require_context();
  Object.defineProperty(exports, "createContextKey", { enumerable: true, get: function() {
    return context_1.createContextKey;
  } });
  Object.defineProperty(exports, "ROOT_CONTEXT", { enumerable: true, get: function() {
    return context_1.ROOT_CONTEXT;
  } });
  var consoleLogger_1 = require_consoleLogger();
  Object.defineProperty(exports, "DiagConsoleLogger", { enumerable: true, get: function() {
    return consoleLogger_1.DiagConsoleLogger;
  } });
  var types_1 = require_types();
  Object.defineProperty(exports, "DiagLogLevel", { enumerable: true, get: function() {
    return types_1.DiagLogLevel;
  } });
  var NoopMeter_1 = require_NoopMeter();
  Object.defineProperty(exports, "createNoopMeter", { enumerable: true, get: function() {
    return NoopMeter_1.createNoopMeter;
  } });
  var Metric_1 = require_Metric();
  Object.defineProperty(exports, "ValueType", { enumerable: true, get: function() {
    return Metric_1.ValueType;
  } });
  var TextMapPropagator_1 = require_TextMapPropagator();
  Object.defineProperty(exports, "defaultTextMapGetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapGetter;
  } });
  Object.defineProperty(exports, "defaultTextMapSetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapSetter;
  } });
  var ProxyTracer_1 = require_ProxyTracer();
  Object.defineProperty(exports, "ProxyTracer", { enumerable: true, get: function() {
    return ProxyTracer_1.ProxyTracer;
  } });
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  Object.defineProperty(exports, "ProxyTracerProvider", { enumerable: true, get: function() {
    return ProxyTracerProvider_1.ProxyTracerProvider;
  } });
  var SamplingResult_1 = require_SamplingResult();
  Object.defineProperty(exports, "SamplingDecision", { enumerable: true, get: function() {
    return SamplingResult_1.SamplingDecision;
  } });
  var span_kind_1 = require_span_kind();
  Object.defineProperty(exports, "SpanKind", { enumerable: true, get: function() {
    return span_kind_1.SpanKind;
  } });
  var status_1 = require_status();
  Object.defineProperty(exports, "SpanStatusCode", { enumerable: true, get: function() {
    return status_1.SpanStatusCode;
  } });
  var trace_flags_1 = require_trace_flags();
  Object.defineProperty(exports, "TraceFlags", { enumerable: true, get: function() {
    return trace_flags_1.TraceFlags;
  } });
  var utils_2 = require_utils2();
  Object.defineProperty(exports, "createTraceState", { enumerable: true, get: function() {
    return utils_2.createTraceState;
  } });
  var spancontext_utils_1 = require_spancontext_utils();
  Object.defineProperty(exports, "isSpanContextValid", { enumerable: true, get: function() {
    return spancontext_utils_1.isSpanContextValid;
  } });
  Object.defineProperty(exports, "isValidTraceId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidTraceId;
  } });
  Object.defineProperty(exports, "isValidSpanId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidSpanId;
  } });
  var invalid_span_constants_1 = require_invalid_span_constants();
  Object.defineProperty(exports, "INVALID_SPANID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPANID;
  } });
  Object.defineProperty(exports, "INVALID_TRACEID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_TRACEID;
  } });
  Object.defineProperty(exports, "INVALID_SPAN_CONTEXT", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPAN_CONTEXT;
  } });
  var context_api_1 = require_context_api();
  Object.defineProperty(exports, "context", { enumerable: true, get: function() {
    return context_api_1.context;
  } });
  var diag_api_1 = require_diag_api();
  Object.defineProperty(exports, "diag", { enumerable: true, get: function() {
    return diag_api_1.diag;
  } });
  var metrics_api_1 = require_metrics_api();
  Object.defineProperty(exports, "metrics", { enumerable: true, get: function() {
    return metrics_api_1.metrics;
  } });
  var propagation_api_1 = require_propagation_api();
  Object.defineProperty(exports, "propagation", { enumerable: true, get: function() {
    return propagation_api_1.propagation;
  } });
  var trace_api_1 = require_trace_api();
  Object.defineProperty(exports, "trace", { enumerable: true, get: function() {
    return trace_api_1.trace;
  } });
  exports.default = {
    context: context_api_1.context,
    diag: diag_api_1.diag,
    metrics: metrics_api_1.metrics,
    propagation: propagation_api_1.propagation,
    trace: trace_api_1.trace
  };
});

// ../../node_modules/@prisma/client/scripts/default-index.js
var require_default_index = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var default_index_exports = {};
  __export2(default_index_exports, {
    Prisma: () => Prisma2,
    PrismaClient: () => PrismaClient,
    default: () => default_index_default
  });
  module.exports = __toCommonJS(default_index_exports);
  var prisma = {
    enginesVersion: "4123509d24aa4dede1e864b46351bf2790323b69"
  };
  var version2 = "6.2.1";
  var clientVersion = version2;
  var PrismaClient = class {
    constructor() {
      throw new Error('@prisma/client did not initialize yet. Please run "prisma generate" and try to import it again.');
    }
  };
  function defineExtension(ext) {
    if (typeof ext === "function") {
      return ext;
    }
    return (client2) => client2.$extends(ext);
  }
  function getExtensionContext(that) {
    return that;
  }
  var Prisma2 = {
    defineExtension,
    getExtensionContext,
    prismaVersion: { client: clientVersion, engine: prisma.enginesVersion }
  };
  var default_index_default = { Prisma: Prisma2 };
});

// ../../node_modules/@prisma/client/extension.js
var require_extension = __commonJS((exports, module) => {
  module.exports = {
    ...require_default_index()
  };
});

// ../../node_modules/kleur/index.js
var require_kleur = __commonJS((exports, module) => {
  var FORCE_COLOR;
  var NODE_DISABLE_COLORS;
  var NO_COLOR;
  var TERM;
  var isTTY = true;
  if (typeof process !== "undefined") {
    ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
    isTTY = process.stdout && process.stdout.isTTY;
  }
  var $ = {
    enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY),
    reset: init2(0, 0),
    bold: init2(1, 22),
    dim: init2(2, 22),
    italic: init2(3, 23),
    underline: init2(4, 24),
    inverse: init2(7, 27),
    hidden: init2(8, 28),
    strikethrough: init2(9, 29),
    black: init2(30, 39),
    red: init2(31, 39),
    green: init2(32, 39),
    yellow: init2(33, 39),
    blue: init2(34, 39),
    magenta: init2(35, 39),
    cyan: init2(36, 39),
    white: init2(37, 39),
    gray: init2(90, 39),
    grey: init2(90, 39),
    bgBlack: init2(40, 49),
    bgRed: init2(41, 49),
    bgGreen: init2(42, 49),
    bgYellow: init2(43, 49),
    bgBlue: init2(44, 49),
    bgMagenta: init2(45, 49),
    bgCyan: init2(46, 49),
    bgWhite: init2(47, 49)
  };
  function run(arr, str) {
    let i4 = 0, tmp, beg = "", end = "";
    for (;i4 < arr.length; i4++) {
      tmp = arr[i4];
      beg += tmp.open;
      end += tmp.close;
      if (!!~str.indexOf(tmp.close)) {
        str = str.replace(tmp.rgx, tmp.close + tmp.open);
      }
    }
    return beg + str + end;
  }
  function chain6(has, keys) {
    let ctx = { has, keys };
    ctx.reset = $.reset.bind(ctx);
    ctx.bold = $.bold.bind(ctx);
    ctx.dim = $.dim.bind(ctx);
    ctx.italic = $.italic.bind(ctx);
    ctx.underline = $.underline.bind(ctx);
    ctx.inverse = $.inverse.bind(ctx);
    ctx.hidden = $.hidden.bind(ctx);
    ctx.strikethrough = $.strikethrough.bind(ctx);
    ctx.black = $.black.bind(ctx);
    ctx.red = $.red.bind(ctx);
    ctx.green = $.green.bind(ctx);
    ctx.yellow = $.yellow.bind(ctx);
    ctx.blue = $.blue.bind(ctx);
    ctx.magenta = $.magenta.bind(ctx);
    ctx.cyan = $.cyan.bind(ctx);
    ctx.white = $.white.bind(ctx);
    ctx.gray = $.gray.bind(ctx);
    ctx.grey = $.grey.bind(ctx);
    ctx.bgBlack = $.bgBlack.bind(ctx);
    ctx.bgRed = $.bgRed.bind(ctx);
    ctx.bgGreen = $.bgGreen.bind(ctx);
    ctx.bgYellow = $.bgYellow.bind(ctx);
    ctx.bgBlue = $.bgBlue.bind(ctx);
    ctx.bgMagenta = $.bgMagenta.bind(ctx);
    ctx.bgCyan = $.bgCyan.bind(ctx);
    ctx.bgWhite = $.bgWhite.bind(ctx);
    return ctx;
  }
  function init2(open, close) {
    let blk = {
      open: `\x1B[${open}m`,
      close: `\x1B[${close}m`,
      rgx: new RegExp(`\\x1b\\[${close}m`, "g")
    };
    return function(txt) {
      if (this !== undefined && this.has !== undefined) {
        !!~this.has.indexOf(open) || (this.has.push(open), this.keys.push(blk));
        return txt === undefined ? this : $.enabled ? run(this.keys, txt + "") : txt + "";
      }
      return txt === undefined ? chain6([open], [blk]) : $.enabled ? run([blk], txt + "") : txt + "";
    };
  }
  module.exports = $;
});

// ../../node_modules/@opentelemetry/context-async-hooks/build/src/AbstractAsyncHooksContextManager.js
var require_AbstractAsyncHooksContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbstractAsyncHooksContextManager = undefined;
  var events_1 = __require("events");
  var ADD_LISTENER_METHODS = [
    "addListener",
    "on",
    "once",
    "prependListener",
    "prependOnceListener"
  ];

  class AbstractAsyncHooksContextManager {
    constructor() {
      this._kOtListeners = Symbol("OtListeners");
      this._wrapped = false;
    }
    bind(context, target) {
      if (target instanceof events_1.EventEmitter) {
        return this._bindEventEmitter(context, target);
      }
      if (typeof target === "function") {
        return this._bindFunction(context, target);
      }
      return target;
    }
    _bindFunction(context, target) {
      const manager = this;
      const contextWrapper = function(...args) {
        return manager.with(context, () => target.apply(this, args));
      };
      Object.defineProperty(contextWrapper, "length", {
        enumerable: false,
        configurable: true,
        writable: false,
        value: target.length
      });
      return contextWrapper;
    }
    _bindEventEmitter(context, ee2) {
      const map2 = this._getPatchMap(ee2);
      if (map2 !== undefined)
        return ee2;
      this._createPatchMap(ee2);
      ADD_LISTENER_METHODS.forEach((methodName) => {
        if (ee2[methodName] === undefined)
          return;
        ee2[methodName] = this._patchAddListener(ee2, ee2[methodName], context);
      });
      if (typeof ee2.removeListener === "function") {
        ee2.removeListener = this._patchRemoveListener(ee2, ee2.removeListener);
      }
      if (typeof ee2.off === "function") {
        ee2.off = this._patchRemoveListener(ee2, ee2.off);
      }
      if (typeof ee2.removeAllListeners === "function") {
        ee2.removeAllListeners = this._patchRemoveAllListeners(ee2, ee2.removeAllListeners);
      }
      return ee2;
    }
    _patchRemoveListener(ee2, original) {
      const contextManager = this;
      return function(event, listener) {
        var _a2;
        const events = (_a2 = contextManager._getPatchMap(ee2)) === null || _a2 === undefined ? undefined : _a2[event];
        if (events === undefined) {
          return original.call(this, event, listener);
        }
        const patchedListener = events.get(listener);
        return original.call(this, event, patchedListener || listener);
      };
    }
    _patchRemoveAllListeners(ee2, original) {
      const contextManager = this;
      return function(event) {
        const map2 = contextManager._getPatchMap(ee2);
        if (map2 !== undefined) {
          if (arguments.length === 0) {
            contextManager._createPatchMap(ee2);
          } else if (map2[event] !== undefined) {
            delete map2[event];
          }
        }
        return original.apply(this, arguments);
      };
    }
    _patchAddListener(ee2, original, context) {
      const contextManager = this;
      return function(event, listener) {
        if (contextManager._wrapped) {
          return original.call(this, event, listener);
        }
        let map2 = contextManager._getPatchMap(ee2);
        if (map2 === undefined) {
          map2 = contextManager._createPatchMap(ee2);
        }
        let listeners = map2[event];
        if (listeners === undefined) {
          listeners = new WeakMap;
          map2[event] = listeners;
        }
        const patchedListener = contextManager.bind(context, listener);
        listeners.set(listener, patchedListener);
        contextManager._wrapped = true;
        try {
          return original.call(this, event, patchedListener);
        } finally {
          contextManager._wrapped = false;
        }
      };
    }
    _createPatchMap(ee2) {
      const map2 = Object.create(null);
      ee2[this._kOtListeners] = map2;
      return map2;
    }
    _getPatchMap(ee2) {
      return ee2[this._kOtListeners];
    }
  }
  exports.AbstractAsyncHooksContextManager = AbstractAsyncHooksContextManager;
});

// ../../node_modules/@opentelemetry/context-async-hooks/build/src/AsyncHooksContextManager.js
var require_AsyncHooksContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncHooksContextManager = undefined;
  var api_1 = require_src();
  var asyncHooks = __require("async_hooks");
  var AbstractAsyncHooksContextManager_1 = require_AbstractAsyncHooksContextManager();

  class AsyncHooksContextManager extends AbstractAsyncHooksContextManager_1.AbstractAsyncHooksContextManager {
    constructor() {
      super();
      this._contexts = new Map;
      this._stack = [];
      this._asyncHook = asyncHooks.createHook({
        init: this._init.bind(this),
        before: this._before.bind(this),
        after: this._after.bind(this),
        destroy: this._destroy.bind(this),
        promiseResolve: this._destroy.bind(this)
      });
    }
    active() {
      var _a2;
      return (_a2 = this._stack[this._stack.length - 1]) !== null && _a2 !== undefined ? _a2 : api_1.ROOT_CONTEXT;
    }
    with(context, fn, thisArg, ...args) {
      this._enterContext(context);
      try {
        return fn.call(thisArg, ...args);
      } finally {
        this._exitContext();
      }
    }
    enable() {
      this._asyncHook.enable();
      return this;
    }
    disable() {
      this._asyncHook.disable();
      this._contexts.clear();
      this._stack = [];
      return this;
    }
    _init(uid, type) {
      if (type === "TIMERWRAP")
        return;
      const context = this._stack[this._stack.length - 1];
      if (context !== undefined) {
        this._contexts.set(uid, context);
      }
    }
    _destroy(uid) {
      this._contexts.delete(uid);
    }
    _before(uid) {
      const context = this._contexts.get(uid);
      if (context !== undefined) {
        this._enterContext(context);
      }
    }
    _after() {
      this._exitContext();
    }
    _enterContext(context) {
      this._stack.push(context);
    }
    _exitContext() {
      this._stack.pop();
    }
  }
  exports.AsyncHooksContextManager = AsyncHooksContextManager;
});

// ../../node_modules/@opentelemetry/context-async-hooks/build/src/AsyncLocalStorageContextManager.js
var require_AsyncLocalStorageContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncLocalStorageContextManager = undefined;
  var api_1 = require_src();
  var async_hooks_1 = __require("async_hooks");
  var AbstractAsyncHooksContextManager_1 = require_AbstractAsyncHooksContextManager();

  class AsyncLocalStorageContextManager extends AbstractAsyncHooksContextManager_1.AbstractAsyncHooksContextManager {
    constructor() {
      super();
      this._asyncLocalStorage = new async_hooks_1.AsyncLocalStorage;
    }
    active() {
      var _a2;
      return (_a2 = this._asyncLocalStorage.getStore()) !== null && _a2 !== undefined ? _a2 : api_1.ROOT_CONTEXT;
    }
    with(context, fn, thisArg, ...args) {
      const cb2 = thisArg == null ? fn : fn.bind(thisArg);
      return this._asyncLocalStorage.run(context, cb2, ...args);
    }
    enable() {
      return this;
    }
    disable() {
      this._asyncLocalStorage.disable();
      return this;
    }
  }
  exports.AsyncLocalStorageContextManager = AsyncLocalStorageContextManager;
});

// ../../node_modules/@opentelemetry/context-async-hooks/build/src/index.js
var require_src2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncLocalStorageContextManager = exports.AsyncHooksContextManager = undefined;
  var AsyncHooksContextManager_1 = require_AsyncHooksContextManager();
  Object.defineProperty(exports, "AsyncHooksContextManager", { enumerable: true, get: function() {
    return AsyncHooksContextManager_1.AsyncHooksContextManager;
  } });
  var AsyncLocalStorageContextManager_1 = require_AsyncLocalStorageContextManager();
  Object.defineProperty(exports, "AsyncLocalStorageContextManager", { enumerable: true, get: function() {
    return AsyncLocalStorageContextManager_1.AsyncLocalStorageContextManager;
  } });
});

// ../../node_modules/@opentelemetry/api-logs/build/src/types/LogRecord.js
var require_LogRecord = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SeverityNumber = undefined;
  var SeverityNumber;
  (function(SeverityNumber2) {
    SeverityNumber2[SeverityNumber2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    SeverityNumber2[SeverityNumber2["TRACE"] = 1] = "TRACE";
    SeverityNumber2[SeverityNumber2["TRACE2"] = 2] = "TRACE2";
    SeverityNumber2[SeverityNumber2["TRACE3"] = 3] = "TRACE3";
    SeverityNumber2[SeverityNumber2["TRACE4"] = 4] = "TRACE4";
    SeverityNumber2[SeverityNumber2["DEBUG"] = 5] = "DEBUG";
    SeverityNumber2[SeverityNumber2["DEBUG2"] = 6] = "DEBUG2";
    SeverityNumber2[SeverityNumber2["DEBUG3"] = 7] = "DEBUG3";
    SeverityNumber2[SeverityNumber2["DEBUG4"] = 8] = "DEBUG4";
    SeverityNumber2[SeverityNumber2["INFO"] = 9] = "INFO";
    SeverityNumber2[SeverityNumber2["INFO2"] = 10] = "INFO2";
    SeverityNumber2[SeverityNumber2["INFO3"] = 11] = "INFO3";
    SeverityNumber2[SeverityNumber2["INFO4"] = 12] = "INFO4";
    SeverityNumber2[SeverityNumber2["WARN"] = 13] = "WARN";
    SeverityNumber2[SeverityNumber2["WARN2"] = 14] = "WARN2";
    SeverityNumber2[SeverityNumber2["WARN3"] = 15] = "WARN3";
    SeverityNumber2[SeverityNumber2["WARN4"] = 16] = "WARN4";
    SeverityNumber2[SeverityNumber2["ERROR"] = 17] = "ERROR";
    SeverityNumber2[SeverityNumber2["ERROR2"] = 18] = "ERROR2";
    SeverityNumber2[SeverityNumber2["ERROR3"] = 19] = "ERROR3";
    SeverityNumber2[SeverityNumber2["ERROR4"] = 20] = "ERROR4";
    SeverityNumber2[SeverityNumber2["FATAL"] = 21] = "FATAL";
    SeverityNumber2[SeverityNumber2["FATAL2"] = 22] = "FATAL2";
    SeverityNumber2[SeverityNumber2["FATAL3"] = 23] = "FATAL3";
    SeverityNumber2[SeverityNumber2["FATAL4"] = 24] = "FATAL4";
  })(SeverityNumber = exports.SeverityNumber || (exports.SeverityNumber = {}));
});

// ../../node_modules/@opentelemetry/api-logs/build/src/NoopLogger.js
var require_NoopLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_LOGGER = exports.NoopLogger = undefined;

  class NoopLogger {
    emit(_logRecord) {
    }
  }
  exports.NoopLogger = NoopLogger;
  exports.NOOP_LOGGER = new NoopLogger;
});

// ../../node_modules/@opentelemetry/api-logs/build/src/NoopLoggerProvider.js
var require_NoopLoggerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_LOGGER_PROVIDER = exports.NoopLoggerProvider = undefined;
  var NoopLogger_1 = require_NoopLogger();

  class NoopLoggerProvider {
    getLogger(_name, _version, _options) {
      return new NoopLogger_1.NoopLogger;
    }
  }
  exports.NoopLoggerProvider = NoopLoggerProvider;
  exports.NOOP_LOGGER_PROVIDER = new NoopLoggerProvider;
});

// ../../node_modules/@opentelemetry/api-logs/build/src/platform/node/globalThis.js
var require_globalThis2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// ../../node_modules/@opentelemetry/api-logs/build/src/platform/node/index.js
var require_node2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  var globalThis_1 = require_globalThis2();
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return globalThis_1._globalThis;
  } });
});

// ../../node_modules/@opentelemetry/api-logs/build/src/platform/index.js
var require_platform2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  var node_1 = require_node2();
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return node_1._globalThis;
  } });
});

// ../../node_modules/@opentelemetry/api-logs/build/src/internal/global-utils.js
var require_global_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.API_BACKWARDS_COMPATIBILITY_VERSION = exports.makeGetter = exports._global = exports.GLOBAL_LOGS_API_KEY = undefined;
  var platform_1 = require_platform2();
  exports.GLOBAL_LOGS_API_KEY = Symbol.for("io.opentelemetry.js.api.logs");
  exports._global = platform_1._globalThis;
  function makeGetter(requiredVersion, instance, fallback) {
    return (version2) => version2 === requiredVersion ? instance : fallback;
  }
  exports.makeGetter = makeGetter;
  exports.API_BACKWARDS_COMPATIBILITY_VERSION = 1;
});

// ../../node_modules/@opentelemetry/api-logs/build/src/api/logs.js
var require_logs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LogsAPI = undefined;
  var global_utils_1 = require_global_utils2();
  var NoopLoggerProvider_1 = require_NoopLoggerProvider();

  class LogsAPI {
    constructor() {
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new LogsAPI;
      }
      return this._instance;
    }
    setGlobalLoggerProvider(provider3) {
      if (global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY]) {
        return this.getLoggerProvider();
      }
      global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY] = (0, global_utils_1.makeGetter)(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, provider3, NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER);
      return provider3;
    }
    getLoggerProvider() {
      var _a2, _b2;
      return (_b2 = (_a2 = global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY]) === null || _a2 === undefined ? undefined : _a2.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b2 !== undefined ? _b2 : NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER;
    }
    getLogger(name, version2, options) {
      return this.getLoggerProvider().getLogger(name, version2, options);
    }
    disable() {
      delete global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY];
    }
  }
  exports.LogsAPI = LogsAPI;
});

// ../../node_modules/@opentelemetry/api-logs/build/src/index.js
var require_src3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logs = exports.NoopLoggerProvider = exports.NOOP_LOGGER_PROVIDER = exports.NoopLogger = exports.NOOP_LOGGER = exports.SeverityNumber = undefined;
  var LogRecord_1 = require_LogRecord();
  Object.defineProperty(exports, "SeverityNumber", { enumerable: true, get: function() {
    return LogRecord_1.SeverityNumber;
  } });
  var NoopLogger_1 = require_NoopLogger();
  Object.defineProperty(exports, "NOOP_LOGGER", { enumerable: true, get: function() {
    return NoopLogger_1.NOOP_LOGGER;
  } });
  Object.defineProperty(exports, "NoopLogger", { enumerable: true, get: function() {
    return NoopLogger_1.NoopLogger;
  } });
  var NoopLoggerProvider_1 = require_NoopLoggerProvider();
  Object.defineProperty(exports, "NOOP_LOGGER_PROVIDER", { enumerable: true, get: function() {
    return NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER;
  } });
  Object.defineProperty(exports, "NoopLoggerProvider", { enumerable: true, get: function() {
    return NoopLoggerProvider_1.NoopLoggerProvider;
  } });
  var logs_1 = require_logs();
  exports.logs = logs_1.LogsAPI.getInstance();
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/autoLoaderUtils.js
var require_autoLoaderUtils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.disableInstrumentations = exports.enableInstrumentations = undefined;
  function enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider) {
    for (let i4 = 0, j4 = instrumentations.length;i4 < j4; i4++) {
      const instrumentation = instrumentations[i4];
      if (tracerProvider) {
        instrumentation.setTracerProvider(tracerProvider);
      }
      if (meterProvider) {
        instrumentation.setMeterProvider(meterProvider);
      }
      if (loggerProvider && instrumentation.setLoggerProvider) {
        instrumentation.setLoggerProvider(loggerProvider);
      }
      if (!instrumentation.getConfig().enabled) {
        instrumentation.enable();
      }
    }
  }
  exports.enableInstrumentations = enableInstrumentations;
  function disableInstrumentations(instrumentations) {
    instrumentations.forEach((instrumentation) => instrumentation.disable());
  }
  exports.disableInstrumentations = disableInstrumentations;
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/autoLoader.js
var require_autoLoader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.registerInstrumentations = undefined;
  var api_1 = require_src();
  var api_logs_1 = require_src3();
  var autoLoaderUtils_1 = require_autoLoaderUtils();
  function registerInstrumentations(options) {
    var _a2, _b2;
    const tracerProvider = options.tracerProvider || api_1.trace.getTracerProvider();
    const meterProvider = options.meterProvider || api_1.metrics.getMeterProvider();
    const loggerProvider = options.loggerProvider || api_logs_1.logs.getLoggerProvider();
    const instrumentations = (_b2 = (_a2 = options.instrumentations) === null || _a2 === undefined ? undefined : _a2.flat()) !== null && _b2 !== undefined ? _b2 : [];
    (0, autoLoaderUtils_1.enableInstrumentations)(instrumentations, tracerProvider, meterProvider, loggerProvider);
    return () => {
      (0, autoLoaderUtils_1.disableInstrumentations)(instrumentations);
    };
  }
  exports.registerInstrumentations = registerInstrumentations;
});

// ../../node_modules/semver/internal/constants.js
var require_constants = __commonJS((exports, module) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
});

// ../../node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports, module) => {
  var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  module.exports = debug;
});

// ../../node_modules/semver/internal/re.js
var require_re = __commonJS((exports, module) => {
  var {
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_LENGTH
  } = require_constants();
  var debug = require_debug();
  exports = module.exports = {};
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src2 = exports.src = [];
  var t4 = exports.t = {};
  var R4 = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  var makeSafeRegex = (value) => {
    for (const [token, max] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
  };
  var createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R4++;
    debug(name, index, value);
    t4[name] = index;
    src2[index] = value;
    re[index] = new RegExp(value, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src2[t4.NUMERICIDENTIFIER]})\\.` + `(${src2[t4.NUMERICIDENTIFIER]})\\.` + `(${src2[t4.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src2[t4.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src2[t4.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src2[t4.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src2[t4.NUMERICIDENTIFIER]}|${src2[t4.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src2[t4.NUMERICIDENTIFIERLOOSE]}|${src2[t4.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src2[t4.PRERELEASEIDENTIFIER]}(?:\\.${src2[t4.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src2[t4.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src2[t4.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src2[t4.BUILDIDENTIFIER]}(?:\\.${src2[t4.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src2[t4.MAINVERSION]}${src2[t4.PRERELEASE]}?${src2[t4.BUILD]}?`);
  createToken("FULL", `^${src2[t4.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src2[t4.MAINVERSIONLOOSE]}${src2[t4.PRERELEASELOOSE]}?${src2[t4.BUILD]}?`);
  createToken("LOOSE", `^${src2[t4.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src2[t4.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src2[t4.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src2[t4.XRANGEIDENTIFIER]})` + `(?:\\.(${src2[t4.XRANGEIDENTIFIER]})` + `(?:\\.(${src2[t4.XRANGEIDENTIFIER]})` + `(?:${src2[t4.PRERELEASE]})?${src2[t4.BUILD]}?` + `)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src2[t4.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src2[t4.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src2[t4.XRANGEIDENTIFIERLOOSE]})` + `(?:${src2[t4.PRERELEASELOOSE]})?${src2[t4.BUILD]}?` + `)?)?`);
  createToken("XRANGE", `^${src2[t4.GTLT]}\\s*${src2[t4.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src2[t4.GTLT]}\\s*${src2[t4.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])" + "(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
  createToken("COERCE", `${src2[t4.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src2[t4.COERCEPLAIN] + `(?:${src2[t4.PRERELEASE]})?` + `(?:${src2[t4.BUILD]})?` + `(?:$|[^\\d])`);
  createToken("COERCERTL", src2[t4.COERCE], true);
  createToken("COERCERTLFULL", src2[t4.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src2[t4.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src2[t4.LONETILDE]}${src2[t4.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src2[t4.LONETILDE]}${src2[t4.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src2[t4.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src2[t4.LONECARET]}${src2[t4.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src2[t4.LONECARET]}${src2[t4.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src2[t4.GTLT]}\\s*(${src2[t4.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src2[t4.GTLT]}\\s*(${src2[t4.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src2[t4.GTLT]}\\s*(${src2[t4.LOOSEPLAIN]}|${src2[t4.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src2[t4.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src2[t4.XRANGEPLAIN]})` + `\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src2[t4.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src2[t4.XRANGEPLAINLOOSE]})` + `\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});

// ../../node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports, module) => {
  var looseOption = Object.freeze({ loose: true });
  var emptyOpts = Object.freeze({});
  var parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  module.exports = parseOptions;
});

// ../../node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports, module) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a5, b3) => {
    const anum = numeric.test(a5);
    const bnum = numeric.test(b3);
    if (anum && bnum) {
      a5 = +a5;
      b3 = +b3;
    }
    return a5 === b3 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a5 < b3 ? -1 : 1;
  };
  var rcompareIdentifiers = (a5, b3) => compareIdentifiers(b3, a5);
  module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// ../../node_modules/semver/classes/semver.js
var require_semver2 = __commonJS((exports, module) => {
  var debug = require_debug();
  var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
  var { safeRe: re, t: t4 } = require_re();
  var parseOptions = require_parse_options();
  var { compareIdentifiers } = require_identifiers();

  class SemVer {
    constructor(version2, options) {
      options = parseOptions(options);
      if (version2 instanceof SemVer) {
        if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
          return version2;
        } else {
          version2 = version2.version;
        }
      } else if (typeof version2 !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
      }
      if (version2.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version2, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m4 = version2.trim().match(options.loose ? re[t4.LOOSE] : re[t4.FULL]);
      if (!m4) {
        throw new TypeError(`Invalid Version: ${version2}`);
      }
      this.raw = version2;
      this.major = +m4[1];
      this.minor = +m4[2];
      this.patch = +m4[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m4[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m4[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m4[5] ? m4[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i4 = 0;
      do {
        const a5 = this.prerelease[i4];
        const b3 = other.prerelease[i4];
        debug("prerelease compare", i4, a5, b3);
        if (a5 === undefined && b3 === undefined) {
          return 0;
        } else if (b3 === undefined) {
          return 1;
        } else if (a5 === undefined) {
          return -1;
        } else if (a5 === b3) {
          continue;
        } else {
          return compareIdentifiers(a5, b3);
        }
      } while (++i4);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i4 = 0;
      do {
        const a5 = this.build[i4];
        const b3 = other.build[i4];
        debug("build compare", i4, a5, b3);
        if (a5 === undefined && b3 === undefined) {
          return 0;
        } else if (b3 === undefined) {
          return 1;
        } else if (a5 === undefined) {
          return -1;
        } else if (a5 === b3) {
          continue;
        } else {
          return compareIdentifiers(a5, b3);
        }
      } while (++i4);
    }
    inc(release2, identifier, identifierBase) {
      switch (release2) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i4 = this.prerelease.length;
            while (--i4 >= 0) {
              if (typeof this.prerelease[i4] === "number") {
                this.prerelease[i4]++;
                i4 = -2;
              }
            }
            if (i4 === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release2}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  module.exports = SemVer;
});

// ../../node_modules/semver/functions/parse.js
var require_parse2 = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var parse6 = (version2, options, throwErrors = false) => {
    if (version2 instanceof SemVer) {
      return version2;
    }
    try {
      return new SemVer(version2, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  module.exports = parse6;
});

// ../../node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports, module) => {
  var parse6 = require_parse2();
  var valid = (version2, options) => {
    const v7 = parse6(version2, options);
    return v7 ? v7.version : null;
  };
  module.exports = valid;
});

// ../../node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports, module) => {
  var parse6 = require_parse2();
  var clean = (version2, options) => {
    const s5 = parse6(version2.trim().replace(/^[=v]+/, ""), options);
    return s5 ? s5.version : null;
  };
  module.exports = clean;
});

// ../../node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var inc = (version2, release2, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = undefined;
    }
    try {
      return new SemVer(version2 instanceof SemVer ? version2.version : version2, options).inc(release2, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  module.exports = inc;
});

// ../../node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports, module) => {
  var parse6 = require_parse2();
  var diff = (version1, version2) => {
    const v12 = parse6(version1, null, true);
    const v22 = parse6(version2, null, true);
    const comparison = v12.compare(v22);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v12 : v22;
    const lowVersion = v1Higher ? v22 : v12;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (highVersion.patch) {
        return "patch";
      }
      if (highVersion.minor) {
        return "minor";
      }
      return "major";
    }
    const prefix = highHasPre ? "pre" : "";
    if (v12.major !== v22.major) {
      return prefix + "major";
    }
    if (v12.minor !== v22.minor) {
      return prefix + "minor";
    }
    if (v12.patch !== v22.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  module.exports = diff;
});

// ../../node_modules/semver/functions/major.js
var require_major = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var major = (a5, loose) => new SemVer(a5, loose).major;
  module.exports = major;
});

// ../../node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var minor = (a5, loose) => new SemVer(a5, loose).minor;
  module.exports = minor;
});

// ../../node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var patch = (a5, loose) => new SemVer(a5, loose).patch;
  module.exports = patch;
});

// ../../node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports, module) => {
  var parse6 = require_parse2();
  var prerelease = (version2, options) => {
    const parsed = parse6(version2, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module.exports = prerelease;
});

// ../../node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var compare = (a5, b3, loose) => new SemVer(a5, loose).compare(new SemVer(b3, loose));
  module.exports = compare;
});

// ../../node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports, module) => {
  var compare = require_compare();
  var rcompare = (a5, b3, loose) => compare(b3, a5, loose);
  module.exports = rcompare;
});

// ../../node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports, module) => {
  var compare = require_compare();
  var compareLoose = (a5, b3) => compare(a5, b3, true);
  module.exports = compareLoose;
});

// ../../node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var compareBuild = (a5, b3, loose) => {
    const versionA = new SemVer(a5, loose);
    const versionB = new SemVer(b3, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module.exports = compareBuild;
});

// ../../node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var sort = (list, loose) => list.sort((a5, b3) => compareBuild(a5, b3, loose));
  module.exports = sort;
});

// ../../node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var rsort = (list, loose) => list.sort((a5, b3) => compareBuild(b3, a5, loose));
  module.exports = rsort;
});

// ../../node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports, module) => {
  var compare = require_compare();
  var gt = (a5, b3, loose) => compare(a5, b3, loose) > 0;
  module.exports = gt;
});

// ../../node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports, module) => {
  var compare = require_compare();
  var lt = (a5, b3, loose) => compare(a5, b3, loose) < 0;
  module.exports = lt;
});

// ../../node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports, module) => {
  var compare = require_compare();
  var eq = (a5, b3, loose) => compare(a5, b3, loose) === 0;
  module.exports = eq;
});

// ../../node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports, module) => {
  var compare = require_compare();
  var neq = (a5, b3, loose) => compare(a5, b3, loose) !== 0;
  module.exports = neq;
});

// ../../node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports, module) => {
  var compare = require_compare();
  var gte = (a5, b3, loose) => compare(a5, b3, loose) >= 0;
  module.exports = gte;
});

// ../../node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports, module) => {
  var compare = require_compare();
  var lte = (a5, b3, loose) => compare(a5, b3, loose) <= 0;
  module.exports = lte;
});

// ../../node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports, module) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a5, op, b3, loose) => {
    switch (op) {
      case "===":
        if (typeof a5 === "object") {
          a5 = a5.version;
        }
        if (typeof b3 === "object") {
          b3 = b3.version;
        }
        return a5 === b3;
      case "!==":
        if (typeof a5 === "object") {
          a5 = a5.version;
        }
        if (typeof b3 === "object") {
          b3 = b3.version;
        }
        return a5 !== b3;
      case "":
      case "=":
      case "==":
        return eq(a5, b3, loose);
      case "!=":
        return neq(a5, b3, loose);
      case ">":
        return gt(a5, b3, loose);
      case ">=":
        return gte(a5, b3, loose);
      case "<":
        return lt(a5, b3, loose);
      case "<=":
        return lte(a5, b3, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module.exports = cmp;
});

// ../../node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var parse6 = require_parse2();
  var { safeRe: re, t: t4 } = require_re();
  var coerce = (version2, options) => {
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 === "number") {
      version2 = String(version2);
    }
    if (typeof version2 !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version2.match(options.includePrerelease ? re[t4.COERCEFULL] : re[t4.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re[t4.COERCERTLFULL] : re[t4.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse6(`${major}.${minor}.${patch}${prerelease}${build}`, options);
  };
  module.exports = coerce;
});

// ../../node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS((exports, module) => {
  class LRUCache {
    constructor() {
      this.max = 1000;
      this.map = new Map;
    }
    get(key) {
      const value = this.map.get(key);
      if (value === undefined) {
        return;
      } else {
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value) {
      const deleted = this.delete(key);
      if (!deleted && value !== undefined) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value);
      }
      return this;
    }
  }
  module.exports = LRUCache;
});

// ../../node_modules/semver/classes/range.js
var require_range = __commonJS((exports, module) => {
  var SPACE_CHARACTERS = /\s+/g;

  class Range {
    constructor(range, options) {
      options = parseOptions(options);
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.formatted = undefined;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r5) => this.parseRange(r5.trim())).filter((c5) => c5.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c5) => !isNullSet(c5[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c5 of this.set) {
            if (c5.length === 1 && isAny(c5[0])) {
              this.set = [c5];
              break;
            }
          }
        }
      }
      this.formatted = undefined;
    }
    get range() {
      if (this.formatted === undefined) {
        this.formatted = "";
        for (let i4 = 0;i4 < this.set.length; i4++) {
          if (i4 > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i4];
          for (let k4 = 0;k4 < comps.length; k4++) {
            if (k4 > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k4].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range;
      const cached = cache3.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re[t4.HYPHENRANGELOOSE] : re[t4.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range);
      range = range.replace(re[t4.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range);
      range = range.replace(re[t4.TILDETRIM], tildeTrimReplace);
      debug("tilde trim", range);
      range = range.replace(re[t4.CARETTRIM], caretTrimReplace);
      debug("caret trim", range);
      let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug("loose invalid filter", comp, this.options);
          return !!comp.match(re[t4.COMPARATORLOOSE]);
        });
      }
      debug("range list", rangeList);
      const rangeMap = new Map;
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache3.set(memoKey, result);
      return result;
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i4 = 0;i4 < this.set.length; i4++) {
        if (testSet(this.set[i4], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  module.exports = Range;
  var LRU = require_lrucache();
  var cache3 = new LRU;
  var parseOptions = require_parse_options();
  var Comparator = require_comparator();
  var debug = require_debug();
  var SemVer = require_semver2();
  var {
    safeRe: re,
    t: t4,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
  var isNullSet = (c5) => c5.value === "<0.0.0-0";
  var isAny = (c5) => c5.value === "";
  var isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c5) => replaceTilde(c5, options)).join(" ");
  };
  var replaceTilde = (comp, options) => {
    const r5 = options.loose ? re[t4.TILDELOOSE] : re[t4.TILDE];
    return comp.replace(r5, (_3, M3, m4, p5, pr) => {
      debug("tilde", comp, _3, M3, m4, p5, pr);
      let ret;
      if (isX(M3)) {
        ret = "";
      } else if (isX(m4)) {
        ret = `>=${M3}.0.0 <${+M3 + 1}.0.0-0`;
      } else if (isX(p5)) {
        ret = `>=${M3}.${m4}.0 <${M3}.${+m4 + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M3}.${m4}.${p5}-${pr} <${M3}.${+m4 + 1}.0-0`;
      } else {
        ret = `>=${M3}.${m4}.${p5} <${M3}.${+m4 + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c5) => replaceCaret(c5, options)).join(" ");
  };
  var replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r5 = options.loose ? re[t4.CARETLOOSE] : re[t4.CARET];
    const z3 = options.includePrerelease ? "-0" : "";
    return comp.replace(r5, (_3, M3, m4, p5, pr) => {
      debug("caret", comp, _3, M3, m4, p5, pr);
      let ret;
      if (isX(M3)) {
        ret = "";
      } else if (isX(m4)) {
        ret = `>=${M3}.0.0${z3} <${+M3 + 1}.0.0-0`;
      } else if (isX(p5)) {
        if (M3 === "0") {
          ret = `>=${M3}.${m4}.0${z3} <${M3}.${+m4 + 1}.0-0`;
        } else {
          ret = `>=${M3}.${m4}.0${z3} <${+M3 + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M3 === "0") {
          if (m4 === "0") {
            ret = `>=${M3}.${m4}.${p5}-${pr} <${M3}.${m4}.${+p5 + 1}-0`;
          } else {
            ret = `>=${M3}.${m4}.${p5}-${pr} <${M3}.${+m4 + 1}.0-0`;
          }
        } else {
          ret = `>=${M3}.${m4}.${p5}-${pr} <${+M3 + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M3 === "0") {
          if (m4 === "0") {
            ret = `>=${M3}.${m4}.${p5}${z3} <${M3}.${m4}.${+p5 + 1}-0`;
          } else {
            ret = `>=${M3}.${m4}.${p5}${z3} <${M3}.${+m4 + 1}.0-0`;
          }
        } else {
          ret = `>=${M3}.${m4}.${p5} <${+M3 + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c5) => replaceXRange(c5, options)).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r5 = options.loose ? re[t4.XRANGELOOSE] : re[t4.XRANGE];
    return comp.replace(r5, (ret, gtlt, M3, m4, p5, pr) => {
      debug("xRange", comp, ret, gtlt, M3, m4, p5, pr);
      const xM = isX(M3);
      const xm = xM || isX(m4);
      const xp = xm || isX(p5);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m4 = 0;
        }
        p5 = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M3 = +M3 + 1;
            m4 = 0;
            p5 = 0;
          } else {
            m4 = +m4 + 1;
            p5 = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M3 = +M3 + 1;
          } else {
            m4 = +m4 + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M3}.${m4}.${p5}${pr}`;
      } else if (xm) {
        ret = `>=${M3}.0.0${pr} <${+M3 + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M3}.${m4}.0${pr} <${M3}.${+m4 + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[t4.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t4.GTE0PRE : t4.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set, version2, options) => {
    for (let i4 = 0;i4 < set.length; i4++) {
      if (!set[i4].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i4 = 0;i4 < set.length; i4++) {
        debug(set[i4].semver);
        if (set[i4].semver === Comparator.ANY) {
          continue;
        }
        if (set[i4].semver.prerelease.length > 0) {
          const allowed = set[i4].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// ../../node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports, module) => {
  var ANY = Symbol("SemVer ANY");

  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r5 = this.options.loose ? re[t4.COMPARATORLOOSE] : re[t4.COMPARATOR];
      const m4 = comp.match(r5);
      if (!m4) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m4[1] !== undefined ? m4[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m4[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m4[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY || version2 === ANY) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  module.exports = Comparator;
  var parseOptions = require_parse_options();
  var { safeRe: re, t: t4 } = require_re();
  var cmp = require_cmp();
  var debug = require_debug();
  var SemVer = require_semver2();
  var Range = require_range();
});

// ../../node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports, module) => {
  var Range = require_range();
  var satisfies = (version2, range, options) => {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version2);
  };
  module.exports = satisfies;
});

// ../../node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports, module) => {
  var Range = require_range();
  var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c5) => c5.value).join(" ").trim().split(" "));
  module.exports = toComparators;
});

// ../../node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var Range = require_range();
  var maxSatisfying = (versions2, range, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions2.forEach((v7) => {
      if (rangeObj.test(v7)) {
        if (!max || maxSV.compare(v7) === -1) {
          max = v7;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  module.exports = maxSatisfying;
});

// ../../node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var Range = require_range();
  var minSatisfying = (versions2, range, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions2.forEach((v7) => {
      if (rangeObj.test(v7)) {
        if (!min || minSV.compare(v7) === 1) {
          min = v7;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  module.exports = minSatisfying;
});

// ../../node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var Range = require_range();
  var gt = require_gt();
  var minVersion = (range, loose) => {
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i4 = 0;i4 < range.set.length; ++i4) {
      const comparators = range.set[i4];
      let setMin = null;
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  module.exports = minVersion;
});

// ../../node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports, module) => {
  var Range = require_range();
  var validRange = (range, options) => {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  module.exports = validRange;
});

// ../../node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports, module) => {
  var SemVer = require_semver2();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var Range = require_range();
  var satisfies = require_satisfies();
  var gt = require_gt();
  var lt = require_lt();
  var lte = require_lte();
  var gte = require_gte();
  var outside = (version2, range, hilo, options) => {
    version2 = new SemVer(version2, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version2, range, options)) {
      return false;
    }
    for (let i4 = 0;i4 < range.set.length; ++i4) {
      const comparators = range.set[i4];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module.exports = outside;
});

// ../../node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports, module) => {
  var outside = require_outside();
  var gtr = (version2, range, options) => outside(version2, range, ">", options);
  module.exports = gtr;
});

// ../../node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports, module) => {
  var outside = require_outside();
  var ltr = (version2, range, options) => outside(version2, range, "<", options);
  module.exports = ltr;
});

// ../../node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports, module) => {
  var Range = require_range();
  var intersects = (r1, r22, options) => {
    r1 = new Range(r1, options);
    r22 = new Range(r22, options);
    return r1.intersects(r22, options);
  };
  module.exports = intersects;
});

// ../../node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports, module) => {
  var satisfies = require_satisfies();
  var compare = require_compare();
  module.exports = (versions2, range, options) => {
    const set = [];
    let first = null;
    let prev = null;
    const v7 = versions2.sort((a5, b3) => compare(a5, b3, options));
    for (const version2 of v7) {
      const included = satisfies(version2, range, options);
      if (included) {
        prev = version2;
        if (!first) {
          first = version2;
        }
      } else {
        if (prev) {
          set.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set.push([first, null]);
    }
    const ranges = [];
    for (const [min, max] of set) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v7[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v7[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});

// ../../node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports, module) => {
  var Range = require_range();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var satisfies = require_satisfies();
  var compare = require_compare();
  var subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
    return true;
  };
  var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  var minimumVersion = [new Comparator(">=0.0.0")];
  var simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = new Set;
    let gt, lt;
    for (const c5 of sub) {
      if (c5.operator === ">" || c5.operator === ">=") {
        gt = higherGT(gt, c5, options);
      } else if (c5.operator === "<" || c5.operator === "<=") {
        lt = lowerLT(lt, c5, options);
      } else {
        eqSet.add(c5.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options)) {
        return null;
      }
      if (lt && !satisfies(eq, String(lt), options)) {
        return null;
      }
      for (const c5 of dom) {
        if (!satisfies(eq, String(c5), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c5 of dom) {
      hasDomGT = hasDomGT || c5.operator === ">" || c5.operator === ">=";
      hasDomLT = hasDomLT || c5.operator === "<" || c5.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c5.semver.prerelease && c5.semver.prerelease.length && c5.semver.major === needDomGTPre.major && c5.semver.minor === needDomGTPre.minor && c5.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c5.operator === ">" || c5.operator === ">=") {
          higher = higherGT(gt, c5, options);
          if (higher === c5 && higher !== gt) {
            return false;
          }
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c5), options)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (c5.semver.prerelease && c5.semver.prerelease.length && c5.semver.major === needDomLTPre.major && c5.semver.minor === needDomLTPre.minor && c5.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c5.operator === "<" || c5.operator === "<=") {
          lower = lowerLT(lt, c5, options);
          if (lower === c5 && lower !== lt) {
            return false;
          }
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c5), options)) {
          return false;
        }
      }
      if (!c5.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  var higherGT = (a5, b3, options) => {
    if (!a5) {
      return b3;
    }
    const comp = compare(a5.semver, b3.semver, options);
    return comp > 0 ? a5 : comp < 0 ? b3 : b3.operator === ">" && a5.operator === ">=" ? b3 : a5;
  };
  var lowerLT = (a5, b3, options) => {
    if (!a5) {
      return b3;
    }
    const comp = compare(a5.semver, b3.semver, options);
    return comp < 0 ? a5 : comp > 0 ? b3 : b3.operator === "<" && a5.operator === "<=" ? b3 : a5;
  };
  module.exports = subset;
});

// ../../node_modules/semver/index.js
var require_semver3 = __commonJS((exports, module) => {
  var internalRe = require_re();
  var constants6 = require_constants();
  var SemVer = require_semver2();
  var identifiers = require_identifiers();
  var parse6 = require_parse2();
  var valid = require_valid();
  var clean = require_clean();
  var inc = require_inc();
  var diff = require_diff();
  var major = require_major();
  var minor = require_minor();
  var patch = require_patch();
  var prerelease = require_prerelease();
  var compare = require_compare();
  var rcompare = require_rcompare();
  var compareLoose = require_compare_loose();
  var compareBuild = require_compare_build();
  var sort = require_sort();
  var rsort = require_rsort();
  var gt = require_gt();
  var lt = require_lt();
  var eq = require_eq();
  var neq = require_neq();
  var gte = require_gte();
  var lte = require_lte();
  var cmp = require_cmp();
  var coerce = require_coerce();
  var Comparator = require_comparator();
  var Range = require_range();
  var satisfies = require_satisfies();
  var toComparators = require_to_comparators();
  var maxSatisfying = require_max_satisfying();
  var minSatisfying = require_min_satisfying();
  var minVersion = require_min_version();
  var validRange = require_valid2();
  var outside = require_outside();
  var gtr = require_gtr();
  var ltr = require_ltr();
  var intersects = require_intersects();
  var simplifyRange = require_simplify();
  var subset = require_subset();
  module.exports = {
    parse: parse6,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants6.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants6.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
  };
});

// ../../node_modules/shimmer/index.js
var require_shimmer = __commonJS((exports, module) => {
  function isFunction2(funktion) {
    return typeof funktion === "function";
  }
  var logger2 = console.error.bind(console);
  function defineProperty(obj, name, value) {
    var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
    Object.defineProperty(obj, name, {
      configurable: true,
      enumerable,
      writable: true,
      value
    });
  }
  function shimmer(options) {
    if (options && options.logger) {
      if (!isFunction2(options.logger))
        logger2("new logger isn't a function, not replacing");
      else
        logger2 = options.logger;
    }
  }
  function wrap(nodule, name, wrapper) {
    if (!nodule || !nodule[name]) {
      logger2("no original function " + name + " to wrap");
      return;
    }
    if (!wrapper) {
      logger2("no wrapper function");
      logger2(new Error().stack);
      return;
    }
    if (!isFunction2(nodule[name]) || !isFunction2(wrapper)) {
      logger2("original object and wrapper must be functions");
      return;
    }
    var original = nodule[name];
    var wrapped = wrapper(original, name);
    defineProperty(wrapped, "__original", original);
    defineProperty(wrapped, "__unwrap", function() {
      if (nodule[name] === wrapped)
        defineProperty(nodule, name, original);
    });
    defineProperty(wrapped, "__wrapped", true);
    defineProperty(nodule, name, wrapped);
    return wrapped;
  }
  function massWrap(nodules, names, wrapper) {
    if (!nodules) {
      logger2("must provide one or more modules to patch");
      logger2(new Error().stack);
      return;
    } else if (!Array.isArray(nodules)) {
      nodules = [nodules];
    }
    if (!(names && Array.isArray(names))) {
      logger2("must provide one or more functions to wrap on modules");
      return;
    }
    nodules.forEach(function(nodule) {
      names.forEach(function(name) {
        wrap(nodule, name, wrapper);
      });
    });
  }
  function unwrap(nodule, name) {
    if (!nodule || !nodule[name]) {
      logger2("no function to unwrap.");
      logger2(new Error().stack);
      return;
    }
    if (!nodule[name].__unwrap) {
      logger2("no original to unwrap to -- has " + name + " already been unwrapped?");
    } else {
      return nodule[name].__unwrap();
    }
  }
  function massUnwrap(nodules, names) {
    if (!nodules) {
      logger2("must provide one or more modules to patch");
      logger2(new Error().stack);
      return;
    } else if (!Array.isArray(nodules)) {
      nodules = [nodules];
    }
    if (!(names && Array.isArray(names))) {
      logger2("must provide one or more functions to unwrap on modules");
      return;
    }
    nodules.forEach(function(nodule) {
      names.forEach(function(name) {
        unwrap(nodule, name);
      });
    });
  }
  shimmer.wrap = wrap;
  shimmer.massWrap = massWrap;
  shimmer.unwrap = unwrap;
  shimmer.massUnwrap = massUnwrap;
  module.exports = shimmer;
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/instrumentation.js
var require_instrumentation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationAbstract = undefined;
  var api_1 = require_src();
  var api_logs_1 = require_src3();
  var shimmer = require_shimmer();

  class InstrumentationAbstract {
    constructor(instrumentationName, instrumentationVersion, config5) {
      this.instrumentationName = instrumentationName;
      this.instrumentationVersion = instrumentationVersion;
      this._config = {};
      this._wrap = shimmer.wrap;
      this._unwrap = shimmer.unwrap;
      this._massWrap = shimmer.massWrap;
      this._massUnwrap = shimmer.massUnwrap;
      this.setConfig(config5);
      this._diag = api_1.diag.createComponentLogger({
        namespace: instrumentationName
      });
      this._tracer = api_1.trace.getTracer(instrumentationName, instrumentationVersion);
      this._meter = api_1.metrics.getMeter(instrumentationName, instrumentationVersion);
      this._logger = api_logs_1.logs.getLogger(instrumentationName, instrumentationVersion);
      this._updateMetricInstruments();
    }
    get meter() {
      return this._meter;
    }
    setMeterProvider(meterProvider) {
      this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
      this._updateMetricInstruments();
    }
    get logger() {
      return this._logger;
    }
    setLoggerProvider(loggerProvider) {
      this._logger = loggerProvider.getLogger(this.instrumentationName, this.instrumentationVersion);
    }
    getModuleDefinitions() {
      var _a2;
      const initResult = (_a2 = this.init()) !== null && _a2 !== undefined ? _a2 : [];
      if (!Array.isArray(initResult)) {
        return [initResult];
      }
      return initResult;
    }
    _updateMetricInstruments() {
      return;
    }
    getConfig() {
      return this._config;
    }
    setConfig(config5) {
      this._config = Object.assign({ enabled: true }, config5);
    }
    setTracerProvider(tracerProvider) {
      this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
    }
    get tracer() {
      return this._tracer;
    }
    _runSpanCustomizationHook(hookHandler, triggerName, span, info) {
      if (!hookHandler) {
        return;
      }
      try {
        hookHandler(span, info);
      } catch (e4) {
        this._diag.error(`Error running span customization hook due to exception in handler`, { triggerName }, e4);
      }
    }
  }
  exports.InstrumentationAbstract = InstrumentationAbstract;
});

// ../../node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS((exports, module) => {
  var os = __require("os");
  module.exports = os.homedir || function homedir() {
    var home = process.env.HOME;
    var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
    if (process.platform === "win32") {
      return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
    }
    if (process.platform === "darwin") {
      return home || (user ? "/Users/" + user : null);
    }
    if (process.platform === "linux") {
      return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
    }
    return home || null;
  };
});

// ../../node_modules/resolve/lib/caller.js
var require_caller = __commonJS((exports, module) => {
  module.exports = function() {
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function(_3, stack2) {
      return stack2;
    };
    var stack = new Error().stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
  };
});

// ../../node_modules/path-parse/index.js
var require_path_parse = __commonJS((exports, module) => {
  var isWindows2 = process.platform === "win32";
  var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
  var win32 = {};
  function win32SplitPath(filename) {
    return splitWindowsRe.exec(filename).slice(1);
  }
  win32.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = win32SplitPath(pathString);
    if (!allParts || allParts.length !== 5) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    return {
      root: allParts[1],
      dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
      base: allParts[2],
      ext: allParts[4],
      name: allParts[3]
    };
  };
  var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
  var posix = {};
  function posixSplitPath(filename) {
    return splitPathRe.exec(filename).slice(1);
  }
  posix.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = posixSplitPath(pathString);
    if (!allParts || allParts.length !== 5) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    return {
      root: allParts[1],
      dir: allParts[0].slice(0, -1),
      base: allParts[2],
      ext: allParts[4],
      name: allParts[3]
    };
  };
  if (isWindows2)
    module.exports = win32.parse;
  else
    module.exports = posix.parse;
  module.exports.posix = posix.parse;
  module.exports.win32 = win32.parse;
});

// ../../node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS((exports, module) => {
  var path = __require("path");
  var parse6 = path.parse || require_path_parse();
  var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
    var prefix = "/";
    if (/^([A-Za-z]:)/.test(absoluteStart)) {
      prefix = "";
    } else if (/^\\\\/.test(absoluteStart)) {
      prefix = "\\\\";
    }
    var paths = [absoluteStart];
    var parsed = parse6(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
      paths.push(parsed.dir);
      parsed = parse6(parsed.dir);
    }
    return paths.reduce(function(dirs, aPath) {
      return dirs.concat(modules.map(function(moduleDir) {
        return path.resolve(prefix, aPath, moduleDir);
      }));
    }, []);
  };
  module.exports = function nodeModulesPaths(start, opts, request2) {
    var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
    if (opts && typeof opts.paths === "function") {
      return opts.paths(request2, start, function() {
        return getNodeModulesDirs(start, modules);
      }, opts);
    }
    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
  };
});

// ../../node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS((exports, module) => {
  module.exports = function(x4, opts) {
    return opts || {};
  };
});

// ../../node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports, module) => {
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty(a5, b3) {
    var arr = [];
    for (var i4 = 0;i4 < a5.length; i4 += 1) {
      arr[i4] = a5[i4];
    }
    for (var j4 = 0;j4 < b3.length; j4 += 1) {
      arr[j4 + a5.length] = b3[j4];
    }
    return arr;
  };
  var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i4 = offset || 0, j4 = 0;i4 < arrLike.length; i4 += 1, j4 += 1) {
      arr[j4] = arrLike[i4];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i4 = 0;i4 < arr.length; i4 += 1) {
      str += arr[i4];
      if (i4 + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  module.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, concatty(args, arguments));
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i4 = 0;i4 < boundLength; i4++) {
      boundArgs[i4] = "$" + i4;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty;
      Empty.prototype = null;
    }
    return bound;
  };
});

// ../../node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports, module) => {
  var implementation = require_implementation();
  module.exports = Function.prototype.bind || implementation;
});

// ../../node_modules/hasown/index.js
var require_hasown = __commonJS((exports, module) => {
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = require_function_bind();
  module.exports = bind.call(call, $hasOwn);
});

// ../../node_modules/is-core-module/core.json
var require_core = __commonJS((exports, module) => {
  module.exports = {
    assert: true,
    "node:assert": [">= 14.18 && < 15", ">= 16"],
    "assert/strict": ">= 15",
    "node:assert/strict": ">= 16",
    async_hooks: ">= 8",
    "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
    buffer_ieee754: ">= 0.5 && < 0.9.7",
    buffer: true,
    "node:buffer": [">= 14.18 && < 15", ">= 16"],
    child_process: true,
    "node:child_process": [">= 14.18 && < 15", ">= 16"],
    cluster: ">= 0.5",
    "node:cluster": [">= 14.18 && < 15", ">= 16"],
    console: true,
    "node:console": [">= 14.18 && < 15", ">= 16"],
    constants: true,
    "node:constants": [">= 14.18 && < 15", ">= 16"],
    crypto: true,
    "node:crypto": [">= 14.18 && < 15", ">= 16"],
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    "node:dgram": [">= 14.18 && < 15", ">= 16"],
    diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
    "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
    dns: true,
    "node:dns": [">= 14.18 && < 15", ">= 16"],
    "dns/promises": ">= 15",
    "node:dns/promises": ">= 16",
    domain: ">= 0.7.12",
    "node:domain": [">= 14.18 && < 15", ">= 16"],
    events: true,
    "node:events": [">= 14.18 && < 15", ">= 16"],
    freelist: "< 6",
    fs: true,
    "node:fs": [">= 14.18 && < 15", ">= 16"],
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
    _http_agent: ">= 0.11.1",
    "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
    _http_client: ">= 0.11.1",
    "node:_http_client": [">= 14.18 && < 15", ">= 16"],
    _http_common: ">= 0.11.1",
    "node:_http_common": [">= 14.18 && < 15", ">= 16"],
    _http_incoming: ">= 0.11.1",
    "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
    _http_outgoing: ">= 0.11.1",
    "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
    _http_server: ">= 0.11.1",
    "node:_http_server": [">= 14.18 && < 15", ">= 16"],
    http: true,
    "node:http": [">= 14.18 && < 15", ">= 16"],
    http2: ">= 8.8",
    "node:http2": [">= 14.18 && < 15", ">= 16"],
    https: true,
    "node:https": [">= 14.18 && < 15", ">= 16"],
    inspector: ">= 8",
    "node:inspector": [">= 14.18 && < 15", ">= 16"],
    "inspector/promises": [">= 19"],
    "node:inspector/promises": [">= 19"],
    _linklist: "< 8",
    module: true,
    "node:module": [">= 14.18 && < 15", ">= 16"],
    net: true,
    "node:net": [">= 14.18 && < 15", ">= 16"],
    "node-inspect/lib/_inspect": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
    os: true,
    "node:os": [">= 14.18 && < 15", ">= 16"],
    path: true,
    "node:path": [">= 14.18 && < 15", ">= 16"],
    "path/posix": ">= 15.3",
    "node:path/posix": ">= 16",
    "path/win32": ">= 15.3",
    "node:path/win32": ">= 16",
    perf_hooks: ">= 8.5",
    "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
    process: ">= 1",
    "node:process": [">= 14.18 && < 15", ">= 16"],
    punycode: ">= 0.5",
    "node:punycode": [">= 14.18 && < 15", ">= 16"],
    querystring: true,
    "node:querystring": [">= 14.18 && < 15", ">= 16"],
    readline: true,
    "node:readline": [">= 14.18 && < 15", ">= 16"],
    "readline/promises": ">= 17",
    "node:readline/promises": ">= 17",
    repl: true,
    "node:repl": [">= 14.18 && < 15", ">= 16"],
    "node:sea": [">= 20.12 && < 21", ">= 21.7"],
    smalloc: ">= 0.11.5 && < 3",
    "node:sqlite": [">= 22.13 && < 23", ">= 23.4"],
    _stream_duplex: ">= 0.9.4",
    "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
    _stream_transform: ">= 0.9.4",
    "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
    _stream_wrap: ">= 1.4.1",
    "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
    _stream_passthrough: ">= 0.9.4",
    "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
    _stream_readable: ">= 0.9.4",
    "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
    _stream_writable: ">= 0.9.4",
    "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
    stream: true,
    "node:stream": [">= 14.18 && < 15", ">= 16"],
    "stream/consumers": ">= 16.7",
    "node:stream/consumers": ">= 16.7",
    "stream/promises": ">= 15",
    "node:stream/promises": ">= 16",
    "stream/web": ">= 16.5",
    "node:stream/web": ">= 16.5",
    string_decoder: true,
    "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
    sys: [">= 0.4 && < 0.7", ">= 0.8"],
    "node:sys": [">= 14.18 && < 15", ">= 16"],
    "test/reporters": ">= 19.9 && < 20.2",
    "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
    "test/mock_loader": ">= 22.3 && < 22.7",
    "node:test/mock_loader": ">= 22.3 && < 22.7",
    "node:test": [">= 16.17 && < 17", ">= 18"],
    timers: true,
    "node:timers": [">= 14.18 && < 15", ">= 16"],
    "timers/promises": ">= 15",
    "node:timers/promises": ">= 16",
    _tls_common: ">= 0.11.13",
    "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
    tls: true,
    "node:tls": [">= 14.18 && < 15", ">= 16"],
    trace_events: ">= 10",
    "node:trace_events": [">= 14.18 && < 15", ">= 16"],
    tty: true,
    "node:tty": [">= 14.18 && < 15", ">= 16"],
    url: true,
    "node:url": [">= 14.18 && < 15", ">= 16"],
    util: true,
    "node:util": [">= 14.18 && < 15", ">= 16"],
    "util/types": ">= 15.3",
    "node:util/types": ">= 16",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    v8: ">= 1",
    "node:v8": [">= 14.18 && < 15", ">= 16"],
    vm: true,
    "node:vm": [">= 14.18 && < 15", ">= 16"],
    wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
    "node:wasi": [">= 18.17 && < 19", ">= 20"],
    worker_threads: ">= 11.7",
    "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
    zlib: ">= 0.5",
    "node:zlib": [">= 14.18 && < 15", ">= 16"]
  };
});

// ../../node_modules/is-core-module/index.js
var require_is_core_module = __commonJS((exports, module) => {
  var hasOwn = require_hasown();
  function specifierIncluded(current, specifier) {
    var nodeParts = current.split(".");
    var parts = specifier.split(" ");
    var op = parts.length > 1 ? parts[0] : "=";
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
    for (var i4 = 0;i4 < 3; ++i4) {
      var cur = parseInt(nodeParts[i4] || 0, 10);
      var ver = parseInt(versionParts[i4] || 0, 10);
      if (cur === ver) {
        continue;
      }
      if (op === "<") {
        return cur < ver;
      }
      if (op === ">=") {
        return cur >= ver;
      }
      return false;
    }
    return op === ">=";
  }
  function matchesRange(current, range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) {
      return false;
    }
    for (var i4 = 0;i4 < specifiers.length; ++i4) {
      if (!specifierIncluded(current, specifiers[i4])) {
        return false;
      }
    }
    return true;
  }
  function versionIncluded(nodeVersion, specifierValue) {
    if (typeof specifierValue === "boolean") {
      return specifierValue;
    }
    var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
    if (typeof current !== "string") {
      throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
    }
    if (specifierValue && typeof specifierValue === "object") {
      for (var i4 = 0;i4 < specifierValue.length; ++i4) {
        if (matchesRange(current, specifierValue[i4])) {
          return true;
        }
      }
      return false;
    }
    return matchesRange(current, specifierValue);
  }
  var data = require_core();
  module.exports = function isCore(x4, nodeVersion) {
    return hasOwn(data, x4) && versionIncluded(nodeVersion, data[x4]);
  };
});

// ../../node_modules/resolve/lib/async.js
var require_async = __commonJS((exports, module) => {
  var fs3 = __require("fs");
  var getHomedir = require_homedir();
  var path = __require("path");
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var normalizeOptions = require_normalize_options();
  var isCore = require_is_core_module();
  var realpathFS = process.platform !== "win32" && fs3.realpath && typeof fs3.realpath.native === "function" ? fs3.realpath.native : fs3.realpath;
  var homedir2 = getHomedir();
  var defaultPaths = function() {
    return [
      path.join(homedir2, ".node_modules"),
      path.join(homedir2, ".node_libraries")
    ];
  };
  var defaultIsFile = function isFile(file, cb2) {
    fs3.stat(file, function(err, stat2) {
      if (!err) {
        return cb2(null, stat2.isFile() || stat2.isFIFO());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb2(null, false);
      return cb2(err);
    });
  };
  var defaultIsDir = function isDirectory(dir, cb2) {
    fs3.stat(dir, function(err, stat2) {
      if (!err) {
        return cb2(null, stat2.isDirectory());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb2(null, false);
      return cb2(err);
    });
  };
  var defaultRealpath = function realpath(x4, cb2) {
    realpathFS(x4, function(realpathErr, realPath) {
      if (realpathErr && realpathErr.code !== "ENOENT")
        cb2(realpathErr);
      else
        cb2(null, realpathErr ? x4 : realPath);
    });
  };
  var maybeRealpath = function maybeRealpath(realpath, x4, opts, cb2) {
    if (opts && opts.preserveSymlinks === false) {
      realpath(x4, cb2);
    } else {
      cb2(null, x4);
    }
  };
  var defaultReadPackage = function defaultReadPackage(readFile3, pkgfile, cb2) {
    readFile3(pkgfile, function(readFileErr, body) {
      if (readFileErr)
        cb2(readFileErr);
      else {
        try {
          var pkg = JSON.parse(body);
          cb2(null, pkg);
        } catch (jsonErr) {
          cb2(null);
        }
      }
    });
  };
  var getPackageCandidates = function getPackageCandidates(x4, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x4);
    for (var i4 = 0;i4 < dirs.length; i4++) {
      dirs[i4] = path.join(dirs[i4], x4);
    }
    return dirs;
  };
  module.exports = function resolve(x4, options, callback) {
    var cb2 = callback;
    var opts = options;
    if (typeof options === "function") {
      cb2 = opts;
      opts = {};
    }
    if (typeof x4 !== "string") {
      var err = new TypeError("Path must be a string.");
      return process.nextTick(function() {
        cb2(err);
      });
    }
    opts = normalizeOptions(x4, opts);
    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile3 = opts.readFile || fs3.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var readPackage = opts.readPackage || defaultReadPackage;
    if (opts.readFile && opts.readPackage) {
      var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
      return process.nextTick(function() {
        cb2(conflictErr);
      });
    }
    var packageIterator = opts.packageIterator;
    var extensions4 = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || defaultPaths();
    var absoluteStart = path.resolve(basedir);
    maybeRealpath(realpath, absoluteStart, opts, function(err2, realStart) {
      if (err2)
        cb2(err2);
      else
        init2(realStart);
    });
    var res;
    function init2(basedir2) {
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x4)) {
        res = path.resolve(basedir2, x4);
        if (x4 === "." || x4 === ".." || x4.slice(-1) === "/")
          res += "/";
        if (/\/$/.test(x4) && res === basedir2) {
          loadAsDirectory(res, opts.package, onfile);
        } else
          loadAsFile(res, opts.package, onfile);
      } else if (includeCoreModules && isCore(x4)) {
        return cb2(null, x4);
      } else
        loadNodeModules(x4, basedir2, function(err2, n4, pkg) {
          if (err2)
            cb2(err2);
          else if (n4) {
            return maybeRealpath(realpath, n4, opts, function(err3, realN) {
              if (err3) {
                cb2(err3);
              } else {
                cb2(null, realN, pkg);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x4 + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb2(moduleError);
          }
        });
    }
    function onfile(err2, m4, pkg) {
      if (err2)
        cb2(err2);
      else if (m4)
        cb2(null, m4, pkg);
      else
        loadAsDirectory(res, function(err3, d4, pkg2) {
          if (err3)
            cb2(err3);
          else if (d4) {
            maybeRealpath(realpath, d4, opts, function(err4, realD) {
              if (err4) {
                cb2(err4);
              } else {
                cb2(null, realD, pkg2);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x4 + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb2(moduleError);
          }
        });
    }
    function loadAsFile(x5, thePackage, callback2) {
      var loadAsFilePackage = thePackage;
      var cb3 = callback2;
      if (typeof loadAsFilePackage === "function") {
        cb3 = loadAsFilePackage;
        loadAsFilePackage = undefined;
      }
      var exts = [""].concat(extensions4);
      load(exts, x5, loadAsFilePackage);
      function load(exts2, x6, loadPackage) {
        if (exts2.length === 0)
          return cb3(null, undefined, loadPackage);
        var file = x6 + exts2[0];
        var pkg = loadPackage;
        if (pkg)
          onpkg(null, pkg);
        else
          loadpkg(path.dirname(file), onpkg);
        function onpkg(err2, pkg_, dir) {
          pkg = pkg_;
          if (err2)
            return cb3(err2);
          if (dir && pkg && opts.pathFilter) {
            var rfile = path.relative(dir, file);
            var rel = rfile.slice(0, rfile.length - exts2[0].length);
            var r5 = opts.pathFilter(pkg, x6, rel);
            if (r5)
              return load([""].concat(extensions4.slice()), path.resolve(dir, r5), pkg);
          }
          isFile(file, onex);
        }
        function onex(err2, ex) {
          if (err2)
            return cb3(err2);
          if (ex)
            return cb3(null, file, pkg);
          load(exts2.slice(1), x6, pkg);
        }
      }
    }
    function loadpkg(dir, cb3) {
      if (dir === "" || dir === "/")
        return cb3(null);
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return cb3(null);
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return cb3(null);
      maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return loadpkg(path.dirname(dir), cb3);
        var pkgfile = path.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (!ex)
            return loadpkg(path.dirname(dir), cb3);
          readPackage(readFile3, pkgfile, function(err3, pkgParam) {
            if (err3)
              cb3(err3);
            var pkg = pkgParam;
            if (pkg && opts.packageFilter) {
              pkg = opts.packageFilter(pkg, pkgfile);
            }
            cb3(null, pkg, dir);
          });
        });
      });
    }
    function loadAsDirectory(x5, loadAsDirectoryPackage, callback2) {
      var cb3 = callback2;
      var fpkg = loadAsDirectoryPackage;
      if (typeof fpkg === "function") {
        cb3 = fpkg;
        fpkg = opts.package;
      }
      maybeRealpath(realpath, x5, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return cb3(unwrapErr);
        var pkgfile = path.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (err2)
            return cb3(err2);
          if (!ex)
            return loadAsFile(path.join(x5, "index"), fpkg, cb3);
          readPackage(readFile3, pkgfile, function(err3, pkgParam) {
            if (err3)
              return cb3(err3);
            var pkg = pkgParam;
            if (pkg && opts.packageFilter) {
              pkg = opts.packageFilter(pkg, pkgfile);
            }
            if (pkg && pkg.main) {
              if (typeof pkg.main !== "string") {
                var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                mainError.code = "INVALID_PACKAGE_MAIN";
                return cb3(mainError);
              }
              if (pkg.main === "." || pkg.main === "./") {
                pkg.main = "index";
              }
              loadAsFile(path.resolve(x5, pkg.main), pkg, function(err4, m4, pkg2) {
                if (err4)
                  return cb3(err4);
                if (m4)
                  return cb3(null, m4, pkg2);
                if (!pkg2)
                  return loadAsFile(path.join(x5, "index"), pkg2, cb3);
                var dir = path.resolve(x5, pkg2.main);
                loadAsDirectory(dir, pkg2, function(err5, n4, pkg3) {
                  if (err5)
                    return cb3(err5);
                  if (n4)
                    return cb3(null, n4, pkg3);
                  loadAsFile(path.join(x5, "index"), pkg3, cb3);
                });
              });
              return;
            }
            loadAsFile(path.join(x5, "/index"), pkg, cb3);
          });
        });
      });
    }
    function processDirs(cb3, dirs) {
      if (dirs.length === 0)
        return cb3(null, undefined);
      var dir = dirs[0];
      isDirectory(path.dirname(dir), isdir);
      function isdir(err2, isdir2) {
        if (err2)
          return cb3(err2);
        if (!isdir2)
          return processDirs(cb3, dirs.slice(1));
        loadAsFile(dir, opts.package, onfile2);
      }
      function onfile2(err2, m4, pkg) {
        if (err2)
          return cb3(err2);
        if (m4)
          return cb3(null, m4, pkg);
        loadAsDirectory(dir, opts.package, ondir);
      }
      function ondir(err2, n4, pkg) {
        if (err2)
          return cb3(err2);
        if (n4)
          return cb3(null, n4, pkg);
        processDirs(cb3, dirs.slice(1));
      }
    }
    function loadNodeModules(x5, start, cb3) {
      var thunk = function() {
        return getPackageCandidates(x5, start, opts);
      };
      processDirs(cb3, packageIterator ? packageIterator(x5, start, thunk, opts) : thunk());
    }
  };
});

// ../../node_modules/resolve/lib/core.json
var require_core2 = __commonJS((exports, module) => {
  module.exports = {
    assert: true,
    "node:assert": [">= 14.18 && < 15", ">= 16"],
    "assert/strict": ">= 15",
    "node:assert/strict": ">= 16",
    async_hooks: ">= 8",
    "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
    buffer_ieee754: ">= 0.5 && < 0.9.7",
    buffer: true,
    "node:buffer": [">= 14.18 && < 15", ">= 16"],
    child_process: true,
    "node:child_process": [">= 14.18 && < 15", ">= 16"],
    cluster: ">= 0.5",
    "node:cluster": [">= 14.18 && < 15", ">= 16"],
    console: true,
    "node:console": [">= 14.18 && < 15", ">= 16"],
    constants: true,
    "node:constants": [">= 14.18 && < 15", ">= 16"],
    crypto: true,
    "node:crypto": [">= 14.18 && < 15", ">= 16"],
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    "node:dgram": [">= 14.18 && < 15", ">= 16"],
    diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
    "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
    dns: true,
    "node:dns": [">= 14.18 && < 15", ">= 16"],
    "dns/promises": ">= 15",
    "node:dns/promises": ">= 16",
    domain: ">= 0.7.12",
    "node:domain": [">= 14.18 && < 15", ">= 16"],
    events: true,
    "node:events": [">= 14.18 && < 15", ">= 16"],
    freelist: "< 6",
    fs: true,
    "node:fs": [">= 14.18 && < 15", ">= 16"],
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
    _http_agent: ">= 0.11.1",
    "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
    _http_client: ">= 0.11.1",
    "node:_http_client": [">= 14.18 && < 15", ">= 16"],
    _http_common: ">= 0.11.1",
    "node:_http_common": [">= 14.18 && < 15", ">= 16"],
    _http_incoming: ">= 0.11.1",
    "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
    _http_outgoing: ">= 0.11.1",
    "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
    _http_server: ">= 0.11.1",
    "node:_http_server": [">= 14.18 && < 15", ">= 16"],
    http: true,
    "node:http": [">= 14.18 && < 15", ">= 16"],
    http2: ">= 8.8",
    "node:http2": [">= 14.18 && < 15", ">= 16"],
    https: true,
    "node:https": [">= 14.18 && < 15", ">= 16"],
    inspector: ">= 8",
    "node:inspector": [">= 14.18 && < 15", ">= 16"],
    "inspector/promises": [">= 19"],
    "node:inspector/promises": [">= 19"],
    _linklist: "< 8",
    module: true,
    "node:module": [">= 14.18 && < 15", ">= 16"],
    net: true,
    "node:net": [">= 14.18 && < 15", ">= 16"],
    "node-inspect/lib/_inspect": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
    os: true,
    "node:os": [">= 14.18 && < 15", ">= 16"],
    path: true,
    "node:path": [">= 14.18 && < 15", ">= 16"],
    "path/posix": ">= 15.3",
    "node:path/posix": ">= 16",
    "path/win32": ">= 15.3",
    "node:path/win32": ">= 16",
    perf_hooks: ">= 8.5",
    "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
    process: ">= 1",
    "node:process": [">= 14.18 && < 15", ">= 16"],
    punycode: ">= 0.5",
    "node:punycode": [">= 14.18 && < 15", ">= 16"],
    querystring: true,
    "node:querystring": [">= 14.18 && < 15", ">= 16"],
    readline: true,
    "node:readline": [">= 14.18 && < 15", ">= 16"],
    "readline/promises": ">= 17",
    "node:readline/promises": ">= 17",
    repl: true,
    "node:repl": [">= 14.18 && < 15", ">= 16"],
    "node:sea": [">= 20.12 && < 21", ">= 21.7"],
    smalloc: ">= 0.11.5 && < 3",
    "node:sqlite": ">= 23.4",
    _stream_duplex: ">= 0.9.4",
    "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
    _stream_transform: ">= 0.9.4",
    "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
    _stream_wrap: ">= 1.4.1",
    "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
    _stream_passthrough: ">= 0.9.4",
    "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
    _stream_readable: ">= 0.9.4",
    "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
    _stream_writable: ">= 0.9.4",
    "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
    stream: true,
    "node:stream": [">= 14.18 && < 15", ">= 16"],
    "stream/consumers": ">= 16.7",
    "node:stream/consumers": ">= 16.7",
    "stream/promises": ">= 15",
    "node:stream/promises": ">= 16",
    "stream/web": ">= 16.5",
    "node:stream/web": ">= 16.5",
    string_decoder: true,
    "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
    sys: [">= 0.4 && < 0.7", ">= 0.8"],
    "node:sys": [">= 14.18 && < 15", ">= 16"],
    "test/reporters": ">= 19.9 && < 20.2",
    "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
    "test/mock_loader": ">= 22.3 && < 22.7",
    "node:test/mock_loader": ">= 22.3 && < 22.7",
    "node:test": [">= 16.17 && < 17", ">= 18"],
    timers: true,
    "node:timers": [">= 14.18 && < 15", ">= 16"],
    "timers/promises": ">= 15",
    "node:timers/promises": ">= 16",
    _tls_common: ">= 0.11.13",
    "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
    tls: true,
    "node:tls": [">= 14.18 && < 15", ">= 16"],
    trace_events: ">= 10",
    "node:trace_events": [">= 14.18 && < 15", ">= 16"],
    tty: true,
    "node:tty": [">= 14.18 && < 15", ">= 16"],
    url: true,
    "node:url": [">= 14.18 && < 15", ">= 16"],
    util: true,
    "node:util": [">= 14.18 && < 15", ">= 16"],
    "util/types": ">= 15.3",
    "node:util/types": ">= 16",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    v8: ">= 1",
    "node:v8": [">= 14.18 && < 15", ">= 16"],
    vm: true,
    "node:vm": [">= 14.18 && < 15", ">= 16"],
    wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
    "node:wasi": [">= 18.17 && < 19", ">= 20"],
    worker_threads: ">= 11.7",
    "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
    zlib: ">= 0.5",
    "node:zlib": [">= 14.18 && < 15", ">= 16"]
  };
});

// ../../node_modules/resolve/lib/core.js
var require_core3 = __commonJS((exports, module) => {
  var isCoreModule = require_is_core_module();
  var data = require_core2();
  var core = {};
  for (mod in data) {
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
      core[mod] = isCoreModule(mod);
    }
  }
  var mod;
  module.exports = core;
});

// ../../node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS((exports, module) => {
  var isCoreModule = require_is_core_module();
  module.exports = function isCore(x4) {
    return isCoreModule(x4);
  };
});

// ../../node_modules/resolve/lib/sync.js
var require_sync = __commonJS((exports, module) => {
  var isCore = require_is_core_module();
  var fs3 = __require("fs");
  var path = __require("path");
  var getHomedir = require_homedir();
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var normalizeOptions = require_normalize_options();
  var realpathFS = process.platform !== "win32" && fs3.realpathSync && typeof fs3.realpathSync.native === "function" ? fs3.realpathSync.native : fs3.realpathSync;
  var homedir2 = getHomedir();
  var defaultPaths = function() {
    return [
      path.join(homedir2, ".node_modules"),
      path.join(homedir2, ".node_libraries")
    ];
  };
  var defaultIsFile = function isFile(file) {
    try {
      var stat2 = fs3.statSync(file, { throwIfNoEntry: false });
    } catch (e4) {
      if (e4 && (e4.code === "ENOENT" || e4.code === "ENOTDIR"))
        return false;
      throw e4;
    }
    return !!stat2 && (stat2.isFile() || stat2.isFIFO());
  };
  var defaultIsDir = function isDirectory(dir) {
    try {
      var stat2 = fs3.statSync(dir, { throwIfNoEntry: false });
    } catch (e4) {
      if (e4 && (e4.code === "ENOENT" || e4.code === "ENOTDIR"))
        return false;
      throw e4;
    }
    return !!stat2 && stat2.isDirectory();
  };
  var defaultRealpathSync = function realpathSync(x4) {
    try {
      return realpathFS(x4);
    } catch (realpathErr) {
      if (realpathErr.code !== "ENOENT") {
        throw realpathErr;
      }
    }
    return x4;
  };
  var maybeRealpathSync = function maybeRealpathSync(realpathSync, x4, opts) {
    if (opts && opts.preserveSymlinks === false) {
      return realpathSync(x4);
    }
    return x4;
  };
  var defaultReadPackageSync = function defaultReadPackageSync(readFileSync2, pkgfile) {
    var body = readFileSync2(pkgfile);
    try {
      var pkg = JSON.parse(body);
      return pkg;
    } catch (jsonErr) {
    }
  };
  var getPackageCandidates = function getPackageCandidates(x4, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x4);
    for (var i4 = 0;i4 < dirs.length; i4++) {
      dirs[i4] = path.join(dirs[i4], x4);
    }
    return dirs;
  };
  module.exports = function resolveSync(x4, options) {
    if (typeof x4 !== "string") {
      throw new TypeError("Path must be a string.");
    }
    var opts = normalizeOptions(x4, options);
    var isFile = opts.isFile || defaultIsFile;
    var readFileSync2 = opts.readFileSync || fs3.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
    if (opts.readFileSync && opts.readPackageSync) {
      throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
    }
    var packageIterator = opts.packageIterator;
    var extensions4 = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || defaultPaths();
    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);
    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x4)) {
      var res = path.resolve(absoluteStart, x4);
      if (x4 === "." || x4 === ".." || x4.slice(-1) === "/")
        res += "/";
      var m4 = loadAsFileSync(res) || loadAsDirectorySync(res);
      if (m4)
        return maybeRealpathSync(realpathSync, m4, opts);
    } else if (includeCoreModules && isCore(x4)) {
      return x4;
    } else {
      var n4 = loadNodeModulesSync(x4, absoluteStart);
      if (n4)
        return maybeRealpathSync(realpathSync, n4, opts);
    }
    var err = new Error("Cannot find module '" + x4 + "' from '" + parent + "'");
    err.code = "MODULE_NOT_FOUND";
    throw err;
    function loadAsFileSync(x5) {
      var pkg = loadpkg(path.dirname(x5));
      if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
        var rfile = path.relative(pkg.dir, x5);
        var r5 = opts.pathFilter(pkg.pkg, x5, rfile);
        if (r5) {
          x5 = path.resolve(pkg.dir, r5);
        }
      }
      if (isFile(x5)) {
        return x5;
      }
      for (var i4 = 0;i4 < extensions4.length; i4++) {
        var file = x5 + extensions4[i4];
        if (isFile(file)) {
          return file;
        }
      }
    }
    function loadpkg(dir) {
      if (dir === "" || dir === "/")
        return;
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return;
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return;
      var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
      if (!isFile(pkgfile)) {
        return loadpkg(path.dirname(dir));
      }
      var pkg = readPackageSync(readFileSync2, pkgfile);
      if (pkg && opts.packageFilter) {
        pkg = opts.packageFilter(pkg, dir);
      }
      return { pkg, dir };
    }
    function loadAsDirectorySync(x5) {
      var pkgfile = path.join(maybeRealpathSync(realpathSync, x5, opts), "/package.json");
      if (isFile(pkgfile)) {
        try {
          var pkg = readPackageSync(readFileSync2, pkgfile);
        } catch (e4) {
        }
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(pkg, x5);
        }
        if (pkg && pkg.main) {
          if (typeof pkg.main !== "string") {
            var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
            mainError.code = "INVALID_PACKAGE_MAIN";
            throw mainError;
          }
          if (pkg.main === "." || pkg.main === "./") {
            pkg.main = "index";
          }
          try {
            var m5 = loadAsFileSync(path.resolve(x5, pkg.main));
            if (m5)
              return m5;
            var n5 = loadAsDirectorySync(path.resolve(x5, pkg.main));
            if (n5)
              return n5;
          } catch (e4) {
          }
        }
      }
      return loadAsFileSync(path.join(x5, "/index"));
    }
    function loadNodeModulesSync(x5, start) {
      var thunk = function() {
        return getPackageCandidates(x5, start, opts);
      };
      var dirs = packageIterator ? packageIterator(x5, start, thunk, opts) : thunk();
      for (var i4 = 0;i4 < dirs.length; i4++) {
        var dir = dirs[i4];
        if (isDirectory(path.dirname(dir))) {
          var m5 = loadAsFileSync(dir);
          if (m5)
            return m5;
          var n5 = loadAsDirectorySync(dir);
          if (n5)
            return n5;
        }
      }
    }
  };
});

// ../../node_modules/resolve/index.js
var require_resolve = __commonJS((exports, module) => {
  var async = require_async();
  async.core = require_core3();
  async.isCore = require_is_core();
  async.sync = require_sync();
  module.exports = async;
});

// ../../node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s5 = 1000;
  var m4 = s5 * 60;
  var h4 = m4 * 60;
  var d4 = h4 * 24;
  var w4 = d4 * 7;
  var y4 = d4 * 365.25;
  module.exports = function(val2, options) {
    options = options || {};
    var type = typeof val2;
    if (type === "string" && val2.length > 0) {
      return parse6(val2);
    } else if (type === "number" && isFinite(val2)) {
      return options.long ? fmtLong(val2) : fmtShort(val2);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val2));
  };
  function parse6(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n4 = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n4 * y4;
      case "weeks":
      case "week":
      case "w":
        return n4 * w4;
      case "days":
      case "day":
      case "d":
        return n4 * d4;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n4 * h4;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n4 * m4;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n4 * s5;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n4;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d4) {
      return Math.round(ms / d4) + "d";
    }
    if (msAbs >= h4) {
      return Math.round(ms / h4) + "h";
    }
    if (msAbs >= m4) {
      return Math.round(ms / m4) + "m";
    }
    if (msAbs >= s5) {
      return Math.round(ms / s5) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d4) {
      return plural(ms, msAbs, d4, "day");
    }
    if (msAbs >= h4) {
      return plural(ms, msAbs, h4, "hour");
    }
    if (msAbs >= m4) {
      return plural(ms, msAbs, m4, "minute");
    }
    if (msAbs >= s5) {
      return plural(ms, msAbs, s5, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n4, name) {
    var isPlural = msAbs >= n4 * 1.5;
    return Math.round(ms / n4) + " " + name + (isPlural ? "s" : "");
  }
});

// ../../node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env3) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env3).forEach((key) => {
      createDebug[key] = env3[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i4 = 0;i4 < namespace.length; i4++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i4);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val2 = args[index];
            match = formatter.call(self2, val2);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v7) => {
          enableOverride = v7;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip2 of createDebug.skips) {
        if (matchesTemplate(name, skip2)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val2) {
      if (val2 instanceof Error) {
        return val2.stack || val2.message;
      }
      return val2;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// ../../node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m4;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m4 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m4[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c5 = "color: " + this.color;
    args.splice(1, 0, c5, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c5);
  }
  exports.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r5;
    try {
      r5 = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r5 && typeof process !== "undefined" && "env" in process) {
      r5 = process.env.DEBUG;
    }
    return r5;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v7) {
    try {
      return JSON.stringify(v7);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// ../../node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv2 = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv2.indexOf(prefix + flag);
    const terminatorPosition = argv2.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// ../../node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var os = __require("os");
  var tty2 = __require("tty");
  var hasFlag = require_has_flag();
  var { env: env3 } = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env3) {
    if (env3.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env3.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env3.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env3.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env3.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env3) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => (sign in env3)) || env3.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env3) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env3.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env3.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env3) {
      const version2 = parseInt((env3.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env3.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env3.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env3.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env3) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty2.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty2.isatty(2)))
  };
});

// ../../node_modules/debug/src/node.js
var require_node3 = __commonJS((exports, module) => {
  var tty2 = __require("tty");
  var util = __require("util");
  exports.init = init2;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_3, k4) => {
      return k4.toUpperCase();
    });
    let val2 = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val2)) {
      val2 = true;
    } else if (/^(no|off|false|disabled)$/i.test(val2)) {
      val2 = false;
    } else if (val2 === "null") {
      val2 = null;
    } else {
      val2 = Number(val2);
    }
    obj[prop] = val2;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty2.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c5 = this.color;
      const colorCode = "\x1B[3" + (c5 < 8 ? c5 : "8;5;" + c5);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init2(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i4 = 0;i4 < keys.length; i4++) {
      debug.inspectOpts[keys[i4]] = exports.inspectOpts[keys[i4]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v7) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v7, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v7) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v7, this.inspectOpts);
  };
});

// ../../node_modules/debug/src/index.js
var require_src4 = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node3();
  }
});

// ../../node_modules/module-details-from-path/index.js
var require_module_details_from_path = __commonJS((exports, module) => {
  var path = __require("path");
  module.exports = function(file) {
    var segments = file.split(path.sep);
    var index = segments.lastIndexOf("node_modules");
    if (index === -1)
      return;
    if (!segments[index + 1])
      return;
    var scoped = segments[index + 1][0] === "@";
    var name = scoped ? segments[index + 1] + "/" + segments[index + 2] : segments[index + 1];
    var offset = scoped ? 3 : 2;
    return {
      name,
      basedir: segments.slice(0, index + offset).join(path.sep),
      path: segments.slice(index + offset).join(path.sep)
    };
  };
});

// ../../node_modules/require-in-the-middle/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "require-in-the-middle",
    version: "7.4.0",
    description: "Module to hook into the Node.js require function",
    main: "index.js",
    types: "types/index.d.ts",
    dependencies: {
      debug: "^4.3.5",
      "module-details-from-path": "^1.0.3",
      resolve: "^1.22.8"
    },
    devDependencies: {
      "@babel/core": "^7.9.0",
      "@babel/preset-env": "^7.9.5",
      "@babel/preset-typescript": "^7.9.0",
      "@babel/register": "^7.9.0",
      "ipp-printer": "^1.0.0",
      patterns: "^1.0.3",
      roundround: "^0.2.0",
      semver: "^6.3.0",
      standard: "^14.3.1",
      tape: "^4.11.0"
    },
    scripts: {
      test: "npm run test:lint && npm run test:tape && npm run test:babel",
      "test:lint": "standard",
      "test:tape": "tape test/*.js",
      "test:babel": "node test/babel/babel-register.js"
    },
    repository: {
      type: "git",
      url: "git+https://github.com/elastic/require-in-the-middle.git"
    },
    keywords: [
      "require",
      "hook",
      "shim",
      "shimmer",
      "shimming",
      "patch",
      "monkey",
      "monkeypatch",
      "module",
      "load"
    ],
    files: [
      "types"
    ],
    author: "Thomas Watson Steen <w@tson.dk> (https://twitter.com/wa7son)",
    license: "MIT",
    bugs: {
      url: "https://github.com/elastic/require-in-the-middle/issues"
    },
    homepage: "https://github.com/elastic/require-in-the-middle#readme",
    engines: {
      node: ">=8.6.0"
    }
  };
});

// ../../node_modules/require-in-the-middle/index.js
var require_require_in_the_middle = __commonJS((exports, module) => {
  var path = __require("path");
  var Module = __require("module");
  var resolve2 = require_resolve();
  var debug = require_src4()("require-in-the-middle");
  var moduleDetailsFromPath = require_module_details_from_path();
  module.exports = Hook;
  module.exports.Hook = Hook;
  var isCore;
  if (Module.isBuiltin) {
    isCore = Module.isBuiltin;
  } else {
    const [major, minor] = process.versions.node.split(".").map(Number);
    if (major === 8 && minor < 8) {
      isCore = (moduleName) => {
        if (moduleName === "http2") {
          return true;
        }
        return !!resolve2.core[moduleName];
      };
    } else {
      isCore = (moduleName) => {
        return !!resolve2.core[moduleName];
      };
    }
  }
  var normalize2 = /([/\\]index)?(\.js)?$/;

  class ExportsCache {
    constructor() {
      this._localCache = new Map;
      this._kRitmExports = Symbol("RitmExports");
    }
    has(filename, isBuiltin) {
      if (this._localCache.has(filename)) {
        return true;
      } else if (!isBuiltin) {
        const mod = __require.cache[filename];
        return !!(mod && (this._kRitmExports in mod));
      } else {
        return false;
      }
    }
    get(filename, isBuiltin) {
      const cachedExports = this._localCache.get(filename);
      if (cachedExports !== undefined) {
        return cachedExports;
      } else if (!isBuiltin) {
        const mod = __require.cache[filename];
        return mod && mod[this._kRitmExports];
      }
    }
    set(filename, exports2, isBuiltin) {
      if (isBuiltin) {
        this._localCache.set(filename, exports2);
      } else if (filename in __require.cache) {
        __require.cache[filename][this._kRitmExports] = exports2;
      } else {
        debug('non-core module is unexpectedly not in require.cache: "%s"', filename);
        this._localCache.set(filename, exports2);
      }
    }
  }
  function Hook(modules, options, onrequire) {
    if (this instanceof Hook === false)
      return new Hook(modules, options, onrequire);
    if (typeof modules === "function") {
      onrequire = modules;
      modules = null;
      options = null;
    } else if (typeof options === "function") {
      onrequire = options;
      options = null;
    }
    if (typeof Module._resolveFilename !== "function") {
      console.error("Error: Expected Module._resolveFilename to be a function (was: %s) - aborting!", typeof Module._resolveFilename);
      console.error("Please report this error as an issue related to Node.js %s at %s", process.version, require_package2().bugs.url);
      return;
    }
    this._cache = new ExportsCache;
    this._unhooked = false;
    this._origRequire = Module.prototype.require;
    const self2 = this;
    const patching = new Set;
    const internals = options ? options.internals === true : false;
    const hasWhitelist = Array.isArray(modules);
    debug("registering require hook");
    this._require = Module.prototype.require = function(id) {
      if (self2._unhooked === true) {
        debug("ignoring require call - module is soft-unhooked");
        return self2._origRequire.apply(this, arguments);
      }
      return patchedRequire.call(this, arguments, false);
    };
    if (typeof process.getBuiltinModule === "function") {
      this._origGetBuiltinModule = process.getBuiltinModule;
      this._getBuiltinModule = process.getBuiltinModule = function(id) {
        if (self2._unhooked === true) {
          debug("ignoring process.getBuiltinModule call - module is soft-unhooked");
          return self2._origGetBuiltinModule.apply(this, arguments);
        }
        return patchedRequire.call(this, arguments, true);
      };
    }
    function patchedRequire(args, coreOnly) {
      const id = args[0];
      const core = isCore(id);
      let filename;
      if (core) {
        filename = id;
        if (id.startsWith("node:")) {
          const idWithoutPrefix = id.slice(5);
          if (isCore(idWithoutPrefix)) {
            filename = idWithoutPrefix;
          }
        }
      } else if (coreOnly) {
        debug("call to process.getBuiltinModule with unknown built-in id");
        return self2._origGetBuiltinModule.apply(this, args);
      } else {
        try {
          filename = Module._resolveFilename(id, this);
        } catch (resolveErr) {
          debug('Module._resolveFilename("%s") threw %j, calling original Module.require', id, resolveErr.message);
          return self2._origRequire.apply(this, args);
        }
      }
      let moduleName, basedir;
      debug("processing %s module require('%s'): %s", core === true ? "core" : "non-core", id, filename);
      if (self2._cache.has(filename, core) === true) {
        debug("returning already patched cached module: %s", filename);
        return self2._cache.get(filename, core);
      }
      const isPatching = patching.has(filename);
      if (isPatching === false) {
        patching.add(filename);
      }
      const exports2 = coreOnly ? self2._origGetBuiltinModule.apply(this, args) : self2._origRequire.apply(this, args);
      if (isPatching === true) {
        debug("module is in the process of being patched already - ignoring: %s", filename);
        return exports2;
      }
      patching.delete(filename);
      if (core === true) {
        if (hasWhitelist === true && modules.includes(filename) === false) {
          debug("ignoring core module not on whitelist: %s", filename);
          return exports2;
        }
        moduleName = filename;
      } else if (hasWhitelist === true && modules.includes(filename)) {
        const parsedPath = path.parse(filename);
        moduleName = parsedPath.name;
        basedir = parsedPath.dir;
      } else {
        const stat2 = moduleDetailsFromPath(filename);
        if (stat2 === undefined) {
          debug("could not parse filename: %s", filename);
          return exports2;
        }
        moduleName = stat2.name;
        basedir = stat2.basedir;
        const fullModuleName = resolveModuleName(stat2);
        debug("resolved filename to module: %s (id: %s, resolved: %s, basedir: %s)", moduleName, id, fullModuleName, basedir);
        let matchFound = false;
        if (hasWhitelist) {
          if (!id.startsWith(".") && modules.includes(id)) {
            moduleName = id;
            matchFound = true;
          }
          if (!modules.includes(moduleName) && !modules.includes(fullModuleName)) {
            return exports2;
          }
          if (modules.includes(fullModuleName) && fullModuleName !== moduleName) {
            moduleName = fullModuleName;
            matchFound = true;
          }
        }
        if (!matchFound) {
          let res;
          try {
            res = resolve2.sync(moduleName, { basedir });
          } catch (e4) {
            debug("could not resolve module: %s", moduleName);
            self2._cache.set(filename, exports2, core);
            return exports2;
          }
          if (res !== filename) {
            if (internals === true) {
              moduleName = moduleName + path.sep + path.relative(basedir, filename);
              debug("preparing to process require of internal file: %s", moduleName);
            } else {
              debug("ignoring require of non-main module file: %s", res);
              self2._cache.set(filename, exports2, core);
              return exports2;
            }
          }
        }
      }
      self2._cache.set(filename, exports2, core);
      debug("calling require hook: %s", moduleName);
      const patchedExports = onrequire(exports2, moduleName, basedir);
      self2._cache.set(filename, patchedExports, core);
      debug("returning module: %s", moduleName);
      return patchedExports;
    }
  }
  Hook.prototype.unhook = function() {
    this._unhooked = true;
    if (this._require === Module.prototype.require) {
      Module.prototype.require = this._origRequire;
      debug("require unhook successful");
    } else {
      debug("require unhook unsuccessful");
    }
    if (process.getBuiltinModule !== undefined) {
      if (this._getBuiltinModule === process.getBuiltinModule) {
        process.getBuiltinModule = this._origGetBuiltinModule;
        debug("process.getBuiltinModule unhook successful");
      } else {
        debug("process.getBuiltinModule unhook unsuccessful");
      }
    }
  };
  function resolveModuleName(stat2) {
    const normalizedPath = path.sep !== "/" ? stat2.path.split(path.sep).join("/") : stat2.path;
    return path.posix.join(stat2.name, normalizedPath).replace(normalize2, "");
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/platform/node/ModuleNameTrie.js
var require_ModuleNameTrie = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ModuleNameTrie = exports.ModuleNameSeparator = undefined;
  exports.ModuleNameSeparator = "/";

  class ModuleNameTrieNode {
    constructor() {
      this.hooks = [];
      this.children = new Map;
    }
  }

  class ModuleNameTrie {
    constructor() {
      this._trie = new ModuleNameTrieNode;
      this._counter = 0;
    }
    insert(hook) {
      let trieNode = this._trie;
      for (const moduleNamePart of hook.moduleName.split(exports.ModuleNameSeparator)) {
        let nextNode = trieNode.children.get(moduleNamePart);
        if (!nextNode) {
          nextNode = new ModuleNameTrieNode;
          trieNode.children.set(moduleNamePart, nextNode);
        }
        trieNode = nextNode;
      }
      trieNode.hooks.push({ hook, insertedId: this._counter++ });
    }
    search(moduleName, { maintainInsertionOrder, fullOnly } = {}) {
      let trieNode = this._trie;
      const results = [];
      let foundFull = true;
      for (const moduleNamePart of moduleName.split(exports.ModuleNameSeparator)) {
        const nextNode = trieNode.children.get(moduleNamePart);
        if (!nextNode) {
          foundFull = false;
          break;
        }
        if (!fullOnly) {
          results.push(...nextNode.hooks);
        }
        trieNode = nextNode;
      }
      if (fullOnly && foundFull) {
        results.push(...trieNode.hooks);
      }
      if (results.length === 0) {
        return [];
      }
      if (results.length === 1) {
        return [results[0].hook];
      }
      if (maintainInsertionOrder) {
        results.sort((a5, b3) => a5.insertedId - b3.insertedId);
      }
      return results.map(({ hook }) => hook);
    }
  }
  exports.ModuleNameTrie = ModuleNameTrie;
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/platform/node/RequireInTheMiddleSingleton.js
var require_RequireInTheMiddleSingleton = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RequireInTheMiddleSingleton = undefined;
  var require_in_the_middle_1 = require_require_in_the_middle();
  var path = __require("path");
  var ModuleNameTrie_1 = require_ModuleNameTrie();
  var isMocha = [
    "afterEach",
    "after",
    "beforeEach",
    "before",
    "describe",
    "it"
  ].every((fn) => {
    return typeof global[fn] === "function";
  });

  class RequireInTheMiddleSingleton {
    constructor() {
      this._moduleNameTrie = new ModuleNameTrie_1.ModuleNameTrie;
      this._initialize();
    }
    _initialize() {
      new require_in_the_middle_1.Hook(null, { internals: true }, (exports2, name, basedir) => {
        const normalizedModuleName = normalizePathSeparators(name);
        const matches = this._moduleNameTrie.search(normalizedModuleName, {
          maintainInsertionOrder: true,
          fullOnly: basedir === undefined
        });
        for (const { onRequire } of matches) {
          exports2 = onRequire(exports2, name, basedir);
        }
        return exports2;
      });
    }
    register(moduleName, onRequire) {
      const hooked = { moduleName, onRequire };
      this._moduleNameTrie.insert(hooked);
      return hooked;
    }
    static getInstance() {
      var _a2;
      if (isMocha)
        return new RequireInTheMiddleSingleton;
      return this._instance = (_a2 = this._instance) !== null && _a2 !== undefined ? _a2 : new RequireInTheMiddleSingleton;
    }
  }
  exports.RequireInTheMiddleSingleton = RequireInTheMiddleSingleton;
  function normalizePathSeparators(moduleNameOrPath) {
    return path.sep !== ModuleNameTrie_1.ModuleNameSeparator ? moduleNameOrPath.split(path.sep).join(ModuleNameTrie_1.ModuleNameSeparator) : moduleNameOrPath;
  }
});

// ../../node_modules/import-in-the-middle/lib/register.js
var require_register = __commonJS((exports) => {
  var importHooks = [];
  var setters = new WeakMap;
  var getters = new WeakMap;
  var specifiers = new Map;
  var toHook = [];
  var proxyHandler = {
    set(target, name, value) {
      return setters.get(target)[name](value);
    },
    get(target, name) {
      if (name === Symbol.toStringTag) {
        return "Module";
      }
      const getter = getters.get(target)[name];
      if (typeof getter === "function") {
        return getter();
      }
    },
    defineProperty(target, property, descriptor) {
      if (!("value" in descriptor)) {
        throw new Error("Getters/setters are not supported for exports property descriptors.");
      }
      return setters.get(target)[property](descriptor.value);
    }
  };
  function register(name, namespace, set, get, specifier) {
    specifiers.set(name, specifier);
    setters.set(namespace, set);
    getters.set(namespace, get);
    const proxy = new Proxy(namespace, proxyHandler);
    importHooks.forEach((hook) => hook(name, proxy));
    toHook.push([name, proxy]);
  }
  exports.register = register;
  exports.importHooks = importHooks;
  exports.specifiers = specifiers;
  exports.toHook = toHook;
});

// ../../node_modules/import-in-the-middle/index.js
var require_import_in_the_middle = __commonJS((exports, module) => {
  var path = __require("path");
  var parse6 = require_module_details_from_path();
  var { fileURLToPath } = __require("url");
  var { MessageChannel } = __require("worker_threads");
  var {
    importHooks,
    specifiers,
    toHook
  } = require_register();
  function addHook(hook) {
    importHooks.push(hook);
    toHook.forEach(([name, namespace]) => hook(name, namespace));
  }
  function removeHook(hook) {
    const index = importHooks.indexOf(hook);
    if (index > -1) {
      importHooks.splice(index, 1);
    }
  }
  function callHookFn(hookFn, namespace, name, baseDir) {
    const newDefault = hookFn(namespace, name, baseDir);
    if (newDefault && newDefault !== namespace) {
      namespace.default = newDefault;
    }
  }
  var sendModulesToLoader;
  function createAddHookMessageChannel() {
    const { port1, port2 } = new MessageChannel;
    let pendingAckCount = 0;
    let resolveFn;
    sendModulesToLoader = (modules) => {
      pendingAckCount++;
      port1.postMessage(modules);
    };
    port1.on("message", () => {
      pendingAckCount--;
      if (resolveFn && pendingAckCount <= 0) {
        resolveFn();
      }
    }).unref();
    function waitForAllMessagesAcknowledged() {
      const timer = setInterval(() => {
      }, 1000);
      const promise = new Promise((resolve2) => {
        resolveFn = resolve2;
      }).then(() => {
        clearInterval(timer);
      });
      if (pendingAckCount === 0) {
        resolveFn();
      }
      return promise;
    }
    const addHookMessagePort = port2;
    const registerOptions = { data: { addHookMessagePort, include: [] }, transferList: [addHookMessagePort] };
    return { registerOptions, addHookMessagePort, waitForAllMessagesAcknowledged };
  }
  function Hook(modules, options, hookFn) {
    if (this instanceof Hook === false)
      return new Hook(modules, options, hookFn);
    if (typeof modules === "function") {
      hookFn = modules;
      modules = null;
      options = null;
    } else if (typeof options === "function") {
      hookFn = options;
      options = null;
    }
    const internals = options ? options.internals === true : false;
    if (sendModulesToLoader && Array.isArray(modules)) {
      sendModulesToLoader(modules);
    }
    this._iitmHook = (name, namespace) => {
      const filename = name;
      const isBuiltin = name.startsWith("node:");
      let baseDir;
      if (isBuiltin) {
        name = name.replace(/^node:/, "");
      } else {
        if (name.startsWith("file://")) {
          try {
            name = fileURLToPath(name);
          } catch (e4) {
          }
        }
        const details = parse6(name);
        if (details) {
          name = details.name;
          baseDir = details.basedir;
        }
      }
      if (modules) {
        for (const moduleName of modules) {
          if (moduleName === name) {
            if (baseDir) {
              if (internals) {
                name = name + path.sep + path.relative(baseDir, fileURLToPath(filename));
              } else {
                if (!baseDir.endsWith(specifiers.get(filename)))
                  continue;
              }
            }
            callHookFn(hookFn, namespace, name, baseDir);
          }
        }
      } else {
        callHookFn(hookFn, namespace, name, baseDir);
      }
    };
    addHook(this._iitmHook);
  }
  Hook.prototype.unhook = function() {
    removeHook(this._iitmHook);
  };
  module.exports = Hook;
  module.exports.Hook = Hook;
  module.exports.addHook = addHook;
  module.exports.removeHook = removeHook;
  module.exports.createAddHookMessageChannel = createAddHookMessageChannel;
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/utils.js
var require_utils3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isWrapped = exports.safeExecuteInTheMiddleAsync = exports.safeExecuteInTheMiddle = undefined;
  function safeExecuteInTheMiddle(execute, onFinish, preventThrowingError) {
    let error;
    let result;
    try {
      result = execute();
    } catch (e4) {
      error = e4;
    } finally {
      onFinish(error, result);
      if (error && !preventThrowingError) {
        throw error;
      }
      return result;
    }
  }
  exports.safeExecuteInTheMiddle = safeExecuteInTheMiddle;
  async function safeExecuteInTheMiddleAsync(execute, onFinish, preventThrowingError) {
    let error;
    let result;
    try {
      result = await execute();
    } catch (e4) {
      error = e4;
    } finally {
      onFinish(error, result);
      if (error && !preventThrowingError) {
        throw error;
      }
      return result;
    }
  }
  exports.safeExecuteInTheMiddleAsync = safeExecuteInTheMiddleAsync;
  function isWrapped(func) {
    return typeof func === "function" && typeof func.__original === "function" && typeof func.__unwrap === "function" && func.__wrapped === true;
  }
  exports.isWrapped = isWrapped;
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/platform/node/instrumentation.js
var require_instrumentation2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationBase = undefined;
  var path = __require("path");
  var util_1 = __require("util");
  var semver_1 = require_semver3();
  var shimmer_1 = require_shimmer();
  var instrumentation_1 = require_instrumentation();
  var RequireInTheMiddleSingleton_1 = require_RequireInTheMiddleSingleton();
  var import_in_the_middle_1 = require_import_in_the_middle();
  var api_1 = require_src();
  var require_in_the_middle_1 = require_require_in_the_middle();
  var fs_1 = __require("fs");
  var utils_1 = require_utils3();

  class InstrumentationBase extends instrumentation_1.InstrumentationAbstract {
    constructor(instrumentationName, instrumentationVersion, config5) {
      super(instrumentationName, instrumentationVersion, config5);
      this._hooks = [];
      this._requireInTheMiddleSingleton = RequireInTheMiddleSingleton_1.RequireInTheMiddleSingleton.getInstance();
      this._enabled = false;
      this._wrap = (moduleExports, name, wrapper) => {
        if ((0, utils_1.isWrapped)(moduleExports[name])) {
          this._unwrap(moduleExports, name);
        }
        if (!util_1.types.isProxy(moduleExports)) {
          return (0, shimmer_1.wrap)(moduleExports, name, wrapper);
        } else {
          const wrapped = (0, shimmer_1.wrap)(Object.assign({}, moduleExports), name, wrapper);
          Object.defineProperty(moduleExports, name, {
            value: wrapped
          });
          return wrapped;
        }
      };
      this._unwrap = (moduleExports, name) => {
        if (!util_1.types.isProxy(moduleExports)) {
          return (0, shimmer_1.unwrap)(moduleExports, name);
        } else {
          return Object.defineProperty(moduleExports, name, {
            value: moduleExports[name]
          });
        }
      };
      this._massWrap = (moduleExportsArray, names, wrapper) => {
        if (!moduleExportsArray) {
          api_1.diag.error("must provide one or more modules to patch");
          return;
        } else if (!Array.isArray(moduleExportsArray)) {
          moduleExportsArray = [moduleExportsArray];
        }
        if (!(names && Array.isArray(names))) {
          api_1.diag.error("must provide one or more functions to wrap on modules");
          return;
        }
        moduleExportsArray.forEach((moduleExports) => {
          names.forEach((name) => {
            this._wrap(moduleExports, name, wrapper);
          });
        });
      };
      this._massUnwrap = (moduleExportsArray, names) => {
        if (!moduleExportsArray) {
          api_1.diag.error("must provide one or more modules to patch");
          return;
        } else if (!Array.isArray(moduleExportsArray)) {
          moduleExportsArray = [moduleExportsArray];
        }
        if (!(names && Array.isArray(names))) {
          api_1.diag.error("must provide one or more functions to wrap on modules");
          return;
        }
        moduleExportsArray.forEach((moduleExports) => {
          names.forEach((name) => {
            this._unwrap(moduleExports, name);
          });
        });
      };
      let modules = this.init();
      if (modules && !Array.isArray(modules)) {
        modules = [modules];
      }
      this._modules = modules || [];
      if (this._config.enabled) {
        this.enable();
      }
    }
    _warnOnPreloadedModules() {
      this._modules.forEach((module2) => {
        const { name } = module2;
        try {
          const resolvedModule = __require.resolve(name);
          if (__require.cache[resolvedModule]) {
            this._diag.warn(`Module ${name} has been loaded before ${this.instrumentationName} so it might not work, please initialize it before requiring ${name}`);
          }
        } catch (_a2) {
        }
      });
    }
    _extractPackageVersion(baseDir) {
      try {
        const json = (0, fs_1.readFileSync)(path.join(baseDir, "package.json"), {
          encoding: "utf8"
        });
        const version2 = JSON.parse(json).version;
        return typeof version2 === "string" ? version2 : undefined;
      } catch (error) {
        api_1.diag.warn("Failed extracting version", baseDir);
      }
      return;
    }
    _onRequire(module2, exports2, name, baseDir) {
      var _a2;
      if (!baseDir) {
        if (typeof module2.patch === "function") {
          module2.moduleExports = exports2;
          if (this._enabled) {
            this._diag.debug("Applying instrumentation patch for nodejs core module on require hook", {
              module: module2.name
            });
            return module2.patch(exports2);
          }
        }
        return exports2;
      }
      const version2 = this._extractPackageVersion(baseDir);
      module2.moduleVersion = version2;
      if (module2.name === name) {
        if (isSupported(module2.supportedVersions, version2, module2.includePrerelease)) {
          if (typeof module2.patch === "function") {
            module2.moduleExports = exports2;
            if (this._enabled) {
              this._diag.debug("Applying instrumentation patch for module on require hook", {
                module: module2.name,
                version: module2.moduleVersion,
                baseDir
              });
              return module2.patch(exports2, module2.moduleVersion);
            }
          }
        }
        return exports2;
      }
      const files = (_a2 = module2.files) !== null && _a2 !== undefined ? _a2 : [];
      const normalizedName = path.normalize(name);
      const supportedFileInstrumentations = files.filter((f4) => f4.name === normalizedName).filter((f4) => isSupported(f4.supportedVersions, version2, module2.includePrerelease));
      return supportedFileInstrumentations.reduce((patchedExports, file) => {
        file.moduleExports = patchedExports;
        if (this._enabled) {
          this._diag.debug("Applying instrumentation patch for nodejs module file on require hook", {
            module: module2.name,
            version: module2.moduleVersion,
            fileName: file.name,
            baseDir
          });
          return file.patch(patchedExports, module2.moduleVersion);
        }
        return patchedExports;
      }, exports2);
    }
    enable() {
      if (this._enabled) {
        return;
      }
      this._enabled = true;
      if (this._hooks.length > 0) {
        for (const module2 of this._modules) {
          if (typeof module2.patch === "function" && module2.moduleExports) {
            this._diag.debug("Applying instrumentation patch for nodejs module on instrumentation enabled", {
              module: module2.name,
              version: module2.moduleVersion
            });
            module2.patch(module2.moduleExports, module2.moduleVersion);
          }
          for (const file of module2.files) {
            if (file.moduleExports) {
              this._diag.debug("Applying instrumentation patch for nodejs module file on instrumentation enabled", {
                module: module2.name,
                version: module2.moduleVersion,
                fileName: file.name
              });
              file.patch(file.moduleExports, module2.moduleVersion);
            }
          }
        }
        return;
      }
      this._warnOnPreloadedModules();
      for (const module2 of this._modules) {
        const hookFn = (exports2, name, baseDir) => {
          return this._onRequire(module2, exports2, name, baseDir);
        };
        const onRequire = (exports2, name, baseDir) => {
          return this._onRequire(module2, exports2, name, baseDir);
        };
        const hook = path.isAbsolute(module2.name) ? new require_in_the_middle_1.Hook([module2.name], { internals: true }, onRequire) : this._requireInTheMiddleSingleton.register(module2.name, onRequire);
        this._hooks.push(hook);
        const esmHook = new import_in_the_middle_1.Hook([module2.name], { internals: false }, hookFn);
        this._hooks.push(esmHook);
      }
    }
    disable() {
      if (!this._enabled) {
        return;
      }
      this._enabled = false;
      for (const module2 of this._modules) {
        if (typeof module2.unpatch === "function" && module2.moduleExports) {
          this._diag.debug("Removing instrumentation patch for nodejs module on instrumentation disabled", {
            module: module2.name,
            version: module2.moduleVersion
          });
          module2.unpatch(module2.moduleExports, module2.moduleVersion);
        }
        for (const file of module2.files) {
          if (file.moduleExports) {
            this._diag.debug("Removing instrumentation patch for nodejs module file on instrumentation disabled", {
              module: module2.name,
              version: module2.moduleVersion,
              fileName: file.name
            });
            file.unpatch(file.moduleExports, module2.moduleVersion);
          }
        }
      }
    }
    isEnabled() {
      return this._enabled;
    }
  }
  exports.InstrumentationBase = InstrumentationBase;
  function isSupported(supportedVersions, version2, includePrerelease) {
    if (typeof version2 === "undefined") {
      return supportedVersions.includes("*");
    }
    return supportedVersions.some((supportedVersion) => {
      return (0, semver_1.satisfies)(version2, supportedVersion, { includePrerelease });
    });
  }
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/platform/node/normalize.js
var require_normalize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = undefined;
  var path_1 = __require("path");
  Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
    return path_1.normalize;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/platform/node/index.js
var require_node4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = exports.InstrumentationBase = undefined;
  var instrumentation_1 = require_instrumentation2();
  Object.defineProperty(exports, "InstrumentationBase", { enumerable: true, get: function() {
    return instrumentation_1.InstrumentationBase;
  } });
  var normalize_1 = require_normalize();
  Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
    return normalize_1.normalize;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/platform/index.js
var require_platform3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = exports.InstrumentationBase = undefined;
  var node_1 = require_node4();
  Object.defineProperty(exports, "InstrumentationBase", { enumerable: true, get: function() {
    return node_1.InstrumentationBase;
  } });
  Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
    return node_1.normalize;
  } });
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/instrumentationNodeModuleDefinition.js
var require_instrumentationNodeModuleDefinition = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationNodeModuleDefinition = undefined;

  class InstrumentationNodeModuleDefinition {
    constructor(name, supportedVersions, patch, unpatch, files) {
      this.name = name;
      this.supportedVersions = supportedVersions;
      this.patch = patch;
      this.unpatch = unpatch;
      this.files = files || [];
    }
  }
  exports.InstrumentationNodeModuleDefinition = InstrumentationNodeModuleDefinition;
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/instrumentationNodeModuleFile.js
var require_instrumentationNodeModuleFile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationNodeModuleFile = undefined;
  var index_1 = require_platform3();

  class InstrumentationNodeModuleFile {
    constructor(name, supportedVersions, patch, unpatch) {
      this.supportedVersions = supportedVersions;
      this.patch = patch;
      this.unpatch = unpatch;
      this.name = (0, index_1.normalize)(name);
    }
  }
  exports.InstrumentationNodeModuleFile = InstrumentationNodeModuleFile;
});

// ../../node_modules/@opentelemetry/instrumentation/build/src/index.js
var require_src5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.safeExecuteInTheMiddleAsync = exports.safeExecuteInTheMiddle = exports.isWrapped = exports.InstrumentationNodeModuleFile = exports.InstrumentationNodeModuleDefinition = exports.InstrumentationBase = exports.registerInstrumentations = undefined;
  var autoLoader_1 = require_autoLoader();
  Object.defineProperty(exports, "registerInstrumentations", { enumerable: true, get: function() {
    return autoLoader_1.registerInstrumentations;
  } });
  var index_1 = require_platform3();
  Object.defineProperty(exports, "InstrumentationBase", { enumerable: true, get: function() {
    return index_1.InstrumentationBase;
  } });
  var instrumentationNodeModuleDefinition_1 = require_instrumentationNodeModuleDefinition();
  Object.defineProperty(exports, "InstrumentationNodeModuleDefinition", { enumerable: true, get: function() {
    return instrumentationNodeModuleDefinition_1.InstrumentationNodeModuleDefinition;
  } });
  var instrumentationNodeModuleFile_1 = require_instrumentationNodeModuleFile();
  Object.defineProperty(exports, "InstrumentationNodeModuleFile", { enumerable: true, get: function() {
    return instrumentationNodeModuleFile_1.InstrumentationNodeModuleFile;
  } });
  var utils_1 = require_utils3();
  Object.defineProperty(exports, "isWrapped", { enumerable: true, get: function() {
    return utils_1.isWrapped;
  } });
  Object.defineProperty(exports, "safeExecuteInTheMiddle", { enumerable: true, get: function() {
    return utils_1.safeExecuteInTheMiddle;
  } });
  Object.defineProperty(exports, "safeExecuteInTheMiddleAsync", { enumerable: true, get: function() {
    return utils_1.safeExecuteInTheMiddleAsync;
  } });
});

// ../../node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js
var require_utils4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createConstMap = undefined;
  function createConstMap(values) {
    let res = {};
    const len = values.length;
    for (let lp = 0;lp < len; lp++) {
      const val2 = values[lp];
      if (val2) {
        res[String(val2).toUpperCase().replace(/[-.]/g, "_")] = val2;
      }
    }
    return res;
  }
  exports.createConstMap = createConstMap;
});

// ../../node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js
var require_SemanticAttributes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SEMATTRS_NET_HOST_CARRIER_ICC = exports.SEMATTRS_NET_HOST_CARRIER_MNC = exports.SEMATTRS_NET_HOST_CARRIER_MCC = exports.SEMATTRS_NET_HOST_CARRIER_NAME = exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = exports.SEMATTRS_NET_HOST_NAME = exports.SEMATTRS_NET_HOST_PORT = exports.SEMATTRS_NET_HOST_IP = exports.SEMATTRS_NET_PEER_NAME = exports.SEMATTRS_NET_PEER_PORT = exports.SEMATTRS_NET_PEER_IP = exports.SEMATTRS_NET_TRANSPORT = exports.SEMATTRS_FAAS_INVOKED_REGION = exports.SEMATTRS_FAAS_INVOKED_PROVIDER = exports.SEMATTRS_FAAS_INVOKED_NAME = exports.SEMATTRS_FAAS_COLDSTART = exports.SEMATTRS_FAAS_CRON = exports.SEMATTRS_FAAS_TIME = exports.SEMATTRS_FAAS_DOCUMENT_NAME = exports.SEMATTRS_FAAS_DOCUMENT_TIME = exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = exports.SEMATTRS_FAAS_EXECUTION = exports.SEMATTRS_FAAS_TRIGGER = exports.SEMATTRS_EXCEPTION_ESCAPED = exports.SEMATTRS_EXCEPTION_STACKTRACE = exports.SEMATTRS_EXCEPTION_MESSAGE = exports.SEMATTRS_EXCEPTION_TYPE = exports.SEMATTRS_DB_SQL_TABLE = exports.SEMATTRS_DB_MONGODB_COLLECTION = exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = exports.SEMATTRS_DB_HBASE_NAMESPACE = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = exports.SEMATTRS_DB_CASSANDRA_TABLE = exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = exports.SEMATTRS_DB_OPERATION = exports.SEMATTRS_DB_STATEMENT = exports.SEMATTRS_DB_NAME = exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = exports.SEMATTRS_DB_USER = exports.SEMATTRS_DB_CONNECTION_STRING = exports.SEMATTRS_DB_SYSTEM = exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = undefined;
  exports.SEMATTRS_MESSAGING_DESTINATION_KIND = exports.SEMATTRS_MESSAGING_DESTINATION = exports.SEMATTRS_MESSAGING_SYSTEM = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = exports.SEMATTRS_AWS_DYNAMODB_COUNT = exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_SELECT = exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = exports.SEMATTRS_AWS_DYNAMODB_LIMIT = exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = exports.SEMATTRS_HTTP_CLIENT_IP = exports.SEMATTRS_HTTP_ROUTE = exports.SEMATTRS_HTTP_SERVER_NAME = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = exports.SEMATTRS_HTTP_USER_AGENT = exports.SEMATTRS_HTTP_FLAVOR = exports.SEMATTRS_HTTP_STATUS_CODE = exports.SEMATTRS_HTTP_SCHEME = exports.SEMATTRS_HTTP_HOST = exports.SEMATTRS_HTTP_TARGET = exports.SEMATTRS_HTTP_URL = exports.SEMATTRS_HTTP_METHOD = exports.SEMATTRS_CODE_LINENO = exports.SEMATTRS_CODE_FILEPATH = exports.SEMATTRS_CODE_NAMESPACE = exports.SEMATTRS_CODE_FUNCTION = exports.SEMATTRS_THREAD_NAME = exports.SEMATTRS_THREAD_ID = exports.SEMATTRS_ENDUSER_SCOPE = exports.SEMATTRS_ENDUSER_ROLE = exports.SEMATTRS_ENDUSER_ID = exports.SEMATTRS_PEER_SERVICE = undefined;
  exports.DBSYSTEMVALUES_FILEMAKER = exports.DBSYSTEMVALUES_DERBY = exports.DBSYSTEMVALUES_FIREBIRD = exports.DBSYSTEMVALUES_ADABAS = exports.DBSYSTEMVALUES_CACHE = exports.DBSYSTEMVALUES_EDB = exports.DBSYSTEMVALUES_FIRSTSQL = exports.DBSYSTEMVALUES_INGRES = exports.DBSYSTEMVALUES_HANADB = exports.DBSYSTEMVALUES_MAXDB = exports.DBSYSTEMVALUES_PROGRESS = exports.DBSYSTEMVALUES_HSQLDB = exports.DBSYSTEMVALUES_CLOUDSCAPE = exports.DBSYSTEMVALUES_HIVE = exports.DBSYSTEMVALUES_REDSHIFT = exports.DBSYSTEMVALUES_POSTGRESQL = exports.DBSYSTEMVALUES_DB2 = exports.DBSYSTEMVALUES_ORACLE = exports.DBSYSTEMVALUES_MYSQL = exports.DBSYSTEMVALUES_MSSQL = exports.DBSYSTEMVALUES_OTHER_SQL = exports.SemanticAttributes = exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_ID = exports.SEMATTRS_MESSAGE_TYPE = exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = exports.SEMATTRS_RPC_JSONRPC_VERSION = exports.SEMATTRS_RPC_GRPC_STATUS_CODE = exports.SEMATTRS_RPC_METHOD = exports.SEMATTRS_RPC_SERVICE = exports.SEMATTRS_RPC_SYSTEM = exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = exports.SEMATTRS_MESSAGING_CONSUMER_ID = exports.SEMATTRS_MESSAGING_OPERATION = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = exports.SEMATTRS_MESSAGING_CONVERSATION_ID = exports.SEMATTRS_MESSAGING_MESSAGE_ID = exports.SEMATTRS_MESSAGING_URL = exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = exports.SEMATTRS_MESSAGING_PROTOCOL = exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = undefined;
  exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = exports.FaasDocumentOperationValues = exports.FAASDOCUMENTOPERATIONVALUES_DELETE = exports.FAASDOCUMENTOPERATIONVALUES_EDIT = exports.FAASDOCUMENTOPERATIONVALUES_INSERT = exports.FaasTriggerValues = exports.FAASTRIGGERVALUES_OTHER = exports.FAASTRIGGERVALUES_TIMER = exports.FAASTRIGGERVALUES_PUBSUB = exports.FAASTRIGGERVALUES_HTTP = exports.FAASTRIGGERVALUES_DATASOURCE = exports.DbCassandraConsistencyLevelValues = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = exports.DbSystemValues = exports.DBSYSTEMVALUES_COCKROACHDB = exports.DBSYSTEMVALUES_MEMCACHED = exports.DBSYSTEMVALUES_ELASTICSEARCH = exports.DBSYSTEMVALUES_GEODE = exports.DBSYSTEMVALUES_NEO4J = exports.DBSYSTEMVALUES_DYNAMODB = exports.DBSYSTEMVALUES_COSMOSDB = exports.DBSYSTEMVALUES_COUCHDB = exports.DBSYSTEMVALUES_COUCHBASE = exports.DBSYSTEMVALUES_REDIS = exports.DBSYSTEMVALUES_MONGODB = exports.DBSYSTEMVALUES_HBASE = exports.DBSYSTEMVALUES_CASSANDRA = exports.DBSYSTEMVALUES_COLDFUSION = exports.DBSYSTEMVALUES_H2 = exports.DBSYSTEMVALUES_VERTICA = exports.DBSYSTEMVALUES_TERADATA = exports.DBSYSTEMVALUES_SYBASE = exports.DBSYSTEMVALUES_SQLITE = exports.DBSYSTEMVALUES_POINTBASE = exports.DBSYSTEMVALUES_PERVASIVE = exports.DBSYSTEMVALUES_NETEZZA = exports.DBSYSTEMVALUES_MARIADB = exports.DBSYSTEMVALUES_INTERBASE = exports.DBSYSTEMVALUES_INSTANTDB = exports.DBSYSTEMVALUES_INFORMIX = undefined;
  exports.MESSAGINGOPERATIONVALUES_RECEIVE = exports.MessagingDestinationKindValues = exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = exports.HttpFlavorValues = exports.HTTPFLAVORVALUES_QUIC = exports.HTTPFLAVORVALUES_SPDY = exports.HTTPFLAVORVALUES_HTTP_2_0 = exports.HTTPFLAVORVALUES_HTTP_1_1 = exports.HTTPFLAVORVALUES_HTTP_1_0 = exports.NetHostConnectionSubtypeValues = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = exports.NetHostConnectionTypeValues = exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = exports.NETHOSTCONNECTIONTYPEVALUES_CELL = exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = exports.NetTransportValues = exports.NETTRANSPORTVALUES_OTHER = exports.NETTRANSPORTVALUES_INPROC = exports.NETTRANSPORTVALUES_PIPE = exports.NETTRANSPORTVALUES_UNIX = exports.NETTRANSPORTVALUES_IP = exports.NETTRANSPORTVALUES_IP_UDP = exports.NETTRANSPORTVALUES_IP_TCP = exports.FaasInvokedProviderValues = exports.FAASINVOKEDPROVIDERVALUES_GCP = exports.FAASINVOKEDPROVIDERVALUES_AZURE = exports.FAASINVOKEDPROVIDERVALUES_AWS = undefined;
  exports.MessageTypeValues = exports.MESSAGETYPEVALUES_RECEIVED = exports.MESSAGETYPEVALUES_SENT = exports.RpcGrpcStatusCodeValues = exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = exports.RPCGRPCSTATUSCODEVALUES_ABORTED = exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = exports.RPCGRPCSTATUSCODEVALUES_OK = exports.MessagingOperationValues = exports.MESSAGINGOPERATIONVALUES_PROCESS = undefined;
  var utils_1 = require_utils4();
  var TMP_AWS_LAMBDA_INVOKED_ARN = "aws.lambda.invoked_arn";
  var TMP_DB_SYSTEM = "db.system";
  var TMP_DB_CONNECTION_STRING = "db.connection_string";
  var TMP_DB_USER = "db.user";
  var TMP_DB_JDBC_DRIVER_CLASSNAME = "db.jdbc.driver_classname";
  var TMP_DB_NAME = "db.name";
  var TMP_DB_STATEMENT = "db.statement";
  var TMP_DB_OPERATION = "db.operation";
  var TMP_DB_MSSQL_INSTANCE_NAME = "db.mssql.instance_name";
  var TMP_DB_CASSANDRA_KEYSPACE = "db.cassandra.keyspace";
  var TMP_DB_CASSANDRA_PAGE_SIZE = "db.cassandra.page_size";
  var TMP_DB_CASSANDRA_CONSISTENCY_LEVEL = "db.cassandra.consistency_level";
  var TMP_DB_CASSANDRA_TABLE = "db.cassandra.table";
  var TMP_DB_CASSANDRA_IDEMPOTENCE = "db.cassandra.idempotence";
  var TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = "db.cassandra.speculative_execution_count";
  var TMP_DB_CASSANDRA_COORDINATOR_ID = "db.cassandra.coordinator.id";
  var TMP_DB_CASSANDRA_COORDINATOR_DC = "db.cassandra.coordinator.dc";
  var TMP_DB_HBASE_NAMESPACE = "db.hbase.namespace";
  var TMP_DB_REDIS_DATABASE_INDEX = "db.redis.database_index";
  var TMP_DB_MONGODB_COLLECTION = "db.mongodb.collection";
  var TMP_DB_SQL_TABLE = "db.sql.table";
  var TMP_EXCEPTION_TYPE = "exception.type";
  var TMP_EXCEPTION_MESSAGE = "exception.message";
  var TMP_EXCEPTION_STACKTRACE = "exception.stacktrace";
  var TMP_EXCEPTION_ESCAPED = "exception.escaped";
  var TMP_FAAS_TRIGGER = "faas.trigger";
  var TMP_FAAS_EXECUTION = "faas.execution";
  var TMP_FAAS_DOCUMENT_COLLECTION = "faas.document.collection";
  var TMP_FAAS_DOCUMENT_OPERATION = "faas.document.operation";
  var TMP_FAAS_DOCUMENT_TIME = "faas.document.time";
  var TMP_FAAS_DOCUMENT_NAME = "faas.document.name";
  var TMP_FAAS_TIME = "faas.time";
  var TMP_FAAS_CRON = "faas.cron";
  var TMP_FAAS_COLDSTART = "faas.coldstart";
  var TMP_FAAS_INVOKED_NAME = "faas.invoked_name";
  var TMP_FAAS_INVOKED_PROVIDER = "faas.invoked_provider";
  var TMP_FAAS_INVOKED_REGION = "faas.invoked_region";
  var TMP_NET_TRANSPORT = "net.transport";
  var TMP_NET_PEER_IP = "net.peer.ip";
  var TMP_NET_PEER_PORT = "net.peer.port";
  var TMP_NET_PEER_NAME = "net.peer.name";
  var TMP_NET_HOST_IP = "net.host.ip";
  var TMP_NET_HOST_PORT = "net.host.port";
  var TMP_NET_HOST_NAME = "net.host.name";
  var TMP_NET_HOST_CONNECTION_TYPE = "net.host.connection.type";
  var TMP_NET_HOST_CONNECTION_SUBTYPE = "net.host.connection.subtype";
  var TMP_NET_HOST_CARRIER_NAME = "net.host.carrier.name";
  var TMP_NET_HOST_CARRIER_MCC = "net.host.carrier.mcc";
  var TMP_NET_HOST_CARRIER_MNC = "net.host.carrier.mnc";
  var TMP_NET_HOST_CARRIER_ICC = "net.host.carrier.icc";
  var TMP_PEER_SERVICE = "peer.service";
  var TMP_ENDUSER_ID = "enduser.id";
  var TMP_ENDUSER_ROLE = "enduser.role";
  var TMP_ENDUSER_SCOPE = "enduser.scope";
  var TMP_THREAD_ID = "thread.id";
  var TMP_THREAD_NAME = "thread.name";
  var TMP_CODE_FUNCTION = "code.function";
  var TMP_CODE_NAMESPACE = "code.namespace";
  var TMP_CODE_FILEPATH = "code.filepath";
  var TMP_CODE_LINENO = "code.lineno";
  var TMP_HTTP_METHOD = "http.method";
  var TMP_HTTP_URL = "http.url";
  var TMP_HTTP_TARGET = "http.target";
  var TMP_HTTP_HOST = "http.host";
  var TMP_HTTP_SCHEME = "http.scheme";
  var TMP_HTTP_STATUS_CODE = "http.status_code";
  var TMP_HTTP_FLAVOR = "http.flavor";
  var TMP_HTTP_USER_AGENT = "http.user_agent";
  var TMP_HTTP_REQUEST_CONTENT_LENGTH = "http.request_content_length";
  var TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = "http.request_content_length_uncompressed";
  var TMP_HTTP_RESPONSE_CONTENT_LENGTH = "http.response_content_length";
  var TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = "http.response_content_length_uncompressed";
  var TMP_HTTP_SERVER_NAME = "http.server_name";
  var TMP_HTTP_ROUTE = "http.route";
  var TMP_HTTP_CLIENT_IP = "http.client_ip";
  var TMP_AWS_DYNAMODB_TABLE_NAMES = "aws.dynamodb.table_names";
  var TMP_AWS_DYNAMODB_CONSUMED_CAPACITY = "aws.dynamodb.consumed_capacity";
  var TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = "aws.dynamodb.item_collection_metrics";
  var TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = "aws.dynamodb.provisioned_read_capacity";
  var TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = "aws.dynamodb.provisioned_write_capacity";
  var TMP_AWS_DYNAMODB_CONSISTENT_READ = "aws.dynamodb.consistent_read";
  var TMP_AWS_DYNAMODB_PROJECTION = "aws.dynamodb.projection";
  var TMP_AWS_DYNAMODB_LIMIT = "aws.dynamodb.limit";
  var TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET = "aws.dynamodb.attributes_to_get";
  var TMP_AWS_DYNAMODB_INDEX_NAME = "aws.dynamodb.index_name";
  var TMP_AWS_DYNAMODB_SELECT = "aws.dynamodb.select";
  var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = "aws.dynamodb.global_secondary_indexes";
  var TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = "aws.dynamodb.local_secondary_indexes";
  var TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = "aws.dynamodb.exclusive_start_table";
  var TMP_AWS_DYNAMODB_TABLE_COUNT = "aws.dynamodb.table_count";
  var TMP_AWS_DYNAMODB_SCAN_FORWARD = "aws.dynamodb.scan_forward";
  var TMP_AWS_DYNAMODB_SEGMENT = "aws.dynamodb.segment";
  var TMP_AWS_DYNAMODB_TOTAL_SEGMENTS = "aws.dynamodb.total_segments";
  var TMP_AWS_DYNAMODB_COUNT = "aws.dynamodb.count";
  var TMP_AWS_DYNAMODB_SCANNED_COUNT = "aws.dynamodb.scanned_count";
  var TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = "aws.dynamodb.attribute_definitions";
  var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = "aws.dynamodb.global_secondary_index_updates";
  var TMP_MESSAGING_SYSTEM = "messaging.system";
  var TMP_MESSAGING_DESTINATION = "messaging.destination";
  var TMP_MESSAGING_DESTINATION_KIND = "messaging.destination_kind";
  var TMP_MESSAGING_TEMP_DESTINATION = "messaging.temp_destination";
  var TMP_MESSAGING_PROTOCOL = "messaging.protocol";
  var TMP_MESSAGING_PROTOCOL_VERSION = "messaging.protocol_version";
  var TMP_MESSAGING_URL = "messaging.url";
  var TMP_MESSAGING_MESSAGE_ID = "messaging.message_id";
  var TMP_MESSAGING_CONVERSATION_ID = "messaging.conversation_id";
  var TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = "messaging.message_payload_size_bytes";
  var TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = "messaging.message_payload_compressed_size_bytes";
  var TMP_MESSAGING_OPERATION = "messaging.operation";
  var TMP_MESSAGING_CONSUMER_ID = "messaging.consumer_id";
  var TMP_MESSAGING_RABBITMQ_ROUTING_KEY = "messaging.rabbitmq.routing_key";
  var TMP_MESSAGING_KAFKA_MESSAGE_KEY = "messaging.kafka.message_key";
  var TMP_MESSAGING_KAFKA_CONSUMER_GROUP = "messaging.kafka.consumer_group";
  var TMP_MESSAGING_KAFKA_CLIENT_ID = "messaging.kafka.client_id";
  var TMP_MESSAGING_KAFKA_PARTITION = "messaging.kafka.partition";
  var TMP_MESSAGING_KAFKA_TOMBSTONE = "messaging.kafka.tombstone";
  var TMP_RPC_SYSTEM = "rpc.system";
  var TMP_RPC_SERVICE = "rpc.service";
  var TMP_RPC_METHOD = "rpc.method";
  var TMP_RPC_GRPC_STATUS_CODE = "rpc.grpc.status_code";
  var TMP_RPC_JSONRPC_VERSION = "rpc.jsonrpc.version";
  var TMP_RPC_JSONRPC_REQUEST_ID = "rpc.jsonrpc.request_id";
  var TMP_RPC_JSONRPC_ERROR_CODE = "rpc.jsonrpc.error_code";
  var TMP_RPC_JSONRPC_ERROR_MESSAGE = "rpc.jsonrpc.error_message";
  var TMP_MESSAGE_TYPE = "message.type";
  var TMP_MESSAGE_ID = "message.id";
  var TMP_MESSAGE_COMPRESSED_SIZE = "message.compressed_size";
  var TMP_MESSAGE_UNCOMPRESSED_SIZE = "message.uncompressed_size";
  exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN;
  exports.SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM;
  exports.SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING;
  exports.SEMATTRS_DB_USER = TMP_DB_USER;
  exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME;
  exports.SEMATTRS_DB_NAME = TMP_DB_NAME;
  exports.SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT;
  exports.SEMATTRS_DB_OPERATION = TMP_DB_OPERATION;
  exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME;
  exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE;
  exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE;
  exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL;
  exports.SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE;
  exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE;
  exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT;
  exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID;
  exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC;
  exports.SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE;
  exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX;
  exports.SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION;
  exports.SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE;
  exports.SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;
  exports.SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;
  exports.SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;
  exports.SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED;
  exports.SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER;
  exports.SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION;
  exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION;
  exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION;
  exports.SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME;
  exports.SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME;
  exports.SEMATTRS_FAAS_TIME = TMP_FAAS_TIME;
  exports.SEMATTRS_FAAS_CRON = TMP_FAAS_CRON;
  exports.SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART;
  exports.SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME;
  exports.SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER;
  exports.SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION;
  exports.SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT;
  exports.SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP;
  exports.SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT;
  exports.SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME;
  exports.SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP;
  exports.SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT;
  exports.SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME;
  exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE;
  exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE;
  exports.SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME;
  exports.SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC;
  exports.SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC;
  exports.SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC;
  exports.SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE;
  exports.SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID;
  exports.SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE;
  exports.SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE;
  exports.SEMATTRS_THREAD_ID = TMP_THREAD_ID;
  exports.SEMATTRS_THREAD_NAME = TMP_THREAD_NAME;
  exports.SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION;
  exports.SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE;
  exports.SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH;
  exports.SEMATTRS_CODE_LINENO = TMP_CODE_LINENO;
  exports.SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD;
  exports.SEMATTRS_HTTP_URL = TMP_HTTP_URL;
  exports.SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET;
  exports.SEMATTRS_HTTP_HOST = TMP_HTTP_HOST;
  exports.SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME;
  exports.SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE;
  exports.SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR;
  exports.SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT;
  exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH;
  exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED;
  exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH;
  exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED;
  exports.SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME;
  exports.SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE;
  exports.SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP;
  exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES;
  exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS;
  exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ;
  exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION;
  exports.SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT;
  exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET;
  exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME;
  exports.SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT;
  exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES;
  exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES;
  exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE;
  exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD;
  exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT;
  exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS;
  exports.SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS;
  exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES;
  exports.SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM;
  exports.SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION;
  exports.SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND;
  exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION;
  exports.SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL;
  exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION;
  exports.SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL;
  exports.SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID;
  exports.SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID;
  exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES;
  exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES;
  exports.SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION;
  exports.SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID;
  exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY;
  exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY;
  exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP;
  exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID;
  exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION;
  exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE;
  exports.SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM;
  exports.SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE;
  exports.SEMATTRS_RPC_METHOD = TMP_RPC_METHOD;
  exports.SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE;
  exports.SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION;
  exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID;
  exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE;
  exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE;
  exports.SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE;
  exports.SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID;
  exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE;
  exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE;
  exports.SemanticAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_AWS_LAMBDA_INVOKED_ARN,
    TMP_DB_SYSTEM,
    TMP_DB_CONNECTION_STRING,
    TMP_DB_USER,
    TMP_DB_JDBC_DRIVER_CLASSNAME,
    TMP_DB_NAME,
    TMP_DB_STATEMENT,
    TMP_DB_OPERATION,
    TMP_DB_MSSQL_INSTANCE_NAME,
    TMP_DB_CASSANDRA_KEYSPACE,
    TMP_DB_CASSANDRA_PAGE_SIZE,
    TMP_DB_CASSANDRA_CONSISTENCY_LEVEL,
    TMP_DB_CASSANDRA_TABLE,
    TMP_DB_CASSANDRA_IDEMPOTENCE,
    TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
    TMP_DB_CASSANDRA_COORDINATOR_ID,
    TMP_DB_CASSANDRA_COORDINATOR_DC,
    TMP_DB_HBASE_NAMESPACE,
    TMP_DB_REDIS_DATABASE_INDEX,
    TMP_DB_MONGODB_COLLECTION,
    TMP_DB_SQL_TABLE,
    TMP_EXCEPTION_TYPE,
    TMP_EXCEPTION_MESSAGE,
    TMP_EXCEPTION_STACKTRACE,
    TMP_EXCEPTION_ESCAPED,
    TMP_FAAS_TRIGGER,
    TMP_FAAS_EXECUTION,
    TMP_FAAS_DOCUMENT_COLLECTION,
    TMP_FAAS_DOCUMENT_OPERATION,
    TMP_FAAS_DOCUMENT_TIME,
    TMP_FAAS_DOCUMENT_NAME,
    TMP_FAAS_TIME,
    TMP_FAAS_CRON,
    TMP_FAAS_COLDSTART,
    TMP_FAAS_INVOKED_NAME,
    TMP_FAAS_INVOKED_PROVIDER,
    TMP_FAAS_INVOKED_REGION,
    TMP_NET_TRANSPORT,
    TMP_NET_PEER_IP,
    TMP_NET_PEER_PORT,
    TMP_NET_PEER_NAME,
    TMP_NET_HOST_IP,
    TMP_NET_HOST_PORT,
    TMP_NET_HOST_NAME,
    TMP_NET_HOST_CONNECTION_TYPE,
    TMP_NET_HOST_CONNECTION_SUBTYPE,
    TMP_NET_HOST_CARRIER_NAME,
    TMP_NET_HOST_CARRIER_MCC,
    TMP_NET_HOST_CARRIER_MNC,
    TMP_NET_HOST_CARRIER_ICC,
    TMP_PEER_SERVICE,
    TMP_ENDUSER_ID,
    TMP_ENDUSER_ROLE,
    TMP_ENDUSER_SCOPE,
    TMP_THREAD_ID,
    TMP_THREAD_NAME,
    TMP_CODE_FUNCTION,
    TMP_CODE_NAMESPACE,
    TMP_CODE_FILEPATH,
    TMP_CODE_LINENO,
    TMP_HTTP_METHOD,
    TMP_HTTP_URL,
    TMP_HTTP_TARGET,
    TMP_HTTP_HOST,
    TMP_HTTP_SCHEME,
    TMP_HTTP_STATUS_CODE,
    TMP_HTTP_FLAVOR,
    TMP_HTTP_USER_AGENT,
    TMP_HTTP_REQUEST_CONTENT_LENGTH,
    TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
    TMP_HTTP_RESPONSE_CONTENT_LENGTH,
    TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
    TMP_HTTP_SERVER_NAME,
    TMP_HTTP_ROUTE,
    TMP_HTTP_CLIENT_IP,
    TMP_AWS_DYNAMODB_TABLE_NAMES,
    TMP_AWS_DYNAMODB_CONSUMED_CAPACITY,
    TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
    TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
    TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
    TMP_AWS_DYNAMODB_CONSISTENT_READ,
    TMP_AWS_DYNAMODB_PROJECTION,
    TMP_AWS_DYNAMODB_LIMIT,
    TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
    TMP_AWS_DYNAMODB_INDEX_NAME,
    TMP_AWS_DYNAMODB_SELECT,
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
    TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
    TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
    TMP_AWS_DYNAMODB_TABLE_COUNT,
    TMP_AWS_DYNAMODB_SCAN_FORWARD,
    TMP_AWS_DYNAMODB_SEGMENT,
    TMP_AWS_DYNAMODB_TOTAL_SEGMENTS,
    TMP_AWS_DYNAMODB_COUNT,
    TMP_AWS_DYNAMODB_SCANNED_COUNT,
    TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
    TMP_MESSAGING_SYSTEM,
    TMP_MESSAGING_DESTINATION,
    TMP_MESSAGING_DESTINATION_KIND,
    TMP_MESSAGING_TEMP_DESTINATION,
    TMP_MESSAGING_PROTOCOL,
    TMP_MESSAGING_PROTOCOL_VERSION,
    TMP_MESSAGING_URL,
    TMP_MESSAGING_MESSAGE_ID,
    TMP_MESSAGING_CONVERSATION_ID,
    TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
    TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
    TMP_MESSAGING_OPERATION,
    TMP_MESSAGING_CONSUMER_ID,
    TMP_MESSAGING_RABBITMQ_ROUTING_KEY,
    TMP_MESSAGING_KAFKA_MESSAGE_KEY,
    TMP_MESSAGING_KAFKA_CONSUMER_GROUP,
    TMP_MESSAGING_KAFKA_CLIENT_ID,
    TMP_MESSAGING_KAFKA_PARTITION,
    TMP_MESSAGING_KAFKA_TOMBSTONE,
    TMP_RPC_SYSTEM,
    TMP_RPC_SERVICE,
    TMP_RPC_METHOD,
    TMP_RPC_GRPC_STATUS_CODE,
    TMP_RPC_JSONRPC_VERSION,
    TMP_RPC_JSONRPC_REQUEST_ID,
    TMP_RPC_JSONRPC_ERROR_CODE,
    TMP_RPC_JSONRPC_ERROR_MESSAGE,
    TMP_MESSAGE_TYPE,
    TMP_MESSAGE_ID,
    TMP_MESSAGE_COMPRESSED_SIZE,
    TMP_MESSAGE_UNCOMPRESSED_SIZE
  ]);
  var TMP_DBSYSTEMVALUES_OTHER_SQL = "other_sql";
  var TMP_DBSYSTEMVALUES_MSSQL = "mssql";
  var TMP_DBSYSTEMVALUES_MYSQL = "mysql";
  var TMP_DBSYSTEMVALUES_ORACLE = "oracle";
  var TMP_DBSYSTEMVALUES_DB2 = "db2";
  var TMP_DBSYSTEMVALUES_POSTGRESQL = "postgresql";
  var TMP_DBSYSTEMVALUES_REDSHIFT = "redshift";
  var TMP_DBSYSTEMVALUES_HIVE = "hive";
  var TMP_DBSYSTEMVALUES_CLOUDSCAPE = "cloudscape";
  var TMP_DBSYSTEMVALUES_HSQLDB = "hsqldb";
  var TMP_DBSYSTEMVALUES_PROGRESS = "progress";
  var TMP_DBSYSTEMVALUES_MAXDB = "maxdb";
  var TMP_DBSYSTEMVALUES_HANADB = "hanadb";
  var TMP_DBSYSTEMVALUES_INGRES = "ingres";
  var TMP_DBSYSTEMVALUES_FIRSTSQL = "firstsql";
  var TMP_DBSYSTEMVALUES_EDB = "edb";
  var TMP_DBSYSTEMVALUES_CACHE = "cache";
  var TMP_DBSYSTEMVALUES_ADABAS = "adabas";
  var TMP_DBSYSTEMVALUES_FIREBIRD = "firebird";
  var TMP_DBSYSTEMVALUES_DERBY = "derby";
  var TMP_DBSYSTEMVALUES_FILEMAKER = "filemaker";
  var TMP_DBSYSTEMVALUES_INFORMIX = "informix";
  var TMP_DBSYSTEMVALUES_INSTANTDB = "instantdb";
  var TMP_DBSYSTEMVALUES_INTERBASE = "interbase";
  var TMP_DBSYSTEMVALUES_MARIADB = "mariadb";
  var TMP_DBSYSTEMVALUES_NETEZZA = "netezza";
  var TMP_DBSYSTEMVALUES_PERVASIVE = "pervasive";
  var TMP_DBSYSTEMVALUES_POINTBASE = "pointbase";
  var TMP_DBSYSTEMVALUES_SQLITE = "sqlite";
  var TMP_DBSYSTEMVALUES_SYBASE = "sybase";
  var TMP_DBSYSTEMVALUES_TERADATA = "teradata";
  var TMP_DBSYSTEMVALUES_VERTICA = "vertica";
  var TMP_DBSYSTEMVALUES_H2 = "h2";
  var TMP_DBSYSTEMVALUES_COLDFUSION = "coldfusion";
  var TMP_DBSYSTEMVALUES_CASSANDRA = "cassandra";
  var TMP_DBSYSTEMVALUES_HBASE = "hbase";
  var TMP_DBSYSTEMVALUES_MONGODB = "mongodb";
  var TMP_DBSYSTEMVALUES_REDIS = "redis";
  var TMP_DBSYSTEMVALUES_COUCHBASE = "couchbase";
  var TMP_DBSYSTEMVALUES_COUCHDB = "couchdb";
  var TMP_DBSYSTEMVALUES_COSMOSDB = "cosmosdb";
  var TMP_DBSYSTEMVALUES_DYNAMODB = "dynamodb";
  var TMP_DBSYSTEMVALUES_NEO4J = "neo4j";
  var TMP_DBSYSTEMVALUES_GEODE = "geode";
  var TMP_DBSYSTEMVALUES_ELASTICSEARCH = "elasticsearch";
  var TMP_DBSYSTEMVALUES_MEMCACHED = "memcached";
  var TMP_DBSYSTEMVALUES_COCKROACHDB = "cockroachdb";
  exports.DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL;
  exports.DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL;
  exports.DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL;
  exports.DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE;
  exports.DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB2;
  exports.DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL;
  exports.DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT;
  exports.DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE;
  exports.DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE;
  exports.DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB;
  exports.DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS;
  exports.DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB;
  exports.DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB;
  exports.DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES;
  exports.DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL;
  exports.DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB;
  exports.DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE;
  exports.DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS;
  exports.DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD;
  exports.DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY;
  exports.DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER;
  exports.DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX;
  exports.DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB;
  exports.DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE;
  exports.DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB;
  exports.DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA;
  exports.DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE;
  exports.DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE;
  exports.DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE;
  exports.DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE;
  exports.DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA;
  exports.DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA;
  exports.DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H2;
  exports.DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION;
  exports.DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA;
  exports.DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE;
  exports.DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB;
  exports.DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS;
  exports.DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE;
  exports.DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB;
  exports.DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB;
  exports.DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB;
  exports.DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J;
  exports.DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE;
  exports.DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH;
  exports.DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED;
  exports.DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB;
  exports.DbSystemValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_DBSYSTEMVALUES_OTHER_SQL,
    TMP_DBSYSTEMVALUES_MSSQL,
    TMP_DBSYSTEMVALUES_MYSQL,
    TMP_DBSYSTEMVALUES_ORACLE,
    TMP_DBSYSTEMVALUES_DB2,
    TMP_DBSYSTEMVALUES_POSTGRESQL,
    TMP_DBSYSTEMVALUES_REDSHIFT,
    TMP_DBSYSTEMVALUES_HIVE,
    TMP_DBSYSTEMVALUES_CLOUDSCAPE,
    TMP_DBSYSTEMVALUES_HSQLDB,
    TMP_DBSYSTEMVALUES_PROGRESS,
    TMP_DBSYSTEMVALUES_MAXDB,
    TMP_DBSYSTEMVALUES_HANADB,
    TMP_DBSYSTEMVALUES_INGRES,
    TMP_DBSYSTEMVALUES_FIRSTSQL,
    TMP_DBSYSTEMVALUES_EDB,
    TMP_DBSYSTEMVALUES_CACHE,
    TMP_DBSYSTEMVALUES_ADABAS,
    TMP_DBSYSTEMVALUES_FIREBIRD,
    TMP_DBSYSTEMVALUES_DERBY,
    TMP_DBSYSTEMVALUES_FILEMAKER,
    TMP_DBSYSTEMVALUES_INFORMIX,
    TMP_DBSYSTEMVALUES_INSTANTDB,
    TMP_DBSYSTEMVALUES_INTERBASE,
    TMP_DBSYSTEMVALUES_MARIADB,
    TMP_DBSYSTEMVALUES_NETEZZA,
    TMP_DBSYSTEMVALUES_PERVASIVE,
    TMP_DBSYSTEMVALUES_POINTBASE,
    TMP_DBSYSTEMVALUES_SQLITE,
    TMP_DBSYSTEMVALUES_SYBASE,
    TMP_DBSYSTEMVALUES_TERADATA,
    TMP_DBSYSTEMVALUES_VERTICA,
    TMP_DBSYSTEMVALUES_H2,
    TMP_DBSYSTEMVALUES_COLDFUSION,
    TMP_DBSYSTEMVALUES_CASSANDRA,
    TMP_DBSYSTEMVALUES_HBASE,
    TMP_DBSYSTEMVALUES_MONGODB,
    TMP_DBSYSTEMVALUES_REDIS,
    TMP_DBSYSTEMVALUES_COUCHBASE,
    TMP_DBSYSTEMVALUES_COUCHDB,
    TMP_DBSYSTEMVALUES_COSMOSDB,
    TMP_DBSYSTEMVALUES_DYNAMODB,
    TMP_DBSYSTEMVALUES_NEO4J,
    TMP_DBSYSTEMVALUES_GEODE,
    TMP_DBSYSTEMVALUES_ELASTICSEARCH,
    TMP_DBSYSTEMVALUES_MEMCACHED,
    TMP_DBSYSTEMVALUES_COCKROACHDB
  ]);
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL = "all";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = "each_quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = "quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = "local_quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE = "one";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO = "two";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE = "three";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = "local_one";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY = "any";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = "serial";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = "local_serial";
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL;
  exports.DbCassandraConsistencyLevelValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL
  ]);
  var TMP_FAASTRIGGERVALUES_DATASOURCE = "datasource";
  var TMP_FAASTRIGGERVALUES_HTTP = "http";
  var TMP_FAASTRIGGERVALUES_PUBSUB = "pubsub";
  var TMP_FAASTRIGGERVALUES_TIMER = "timer";
  var TMP_FAASTRIGGERVALUES_OTHER = "other";
  exports.FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE;
  exports.FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP;
  exports.FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB;
  exports.FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER;
  exports.FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER;
  exports.FaasTriggerValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASTRIGGERVALUES_DATASOURCE,
    TMP_FAASTRIGGERVALUES_HTTP,
    TMP_FAASTRIGGERVALUES_PUBSUB,
    TMP_FAASTRIGGERVALUES_TIMER,
    TMP_FAASTRIGGERVALUES_OTHER
  ]);
  var TMP_FAASDOCUMENTOPERATIONVALUES_INSERT = "insert";
  var TMP_FAASDOCUMENTOPERATIONVALUES_EDIT = "edit";
  var TMP_FAASDOCUMENTOPERATIONVALUES_DELETE = "delete";
  exports.FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT;
  exports.FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT;
  exports.FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE;
  exports.FaasDocumentOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASDOCUMENTOPERATIONVALUES_INSERT,
    TMP_FAASDOCUMENTOPERATIONVALUES_EDIT,
    TMP_FAASDOCUMENTOPERATIONVALUES_DELETE
  ]);
  var TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
  var TMP_FAASINVOKEDPROVIDERVALUES_AWS = "aws";
  var TMP_FAASINVOKEDPROVIDERVALUES_AZURE = "azure";
  var TMP_FAASINVOKEDPROVIDERVALUES_GCP = "gcp";
  exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD;
  exports.FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS;
  exports.FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE;
  exports.FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP;
  exports.FaasInvokedProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
    TMP_FAASINVOKEDPROVIDERVALUES_AWS,
    TMP_FAASINVOKEDPROVIDERVALUES_AZURE,
    TMP_FAASINVOKEDPROVIDERVALUES_GCP
  ]);
  var TMP_NETTRANSPORTVALUES_IP_TCP = "ip_tcp";
  var TMP_NETTRANSPORTVALUES_IP_UDP = "ip_udp";
  var TMP_NETTRANSPORTVALUES_IP = "ip";
  var TMP_NETTRANSPORTVALUES_UNIX = "unix";
  var TMP_NETTRANSPORTVALUES_PIPE = "pipe";
  var TMP_NETTRANSPORTVALUES_INPROC = "inproc";
  var TMP_NETTRANSPORTVALUES_OTHER = "other";
  exports.NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP;
  exports.NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP;
  exports.NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP;
  exports.NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX;
  exports.NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE;
  exports.NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC;
  exports.NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER;
  exports.NetTransportValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETTRANSPORTVALUES_IP_TCP,
    TMP_NETTRANSPORTVALUES_IP_UDP,
    TMP_NETTRANSPORTVALUES_IP,
    TMP_NETTRANSPORTVALUES_UNIX,
    TMP_NETTRANSPORTVALUES_PIPE,
    TMP_NETTRANSPORTVALUES_INPROC,
    TMP_NETTRANSPORTVALUES_OTHER
  ]);
  var TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI = "wifi";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED = "wired";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_CELL = "cell";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = "unavailable";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = "unknown";
  exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI;
  exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED;
  exports.NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL;
  exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE;
  exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN;
  exports.NetHostConnectionTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI,
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED,
    TMP_NETHOSTCONNECTIONTYPEVALUES_CELL,
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN
  ]);
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = "gprs";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = "edge";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = "umts";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = "cdma";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = "evdo_0";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = "evdo_a";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = "cdma2000_1xrtt";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = "hsdpa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = "hsupa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = "hspa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = "iden";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = "evdo_b";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE = "lte";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = "ehrpd";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = "hspap";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM = "gsm";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = "td_scdma";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = "iwlan";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR = "nr";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = "nrnsa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = "lte_ca";
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA;
  exports.NetHostConnectionSubtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA
  ]);
  var TMP_HTTPFLAVORVALUES_HTTP_1_0 = "1.0";
  var TMP_HTTPFLAVORVALUES_HTTP_1_1 = "1.1";
  var TMP_HTTPFLAVORVALUES_HTTP_2_0 = "2.0";
  var TMP_HTTPFLAVORVALUES_SPDY = "SPDY";
  var TMP_HTTPFLAVORVALUES_QUIC = "QUIC";
  exports.HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_0;
  exports.HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_1;
  exports.HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_0;
  exports.HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY;
  exports.HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC;
  exports.HttpFlavorValues = {
    HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_0,
    HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_1,
    HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_0,
    SPDY: TMP_HTTPFLAVORVALUES_SPDY,
    QUIC: TMP_HTTPFLAVORVALUES_QUIC
  };
  var TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE = "queue";
  var TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC = "topic";
  exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE;
  exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC;
  exports.MessagingDestinationKindValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE,
    TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC
  ]);
  var TMP_MESSAGINGOPERATIONVALUES_RECEIVE = "receive";
  var TMP_MESSAGINGOPERATIONVALUES_PROCESS = "process";
  exports.MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE;
  exports.MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS;
  exports.MessagingOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGINGOPERATIONVALUES_RECEIVE,
    TMP_MESSAGINGOPERATIONVALUES_PROCESS
  ]);
  var TMP_RPCGRPCSTATUSCODEVALUES_OK = 0;
  var TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED = 1;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN = 2;
  var TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = 3;
  var TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = 4;
  var TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND = 5;
  var TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = 6;
  var TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = 7;
  var TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = 8;
  var TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = 9;
  var TMP_RPCGRPCSTATUSCODEVALUES_ABORTED = 10;
  var TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = 11;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = 12;
  var TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL = 13;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = 14;
  var TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS = 15;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = 16;
  exports.RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK;
  exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED;
  exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN;
  exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT;
  exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED;
  exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND;
  exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS;
  exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED;
  exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED;
  exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION;
  exports.RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED;
  exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE;
  exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED;
  exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL;
  exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE;
  exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS;
  exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED;
  exports.RpcGrpcStatusCodeValues = {
    OK: TMP_RPCGRPCSTATUSCODEVALUES_OK,
    CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED,
    UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN,
    INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
    DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
    NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
    ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
    PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
    RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
    FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
    ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED,
    OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
    UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
    INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL,
    UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
    DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
    UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED
  };
  var TMP_MESSAGETYPEVALUES_SENT = "SENT";
  var TMP_MESSAGETYPEVALUES_RECEIVED = "RECEIVED";
  exports.MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT;
  exports.MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED;
  exports.MessageTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGETYPEVALUES_SENT,
    TMP_MESSAGETYPEVALUES_RECEIVED
  ]);
});

// ../../node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js
var require_trace2 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(require_SemanticAttributes(), exports);
});

// ../../node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js
var require_SemanticResourceAttributes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SEMRESATTRS_K8S_STATEFULSET_NAME = exports.SEMRESATTRS_K8S_STATEFULSET_UID = exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = exports.SEMRESATTRS_K8S_REPLICASET_NAME = exports.SEMRESATTRS_K8S_REPLICASET_UID = exports.SEMRESATTRS_K8S_CONTAINER_NAME = exports.SEMRESATTRS_K8S_POD_NAME = exports.SEMRESATTRS_K8S_POD_UID = exports.SEMRESATTRS_K8S_NAMESPACE_NAME = exports.SEMRESATTRS_K8S_NODE_UID = exports.SEMRESATTRS_K8S_NODE_NAME = exports.SEMRESATTRS_K8S_CLUSTER_NAME = exports.SEMRESATTRS_HOST_IMAGE_VERSION = exports.SEMRESATTRS_HOST_IMAGE_ID = exports.SEMRESATTRS_HOST_IMAGE_NAME = exports.SEMRESATTRS_HOST_ARCH = exports.SEMRESATTRS_HOST_TYPE = exports.SEMRESATTRS_HOST_NAME = exports.SEMRESATTRS_HOST_ID = exports.SEMRESATTRS_FAAS_MAX_MEMORY = exports.SEMRESATTRS_FAAS_INSTANCE = exports.SEMRESATTRS_FAAS_VERSION = exports.SEMRESATTRS_FAAS_ID = exports.SEMRESATTRS_FAAS_NAME = exports.SEMRESATTRS_DEVICE_MODEL_NAME = exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = exports.SEMRESATTRS_DEVICE_ID = exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = exports.SEMRESATTRS_CONTAINER_RUNTIME = exports.SEMRESATTRS_CONTAINER_ID = exports.SEMRESATTRS_CONTAINER_NAME = exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = exports.SEMRESATTRS_AWS_ECS_TASK_ARN = exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = exports.SEMRESATTRS_CLOUD_PLATFORM = exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = exports.SEMRESATTRS_CLOUD_REGION = exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = exports.SEMRESATTRS_CLOUD_PROVIDER = undefined;
  exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = exports.CLOUDPLATFORMVALUES_AZURE_AKS = exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = exports.CLOUDPLATFORMVALUES_AZURE_VM = exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = exports.CLOUDPLATFORMVALUES_AWS_EKS = exports.CLOUDPLATFORMVALUES_AWS_ECS = exports.CLOUDPLATFORMVALUES_AWS_EC2 = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = exports.CloudProviderValues = exports.CLOUDPROVIDERVALUES_GCP = exports.CLOUDPROVIDERVALUES_AZURE = exports.CLOUDPROVIDERVALUES_AWS = exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = exports.SemanticResourceAttributes = exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = exports.SEMRESATTRS_WEBENGINE_VERSION = exports.SEMRESATTRS_WEBENGINE_NAME = exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = exports.SEMRESATTRS_TELEMETRY_SDK_NAME = exports.SEMRESATTRS_SERVICE_VERSION = exports.SEMRESATTRS_SERVICE_INSTANCE_ID = exports.SEMRESATTRS_SERVICE_NAMESPACE = exports.SEMRESATTRS_SERVICE_NAME = exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = exports.SEMRESATTRS_PROCESS_OWNER = exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = exports.SEMRESATTRS_PROCESS_COMMAND_LINE = exports.SEMRESATTRS_PROCESS_COMMAND = exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = exports.SEMRESATTRS_PROCESS_PID = exports.SEMRESATTRS_OS_VERSION = exports.SEMRESATTRS_OS_NAME = exports.SEMRESATTRS_OS_DESCRIPTION = exports.SEMRESATTRS_OS_TYPE = exports.SEMRESATTRS_K8S_CRONJOB_NAME = exports.SEMRESATTRS_K8S_CRONJOB_UID = exports.SEMRESATTRS_K8S_JOB_NAME = exports.SEMRESATTRS_K8S_JOB_UID = exports.SEMRESATTRS_K8S_DAEMONSET_NAME = exports.SEMRESATTRS_K8S_DAEMONSET_UID = undefined;
  exports.TelemetrySdkLanguageValues = exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = exports.TELEMETRYSDKLANGUAGEVALUES_PHP = exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = exports.TELEMETRYSDKLANGUAGEVALUES_GO = exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = exports.TELEMETRYSDKLANGUAGEVALUES_CPP = exports.OsTypeValues = exports.OSTYPEVALUES_Z_OS = exports.OSTYPEVALUES_SOLARIS = exports.OSTYPEVALUES_AIX = exports.OSTYPEVALUES_HPUX = exports.OSTYPEVALUES_DRAGONFLYBSD = exports.OSTYPEVALUES_OPENBSD = exports.OSTYPEVALUES_NETBSD = exports.OSTYPEVALUES_FREEBSD = exports.OSTYPEVALUES_DARWIN = exports.OSTYPEVALUES_LINUX = exports.OSTYPEVALUES_WINDOWS = exports.HostArchValues = exports.HOSTARCHVALUES_X86 = exports.HOSTARCHVALUES_PPC64 = exports.HOSTARCHVALUES_PPC32 = exports.HOSTARCHVALUES_IA64 = exports.HOSTARCHVALUES_ARM64 = exports.HOSTARCHVALUES_ARM32 = exports.HOSTARCHVALUES_AMD64 = exports.AwsEcsLaunchtypeValues = exports.AWSECSLAUNCHTYPEVALUES_FARGATE = exports.AWSECSLAUNCHTYPEVALUES_EC2 = exports.CloudPlatformValues = exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = undefined;
  var utils_1 = require_utils4();
  var TMP_CLOUD_PROVIDER = "cloud.provider";
  var TMP_CLOUD_ACCOUNT_ID = "cloud.account.id";
  var TMP_CLOUD_REGION = "cloud.region";
  var TMP_CLOUD_AVAILABILITY_ZONE = "cloud.availability_zone";
  var TMP_CLOUD_PLATFORM = "cloud.platform";
  var TMP_AWS_ECS_CONTAINER_ARN = "aws.ecs.container.arn";
  var TMP_AWS_ECS_CLUSTER_ARN = "aws.ecs.cluster.arn";
  var TMP_AWS_ECS_LAUNCHTYPE = "aws.ecs.launchtype";
  var TMP_AWS_ECS_TASK_ARN = "aws.ecs.task.arn";
  var TMP_AWS_ECS_TASK_FAMILY = "aws.ecs.task.family";
  var TMP_AWS_ECS_TASK_REVISION = "aws.ecs.task.revision";
  var TMP_AWS_EKS_CLUSTER_ARN = "aws.eks.cluster.arn";
  var TMP_AWS_LOG_GROUP_NAMES = "aws.log.group.names";
  var TMP_AWS_LOG_GROUP_ARNS = "aws.log.group.arns";
  var TMP_AWS_LOG_STREAM_NAMES = "aws.log.stream.names";
  var TMP_AWS_LOG_STREAM_ARNS = "aws.log.stream.arns";
  var TMP_CONTAINER_NAME = "container.name";
  var TMP_CONTAINER_ID = "container.id";
  var TMP_CONTAINER_RUNTIME = "container.runtime";
  var TMP_CONTAINER_IMAGE_NAME = "container.image.name";
  var TMP_CONTAINER_IMAGE_TAG = "container.image.tag";
  var TMP_DEPLOYMENT_ENVIRONMENT = "deployment.environment";
  var TMP_DEVICE_ID = "device.id";
  var TMP_DEVICE_MODEL_IDENTIFIER = "device.model.identifier";
  var TMP_DEVICE_MODEL_NAME = "device.model.name";
  var TMP_FAAS_NAME = "faas.name";
  var TMP_FAAS_ID = "faas.id";
  var TMP_FAAS_VERSION = "faas.version";
  var TMP_FAAS_INSTANCE = "faas.instance";
  var TMP_FAAS_MAX_MEMORY = "faas.max_memory";
  var TMP_HOST_ID = "host.id";
  var TMP_HOST_NAME = "host.name";
  var TMP_HOST_TYPE = "host.type";
  var TMP_HOST_ARCH = "host.arch";
  var TMP_HOST_IMAGE_NAME = "host.image.name";
  var TMP_HOST_IMAGE_ID = "host.image.id";
  var TMP_HOST_IMAGE_VERSION = "host.image.version";
  var TMP_K8S_CLUSTER_NAME = "k8s.cluster.name";
  var TMP_K8S_NODE_NAME = "k8s.node.name";
  var TMP_K8S_NODE_UID = "k8s.node.uid";
  var TMP_K8S_NAMESPACE_NAME = "k8s.namespace.name";
  var TMP_K8S_POD_UID = "k8s.pod.uid";
  var TMP_K8S_POD_NAME = "k8s.pod.name";
  var TMP_K8S_CONTAINER_NAME = "k8s.container.name";
  var TMP_K8S_REPLICASET_UID = "k8s.replicaset.uid";
  var TMP_K8S_REPLICASET_NAME = "k8s.replicaset.name";
  var TMP_K8S_DEPLOYMENT_UID = "k8s.deployment.uid";
  var TMP_K8S_DEPLOYMENT_NAME = "k8s.deployment.name";
  var TMP_K8S_STATEFULSET_UID = "k8s.statefulset.uid";
  var TMP_K8S_STATEFULSET_NAME = "k8s.statefulset.name";
  var TMP_K8S_DAEMONSET_UID = "k8s.daemonset.uid";
  var TMP_K8S_DAEMONSET_NAME = "k8s.daemonset.name";
  var TMP_K8S_JOB_UID = "k8s.job.uid";
  var TMP_K8S_JOB_NAME = "k8s.job.name";
  var TMP_K8S_CRONJOB_UID = "k8s.cronjob.uid";
  var TMP_K8S_CRONJOB_NAME = "k8s.cronjob.name";
  var TMP_OS_TYPE = "os.type";
  var TMP_OS_DESCRIPTION = "os.description";
  var TMP_OS_NAME = "os.name";
  var TMP_OS_VERSION = "os.version";
  var TMP_PROCESS_PID = "process.pid";
  var TMP_PROCESS_EXECUTABLE_NAME = "process.executable.name";
  var TMP_PROCESS_EXECUTABLE_PATH = "process.executable.path";
  var TMP_PROCESS_COMMAND = "process.command";
  var TMP_PROCESS_COMMAND_LINE = "process.command_line";
  var TMP_PROCESS_COMMAND_ARGS = "process.command_args";
  var TMP_PROCESS_OWNER = "process.owner";
  var TMP_PROCESS_RUNTIME_NAME = "process.runtime.name";
  var TMP_PROCESS_RUNTIME_VERSION = "process.runtime.version";
  var TMP_PROCESS_RUNTIME_DESCRIPTION = "process.runtime.description";
  var TMP_SERVICE_NAME = "service.name";
  var TMP_SERVICE_NAMESPACE = "service.namespace";
  var TMP_SERVICE_INSTANCE_ID = "service.instance.id";
  var TMP_SERVICE_VERSION = "service.version";
  var TMP_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
  var TMP_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
  var TMP_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
  var TMP_TELEMETRY_AUTO_VERSION = "telemetry.auto.version";
  var TMP_WEBENGINE_NAME = "webengine.name";
  var TMP_WEBENGINE_VERSION = "webengine.version";
  var TMP_WEBENGINE_DESCRIPTION = "webengine.description";
  exports.SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER;
  exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID;
  exports.SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION;
  exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE;
  exports.SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM;
  exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN;
  exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN;
  exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE;
  exports.SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN;
  exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY;
  exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION;
  exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN;
  exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES;
  exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS;
  exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES;
  exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS;
  exports.SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME;
  exports.SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID;
  exports.SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME;
  exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME;
  exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG;
  exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT;
  exports.SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID;
  exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER;
  exports.SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME;
  exports.SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME;
  exports.SEMRESATTRS_FAAS_ID = TMP_FAAS_ID;
  exports.SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION;
  exports.SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE;
  exports.SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY;
  exports.SEMRESATTRS_HOST_ID = TMP_HOST_ID;
  exports.SEMRESATTRS_HOST_NAME = TMP_HOST_NAME;
  exports.SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE;
  exports.SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH;
  exports.SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME;
  exports.SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID;
  exports.SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION;
  exports.SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME;
  exports.SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME;
  exports.SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID;
  exports.SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME;
  exports.SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID;
  exports.SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME;
  exports.SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME;
  exports.SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID;
  exports.SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME;
  exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID;
  exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME;
  exports.SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID;
  exports.SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME;
  exports.SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID;
  exports.SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME;
  exports.SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID;
  exports.SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME;
  exports.SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID;
  exports.SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME;
  exports.SEMRESATTRS_OS_TYPE = TMP_OS_TYPE;
  exports.SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION;
  exports.SEMRESATTRS_OS_NAME = TMP_OS_NAME;
  exports.SEMRESATTRS_OS_VERSION = TMP_OS_VERSION;
  exports.SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID;
  exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME;
  exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH;
  exports.SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND;
  exports.SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE;
  exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS;
  exports.SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER;
  exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME;
  exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION;
  exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION;
  exports.SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME;
  exports.SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE;
  exports.SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID;
  exports.SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION;
  exports.SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME;
  exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE;
  exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION;
  exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION;
  exports.SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME;
  exports.SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION;
  exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION;
  exports.SemanticResourceAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUD_PROVIDER,
    TMP_CLOUD_ACCOUNT_ID,
    TMP_CLOUD_REGION,
    TMP_CLOUD_AVAILABILITY_ZONE,
    TMP_CLOUD_PLATFORM,
    TMP_AWS_ECS_CONTAINER_ARN,
    TMP_AWS_ECS_CLUSTER_ARN,
    TMP_AWS_ECS_LAUNCHTYPE,
    TMP_AWS_ECS_TASK_ARN,
    TMP_AWS_ECS_TASK_FAMILY,
    TMP_AWS_ECS_TASK_REVISION,
    TMP_AWS_EKS_CLUSTER_ARN,
    TMP_AWS_LOG_GROUP_NAMES,
    TMP_AWS_LOG_GROUP_ARNS,
    TMP_AWS_LOG_STREAM_NAMES,
    TMP_AWS_LOG_STREAM_ARNS,
    TMP_CONTAINER_NAME,
    TMP_CONTAINER_ID,
    TMP_CONTAINER_RUNTIME,
    TMP_CONTAINER_IMAGE_NAME,
    TMP_CONTAINER_IMAGE_TAG,
    TMP_DEPLOYMENT_ENVIRONMENT,
    TMP_DEVICE_ID,
    TMP_DEVICE_MODEL_IDENTIFIER,
    TMP_DEVICE_MODEL_NAME,
    TMP_FAAS_NAME,
    TMP_FAAS_ID,
    TMP_FAAS_VERSION,
    TMP_FAAS_INSTANCE,
    TMP_FAAS_MAX_MEMORY,
    TMP_HOST_ID,
    TMP_HOST_NAME,
    TMP_HOST_TYPE,
    TMP_HOST_ARCH,
    TMP_HOST_IMAGE_NAME,
    TMP_HOST_IMAGE_ID,
    TMP_HOST_IMAGE_VERSION,
    TMP_K8S_CLUSTER_NAME,
    TMP_K8S_NODE_NAME,
    TMP_K8S_NODE_UID,
    TMP_K8S_NAMESPACE_NAME,
    TMP_K8S_POD_UID,
    TMP_K8S_POD_NAME,
    TMP_K8S_CONTAINER_NAME,
    TMP_K8S_REPLICASET_UID,
    TMP_K8S_REPLICASET_NAME,
    TMP_K8S_DEPLOYMENT_UID,
    TMP_K8S_DEPLOYMENT_NAME,
    TMP_K8S_STATEFULSET_UID,
    TMP_K8S_STATEFULSET_NAME,
    TMP_K8S_DAEMONSET_UID,
    TMP_K8S_DAEMONSET_NAME,
    TMP_K8S_JOB_UID,
    TMP_K8S_JOB_NAME,
    TMP_K8S_CRONJOB_UID,
    TMP_K8S_CRONJOB_NAME,
    TMP_OS_TYPE,
    TMP_OS_DESCRIPTION,
    TMP_OS_NAME,
    TMP_OS_VERSION,
    TMP_PROCESS_PID,
    TMP_PROCESS_EXECUTABLE_NAME,
    TMP_PROCESS_EXECUTABLE_PATH,
    TMP_PROCESS_COMMAND,
    TMP_PROCESS_COMMAND_LINE,
    TMP_PROCESS_COMMAND_ARGS,
    TMP_PROCESS_OWNER,
    TMP_PROCESS_RUNTIME_NAME,
    TMP_PROCESS_RUNTIME_VERSION,
    TMP_PROCESS_RUNTIME_DESCRIPTION,
    TMP_SERVICE_NAME,
    TMP_SERVICE_NAMESPACE,
    TMP_SERVICE_INSTANCE_ID,
    TMP_SERVICE_VERSION,
    TMP_TELEMETRY_SDK_NAME,
    TMP_TELEMETRY_SDK_LANGUAGE,
    TMP_TELEMETRY_SDK_VERSION,
    TMP_TELEMETRY_AUTO_VERSION,
    TMP_WEBENGINE_NAME,
    TMP_WEBENGINE_VERSION,
    TMP_WEBENGINE_DESCRIPTION
  ]);
  var TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
  var TMP_CLOUDPROVIDERVALUES_AWS = "aws";
  var TMP_CLOUDPROVIDERVALUES_AZURE = "azure";
  var TMP_CLOUDPROVIDERVALUES_GCP = "gcp";
  exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD;
  exports.CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS;
  exports.CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE;
  exports.CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP;
  exports.CloudProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
    TMP_CLOUDPROVIDERVALUES_AWS,
    TMP_CLOUDPROVIDERVALUES_AZURE,
    TMP_CLOUDPROVIDERVALUES_GCP
  ]);
  var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = "alibaba_cloud_ecs";
  var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = "alibaba_cloud_fc";
  var TMP_CLOUDPLATFORMVALUES_AWS_EC2 = "aws_ec2";
  var TMP_CLOUDPLATFORMVALUES_AWS_ECS = "aws_ecs";
  var TMP_CLOUDPLATFORMVALUES_AWS_EKS = "aws_eks";
  var TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA = "aws_lambda";
  var TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = "aws_elastic_beanstalk";
  var TMP_CLOUDPLATFORMVALUES_AZURE_VM = "azure_vm";
  var TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = "azure_container_instances";
  var TMP_CLOUDPLATFORMVALUES_AZURE_AKS = "azure_aks";
  var TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = "azure_functions";
  var TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = "azure_app_service";
  var TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = "gcp_compute_engine";
  var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = "gcp_cloud_run";
  var TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = "gcp_kubernetes_engine";
  var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = "gcp_cloud_functions";
  var TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE = "gcp_app_engine";
  exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS;
  exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC;
  exports.CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC2;
  exports.CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS;
  exports.CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS;
  exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA;
  exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK;
  exports.CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM;
  exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES;
  exports.CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS;
  exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS;
  exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE;
  exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE;
  exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN;
  exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE;
  exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS;
  exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE;
  exports.CloudPlatformValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
    TMP_CLOUDPLATFORMVALUES_AWS_EC2,
    TMP_CLOUDPLATFORMVALUES_AWS_ECS,
    TMP_CLOUDPLATFORMVALUES_AWS_EKS,
    TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA,
    TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
    TMP_CLOUDPLATFORMVALUES_AZURE_VM,
    TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
    TMP_CLOUDPLATFORMVALUES_AZURE_AKS,
    TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
    TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
    TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
    TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
    TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE
  ]);
  var TMP_AWSECSLAUNCHTYPEVALUES_EC2 = "ec2";
  var TMP_AWSECSLAUNCHTYPEVALUES_FARGATE = "fargate";
  exports.AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC2;
  exports.AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE;
  exports.AwsEcsLaunchtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_AWSECSLAUNCHTYPEVALUES_EC2,
    TMP_AWSECSLAUNCHTYPEVALUES_FARGATE
  ]);
  var TMP_HOSTARCHVALUES_AMD64 = "amd64";
  var TMP_HOSTARCHVALUES_ARM32 = "arm32";
  var TMP_HOSTARCHVALUES_ARM64 = "arm64";
  var TMP_HOSTARCHVALUES_IA64 = "ia64";
  var TMP_HOSTARCHVALUES_PPC32 = "ppc32";
  var TMP_HOSTARCHVALUES_PPC64 = "ppc64";
  var TMP_HOSTARCHVALUES_X86 = "x86";
  exports.HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD64;
  exports.HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM32;
  exports.HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM64;
  exports.HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA64;
  exports.HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC32;
  exports.HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC64;
  exports.HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X86;
  exports.HostArchValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_HOSTARCHVALUES_AMD64,
    TMP_HOSTARCHVALUES_ARM32,
    TMP_HOSTARCHVALUES_ARM64,
    TMP_HOSTARCHVALUES_IA64,
    TMP_HOSTARCHVALUES_PPC32,
    TMP_HOSTARCHVALUES_PPC64,
    TMP_HOSTARCHVALUES_X86
  ]);
  var TMP_OSTYPEVALUES_WINDOWS = "windows";
  var TMP_OSTYPEVALUES_LINUX = "linux";
  var TMP_OSTYPEVALUES_DARWIN = "darwin";
  var TMP_OSTYPEVALUES_FREEBSD = "freebsd";
  var TMP_OSTYPEVALUES_NETBSD = "netbsd";
  var TMP_OSTYPEVALUES_OPENBSD = "openbsd";
  var TMP_OSTYPEVALUES_DRAGONFLYBSD = "dragonflybsd";
  var TMP_OSTYPEVALUES_HPUX = "hpux";
  var TMP_OSTYPEVALUES_AIX = "aix";
  var TMP_OSTYPEVALUES_SOLARIS = "solaris";
  var TMP_OSTYPEVALUES_Z_OS = "z_os";
  exports.OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS;
  exports.OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX;
  exports.OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN;
  exports.OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD;
  exports.OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD;
  exports.OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD;
  exports.OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD;
  exports.OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX;
  exports.OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX;
  exports.OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS;
  exports.OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS;
  exports.OsTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_OSTYPEVALUES_WINDOWS,
    TMP_OSTYPEVALUES_LINUX,
    TMP_OSTYPEVALUES_DARWIN,
    TMP_OSTYPEVALUES_FREEBSD,
    TMP_OSTYPEVALUES_NETBSD,
    TMP_OSTYPEVALUES_OPENBSD,
    TMP_OSTYPEVALUES_DRAGONFLYBSD,
    TMP_OSTYPEVALUES_HPUX,
    TMP_OSTYPEVALUES_AIX,
    TMP_OSTYPEVALUES_SOLARIS,
    TMP_OSTYPEVALUES_Z_OS
  ]);
  var TMP_TELEMETRYSDKLANGUAGEVALUES_CPP = "cpp";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET = "dotnet";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG = "erlang";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_GO = "go";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA = "java";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS = "nodejs";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_PHP = "php";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON = "python";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY = "ruby";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS = "webjs";
  exports.TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP;
  exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET;
  exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG;
  exports.TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO;
  exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA;
  exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS;
  exports.TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP;
  exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON;
  exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY;
  exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS;
  exports.TelemetrySdkLanguageValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_TELEMETRYSDKLANGUAGEVALUES_CPP,
    TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET,
    TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG,
    TMP_TELEMETRYSDKLANGUAGEVALUES_GO,
    TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA,
    TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS,
    TMP_TELEMETRYSDKLANGUAGEVALUES_PHP,
    TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON,
    TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY,
    TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS
  ]);
});

// ../../node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js
var require_resource = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(require_SemanticResourceAttributes(), exports);
});

// ../../node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/src/stable_attributes.js
var require_stable_attributes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HTTP_REQUEST_METHOD_VALUE_POST = exports.HTTP_REQUEST_METHOD_VALUE_PATCH = exports.HTTP_REQUEST_METHOD_VALUE_OPTIONS = exports.HTTP_REQUEST_METHOD_VALUE_HEAD = exports.HTTP_REQUEST_METHOD_VALUE_GET = exports.HTTP_REQUEST_METHOD_VALUE_DELETE = exports.HTTP_REQUEST_METHOD_VALUE_CONNECT = exports.HTTP_REQUEST_METHOD_VALUE_OTHER = exports.ATTR_HTTP_REQUEST_METHOD = exports.ATTR_HTTP_REQUEST_HEADER = exports.ATTR_EXCEPTION_TYPE = exports.ATTR_EXCEPTION_STACKTRACE = exports.ATTR_EXCEPTION_MESSAGE = exports.ATTR_EXCEPTION_ESCAPED = exports.ERROR_TYPE_VALUE_OTHER = exports.ATTR_ERROR_TYPE = exports.ATTR_CLIENT_PORT = exports.ATTR_CLIENT_ADDRESS = exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = exports.ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = exports.ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = exports.ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = exports.ATTR_ASPNETCORE_RATE_LIMITING_POLICY = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = exports.ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = exports.ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = exports.ATTR_TELEMETRY_SDK_VERSION = exports.ATTR_TELEMETRY_SDK_NAME = exports.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = exports.TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUST = exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = exports.TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = exports.TELEMETRY_SDK_LANGUAGE_VALUE_PHP = exports.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = exports.TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = exports.TELEMETRY_SDK_LANGUAGE_VALUE_GO = exports.TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = exports.TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = exports.TELEMETRY_SDK_LANGUAGE_VALUE_CPP = exports.ATTR_TELEMETRY_SDK_LANGUAGE = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = exports.ATTR_ASPNETCORE_RATE_LIMITING_RESULT = undefined;
  exports.SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = exports.SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = exports.SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = exports.ATTR_SIGNALR_CONNECTION_STATUS = exports.ATTR_SERVICE_VERSION = exports.ATTR_SERVICE_NAME = exports.ATTR_SERVER_PORT = exports.ATTR_SERVER_ADDRESS = exports.ATTR_OTEL_STATUS_DESCRIPTION = exports.OTEL_STATUS_CODE_VALUE_OK = exports.OTEL_STATUS_CODE_VALUE_ERROR = exports.ATTR_OTEL_STATUS_CODE = exports.ATTR_OTEL_SCOPE_VERSION = exports.ATTR_OTEL_SCOPE_NAME = exports.NETWORK_TYPE_VALUE_IPV6 = exports.NETWORK_TYPE_VALUE_IPV4 = exports.ATTR_NETWORK_TYPE = exports.NETWORK_TRANSPORT_VALUE_UNIX = exports.NETWORK_TRANSPORT_VALUE_UDP = exports.NETWORK_TRANSPORT_VALUE_TCP = exports.NETWORK_TRANSPORT_VALUE_QUIC = exports.NETWORK_TRANSPORT_VALUE_PIPE = exports.ATTR_NETWORK_TRANSPORT = exports.ATTR_NETWORK_PROTOCOL_VERSION = exports.ATTR_NETWORK_PROTOCOL_NAME = exports.ATTR_NETWORK_PEER_PORT = exports.ATTR_NETWORK_PEER_ADDRESS = exports.ATTR_NETWORK_LOCAL_PORT = exports.ATTR_NETWORK_LOCAL_ADDRESS = exports.JVM_THREAD_STATE_VALUE_WAITING = exports.JVM_THREAD_STATE_VALUE_TIMED_WAITING = exports.JVM_THREAD_STATE_VALUE_TERMINATED = exports.JVM_THREAD_STATE_VALUE_RUNNABLE = exports.JVM_THREAD_STATE_VALUE_NEW = exports.JVM_THREAD_STATE_VALUE_BLOCKED = exports.ATTR_JVM_THREAD_STATE = exports.ATTR_JVM_THREAD_DAEMON = exports.JVM_MEMORY_TYPE_VALUE_NON_HEAP = exports.JVM_MEMORY_TYPE_VALUE_HEAP = exports.ATTR_JVM_MEMORY_TYPE = exports.ATTR_JVM_MEMORY_POOL_NAME = exports.ATTR_JVM_GC_NAME = exports.ATTR_JVM_GC_ACTION = exports.ATTR_HTTP_ROUTE = exports.ATTR_HTTP_RESPONSE_STATUS_CODE = exports.ATTR_HTTP_RESPONSE_HEADER = exports.ATTR_HTTP_REQUEST_RESEND_COUNT = exports.ATTR_HTTP_REQUEST_METHOD_ORIGINAL = exports.HTTP_REQUEST_METHOD_VALUE_TRACE = exports.HTTP_REQUEST_METHOD_VALUE_PUT = undefined;
  exports.ATTR_USER_AGENT_ORIGINAL = exports.ATTR_URL_SCHEME = exports.ATTR_URL_QUERY = exports.ATTR_URL_PATH = exports.ATTR_URL_FULL = exports.ATTR_URL_FRAGMENT = exports.SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = exports.SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = exports.SIGNALR_TRANSPORT_VALUE_LONG_POLLING = exports.ATTR_SIGNALR_TRANSPORT = undefined;
  exports.ATTR_ASPNETCORE_RATE_LIMITING_RESULT = "aspnetcore.rate_limiting.result";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = "acquired";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = "endpoint_limiter";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = "global_limiter";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = "request_canceled";
  exports.ATTR_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_CPP = "cpp";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = "dotnet";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = "erlang";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_GO = "go";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = "java";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = "nodejs";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_PHP = "php";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = "python";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = "ruby";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUST = "rust";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = "swift";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = "webjs";
  exports.ATTR_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
  exports.ATTR_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
  exports.ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = "aspnetcore.diagnostics.handler.type";
  exports.ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = "aspnetcore.diagnostics.exception.result";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = "aborted";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = "handled";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = "skipped";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = "unhandled";
  exports.ATTR_ASPNETCORE_RATE_LIMITING_POLICY = "aspnetcore.rate_limiting.policy";
  exports.ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = "aspnetcore.request.is_unhandled";
  exports.ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = "aspnetcore.routing.is_fallback";
  exports.ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = "aspnetcore.routing.match_status";
  exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = "failure";
  exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = "success";
  exports.ATTR_CLIENT_ADDRESS = "client.address";
  exports.ATTR_CLIENT_PORT = "client.port";
  exports.ATTR_ERROR_TYPE = "error.type";
  exports.ERROR_TYPE_VALUE_OTHER = "_OTHER";
  exports.ATTR_EXCEPTION_ESCAPED = "exception.escaped";
  exports.ATTR_EXCEPTION_MESSAGE = "exception.message";
  exports.ATTR_EXCEPTION_STACKTRACE = "exception.stacktrace";
  exports.ATTR_EXCEPTION_TYPE = "exception.type";
  var ATTR_HTTP_REQUEST_HEADER = (key) => `http.request.header.${key}`;
  exports.ATTR_HTTP_REQUEST_HEADER = ATTR_HTTP_REQUEST_HEADER;
  exports.ATTR_HTTP_REQUEST_METHOD = "http.request.method";
  exports.HTTP_REQUEST_METHOD_VALUE_OTHER = "_OTHER";
  exports.HTTP_REQUEST_METHOD_VALUE_CONNECT = "CONNECT";
  exports.HTTP_REQUEST_METHOD_VALUE_DELETE = "DELETE";
  exports.HTTP_REQUEST_METHOD_VALUE_GET = "GET";
  exports.HTTP_REQUEST_METHOD_VALUE_HEAD = "HEAD";
  exports.HTTP_REQUEST_METHOD_VALUE_OPTIONS = "OPTIONS";
  exports.HTTP_REQUEST_METHOD_VALUE_PATCH = "PATCH";
  exports.HTTP_REQUEST_METHOD_VALUE_POST = "POST";
  exports.HTTP_REQUEST_METHOD_VALUE_PUT = "PUT";
  exports.HTTP_REQUEST_METHOD_VALUE_TRACE = "TRACE";
  exports.ATTR_HTTP_REQUEST_METHOD_ORIGINAL = "http.request.method_original";
  exports.ATTR_HTTP_REQUEST_RESEND_COUNT = "http.request.resend_count";
  var ATTR_HTTP_RESPONSE_HEADER = (key) => `http.response.header.${key}`;
  exports.ATTR_HTTP_RESPONSE_HEADER = ATTR_HTTP_RESPONSE_HEADER;
  exports.ATTR_HTTP_RESPONSE_STATUS_CODE = "http.response.status_code";
  exports.ATTR_HTTP_ROUTE = "http.route";
  exports.ATTR_JVM_GC_ACTION = "jvm.gc.action";
  exports.ATTR_JVM_GC_NAME = "jvm.gc.name";
  exports.ATTR_JVM_MEMORY_POOL_NAME = "jvm.memory.pool.name";
  exports.ATTR_JVM_MEMORY_TYPE = "jvm.memory.type";
  exports.JVM_MEMORY_TYPE_VALUE_HEAP = "heap";
  exports.JVM_MEMORY_TYPE_VALUE_NON_HEAP = "non_heap";
  exports.ATTR_JVM_THREAD_DAEMON = "jvm.thread.daemon";
  exports.ATTR_JVM_THREAD_STATE = "jvm.thread.state";
  exports.JVM_THREAD_STATE_VALUE_BLOCKED = "blocked";
  exports.JVM_THREAD_STATE_VALUE_NEW = "new";
  exports.JVM_THREAD_STATE_VALUE_RUNNABLE = "runnable";
  exports.JVM_THREAD_STATE_VALUE_TERMINATED = "terminated";
  exports.JVM_THREAD_STATE_VALUE_TIMED_WAITING = "timed_waiting";
  exports.JVM_THREAD_STATE_VALUE_WAITING = "waiting";
  exports.ATTR_NETWORK_LOCAL_ADDRESS = "network.local.address";
  exports.ATTR_NETWORK_LOCAL_PORT = "network.local.port";
  exports.ATTR_NETWORK_PEER_ADDRESS = "network.peer.address";
  exports.ATTR_NETWORK_PEER_PORT = "network.peer.port";
  exports.ATTR_NETWORK_PROTOCOL_NAME = "network.protocol.name";
  exports.ATTR_NETWORK_PROTOCOL_VERSION = "network.protocol.version";
  exports.ATTR_NETWORK_TRANSPORT = "network.transport";
  exports.NETWORK_TRANSPORT_VALUE_PIPE = "pipe";
  exports.NETWORK_TRANSPORT_VALUE_QUIC = "quic";
  exports.NETWORK_TRANSPORT_VALUE_TCP = "tcp";
  exports.NETWORK_TRANSPORT_VALUE_UDP = "udp";
  exports.NETWORK_TRANSPORT_VALUE_UNIX = "unix";
  exports.ATTR_NETWORK_TYPE = "network.type";
  exports.NETWORK_TYPE_VALUE_IPV4 = "ipv4";
  exports.NETWORK_TYPE_VALUE_IPV6 = "ipv6";
  exports.ATTR_OTEL_SCOPE_NAME = "otel.scope.name";
  exports.ATTR_OTEL_SCOPE_VERSION = "otel.scope.version";
  exports.ATTR_OTEL_STATUS_CODE = "otel.status_code";
  exports.OTEL_STATUS_CODE_VALUE_ERROR = "ERROR";
  exports.OTEL_STATUS_CODE_VALUE_OK = "OK";
  exports.ATTR_OTEL_STATUS_DESCRIPTION = "otel.status_description";
  exports.ATTR_SERVER_ADDRESS = "server.address";
  exports.ATTR_SERVER_PORT = "server.port";
  exports.ATTR_SERVICE_NAME = "service.name";
  exports.ATTR_SERVICE_VERSION = "service.version";
  exports.ATTR_SIGNALR_CONNECTION_STATUS = "signalr.connection.status";
  exports.SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = "app_shutdown";
  exports.SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = "normal_closure";
  exports.SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = "timeout";
  exports.ATTR_SIGNALR_TRANSPORT = "signalr.transport";
  exports.SIGNALR_TRANSPORT_VALUE_LONG_POLLING = "long_polling";
  exports.SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = "server_sent_events";
  exports.SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = "web_sockets";
  exports.ATTR_URL_FRAGMENT = "url.fragment";
  exports.ATTR_URL_FULL = "url.full";
  exports.ATTR_URL_PATH = "url.path";
  exports.ATTR_URL_QUERY = "url.query";
  exports.ATTR_URL_SCHEME = "url.scheme";
  exports.ATTR_USER_AGENT_ORIGINAL = "user_agent.original";
});

// ../../node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/src/stable_metrics.js
var require_stable_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.METRIC_SIGNALR_SERVER_CONNECTION_DURATION = exports.METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = exports.METRIC_KESTREL_UPGRADED_CONNECTIONS = exports.METRIC_KESTREL_TLS_HANDSHAKE_DURATION = exports.METRIC_KESTREL_REJECTED_CONNECTIONS = exports.METRIC_KESTREL_QUEUED_REQUESTS = exports.METRIC_KESTREL_QUEUED_CONNECTIONS = exports.METRIC_KESTREL_CONNECTION_DURATION = exports.METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = exports.METRIC_KESTREL_ACTIVE_CONNECTIONS = exports.METRIC_JVM_THREAD_COUNT = exports.METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = exports.METRIC_JVM_MEMORY_USED = exports.METRIC_JVM_MEMORY_LIMIT = exports.METRIC_JVM_MEMORY_COMMITTED = exports.METRIC_JVM_GC_DURATION = exports.METRIC_JVM_CPU_TIME = exports.METRIC_JVM_CPU_RECENT_UTILIZATION = exports.METRIC_JVM_CPU_COUNT = exports.METRIC_JVM_CLASS_UNLOADED = exports.METRIC_JVM_CLASS_LOADED = exports.METRIC_JVM_CLASS_COUNT = exports.METRIC_HTTP_SERVER_REQUEST_DURATION = exports.METRIC_HTTP_CLIENT_REQUEST_DURATION = exports.METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = exports.METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = exports.METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = undefined;
  exports.METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = "aspnetcore.diagnostics.exceptions";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = "aspnetcore.rate_limiting.active_request_leases";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = "aspnetcore.rate_limiting.queued_requests";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = "aspnetcore.rate_limiting.request.time_in_queue";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = "aspnetcore.rate_limiting.request_lease.duration";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = "aspnetcore.rate_limiting.requests";
  exports.METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = "aspnetcore.routing.match_attempts";
  exports.METRIC_HTTP_CLIENT_REQUEST_DURATION = "http.client.request.duration";
  exports.METRIC_HTTP_SERVER_REQUEST_DURATION = "http.server.request.duration";
  exports.METRIC_JVM_CLASS_COUNT = "jvm.class.count";
  exports.METRIC_JVM_CLASS_LOADED = "jvm.class.loaded";
  exports.METRIC_JVM_CLASS_UNLOADED = "jvm.class.unloaded";
  exports.METRIC_JVM_CPU_COUNT = "jvm.cpu.count";
  exports.METRIC_JVM_CPU_RECENT_UTILIZATION = "jvm.cpu.recent_utilization";
  exports.METRIC_JVM_CPU_TIME = "jvm.cpu.time";
  exports.METRIC_JVM_GC_DURATION = "jvm.gc.duration";
  exports.METRIC_JVM_MEMORY_COMMITTED = "jvm.memory.committed";
  exports.METRIC_JVM_MEMORY_LIMIT = "jvm.memory.limit";
  exports.METRIC_JVM_MEMORY_USED = "jvm.memory.used";
  exports.METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = "jvm.memory.used_after_last_gc";
  exports.METRIC_JVM_THREAD_COUNT = "jvm.thread.count";
  exports.METRIC_KESTREL_ACTIVE_CONNECTIONS = "kestrel.active_connections";
  exports.METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = "kestrel.active_tls_handshakes";
  exports.METRIC_KESTREL_CONNECTION_DURATION = "kestrel.connection.duration";
  exports.METRIC_KESTREL_QUEUED_CONNECTIONS = "kestrel.queued_connections";
  exports.METRIC_KESTREL_QUEUED_REQUESTS = "kestrel.queued_requests";
  exports.METRIC_KESTREL_REJECTED_CONNECTIONS = "kestrel.rejected_connections";
  exports.METRIC_KESTREL_TLS_HANDSHAKE_DURATION = "kestrel.tls_handshake.duration";
  exports.METRIC_KESTREL_UPGRADED_CONNECTIONS = "kestrel.upgraded_connections";
  exports.METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = "signalr.server.active_connections";
  exports.METRIC_SIGNALR_SERVER_CONNECTION_DURATION = "signalr.server.connection.duration";
});

// ../../node_modules/@opentelemetry/resources/node_modules/@opentelemetry/semantic-conventions/build/src/index.js
var require_src6 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(require_trace2(), exports);
  __exportStar2(require_resource(), exports);
  __exportStar2(require_stable_attributes(), exports);
  __exportStar2(require_stable_metrics(), exports);
});

// ../../node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js
var require_suppress_tracing = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isTracingSuppressed = exports.unsuppressTracing = exports.suppressTracing = undefined;
  var api_1 = require_src();
  var SUPPRESS_TRACING_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
  function suppressTracing(context) {
    return context.setValue(SUPPRESS_TRACING_KEY, true);
  }
  exports.suppressTracing = suppressTracing;
  function unsuppressTracing(context) {
    return context.deleteValue(SUPPRESS_TRACING_KEY);
  }
  exports.unsuppressTracing = unsuppressTracing;
  function isTracingSuppressed(context) {
    return context.getValue(SUPPRESS_TRACING_KEY) === true;
  }
  exports.isTracingSuppressed = isTracingSuppressed;
});

// ../../node_modules/@opentelemetry/core/build/src/baggage/constants.js
var require_constants2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BAGGAGE_MAX_TOTAL_LENGTH = exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = exports.BAGGAGE_HEADER = exports.BAGGAGE_ITEMS_SEPARATOR = exports.BAGGAGE_PROPERTIES_SEPARATOR = exports.BAGGAGE_KEY_PAIR_SEPARATOR = undefined;
  exports.BAGGAGE_KEY_PAIR_SEPARATOR = "=";
  exports.BAGGAGE_PROPERTIES_SEPARATOR = ";";
  exports.BAGGAGE_ITEMS_SEPARATOR = ",";
  exports.BAGGAGE_HEADER = "baggage";
  exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
  exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
  exports.BAGGAGE_MAX_TOTAL_LENGTH = 8192;
});

// ../../node_modules/@opentelemetry/core/build/src/baggage/utils.js
var require_utils5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseKeyPairsIntoRecord = exports.parsePairKeyValue = exports.getKeyPairs = exports.serializeKeyPairs = undefined;
  var api_1 = require_src();
  var constants_1 = require_constants2();
  function serializeKeyPairs(keyPairs) {
    return keyPairs.reduce((hValue, current) => {
      const value = `${hValue}${hValue !== "" ? constants_1.BAGGAGE_ITEMS_SEPARATOR : ""}${current}`;
      return value.length > constants_1.BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
    }, "");
  }
  exports.serializeKeyPairs = serializeKeyPairs;
  function getKeyPairs(baggage) {
    return baggage.getAllEntries().map(([key, value]) => {
      let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
      if (value.metadata !== undefined) {
        entry += constants_1.BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
      }
      return entry;
    });
  }
  exports.getKeyPairs = getKeyPairs;
  function parsePairKeyValue(entry) {
    const valueProps = entry.split(constants_1.BAGGAGE_PROPERTIES_SEPARATOR);
    if (valueProps.length <= 0)
      return;
    const keyPairPart = valueProps.shift();
    if (!keyPairPart)
      return;
    const separatorIndex = keyPairPart.indexOf(constants_1.BAGGAGE_KEY_PAIR_SEPARATOR);
    if (separatorIndex <= 0)
      return;
    const key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
    const value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
    let metadata;
    if (valueProps.length > 0) {
      metadata = (0, api_1.baggageEntryMetadataFromString)(valueProps.join(constants_1.BAGGAGE_PROPERTIES_SEPARATOR));
    }
    return { key, value, metadata };
  }
  exports.parsePairKeyValue = parsePairKeyValue;
  function parseKeyPairsIntoRecord(value) {
    if (typeof value !== "string" || value.length === 0)
      return {};
    return value.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).map((entry) => {
      return parsePairKeyValue(entry);
    }).filter((keyPair) => keyPair !== undefined && keyPair.value.length > 0).reduce((headers, keyPair) => {
      headers[keyPair.key] = keyPair.value;
      return headers;
    }, {});
  }
  exports.parseKeyPairsIntoRecord = parseKeyPairsIntoRecord;
});

// ../../node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js
var require_W3CBaggagePropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.W3CBaggagePropagator = undefined;
  var api_1 = require_src();
  var suppress_tracing_1 = require_suppress_tracing();
  var constants_1 = require_constants2();
  var utils_1 = require_utils5();

  class W3CBaggagePropagator {
    inject(context, carrier, setter) {
      const baggage = api_1.propagation.getBaggage(context);
      if (!baggage || (0, suppress_tracing_1.isTracingSuppressed)(context))
        return;
      const keyPairs = (0, utils_1.getKeyPairs)(baggage).filter((pair) => {
        return pair.length <= constants_1.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
      }).slice(0, constants_1.BAGGAGE_MAX_NAME_VALUE_PAIRS);
      const headerValue = (0, utils_1.serializeKeyPairs)(keyPairs);
      if (headerValue.length > 0) {
        setter.set(carrier, constants_1.BAGGAGE_HEADER, headerValue);
      }
    }
    extract(context, carrier, getter) {
      const headerValue = getter.get(carrier, constants_1.BAGGAGE_HEADER);
      const baggageString = Array.isArray(headerValue) ? headerValue.join(constants_1.BAGGAGE_ITEMS_SEPARATOR) : headerValue;
      if (!baggageString)
        return context;
      const baggage = {};
      if (baggageString.length === 0) {
        return context;
      }
      const pairs = baggageString.split(constants_1.BAGGAGE_ITEMS_SEPARATOR);
      pairs.forEach((entry) => {
        const keyPair = (0, utils_1.parsePairKeyValue)(entry);
        if (keyPair) {
          const baggageEntry = { value: keyPair.value };
          if (keyPair.metadata) {
            baggageEntry.metadata = keyPair.metadata;
          }
          baggage[keyPair.key] = baggageEntry;
        }
      });
      if (Object.entries(baggage).length === 0) {
        return context;
      }
      return api_1.propagation.setBaggage(context, api_1.propagation.createBaggage(baggage));
    }
    fields() {
      return [constants_1.BAGGAGE_HEADER];
    }
  }
  exports.W3CBaggagePropagator = W3CBaggagePropagator;
});

// ../../node_modules/@opentelemetry/core/build/src/common/anchored-clock.js
var require_anchored_clock = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnchoredClock = undefined;

  class AnchoredClock {
    constructor(systemClock, monotonicClock) {
      this._monotonicClock = monotonicClock;
      this._epochMillis = systemClock.now();
      this._performanceMillis = monotonicClock.now();
    }
    now() {
      const delta = this._monotonicClock.now() - this._performanceMillis;
      return this._epochMillis + delta;
    }
  }
  exports.AnchoredClock = AnchoredClock;
});

// ../../node_modules/@opentelemetry/core/build/src/common/attributes.js
var require_attributes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isAttributeValue = exports.isAttributeKey = exports.sanitizeAttributes = undefined;
  var api_1 = require_src();
  function sanitizeAttributes(attributes) {
    const out = {};
    if (typeof attributes !== "object" || attributes == null) {
      return out;
    }
    for (const [key, val2] of Object.entries(attributes)) {
      if (!isAttributeKey(key)) {
        api_1.diag.warn(`Invalid attribute key: ${key}`);
        continue;
      }
      if (!isAttributeValue(val2)) {
        api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
        continue;
      }
      if (Array.isArray(val2)) {
        out[key] = val2.slice();
      } else {
        out[key] = val2;
      }
    }
    return out;
  }
  exports.sanitizeAttributes = sanitizeAttributes;
  function isAttributeKey(key) {
    return typeof key === "string" && key.length > 0;
  }
  exports.isAttributeKey = isAttributeKey;
  function isAttributeValue(val2) {
    if (val2 == null) {
      return true;
    }
    if (Array.isArray(val2)) {
      return isHomogeneousAttributeValueArray(val2);
    }
    return isValidPrimitiveAttributeValue(val2);
  }
  exports.isAttributeValue = isAttributeValue;
  function isHomogeneousAttributeValueArray(arr) {
    let type;
    for (const element of arr) {
      if (element == null)
        continue;
      if (!type) {
        if (isValidPrimitiveAttributeValue(element)) {
          type = typeof element;
          continue;
        }
        return false;
      }
      if (typeof element === type) {
        continue;
      }
      return false;
    }
    return true;
  }
  function isValidPrimitiveAttributeValue(val2) {
    switch (typeof val2) {
      case "number":
      case "boolean":
      case "string":
        return true;
    }
    return false;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js
var require_logging_error_handler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.loggingErrorHandler = undefined;
  var api_1 = require_src();
  function loggingErrorHandler() {
    return (ex) => {
      api_1.diag.error(stringifyException(ex));
    };
  }
  exports.loggingErrorHandler = loggingErrorHandler;
  function stringifyException(ex) {
    if (typeof ex === "string") {
      return ex;
    } else {
      return JSON.stringify(flattenException(ex));
    }
  }
  function flattenException(ex) {
    const result = {};
    let current = ex;
    while (current !== null) {
      Object.getOwnPropertyNames(current).forEach((propertyName) => {
        if (result[propertyName])
          return;
        const value = current[propertyName];
        if (value) {
          result[propertyName] = String(value);
        }
      });
      current = Object.getPrototypeOf(current);
    }
    return result;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/common/global-error-handler.js
var require_global_error_handler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.globalErrorHandler = exports.setGlobalErrorHandler = undefined;
  var logging_error_handler_1 = require_logging_error_handler();
  var delegateHandler = (0, logging_error_handler_1.loggingErrorHandler)();
  function setGlobalErrorHandler(handler) {
    delegateHandler = handler;
  }
  exports.setGlobalErrorHandler = setGlobalErrorHandler;
  function globalErrorHandler(ex) {
    try {
      delegateHandler(ex);
    } catch (_a2) {
    }
  }
  exports.globalErrorHandler = globalErrorHandler;
});

// ../../node_modules/@opentelemetry/core/build/src/utils/sampling.js
var require_sampling = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TracesSamplerValues = undefined;
  var TracesSamplerValues;
  (function(TracesSamplerValues2) {
    TracesSamplerValues2["AlwaysOff"] = "always_off";
    TracesSamplerValues2["AlwaysOn"] = "always_on";
    TracesSamplerValues2["ParentBasedAlwaysOff"] = "parentbased_always_off";
    TracesSamplerValues2["ParentBasedAlwaysOn"] = "parentbased_always_on";
    TracesSamplerValues2["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
    TracesSamplerValues2["TraceIdRatio"] = "traceidratio";
  })(TracesSamplerValues = exports.TracesSamplerValues || (exports.TracesSamplerValues = {}));
});

// ../../node_modules/@opentelemetry/core/build/src/utils/environment.js
var require_environment = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseEnvironment = exports.DEFAULT_ENVIRONMENT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = undefined;
  var api_1 = require_src();
  var sampling_1 = require_sampling();
  var DEFAULT_LIST_SEPARATOR = ",";
  var ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
  function isEnvVarABoolean(key) {
    return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
  }
  var ENVIRONMENT_NUMBERS_KEYS = [
    "OTEL_BSP_EXPORT_TIMEOUT",
    "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
    "OTEL_BSP_MAX_QUEUE_SIZE",
    "OTEL_BSP_SCHEDULE_DELAY",
    "OTEL_BLRP_EXPORT_TIMEOUT",
    "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
    "OTEL_BLRP_MAX_QUEUE_SIZE",
    "OTEL_BLRP_SCHEDULE_DELAY",
    "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
    "OTEL_ATTRIBUTE_COUNT_LIMIT",
    "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
    "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
    "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
    "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
    "OTEL_SPAN_EVENT_COUNT_LIMIT",
    "OTEL_SPAN_LINK_COUNT_LIMIT",
    "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
    "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
    "OTEL_EXPORTER_OTLP_TIMEOUT",
    "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
    "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
    "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
    "OTEL_EXPORTER_JAEGER_AGENT_PORT"
  ];
  function isEnvVarANumber(key) {
    return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
  }
  var ENVIRONMENT_LISTS_KEYS = [
    "OTEL_NO_PATCH_MODULES",
    "OTEL_PROPAGATORS",
    "OTEL_SEMCONV_STABILITY_OPT_IN"
  ];
  function isEnvVarAList(key) {
    return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
  }
  exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
  exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
  exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
  exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
  exports.DEFAULT_ENVIRONMENT = {
    OTEL_SDK_DISABLED: false,
    CONTAINER_NAME: "",
    ECS_CONTAINER_METADATA_URI_V4: "",
    ECS_CONTAINER_METADATA_URI: "",
    HOSTNAME: "",
    KUBERNETES_SERVICE_HOST: "",
    NAMESPACE: "",
    OTEL_BSP_EXPORT_TIMEOUT: 30000,
    OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BSP_MAX_QUEUE_SIZE: 2048,
    OTEL_BSP_SCHEDULE_DELAY: 5000,
    OTEL_BLRP_EXPORT_TIMEOUT: 30000,
    OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
    OTEL_BLRP_SCHEDULE_DELAY: 5000,
    OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
    OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
    OTEL_EXPORTER_JAEGER_ENDPOINT: "",
    OTEL_EXPORTER_JAEGER_PASSWORD: "",
    OTEL_EXPORTER_JAEGER_USER: "",
    OTEL_EXPORTER_OTLP_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_HEADERS: "",
    OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
    OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
    OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
    OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
    OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
    OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
    OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
    OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
    OTEL_LOG_LEVEL: api_1.DiagLogLevel.INFO,
    OTEL_NO_PATCH_MODULES: [],
    OTEL_PROPAGATORS: ["tracecontext", "baggage"],
    OTEL_RESOURCE_ATTRIBUTES: "",
    OTEL_SERVICE_NAME: "",
    OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
    OTEL_SPAN_LINK_COUNT_LIMIT: 128,
    OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
    OTEL_TRACES_EXPORTER: "",
    OTEL_TRACES_SAMPLER: sampling_1.TracesSamplerValues.ParentBasedAlwaysOn,
    OTEL_TRACES_SAMPLER_ARG: "",
    OTEL_LOGS_EXPORTER: "",
    OTEL_EXPORTER_OTLP_INSECURE: "",
    OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
    OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
    OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
    OTEL_EXPORTER_OTLP_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative",
    OTEL_SEMCONV_STABILITY_OPT_IN: []
  };
  function parseBoolean2(key, environment, values) {
    if (typeof values[key] === "undefined") {
      return;
    }
    const value = String(values[key]);
    environment[key] = value.toLowerCase() === "true";
  }
  function parseNumber2(name, environment, values, min = -Infinity, max = Infinity) {
    if (typeof values[name] !== "undefined") {
      const value = Number(values[name]);
      if (!isNaN(value)) {
        if (value < min) {
          environment[name] = min;
        } else if (value > max) {
          environment[name] = max;
        } else {
          environment[name] = value;
        }
      }
    }
  }
  function parseStringList(name, output, input, separator = DEFAULT_LIST_SEPARATOR) {
    const givenValue = input[name];
    if (typeof givenValue === "string") {
      output[name] = givenValue.split(separator).map((v7) => v7.trim());
    }
  }
  var logLevelMap = {
    ALL: api_1.DiagLogLevel.ALL,
    VERBOSE: api_1.DiagLogLevel.VERBOSE,
    DEBUG: api_1.DiagLogLevel.DEBUG,
    INFO: api_1.DiagLogLevel.INFO,
    WARN: api_1.DiagLogLevel.WARN,
    ERROR: api_1.DiagLogLevel.ERROR,
    NONE: api_1.DiagLogLevel.NONE
  };
  function setLogLevelFromEnv(key, environment, values) {
    const value = values[key];
    if (typeof value === "string") {
      const theLevel = logLevelMap[value.toUpperCase()];
      if (theLevel != null) {
        environment[key] = theLevel;
      }
    }
  }
  function parseEnvironment(values) {
    const environment = {};
    for (const env3 in exports.DEFAULT_ENVIRONMENT) {
      const key = env3;
      switch (key) {
        case "OTEL_LOG_LEVEL":
          setLogLevelFromEnv(key, environment, values);
          break;
        default:
          if (isEnvVarABoolean(key)) {
            parseBoolean2(key, environment, values);
          } else if (isEnvVarANumber(key)) {
            parseNumber2(key, environment, values);
          } else if (isEnvVarAList(key)) {
            parseStringList(key, environment, values);
          } else {
            const value = values[key];
            if (typeof value !== "undefined" && value !== null) {
              environment[key] = String(value);
            }
          }
      }
    }
    return environment;
  }
  exports.parseEnvironment = parseEnvironment;
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/environment.js
var require_environment2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEnvWithoutDefaults = exports.getEnv = undefined;
  var environment_1 = require_environment();
  function getEnv() {
    const processEnv = (0, environment_1.parseEnvironment)(process.env);
    return Object.assign({}, environment_1.DEFAULT_ENVIRONMENT, processEnv);
  }
  exports.getEnv = getEnv;
  function getEnvWithoutDefaults() {
    return (0, environment_1.parseEnvironment)(process.env);
  }
  exports.getEnvWithoutDefaults = getEnvWithoutDefaults;
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js
var require_globalThis3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// ../../node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js
var require_hex_to_binary = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hexToBinary = undefined;
  function intValue(charCode) {
    if (charCode >= 48 && charCode <= 57) {
      return charCode - 48;
    }
    if (charCode >= 97 && charCode <= 102) {
      return charCode - 87;
    }
    return charCode - 55;
  }
  function hexToBinary(hexStr) {
    const buf = new Uint8Array(hexStr.length / 2);
    let offset = 0;
    for (let i4 = 0;i4 < hexStr.length; i4 += 2) {
      const hi = intValue(hexStr.charCodeAt(i4));
      const lo = intValue(hexStr.charCodeAt(i4 + 1));
      buf[offset++] = hi << 4 | lo;
    }
    return buf;
  }
  exports.hexToBinary = hexToBinary;
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js
var require_hex_to_base64 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hexToBase64 = undefined;
  var hex_to_binary_1 = require_hex_to_binary();
  function hexToBase64(hexStr) {
    return Buffer.from((0, hex_to_binary_1.hexToBinary)(hexStr)).toString("base64");
  }
  exports.hexToBase64 = hexToBase64;
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RandomIdGenerator = undefined;
  var SPAN_ID_BYTES = 8;
  var TRACE_ID_BYTES = 16;

  class RandomIdGenerator {
    constructor() {
      this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
      this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
    }
  }
  exports.RandomIdGenerator = RandomIdGenerator;
  var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
  function getIdGenerator(bytes) {
    return function generateId() {
      for (let i4 = 0;i4 < bytes / 4; i4++) {
        SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i4 * 4);
      }
      for (let i4 = 0;i4 < bytes; i4++) {
        if (SHARED_BUFFER[i4] > 0) {
          break;
        } else if (i4 === bytes - 1) {
          SHARED_BUFFER[bytes - 1] = 1;
        }
      }
      return SHARED_BUFFER.toString("hex", 0, bytes);
    };
  }
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/performance.js
var require_performance = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.otperformance = undefined;
  var perf_hooks_1 = __require("perf_hooks");
  exports.otperformance = perf_hooks_1.performance;
});

// ../../node_modules/@opentelemetry/core/build/src/version.js
var require_version3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "1.30.1";
});

// ../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js
var require_utils6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createConstMap = undefined;
  function createConstMap(values) {
    let res = {};
    const len = values.length;
    for (let lp = 0;lp < len; lp++) {
      const val2 = values[lp];
      if (val2) {
        res[String(val2).toUpperCase().replace(/[-.]/g, "_")] = val2;
      }
    }
    return res;
  }
  exports.createConstMap = createConstMap;
});

// ../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js
var require_SemanticAttributes2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SEMATTRS_NET_HOST_CARRIER_ICC = exports.SEMATTRS_NET_HOST_CARRIER_MNC = exports.SEMATTRS_NET_HOST_CARRIER_MCC = exports.SEMATTRS_NET_HOST_CARRIER_NAME = exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = exports.SEMATTRS_NET_HOST_NAME = exports.SEMATTRS_NET_HOST_PORT = exports.SEMATTRS_NET_HOST_IP = exports.SEMATTRS_NET_PEER_NAME = exports.SEMATTRS_NET_PEER_PORT = exports.SEMATTRS_NET_PEER_IP = exports.SEMATTRS_NET_TRANSPORT = exports.SEMATTRS_FAAS_INVOKED_REGION = exports.SEMATTRS_FAAS_INVOKED_PROVIDER = exports.SEMATTRS_FAAS_INVOKED_NAME = exports.SEMATTRS_FAAS_COLDSTART = exports.SEMATTRS_FAAS_CRON = exports.SEMATTRS_FAAS_TIME = exports.SEMATTRS_FAAS_DOCUMENT_NAME = exports.SEMATTRS_FAAS_DOCUMENT_TIME = exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = exports.SEMATTRS_FAAS_EXECUTION = exports.SEMATTRS_FAAS_TRIGGER = exports.SEMATTRS_EXCEPTION_ESCAPED = exports.SEMATTRS_EXCEPTION_STACKTRACE = exports.SEMATTRS_EXCEPTION_MESSAGE = exports.SEMATTRS_EXCEPTION_TYPE = exports.SEMATTRS_DB_SQL_TABLE = exports.SEMATTRS_DB_MONGODB_COLLECTION = exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = exports.SEMATTRS_DB_HBASE_NAMESPACE = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = exports.SEMATTRS_DB_CASSANDRA_TABLE = exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = exports.SEMATTRS_DB_OPERATION = exports.SEMATTRS_DB_STATEMENT = exports.SEMATTRS_DB_NAME = exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = exports.SEMATTRS_DB_USER = exports.SEMATTRS_DB_CONNECTION_STRING = exports.SEMATTRS_DB_SYSTEM = exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = undefined;
  exports.SEMATTRS_MESSAGING_DESTINATION_KIND = exports.SEMATTRS_MESSAGING_DESTINATION = exports.SEMATTRS_MESSAGING_SYSTEM = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = exports.SEMATTRS_AWS_DYNAMODB_COUNT = exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_SELECT = exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = exports.SEMATTRS_AWS_DYNAMODB_LIMIT = exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = exports.SEMATTRS_HTTP_CLIENT_IP = exports.SEMATTRS_HTTP_ROUTE = exports.SEMATTRS_HTTP_SERVER_NAME = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = exports.SEMATTRS_HTTP_USER_AGENT = exports.SEMATTRS_HTTP_FLAVOR = exports.SEMATTRS_HTTP_STATUS_CODE = exports.SEMATTRS_HTTP_SCHEME = exports.SEMATTRS_HTTP_HOST = exports.SEMATTRS_HTTP_TARGET = exports.SEMATTRS_HTTP_URL = exports.SEMATTRS_HTTP_METHOD = exports.SEMATTRS_CODE_LINENO = exports.SEMATTRS_CODE_FILEPATH = exports.SEMATTRS_CODE_NAMESPACE = exports.SEMATTRS_CODE_FUNCTION = exports.SEMATTRS_THREAD_NAME = exports.SEMATTRS_THREAD_ID = exports.SEMATTRS_ENDUSER_SCOPE = exports.SEMATTRS_ENDUSER_ROLE = exports.SEMATTRS_ENDUSER_ID = exports.SEMATTRS_PEER_SERVICE = undefined;
  exports.DBSYSTEMVALUES_FILEMAKER = exports.DBSYSTEMVALUES_DERBY = exports.DBSYSTEMVALUES_FIREBIRD = exports.DBSYSTEMVALUES_ADABAS = exports.DBSYSTEMVALUES_CACHE = exports.DBSYSTEMVALUES_EDB = exports.DBSYSTEMVALUES_FIRSTSQL = exports.DBSYSTEMVALUES_INGRES = exports.DBSYSTEMVALUES_HANADB = exports.DBSYSTEMVALUES_MAXDB = exports.DBSYSTEMVALUES_PROGRESS = exports.DBSYSTEMVALUES_HSQLDB = exports.DBSYSTEMVALUES_CLOUDSCAPE = exports.DBSYSTEMVALUES_HIVE = exports.DBSYSTEMVALUES_REDSHIFT = exports.DBSYSTEMVALUES_POSTGRESQL = exports.DBSYSTEMVALUES_DB2 = exports.DBSYSTEMVALUES_ORACLE = exports.DBSYSTEMVALUES_MYSQL = exports.DBSYSTEMVALUES_MSSQL = exports.DBSYSTEMVALUES_OTHER_SQL = exports.SemanticAttributes = exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_ID = exports.SEMATTRS_MESSAGE_TYPE = exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = exports.SEMATTRS_RPC_JSONRPC_VERSION = exports.SEMATTRS_RPC_GRPC_STATUS_CODE = exports.SEMATTRS_RPC_METHOD = exports.SEMATTRS_RPC_SERVICE = exports.SEMATTRS_RPC_SYSTEM = exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = exports.SEMATTRS_MESSAGING_CONSUMER_ID = exports.SEMATTRS_MESSAGING_OPERATION = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = exports.SEMATTRS_MESSAGING_CONVERSATION_ID = exports.SEMATTRS_MESSAGING_MESSAGE_ID = exports.SEMATTRS_MESSAGING_URL = exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = exports.SEMATTRS_MESSAGING_PROTOCOL = exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = undefined;
  exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = exports.FaasDocumentOperationValues = exports.FAASDOCUMENTOPERATIONVALUES_DELETE = exports.FAASDOCUMENTOPERATIONVALUES_EDIT = exports.FAASDOCUMENTOPERATIONVALUES_INSERT = exports.FaasTriggerValues = exports.FAASTRIGGERVALUES_OTHER = exports.FAASTRIGGERVALUES_TIMER = exports.FAASTRIGGERVALUES_PUBSUB = exports.FAASTRIGGERVALUES_HTTP = exports.FAASTRIGGERVALUES_DATASOURCE = exports.DbCassandraConsistencyLevelValues = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = exports.DbSystemValues = exports.DBSYSTEMVALUES_COCKROACHDB = exports.DBSYSTEMVALUES_MEMCACHED = exports.DBSYSTEMVALUES_ELASTICSEARCH = exports.DBSYSTEMVALUES_GEODE = exports.DBSYSTEMVALUES_NEO4J = exports.DBSYSTEMVALUES_DYNAMODB = exports.DBSYSTEMVALUES_COSMOSDB = exports.DBSYSTEMVALUES_COUCHDB = exports.DBSYSTEMVALUES_COUCHBASE = exports.DBSYSTEMVALUES_REDIS = exports.DBSYSTEMVALUES_MONGODB = exports.DBSYSTEMVALUES_HBASE = exports.DBSYSTEMVALUES_CASSANDRA = exports.DBSYSTEMVALUES_COLDFUSION = exports.DBSYSTEMVALUES_H2 = exports.DBSYSTEMVALUES_VERTICA = exports.DBSYSTEMVALUES_TERADATA = exports.DBSYSTEMVALUES_SYBASE = exports.DBSYSTEMVALUES_SQLITE = exports.DBSYSTEMVALUES_POINTBASE = exports.DBSYSTEMVALUES_PERVASIVE = exports.DBSYSTEMVALUES_NETEZZA = exports.DBSYSTEMVALUES_MARIADB = exports.DBSYSTEMVALUES_INTERBASE = exports.DBSYSTEMVALUES_INSTANTDB = exports.DBSYSTEMVALUES_INFORMIX = undefined;
  exports.MESSAGINGOPERATIONVALUES_RECEIVE = exports.MessagingDestinationKindValues = exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = exports.HttpFlavorValues = exports.HTTPFLAVORVALUES_QUIC = exports.HTTPFLAVORVALUES_SPDY = exports.HTTPFLAVORVALUES_HTTP_2_0 = exports.HTTPFLAVORVALUES_HTTP_1_1 = exports.HTTPFLAVORVALUES_HTTP_1_0 = exports.NetHostConnectionSubtypeValues = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = exports.NetHostConnectionTypeValues = exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = exports.NETHOSTCONNECTIONTYPEVALUES_CELL = exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = exports.NetTransportValues = exports.NETTRANSPORTVALUES_OTHER = exports.NETTRANSPORTVALUES_INPROC = exports.NETTRANSPORTVALUES_PIPE = exports.NETTRANSPORTVALUES_UNIX = exports.NETTRANSPORTVALUES_IP = exports.NETTRANSPORTVALUES_IP_UDP = exports.NETTRANSPORTVALUES_IP_TCP = exports.FaasInvokedProviderValues = exports.FAASINVOKEDPROVIDERVALUES_GCP = exports.FAASINVOKEDPROVIDERVALUES_AZURE = exports.FAASINVOKEDPROVIDERVALUES_AWS = undefined;
  exports.MessageTypeValues = exports.MESSAGETYPEVALUES_RECEIVED = exports.MESSAGETYPEVALUES_SENT = exports.RpcGrpcStatusCodeValues = exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = exports.RPCGRPCSTATUSCODEVALUES_ABORTED = exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = exports.RPCGRPCSTATUSCODEVALUES_OK = exports.MessagingOperationValues = exports.MESSAGINGOPERATIONVALUES_PROCESS = undefined;
  var utils_1 = require_utils6();
  var TMP_AWS_LAMBDA_INVOKED_ARN = "aws.lambda.invoked_arn";
  var TMP_DB_SYSTEM = "db.system";
  var TMP_DB_CONNECTION_STRING = "db.connection_string";
  var TMP_DB_USER = "db.user";
  var TMP_DB_JDBC_DRIVER_CLASSNAME = "db.jdbc.driver_classname";
  var TMP_DB_NAME = "db.name";
  var TMP_DB_STATEMENT = "db.statement";
  var TMP_DB_OPERATION = "db.operation";
  var TMP_DB_MSSQL_INSTANCE_NAME = "db.mssql.instance_name";
  var TMP_DB_CASSANDRA_KEYSPACE = "db.cassandra.keyspace";
  var TMP_DB_CASSANDRA_PAGE_SIZE = "db.cassandra.page_size";
  var TMP_DB_CASSANDRA_CONSISTENCY_LEVEL = "db.cassandra.consistency_level";
  var TMP_DB_CASSANDRA_TABLE = "db.cassandra.table";
  var TMP_DB_CASSANDRA_IDEMPOTENCE = "db.cassandra.idempotence";
  var TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = "db.cassandra.speculative_execution_count";
  var TMP_DB_CASSANDRA_COORDINATOR_ID = "db.cassandra.coordinator.id";
  var TMP_DB_CASSANDRA_COORDINATOR_DC = "db.cassandra.coordinator.dc";
  var TMP_DB_HBASE_NAMESPACE = "db.hbase.namespace";
  var TMP_DB_REDIS_DATABASE_INDEX = "db.redis.database_index";
  var TMP_DB_MONGODB_COLLECTION = "db.mongodb.collection";
  var TMP_DB_SQL_TABLE = "db.sql.table";
  var TMP_EXCEPTION_TYPE = "exception.type";
  var TMP_EXCEPTION_MESSAGE = "exception.message";
  var TMP_EXCEPTION_STACKTRACE = "exception.stacktrace";
  var TMP_EXCEPTION_ESCAPED = "exception.escaped";
  var TMP_FAAS_TRIGGER = "faas.trigger";
  var TMP_FAAS_EXECUTION = "faas.execution";
  var TMP_FAAS_DOCUMENT_COLLECTION = "faas.document.collection";
  var TMP_FAAS_DOCUMENT_OPERATION = "faas.document.operation";
  var TMP_FAAS_DOCUMENT_TIME = "faas.document.time";
  var TMP_FAAS_DOCUMENT_NAME = "faas.document.name";
  var TMP_FAAS_TIME = "faas.time";
  var TMP_FAAS_CRON = "faas.cron";
  var TMP_FAAS_COLDSTART = "faas.coldstart";
  var TMP_FAAS_INVOKED_NAME = "faas.invoked_name";
  var TMP_FAAS_INVOKED_PROVIDER = "faas.invoked_provider";
  var TMP_FAAS_INVOKED_REGION = "faas.invoked_region";
  var TMP_NET_TRANSPORT = "net.transport";
  var TMP_NET_PEER_IP = "net.peer.ip";
  var TMP_NET_PEER_PORT = "net.peer.port";
  var TMP_NET_PEER_NAME = "net.peer.name";
  var TMP_NET_HOST_IP = "net.host.ip";
  var TMP_NET_HOST_PORT = "net.host.port";
  var TMP_NET_HOST_NAME = "net.host.name";
  var TMP_NET_HOST_CONNECTION_TYPE = "net.host.connection.type";
  var TMP_NET_HOST_CONNECTION_SUBTYPE = "net.host.connection.subtype";
  var TMP_NET_HOST_CARRIER_NAME = "net.host.carrier.name";
  var TMP_NET_HOST_CARRIER_MCC = "net.host.carrier.mcc";
  var TMP_NET_HOST_CARRIER_MNC = "net.host.carrier.mnc";
  var TMP_NET_HOST_CARRIER_ICC = "net.host.carrier.icc";
  var TMP_PEER_SERVICE = "peer.service";
  var TMP_ENDUSER_ID = "enduser.id";
  var TMP_ENDUSER_ROLE = "enduser.role";
  var TMP_ENDUSER_SCOPE = "enduser.scope";
  var TMP_THREAD_ID = "thread.id";
  var TMP_THREAD_NAME = "thread.name";
  var TMP_CODE_FUNCTION = "code.function";
  var TMP_CODE_NAMESPACE = "code.namespace";
  var TMP_CODE_FILEPATH = "code.filepath";
  var TMP_CODE_LINENO = "code.lineno";
  var TMP_HTTP_METHOD = "http.method";
  var TMP_HTTP_URL = "http.url";
  var TMP_HTTP_TARGET = "http.target";
  var TMP_HTTP_HOST = "http.host";
  var TMP_HTTP_SCHEME = "http.scheme";
  var TMP_HTTP_STATUS_CODE = "http.status_code";
  var TMP_HTTP_FLAVOR = "http.flavor";
  var TMP_HTTP_USER_AGENT = "http.user_agent";
  var TMP_HTTP_REQUEST_CONTENT_LENGTH = "http.request_content_length";
  var TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = "http.request_content_length_uncompressed";
  var TMP_HTTP_RESPONSE_CONTENT_LENGTH = "http.response_content_length";
  var TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = "http.response_content_length_uncompressed";
  var TMP_HTTP_SERVER_NAME = "http.server_name";
  var TMP_HTTP_ROUTE = "http.route";
  var TMP_HTTP_CLIENT_IP = "http.client_ip";
  var TMP_AWS_DYNAMODB_TABLE_NAMES = "aws.dynamodb.table_names";
  var TMP_AWS_DYNAMODB_CONSUMED_CAPACITY = "aws.dynamodb.consumed_capacity";
  var TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = "aws.dynamodb.item_collection_metrics";
  var TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = "aws.dynamodb.provisioned_read_capacity";
  var TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = "aws.dynamodb.provisioned_write_capacity";
  var TMP_AWS_DYNAMODB_CONSISTENT_READ = "aws.dynamodb.consistent_read";
  var TMP_AWS_DYNAMODB_PROJECTION = "aws.dynamodb.projection";
  var TMP_AWS_DYNAMODB_LIMIT = "aws.dynamodb.limit";
  var TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET = "aws.dynamodb.attributes_to_get";
  var TMP_AWS_DYNAMODB_INDEX_NAME = "aws.dynamodb.index_name";
  var TMP_AWS_DYNAMODB_SELECT = "aws.dynamodb.select";
  var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = "aws.dynamodb.global_secondary_indexes";
  var TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = "aws.dynamodb.local_secondary_indexes";
  var TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = "aws.dynamodb.exclusive_start_table";
  var TMP_AWS_DYNAMODB_TABLE_COUNT = "aws.dynamodb.table_count";
  var TMP_AWS_DYNAMODB_SCAN_FORWARD = "aws.dynamodb.scan_forward";
  var TMP_AWS_DYNAMODB_SEGMENT = "aws.dynamodb.segment";
  var TMP_AWS_DYNAMODB_TOTAL_SEGMENTS = "aws.dynamodb.total_segments";
  var TMP_AWS_DYNAMODB_COUNT = "aws.dynamodb.count";
  var TMP_AWS_DYNAMODB_SCANNED_COUNT = "aws.dynamodb.scanned_count";
  var TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = "aws.dynamodb.attribute_definitions";
  var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = "aws.dynamodb.global_secondary_index_updates";
  var TMP_MESSAGING_SYSTEM = "messaging.system";
  var TMP_MESSAGING_DESTINATION = "messaging.destination";
  var TMP_MESSAGING_DESTINATION_KIND = "messaging.destination_kind";
  var TMP_MESSAGING_TEMP_DESTINATION = "messaging.temp_destination";
  var TMP_MESSAGING_PROTOCOL = "messaging.protocol";
  var TMP_MESSAGING_PROTOCOL_VERSION = "messaging.protocol_version";
  var TMP_MESSAGING_URL = "messaging.url";
  var TMP_MESSAGING_MESSAGE_ID = "messaging.message_id";
  var TMP_MESSAGING_CONVERSATION_ID = "messaging.conversation_id";
  var TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = "messaging.message_payload_size_bytes";
  var TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = "messaging.message_payload_compressed_size_bytes";
  var TMP_MESSAGING_OPERATION = "messaging.operation";
  var TMP_MESSAGING_CONSUMER_ID = "messaging.consumer_id";
  var TMP_MESSAGING_RABBITMQ_ROUTING_KEY = "messaging.rabbitmq.routing_key";
  var TMP_MESSAGING_KAFKA_MESSAGE_KEY = "messaging.kafka.message_key";
  var TMP_MESSAGING_KAFKA_CONSUMER_GROUP = "messaging.kafka.consumer_group";
  var TMP_MESSAGING_KAFKA_CLIENT_ID = "messaging.kafka.client_id";
  var TMP_MESSAGING_KAFKA_PARTITION = "messaging.kafka.partition";
  var TMP_MESSAGING_KAFKA_TOMBSTONE = "messaging.kafka.tombstone";
  var TMP_RPC_SYSTEM = "rpc.system";
  var TMP_RPC_SERVICE = "rpc.service";
  var TMP_RPC_METHOD = "rpc.method";
  var TMP_RPC_GRPC_STATUS_CODE = "rpc.grpc.status_code";
  var TMP_RPC_JSONRPC_VERSION = "rpc.jsonrpc.version";
  var TMP_RPC_JSONRPC_REQUEST_ID = "rpc.jsonrpc.request_id";
  var TMP_RPC_JSONRPC_ERROR_CODE = "rpc.jsonrpc.error_code";
  var TMP_RPC_JSONRPC_ERROR_MESSAGE = "rpc.jsonrpc.error_message";
  var TMP_MESSAGE_TYPE = "message.type";
  var TMP_MESSAGE_ID = "message.id";
  var TMP_MESSAGE_COMPRESSED_SIZE = "message.compressed_size";
  var TMP_MESSAGE_UNCOMPRESSED_SIZE = "message.uncompressed_size";
  exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN;
  exports.SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM;
  exports.SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING;
  exports.SEMATTRS_DB_USER = TMP_DB_USER;
  exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME;
  exports.SEMATTRS_DB_NAME = TMP_DB_NAME;
  exports.SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT;
  exports.SEMATTRS_DB_OPERATION = TMP_DB_OPERATION;
  exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME;
  exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE;
  exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE;
  exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL;
  exports.SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE;
  exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE;
  exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT;
  exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID;
  exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC;
  exports.SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE;
  exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX;
  exports.SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION;
  exports.SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE;
  exports.SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;
  exports.SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;
  exports.SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;
  exports.SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED;
  exports.SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER;
  exports.SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION;
  exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION;
  exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION;
  exports.SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME;
  exports.SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME;
  exports.SEMATTRS_FAAS_TIME = TMP_FAAS_TIME;
  exports.SEMATTRS_FAAS_CRON = TMP_FAAS_CRON;
  exports.SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART;
  exports.SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME;
  exports.SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER;
  exports.SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION;
  exports.SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT;
  exports.SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP;
  exports.SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT;
  exports.SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME;
  exports.SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP;
  exports.SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT;
  exports.SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME;
  exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE;
  exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE;
  exports.SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME;
  exports.SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC;
  exports.SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC;
  exports.SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC;
  exports.SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE;
  exports.SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID;
  exports.SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE;
  exports.SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE;
  exports.SEMATTRS_THREAD_ID = TMP_THREAD_ID;
  exports.SEMATTRS_THREAD_NAME = TMP_THREAD_NAME;
  exports.SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION;
  exports.SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE;
  exports.SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH;
  exports.SEMATTRS_CODE_LINENO = TMP_CODE_LINENO;
  exports.SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD;
  exports.SEMATTRS_HTTP_URL = TMP_HTTP_URL;
  exports.SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET;
  exports.SEMATTRS_HTTP_HOST = TMP_HTTP_HOST;
  exports.SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME;
  exports.SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE;
  exports.SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR;
  exports.SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT;
  exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH;
  exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED;
  exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH;
  exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED;
  exports.SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME;
  exports.SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE;
  exports.SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP;
  exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES;
  exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS;
  exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ;
  exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION;
  exports.SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT;
  exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET;
  exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME;
  exports.SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT;
  exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES;
  exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES;
  exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE;
  exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD;
  exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT;
  exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS;
  exports.SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS;
  exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES;
  exports.SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM;
  exports.SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION;
  exports.SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND;
  exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION;
  exports.SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL;
  exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION;
  exports.SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL;
  exports.SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID;
  exports.SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID;
  exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES;
  exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES;
  exports.SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION;
  exports.SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID;
  exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY;
  exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY;
  exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP;
  exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID;
  exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION;
  exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE;
  exports.SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM;
  exports.SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE;
  exports.SEMATTRS_RPC_METHOD = TMP_RPC_METHOD;
  exports.SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE;
  exports.SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION;
  exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID;
  exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE;
  exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE;
  exports.SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE;
  exports.SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID;
  exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE;
  exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE;
  exports.SemanticAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_AWS_LAMBDA_INVOKED_ARN,
    TMP_DB_SYSTEM,
    TMP_DB_CONNECTION_STRING,
    TMP_DB_USER,
    TMP_DB_JDBC_DRIVER_CLASSNAME,
    TMP_DB_NAME,
    TMP_DB_STATEMENT,
    TMP_DB_OPERATION,
    TMP_DB_MSSQL_INSTANCE_NAME,
    TMP_DB_CASSANDRA_KEYSPACE,
    TMP_DB_CASSANDRA_PAGE_SIZE,
    TMP_DB_CASSANDRA_CONSISTENCY_LEVEL,
    TMP_DB_CASSANDRA_TABLE,
    TMP_DB_CASSANDRA_IDEMPOTENCE,
    TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
    TMP_DB_CASSANDRA_COORDINATOR_ID,
    TMP_DB_CASSANDRA_COORDINATOR_DC,
    TMP_DB_HBASE_NAMESPACE,
    TMP_DB_REDIS_DATABASE_INDEX,
    TMP_DB_MONGODB_COLLECTION,
    TMP_DB_SQL_TABLE,
    TMP_EXCEPTION_TYPE,
    TMP_EXCEPTION_MESSAGE,
    TMP_EXCEPTION_STACKTRACE,
    TMP_EXCEPTION_ESCAPED,
    TMP_FAAS_TRIGGER,
    TMP_FAAS_EXECUTION,
    TMP_FAAS_DOCUMENT_COLLECTION,
    TMP_FAAS_DOCUMENT_OPERATION,
    TMP_FAAS_DOCUMENT_TIME,
    TMP_FAAS_DOCUMENT_NAME,
    TMP_FAAS_TIME,
    TMP_FAAS_CRON,
    TMP_FAAS_COLDSTART,
    TMP_FAAS_INVOKED_NAME,
    TMP_FAAS_INVOKED_PROVIDER,
    TMP_FAAS_INVOKED_REGION,
    TMP_NET_TRANSPORT,
    TMP_NET_PEER_IP,
    TMP_NET_PEER_PORT,
    TMP_NET_PEER_NAME,
    TMP_NET_HOST_IP,
    TMP_NET_HOST_PORT,
    TMP_NET_HOST_NAME,
    TMP_NET_HOST_CONNECTION_TYPE,
    TMP_NET_HOST_CONNECTION_SUBTYPE,
    TMP_NET_HOST_CARRIER_NAME,
    TMP_NET_HOST_CARRIER_MCC,
    TMP_NET_HOST_CARRIER_MNC,
    TMP_NET_HOST_CARRIER_ICC,
    TMP_PEER_SERVICE,
    TMP_ENDUSER_ID,
    TMP_ENDUSER_ROLE,
    TMP_ENDUSER_SCOPE,
    TMP_THREAD_ID,
    TMP_THREAD_NAME,
    TMP_CODE_FUNCTION,
    TMP_CODE_NAMESPACE,
    TMP_CODE_FILEPATH,
    TMP_CODE_LINENO,
    TMP_HTTP_METHOD,
    TMP_HTTP_URL,
    TMP_HTTP_TARGET,
    TMP_HTTP_HOST,
    TMP_HTTP_SCHEME,
    TMP_HTTP_STATUS_CODE,
    TMP_HTTP_FLAVOR,
    TMP_HTTP_USER_AGENT,
    TMP_HTTP_REQUEST_CONTENT_LENGTH,
    TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
    TMP_HTTP_RESPONSE_CONTENT_LENGTH,
    TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
    TMP_HTTP_SERVER_NAME,
    TMP_HTTP_ROUTE,
    TMP_HTTP_CLIENT_IP,
    TMP_AWS_DYNAMODB_TABLE_NAMES,
    TMP_AWS_DYNAMODB_CONSUMED_CAPACITY,
    TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
    TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
    TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
    TMP_AWS_DYNAMODB_CONSISTENT_READ,
    TMP_AWS_DYNAMODB_PROJECTION,
    TMP_AWS_DYNAMODB_LIMIT,
    TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
    TMP_AWS_DYNAMODB_INDEX_NAME,
    TMP_AWS_DYNAMODB_SELECT,
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
    TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
    TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
    TMP_AWS_DYNAMODB_TABLE_COUNT,
    TMP_AWS_DYNAMODB_SCAN_FORWARD,
    TMP_AWS_DYNAMODB_SEGMENT,
    TMP_AWS_DYNAMODB_TOTAL_SEGMENTS,
    TMP_AWS_DYNAMODB_COUNT,
    TMP_AWS_DYNAMODB_SCANNED_COUNT,
    TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
    TMP_MESSAGING_SYSTEM,
    TMP_MESSAGING_DESTINATION,
    TMP_MESSAGING_DESTINATION_KIND,
    TMP_MESSAGING_TEMP_DESTINATION,
    TMP_MESSAGING_PROTOCOL,
    TMP_MESSAGING_PROTOCOL_VERSION,
    TMP_MESSAGING_URL,
    TMP_MESSAGING_MESSAGE_ID,
    TMP_MESSAGING_CONVERSATION_ID,
    TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
    TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
    TMP_MESSAGING_OPERATION,
    TMP_MESSAGING_CONSUMER_ID,
    TMP_MESSAGING_RABBITMQ_ROUTING_KEY,
    TMP_MESSAGING_KAFKA_MESSAGE_KEY,
    TMP_MESSAGING_KAFKA_CONSUMER_GROUP,
    TMP_MESSAGING_KAFKA_CLIENT_ID,
    TMP_MESSAGING_KAFKA_PARTITION,
    TMP_MESSAGING_KAFKA_TOMBSTONE,
    TMP_RPC_SYSTEM,
    TMP_RPC_SERVICE,
    TMP_RPC_METHOD,
    TMP_RPC_GRPC_STATUS_CODE,
    TMP_RPC_JSONRPC_VERSION,
    TMP_RPC_JSONRPC_REQUEST_ID,
    TMP_RPC_JSONRPC_ERROR_CODE,
    TMP_RPC_JSONRPC_ERROR_MESSAGE,
    TMP_MESSAGE_TYPE,
    TMP_MESSAGE_ID,
    TMP_MESSAGE_COMPRESSED_SIZE,
    TMP_MESSAGE_UNCOMPRESSED_SIZE
  ]);
  var TMP_DBSYSTEMVALUES_OTHER_SQL = "other_sql";
  var TMP_DBSYSTEMVALUES_MSSQL = "mssql";
  var TMP_DBSYSTEMVALUES_MYSQL = "mysql";
  var TMP_DBSYSTEMVALUES_ORACLE = "oracle";
  var TMP_DBSYSTEMVALUES_DB2 = "db2";
  var TMP_DBSYSTEMVALUES_POSTGRESQL = "postgresql";
  var TMP_DBSYSTEMVALUES_REDSHIFT = "redshift";
  var TMP_DBSYSTEMVALUES_HIVE = "hive";
  var TMP_DBSYSTEMVALUES_CLOUDSCAPE = "cloudscape";
  var TMP_DBSYSTEMVALUES_HSQLDB = "hsqldb";
  var TMP_DBSYSTEMVALUES_PROGRESS = "progress";
  var TMP_DBSYSTEMVALUES_MAXDB = "maxdb";
  var TMP_DBSYSTEMVALUES_HANADB = "hanadb";
  var TMP_DBSYSTEMVALUES_INGRES = "ingres";
  var TMP_DBSYSTEMVALUES_FIRSTSQL = "firstsql";
  var TMP_DBSYSTEMVALUES_EDB = "edb";
  var TMP_DBSYSTEMVALUES_CACHE = "cache";
  var TMP_DBSYSTEMVALUES_ADABAS = "adabas";
  var TMP_DBSYSTEMVALUES_FIREBIRD = "firebird";
  var TMP_DBSYSTEMVALUES_DERBY = "derby";
  var TMP_DBSYSTEMVALUES_FILEMAKER = "filemaker";
  var TMP_DBSYSTEMVALUES_INFORMIX = "informix";
  var TMP_DBSYSTEMVALUES_INSTANTDB = "instantdb";
  var TMP_DBSYSTEMVALUES_INTERBASE = "interbase";
  var TMP_DBSYSTEMVALUES_MARIADB = "mariadb";
  var TMP_DBSYSTEMVALUES_NETEZZA = "netezza";
  var TMP_DBSYSTEMVALUES_PERVASIVE = "pervasive";
  var TMP_DBSYSTEMVALUES_POINTBASE = "pointbase";
  var TMP_DBSYSTEMVALUES_SQLITE = "sqlite";
  var TMP_DBSYSTEMVALUES_SYBASE = "sybase";
  var TMP_DBSYSTEMVALUES_TERADATA = "teradata";
  var TMP_DBSYSTEMVALUES_VERTICA = "vertica";
  var TMP_DBSYSTEMVALUES_H2 = "h2";
  var TMP_DBSYSTEMVALUES_COLDFUSION = "coldfusion";
  var TMP_DBSYSTEMVALUES_CASSANDRA = "cassandra";
  var TMP_DBSYSTEMVALUES_HBASE = "hbase";
  var TMP_DBSYSTEMVALUES_MONGODB = "mongodb";
  var TMP_DBSYSTEMVALUES_REDIS = "redis";
  var TMP_DBSYSTEMVALUES_COUCHBASE = "couchbase";
  var TMP_DBSYSTEMVALUES_COUCHDB = "couchdb";
  var TMP_DBSYSTEMVALUES_COSMOSDB = "cosmosdb";
  var TMP_DBSYSTEMVALUES_DYNAMODB = "dynamodb";
  var TMP_DBSYSTEMVALUES_NEO4J = "neo4j";
  var TMP_DBSYSTEMVALUES_GEODE = "geode";
  var TMP_DBSYSTEMVALUES_ELASTICSEARCH = "elasticsearch";
  var TMP_DBSYSTEMVALUES_MEMCACHED = "memcached";
  var TMP_DBSYSTEMVALUES_COCKROACHDB = "cockroachdb";
  exports.DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL;
  exports.DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL;
  exports.DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL;
  exports.DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE;
  exports.DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB2;
  exports.DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL;
  exports.DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT;
  exports.DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE;
  exports.DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE;
  exports.DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB;
  exports.DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS;
  exports.DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB;
  exports.DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB;
  exports.DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES;
  exports.DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL;
  exports.DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB;
  exports.DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE;
  exports.DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS;
  exports.DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD;
  exports.DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY;
  exports.DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER;
  exports.DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX;
  exports.DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB;
  exports.DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE;
  exports.DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB;
  exports.DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA;
  exports.DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE;
  exports.DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE;
  exports.DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE;
  exports.DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE;
  exports.DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA;
  exports.DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA;
  exports.DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H2;
  exports.DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION;
  exports.DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA;
  exports.DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE;
  exports.DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB;
  exports.DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS;
  exports.DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE;
  exports.DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB;
  exports.DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB;
  exports.DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB;
  exports.DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J;
  exports.DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE;
  exports.DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH;
  exports.DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED;
  exports.DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB;
  exports.DbSystemValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_DBSYSTEMVALUES_OTHER_SQL,
    TMP_DBSYSTEMVALUES_MSSQL,
    TMP_DBSYSTEMVALUES_MYSQL,
    TMP_DBSYSTEMVALUES_ORACLE,
    TMP_DBSYSTEMVALUES_DB2,
    TMP_DBSYSTEMVALUES_POSTGRESQL,
    TMP_DBSYSTEMVALUES_REDSHIFT,
    TMP_DBSYSTEMVALUES_HIVE,
    TMP_DBSYSTEMVALUES_CLOUDSCAPE,
    TMP_DBSYSTEMVALUES_HSQLDB,
    TMP_DBSYSTEMVALUES_PROGRESS,
    TMP_DBSYSTEMVALUES_MAXDB,
    TMP_DBSYSTEMVALUES_HANADB,
    TMP_DBSYSTEMVALUES_INGRES,
    TMP_DBSYSTEMVALUES_FIRSTSQL,
    TMP_DBSYSTEMVALUES_EDB,
    TMP_DBSYSTEMVALUES_CACHE,
    TMP_DBSYSTEMVALUES_ADABAS,
    TMP_DBSYSTEMVALUES_FIREBIRD,
    TMP_DBSYSTEMVALUES_DERBY,
    TMP_DBSYSTEMVALUES_FILEMAKER,
    TMP_DBSYSTEMVALUES_INFORMIX,
    TMP_DBSYSTEMVALUES_INSTANTDB,
    TMP_DBSYSTEMVALUES_INTERBASE,
    TMP_DBSYSTEMVALUES_MARIADB,
    TMP_DBSYSTEMVALUES_NETEZZA,
    TMP_DBSYSTEMVALUES_PERVASIVE,
    TMP_DBSYSTEMVALUES_POINTBASE,
    TMP_DBSYSTEMVALUES_SQLITE,
    TMP_DBSYSTEMVALUES_SYBASE,
    TMP_DBSYSTEMVALUES_TERADATA,
    TMP_DBSYSTEMVALUES_VERTICA,
    TMP_DBSYSTEMVALUES_H2,
    TMP_DBSYSTEMVALUES_COLDFUSION,
    TMP_DBSYSTEMVALUES_CASSANDRA,
    TMP_DBSYSTEMVALUES_HBASE,
    TMP_DBSYSTEMVALUES_MONGODB,
    TMP_DBSYSTEMVALUES_REDIS,
    TMP_DBSYSTEMVALUES_COUCHBASE,
    TMP_DBSYSTEMVALUES_COUCHDB,
    TMP_DBSYSTEMVALUES_COSMOSDB,
    TMP_DBSYSTEMVALUES_DYNAMODB,
    TMP_DBSYSTEMVALUES_NEO4J,
    TMP_DBSYSTEMVALUES_GEODE,
    TMP_DBSYSTEMVALUES_ELASTICSEARCH,
    TMP_DBSYSTEMVALUES_MEMCACHED,
    TMP_DBSYSTEMVALUES_COCKROACHDB
  ]);
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL = "all";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = "each_quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = "quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = "local_quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE = "one";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO = "two";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE = "three";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = "local_one";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY = "any";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = "serial";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = "local_serial";
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL;
  exports.DbCassandraConsistencyLevelValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL
  ]);
  var TMP_FAASTRIGGERVALUES_DATASOURCE = "datasource";
  var TMP_FAASTRIGGERVALUES_HTTP = "http";
  var TMP_FAASTRIGGERVALUES_PUBSUB = "pubsub";
  var TMP_FAASTRIGGERVALUES_TIMER = "timer";
  var TMP_FAASTRIGGERVALUES_OTHER = "other";
  exports.FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE;
  exports.FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP;
  exports.FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB;
  exports.FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER;
  exports.FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER;
  exports.FaasTriggerValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASTRIGGERVALUES_DATASOURCE,
    TMP_FAASTRIGGERVALUES_HTTP,
    TMP_FAASTRIGGERVALUES_PUBSUB,
    TMP_FAASTRIGGERVALUES_TIMER,
    TMP_FAASTRIGGERVALUES_OTHER
  ]);
  var TMP_FAASDOCUMENTOPERATIONVALUES_INSERT = "insert";
  var TMP_FAASDOCUMENTOPERATIONVALUES_EDIT = "edit";
  var TMP_FAASDOCUMENTOPERATIONVALUES_DELETE = "delete";
  exports.FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT;
  exports.FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT;
  exports.FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE;
  exports.FaasDocumentOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASDOCUMENTOPERATIONVALUES_INSERT,
    TMP_FAASDOCUMENTOPERATIONVALUES_EDIT,
    TMP_FAASDOCUMENTOPERATIONVALUES_DELETE
  ]);
  var TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
  var TMP_FAASINVOKEDPROVIDERVALUES_AWS = "aws";
  var TMP_FAASINVOKEDPROVIDERVALUES_AZURE = "azure";
  var TMP_FAASINVOKEDPROVIDERVALUES_GCP = "gcp";
  exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD;
  exports.FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS;
  exports.FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE;
  exports.FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP;
  exports.FaasInvokedProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
    TMP_FAASINVOKEDPROVIDERVALUES_AWS,
    TMP_FAASINVOKEDPROVIDERVALUES_AZURE,
    TMP_FAASINVOKEDPROVIDERVALUES_GCP
  ]);
  var TMP_NETTRANSPORTVALUES_IP_TCP = "ip_tcp";
  var TMP_NETTRANSPORTVALUES_IP_UDP = "ip_udp";
  var TMP_NETTRANSPORTVALUES_IP = "ip";
  var TMP_NETTRANSPORTVALUES_UNIX = "unix";
  var TMP_NETTRANSPORTVALUES_PIPE = "pipe";
  var TMP_NETTRANSPORTVALUES_INPROC = "inproc";
  var TMP_NETTRANSPORTVALUES_OTHER = "other";
  exports.NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP;
  exports.NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP;
  exports.NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP;
  exports.NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX;
  exports.NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE;
  exports.NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC;
  exports.NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER;
  exports.NetTransportValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETTRANSPORTVALUES_IP_TCP,
    TMP_NETTRANSPORTVALUES_IP_UDP,
    TMP_NETTRANSPORTVALUES_IP,
    TMP_NETTRANSPORTVALUES_UNIX,
    TMP_NETTRANSPORTVALUES_PIPE,
    TMP_NETTRANSPORTVALUES_INPROC,
    TMP_NETTRANSPORTVALUES_OTHER
  ]);
  var TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI = "wifi";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED = "wired";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_CELL = "cell";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = "unavailable";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = "unknown";
  exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI;
  exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED;
  exports.NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL;
  exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE;
  exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN;
  exports.NetHostConnectionTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI,
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED,
    TMP_NETHOSTCONNECTIONTYPEVALUES_CELL,
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN
  ]);
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = "gprs";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = "edge";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = "umts";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = "cdma";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = "evdo_0";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = "evdo_a";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = "cdma2000_1xrtt";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = "hsdpa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = "hsupa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = "hspa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = "iden";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = "evdo_b";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE = "lte";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = "ehrpd";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = "hspap";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM = "gsm";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = "td_scdma";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = "iwlan";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR = "nr";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = "nrnsa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = "lte_ca";
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA;
  exports.NetHostConnectionSubtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA
  ]);
  var TMP_HTTPFLAVORVALUES_HTTP_1_0 = "1.0";
  var TMP_HTTPFLAVORVALUES_HTTP_1_1 = "1.1";
  var TMP_HTTPFLAVORVALUES_HTTP_2_0 = "2.0";
  var TMP_HTTPFLAVORVALUES_SPDY = "SPDY";
  var TMP_HTTPFLAVORVALUES_QUIC = "QUIC";
  exports.HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_0;
  exports.HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_1;
  exports.HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_0;
  exports.HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY;
  exports.HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC;
  exports.HttpFlavorValues = {
    HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_0,
    HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_1,
    HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_0,
    SPDY: TMP_HTTPFLAVORVALUES_SPDY,
    QUIC: TMP_HTTPFLAVORVALUES_QUIC
  };
  var TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE = "queue";
  var TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC = "topic";
  exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE;
  exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC;
  exports.MessagingDestinationKindValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE,
    TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC
  ]);
  var TMP_MESSAGINGOPERATIONVALUES_RECEIVE = "receive";
  var TMP_MESSAGINGOPERATIONVALUES_PROCESS = "process";
  exports.MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE;
  exports.MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS;
  exports.MessagingOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGINGOPERATIONVALUES_RECEIVE,
    TMP_MESSAGINGOPERATIONVALUES_PROCESS
  ]);
  var TMP_RPCGRPCSTATUSCODEVALUES_OK = 0;
  var TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED = 1;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN = 2;
  var TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = 3;
  var TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = 4;
  var TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND = 5;
  var TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = 6;
  var TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = 7;
  var TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = 8;
  var TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = 9;
  var TMP_RPCGRPCSTATUSCODEVALUES_ABORTED = 10;
  var TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = 11;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = 12;
  var TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL = 13;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = 14;
  var TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS = 15;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = 16;
  exports.RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK;
  exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED;
  exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN;
  exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT;
  exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED;
  exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND;
  exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS;
  exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED;
  exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED;
  exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION;
  exports.RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED;
  exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE;
  exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED;
  exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL;
  exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE;
  exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS;
  exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED;
  exports.RpcGrpcStatusCodeValues = {
    OK: TMP_RPCGRPCSTATUSCODEVALUES_OK,
    CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED,
    UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN,
    INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
    DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
    NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
    ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
    PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
    RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
    FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
    ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED,
    OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
    UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
    INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL,
    UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
    DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
    UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED
  };
  var TMP_MESSAGETYPEVALUES_SENT = "SENT";
  var TMP_MESSAGETYPEVALUES_RECEIVED = "RECEIVED";
  exports.MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT;
  exports.MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED;
  exports.MessageTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGETYPEVALUES_SENT,
    TMP_MESSAGETYPEVALUES_RECEIVED
  ]);
});

// ../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js
var require_trace3 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(require_SemanticAttributes2(), exports);
});

// ../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js
var require_SemanticResourceAttributes2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SEMRESATTRS_K8S_STATEFULSET_NAME = exports.SEMRESATTRS_K8S_STATEFULSET_UID = exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = exports.SEMRESATTRS_K8S_REPLICASET_NAME = exports.SEMRESATTRS_K8S_REPLICASET_UID = exports.SEMRESATTRS_K8S_CONTAINER_NAME = exports.SEMRESATTRS_K8S_POD_NAME = exports.SEMRESATTRS_K8S_POD_UID = exports.SEMRESATTRS_K8S_NAMESPACE_NAME = exports.SEMRESATTRS_K8S_NODE_UID = exports.SEMRESATTRS_K8S_NODE_NAME = exports.SEMRESATTRS_K8S_CLUSTER_NAME = exports.SEMRESATTRS_HOST_IMAGE_VERSION = exports.SEMRESATTRS_HOST_IMAGE_ID = exports.SEMRESATTRS_HOST_IMAGE_NAME = exports.SEMRESATTRS_HOST_ARCH = exports.SEMRESATTRS_HOST_TYPE = exports.SEMRESATTRS_HOST_NAME = exports.SEMRESATTRS_HOST_ID = exports.SEMRESATTRS_FAAS_MAX_MEMORY = exports.SEMRESATTRS_FAAS_INSTANCE = exports.SEMRESATTRS_FAAS_VERSION = exports.SEMRESATTRS_FAAS_ID = exports.SEMRESATTRS_FAAS_NAME = exports.SEMRESATTRS_DEVICE_MODEL_NAME = exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = exports.SEMRESATTRS_DEVICE_ID = exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = exports.SEMRESATTRS_CONTAINER_RUNTIME = exports.SEMRESATTRS_CONTAINER_ID = exports.SEMRESATTRS_CONTAINER_NAME = exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = exports.SEMRESATTRS_AWS_ECS_TASK_ARN = exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = exports.SEMRESATTRS_CLOUD_PLATFORM = exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = exports.SEMRESATTRS_CLOUD_REGION = exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = exports.SEMRESATTRS_CLOUD_PROVIDER = undefined;
  exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = exports.CLOUDPLATFORMVALUES_AZURE_AKS = exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = exports.CLOUDPLATFORMVALUES_AZURE_VM = exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = exports.CLOUDPLATFORMVALUES_AWS_EKS = exports.CLOUDPLATFORMVALUES_AWS_ECS = exports.CLOUDPLATFORMVALUES_AWS_EC2 = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = exports.CloudProviderValues = exports.CLOUDPROVIDERVALUES_GCP = exports.CLOUDPROVIDERVALUES_AZURE = exports.CLOUDPROVIDERVALUES_AWS = exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = exports.SemanticResourceAttributes = exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = exports.SEMRESATTRS_WEBENGINE_VERSION = exports.SEMRESATTRS_WEBENGINE_NAME = exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = exports.SEMRESATTRS_TELEMETRY_SDK_NAME = exports.SEMRESATTRS_SERVICE_VERSION = exports.SEMRESATTRS_SERVICE_INSTANCE_ID = exports.SEMRESATTRS_SERVICE_NAMESPACE = exports.SEMRESATTRS_SERVICE_NAME = exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = exports.SEMRESATTRS_PROCESS_OWNER = exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = exports.SEMRESATTRS_PROCESS_COMMAND_LINE = exports.SEMRESATTRS_PROCESS_COMMAND = exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = exports.SEMRESATTRS_PROCESS_PID = exports.SEMRESATTRS_OS_VERSION = exports.SEMRESATTRS_OS_NAME = exports.SEMRESATTRS_OS_DESCRIPTION = exports.SEMRESATTRS_OS_TYPE = exports.SEMRESATTRS_K8S_CRONJOB_NAME = exports.SEMRESATTRS_K8S_CRONJOB_UID = exports.SEMRESATTRS_K8S_JOB_NAME = exports.SEMRESATTRS_K8S_JOB_UID = exports.SEMRESATTRS_K8S_DAEMONSET_NAME = exports.SEMRESATTRS_K8S_DAEMONSET_UID = undefined;
  exports.TelemetrySdkLanguageValues = exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = exports.TELEMETRYSDKLANGUAGEVALUES_PHP = exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = exports.TELEMETRYSDKLANGUAGEVALUES_GO = exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = exports.TELEMETRYSDKLANGUAGEVALUES_CPP = exports.OsTypeValues = exports.OSTYPEVALUES_Z_OS = exports.OSTYPEVALUES_SOLARIS = exports.OSTYPEVALUES_AIX = exports.OSTYPEVALUES_HPUX = exports.OSTYPEVALUES_DRAGONFLYBSD = exports.OSTYPEVALUES_OPENBSD = exports.OSTYPEVALUES_NETBSD = exports.OSTYPEVALUES_FREEBSD = exports.OSTYPEVALUES_DARWIN = exports.OSTYPEVALUES_LINUX = exports.OSTYPEVALUES_WINDOWS = exports.HostArchValues = exports.HOSTARCHVALUES_X86 = exports.HOSTARCHVALUES_PPC64 = exports.HOSTARCHVALUES_PPC32 = exports.HOSTARCHVALUES_IA64 = exports.HOSTARCHVALUES_ARM64 = exports.HOSTARCHVALUES_ARM32 = exports.HOSTARCHVALUES_AMD64 = exports.AwsEcsLaunchtypeValues = exports.AWSECSLAUNCHTYPEVALUES_FARGATE = exports.AWSECSLAUNCHTYPEVALUES_EC2 = exports.CloudPlatformValues = exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = undefined;
  var utils_1 = require_utils6();
  var TMP_CLOUD_PROVIDER = "cloud.provider";
  var TMP_CLOUD_ACCOUNT_ID = "cloud.account.id";
  var TMP_CLOUD_REGION = "cloud.region";
  var TMP_CLOUD_AVAILABILITY_ZONE = "cloud.availability_zone";
  var TMP_CLOUD_PLATFORM = "cloud.platform";
  var TMP_AWS_ECS_CONTAINER_ARN = "aws.ecs.container.arn";
  var TMP_AWS_ECS_CLUSTER_ARN = "aws.ecs.cluster.arn";
  var TMP_AWS_ECS_LAUNCHTYPE = "aws.ecs.launchtype";
  var TMP_AWS_ECS_TASK_ARN = "aws.ecs.task.arn";
  var TMP_AWS_ECS_TASK_FAMILY = "aws.ecs.task.family";
  var TMP_AWS_ECS_TASK_REVISION = "aws.ecs.task.revision";
  var TMP_AWS_EKS_CLUSTER_ARN = "aws.eks.cluster.arn";
  var TMP_AWS_LOG_GROUP_NAMES = "aws.log.group.names";
  var TMP_AWS_LOG_GROUP_ARNS = "aws.log.group.arns";
  var TMP_AWS_LOG_STREAM_NAMES = "aws.log.stream.names";
  var TMP_AWS_LOG_STREAM_ARNS = "aws.log.stream.arns";
  var TMP_CONTAINER_NAME = "container.name";
  var TMP_CONTAINER_ID = "container.id";
  var TMP_CONTAINER_RUNTIME = "container.runtime";
  var TMP_CONTAINER_IMAGE_NAME = "container.image.name";
  var TMP_CONTAINER_IMAGE_TAG = "container.image.tag";
  var TMP_DEPLOYMENT_ENVIRONMENT = "deployment.environment";
  var TMP_DEVICE_ID = "device.id";
  var TMP_DEVICE_MODEL_IDENTIFIER = "device.model.identifier";
  var TMP_DEVICE_MODEL_NAME = "device.model.name";
  var TMP_FAAS_NAME = "faas.name";
  var TMP_FAAS_ID = "faas.id";
  var TMP_FAAS_VERSION = "faas.version";
  var TMP_FAAS_INSTANCE = "faas.instance";
  var TMP_FAAS_MAX_MEMORY = "faas.max_memory";
  var TMP_HOST_ID = "host.id";
  var TMP_HOST_NAME = "host.name";
  var TMP_HOST_TYPE = "host.type";
  var TMP_HOST_ARCH = "host.arch";
  var TMP_HOST_IMAGE_NAME = "host.image.name";
  var TMP_HOST_IMAGE_ID = "host.image.id";
  var TMP_HOST_IMAGE_VERSION = "host.image.version";
  var TMP_K8S_CLUSTER_NAME = "k8s.cluster.name";
  var TMP_K8S_NODE_NAME = "k8s.node.name";
  var TMP_K8S_NODE_UID = "k8s.node.uid";
  var TMP_K8S_NAMESPACE_NAME = "k8s.namespace.name";
  var TMP_K8S_POD_UID = "k8s.pod.uid";
  var TMP_K8S_POD_NAME = "k8s.pod.name";
  var TMP_K8S_CONTAINER_NAME = "k8s.container.name";
  var TMP_K8S_REPLICASET_UID = "k8s.replicaset.uid";
  var TMP_K8S_REPLICASET_NAME = "k8s.replicaset.name";
  var TMP_K8S_DEPLOYMENT_UID = "k8s.deployment.uid";
  var TMP_K8S_DEPLOYMENT_NAME = "k8s.deployment.name";
  var TMP_K8S_STATEFULSET_UID = "k8s.statefulset.uid";
  var TMP_K8S_STATEFULSET_NAME = "k8s.statefulset.name";
  var TMP_K8S_DAEMONSET_UID = "k8s.daemonset.uid";
  var TMP_K8S_DAEMONSET_NAME = "k8s.daemonset.name";
  var TMP_K8S_JOB_UID = "k8s.job.uid";
  var TMP_K8S_JOB_NAME = "k8s.job.name";
  var TMP_K8S_CRONJOB_UID = "k8s.cronjob.uid";
  var TMP_K8S_CRONJOB_NAME = "k8s.cronjob.name";
  var TMP_OS_TYPE = "os.type";
  var TMP_OS_DESCRIPTION = "os.description";
  var TMP_OS_NAME = "os.name";
  var TMP_OS_VERSION = "os.version";
  var TMP_PROCESS_PID = "process.pid";
  var TMP_PROCESS_EXECUTABLE_NAME = "process.executable.name";
  var TMP_PROCESS_EXECUTABLE_PATH = "process.executable.path";
  var TMP_PROCESS_COMMAND = "process.command";
  var TMP_PROCESS_COMMAND_LINE = "process.command_line";
  var TMP_PROCESS_COMMAND_ARGS = "process.command_args";
  var TMP_PROCESS_OWNER = "process.owner";
  var TMP_PROCESS_RUNTIME_NAME = "process.runtime.name";
  var TMP_PROCESS_RUNTIME_VERSION = "process.runtime.version";
  var TMP_PROCESS_RUNTIME_DESCRIPTION = "process.runtime.description";
  var TMP_SERVICE_NAME = "service.name";
  var TMP_SERVICE_NAMESPACE = "service.namespace";
  var TMP_SERVICE_INSTANCE_ID = "service.instance.id";
  var TMP_SERVICE_VERSION = "service.version";
  var TMP_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
  var TMP_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
  var TMP_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
  var TMP_TELEMETRY_AUTO_VERSION = "telemetry.auto.version";
  var TMP_WEBENGINE_NAME = "webengine.name";
  var TMP_WEBENGINE_VERSION = "webengine.version";
  var TMP_WEBENGINE_DESCRIPTION = "webengine.description";
  exports.SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER;
  exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID;
  exports.SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION;
  exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE;
  exports.SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM;
  exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN;
  exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN;
  exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE;
  exports.SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN;
  exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY;
  exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION;
  exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN;
  exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES;
  exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS;
  exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES;
  exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS;
  exports.SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME;
  exports.SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID;
  exports.SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME;
  exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME;
  exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG;
  exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT;
  exports.SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID;
  exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER;
  exports.SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME;
  exports.SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME;
  exports.SEMRESATTRS_FAAS_ID = TMP_FAAS_ID;
  exports.SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION;
  exports.SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE;
  exports.SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY;
  exports.SEMRESATTRS_HOST_ID = TMP_HOST_ID;
  exports.SEMRESATTRS_HOST_NAME = TMP_HOST_NAME;
  exports.SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE;
  exports.SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH;
  exports.SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME;
  exports.SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID;
  exports.SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION;
  exports.SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME;
  exports.SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME;
  exports.SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID;
  exports.SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME;
  exports.SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID;
  exports.SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME;
  exports.SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME;
  exports.SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID;
  exports.SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME;
  exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID;
  exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME;
  exports.SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID;
  exports.SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME;
  exports.SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID;
  exports.SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME;
  exports.SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID;
  exports.SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME;
  exports.SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID;
  exports.SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME;
  exports.SEMRESATTRS_OS_TYPE = TMP_OS_TYPE;
  exports.SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION;
  exports.SEMRESATTRS_OS_NAME = TMP_OS_NAME;
  exports.SEMRESATTRS_OS_VERSION = TMP_OS_VERSION;
  exports.SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID;
  exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME;
  exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH;
  exports.SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND;
  exports.SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE;
  exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS;
  exports.SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER;
  exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME;
  exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION;
  exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION;
  exports.SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME;
  exports.SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE;
  exports.SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID;
  exports.SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION;
  exports.SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME;
  exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE;
  exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION;
  exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION;
  exports.SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME;
  exports.SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION;
  exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION;
  exports.SemanticResourceAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUD_PROVIDER,
    TMP_CLOUD_ACCOUNT_ID,
    TMP_CLOUD_REGION,
    TMP_CLOUD_AVAILABILITY_ZONE,
    TMP_CLOUD_PLATFORM,
    TMP_AWS_ECS_CONTAINER_ARN,
    TMP_AWS_ECS_CLUSTER_ARN,
    TMP_AWS_ECS_LAUNCHTYPE,
    TMP_AWS_ECS_TASK_ARN,
    TMP_AWS_ECS_TASK_FAMILY,
    TMP_AWS_ECS_TASK_REVISION,
    TMP_AWS_EKS_CLUSTER_ARN,
    TMP_AWS_LOG_GROUP_NAMES,
    TMP_AWS_LOG_GROUP_ARNS,
    TMP_AWS_LOG_STREAM_NAMES,
    TMP_AWS_LOG_STREAM_ARNS,
    TMP_CONTAINER_NAME,
    TMP_CONTAINER_ID,
    TMP_CONTAINER_RUNTIME,
    TMP_CONTAINER_IMAGE_NAME,
    TMP_CONTAINER_IMAGE_TAG,
    TMP_DEPLOYMENT_ENVIRONMENT,
    TMP_DEVICE_ID,
    TMP_DEVICE_MODEL_IDENTIFIER,
    TMP_DEVICE_MODEL_NAME,
    TMP_FAAS_NAME,
    TMP_FAAS_ID,
    TMP_FAAS_VERSION,
    TMP_FAAS_INSTANCE,
    TMP_FAAS_MAX_MEMORY,
    TMP_HOST_ID,
    TMP_HOST_NAME,
    TMP_HOST_TYPE,
    TMP_HOST_ARCH,
    TMP_HOST_IMAGE_NAME,
    TMP_HOST_IMAGE_ID,
    TMP_HOST_IMAGE_VERSION,
    TMP_K8S_CLUSTER_NAME,
    TMP_K8S_NODE_NAME,
    TMP_K8S_NODE_UID,
    TMP_K8S_NAMESPACE_NAME,
    TMP_K8S_POD_UID,
    TMP_K8S_POD_NAME,
    TMP_K8S_CONTAINER_NAME,
    TMP_K8S_REPLICASET_UID,
    TMP_K8S_REPLICASET_NAME,
    TMP_K8S_DEPLOYMENT_UID,
    TMP_K8S_DEPLOYMENT_NAME,
    TMP_K8S_STATEFULSET_UID,
    TMP_K8S_STATEFULSET_NAME,
    TMP_K8S_DAEMONSET_UID,
    TMP_K8S_DAEMONSET_NAME,
    TMP_K8S_JOB_UID,
    TMP_K8S_JOB_NAME,
    TMP_K8S_CRONJOB_UID,
    TMP_K8S_CRONJOB_NAME,
    TMP_OS_TYPE,
    TMP_OS_DESCRIPTION,
    TMP_OS_NAME,
    TMP_OS_VERSION,
    TMP_PROCESS_PID,
    TMP_PROCESS_EXECUTABLE_NAME,
    TMP_PROCESS_EXECUTABLE_PATH,
    TMP_PROCESS_COMMAND,
    TMP_PROCESS_COMMAND_LINE,
    TMP_PROCESS_COMMAND_ARGS,
    TMP_PROCESS_OWNER,
    TMP_PROCESS_RUNTIME_NAME,
    TMP_PROCESS_RUNTIME_VERSION,
    TMP_PROCESS_RUNTIME_DESCRIPTION,
    TMP_SERVICE_NAME,
    TMP_SERVICE_NAMESPACE,
    TMP_SERVICE_INSTANCE_ID,
    TMP_SERVICE_VERSION,
    TMP_TELEMETRY_SDK_NAME,
    TMP_TELEMETRY_SDK_LANGUAGE,
    TMP_TELEMETRY_SDK_VERSION,
    TMP_TELEMETRY_AUTO_VERSION,
    TMP_WEBENGINE_NAME,
    TMP_WEBENGINE_VERSION,
    TMP_WEBENGINE_DESCRIPTION
  ]);
  var TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
  var TMP_CLOUDPROVIDERVALUES_AWS = "aws";
  var TMP_CLOUDPROVIDERVALUES_AZURE = "azure";
  var TMP_CLOUDPROVIDERVALUES_GCP = "gcp";
  exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD;
  exports.CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS;
  exports.CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE;
  exports.CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP;
  exports.CloudProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
    TMP_CLOUDPROVIDERVALUES_AWS,
    TMP_CLOUDPROVIDERVALUES_AZURE,
    TMP_CLOUDPROVIDERVALUES_GCP
  ]);
  var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = "alibaba_cloud_ecs";
  var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = "alibaba_cloud_fc";
  var TMP_CLOUDPLATFORMVALUES_AWS_EC2 = "aws_ec2";
  var TMP_CLOUDPLATFORMVALUES_AWS_ECS = "aws_ecs";
  var TMP_CLOUDPLATFORMVALUES_AWS_EKS = "aws_eks";
  var TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA = "aws_lambda";
  var TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = "aws_elastic_beanstalk";
  var TMP_CLOUDPLATFORMVALUES_AZURE_VM = "azure_vm";
  var TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = "azure_container_instances";
  var TMP_CLOUDPLATFORMVALUES_AZURE_AKS = "azure_aks";
  var TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = "azure_functions";
  var TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = "azure_app_service";
  var TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = "gcp_compute_engine";
  var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = "gcp_cloud_run";
  var TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = "gcp_kubernetes_engine";
  var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = "gcp_cloud_functions";
  var TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE = "gcp_app_engine";
  exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS;
  exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC;
  exports.CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC2;
  exports.CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS;
  exports.CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS;
  exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA;
  exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK;
  exports.CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM;
  exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES;
  exports.CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS;
  exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS;
  exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE;
  exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE;
  exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN;
  exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE;
  exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS;
  exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE;
  exports.CloudPlatformValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
    TMP_CLOUDPLATFORMVALUES_AWS_EC2,
    TMP_CLOUDPLATFORMVALUES_AWS_ECS,
    TMP_CLOUDPLATFORMVALUES_AWS_EKS,
    TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA,
    TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
    TMP_CLOUDPLATFORMVALUES_AZURE_VM,
    TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
    TMP_CLOUDPLATFORMVALUES_AZURE_AKS,
    TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
    TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
    TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
    TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
    TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE
  ]);
  var TMP_AWSECSLAUNCHTYPEVALUES_EC2 = "ec2";
  var TMP_AWSECSLAUNCHTYPEVALUES_FARGATE = "fargate";
  exports.AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC2;
  exports.AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE;
  exports.AwsEcsLaunchtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_AWSECSLAUNCHTYPEVALUES_EC2,
    TMP_AWSECSLAUNCHTYPEVALUES_FARGATE
  ]);
  var TMP_HOSTARCHVALUES_AMD64 = "amd64";
  var TMP_HOSTARCHVALUES_ARM32 = "arm32";
  var TMP_HOSTARCHVALUES_ARM64 = "arm64";
  var TMP_HOSTARCHVALUES_IA64 = "ia64";
  var TMP_HOSTARCHVALUES_PPC32 = "ppc32";
  var TMP_HOSTARCHVALUES_PPC64 = "ppc64";
  var TMP_HOSTARCHVALUES_X86 = "x86";
  exports.HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD64;
  exports.HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM32;
  exports.HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM64;
  exports.HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA64;
  exports.HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC32;
  exports.HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC64;
  exports.HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X86;
  exports.HostArchValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_HOSTARCHVALUES_AMD64,
    TMP_HOSTARCHVALUES_ARM32,
    TMP_HOSTARCHVALUES_ARM64,
    TMP_HOSTARCHVALUES_IA64,
    TMP_HOSTARCHVALUES_PPC32,
    TMP_HOSTARCHVALUES_PPC64,
    TMP_HOSTARCHVALUES_X86
  ]);
  var TMP_OSTYPEVALUES_WINDOWS = "windows";
  var TMP_OSTYPEVALUES_LINUX = "linux";
  var TMP_OSTYPEVALUES_DARWIN = "darwin";
  var TMP_OSTYPEVALUES_FREEBSD = "freebsd";
  var TMP_OSTYPEVALUES_NETBSD = "netbsd";
  var TMP_OSTYPEVALUES_OPENBSD = "openbsd";
  var TMP_OSTYPEVALUES_DRAGONFLYBSD = "dragonflybsd";
  var TMP_OSTYPEVALUES_HPUX = "hpux";
  var TMP_OSTYPEVALUES_AIX = "aix";
  var TMP_OSTYPEVALUES_SOLARIS = "solaris";
  var TMP_OSTYPEVALUES_Z_OS = "z_os";
  exports.OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS;
  exports.OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX;
  exports.OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN;
  exports.OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD;
  exports.OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD;
  exports.OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD;
  exports.OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD;
  exports.OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX;
  exports.OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX;
  exports.OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS;
  exports.OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS;
  exports.OsTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_OSTYPEVALUES_WINDOWS,
    TMP_OSTYPEVALUES_LINUX,
    TMP_OSTYPEVALUES_DARWIN,
    TMP_OSTYPEVALUES_FREEBSD,
    TMP_OSTYPEVALUES_NETBSD,
    TMP_OSTYPEVALUES_OPENBSD,
    TMP_OSTYPEVALUES_DRAGONFLYBSD,
    TMP_OSTYPEVALUES_HPUX,
    TMP_OSTYPEVALUES_AIX,
    TMP_OSTYPEVALUES_SOLARIS,
    TMP_OSTYPEVALUES_Z_OS
  ]);
  var TMP_TELEMETRYSDKLANGUAGEVALUES_CPP = "cpp";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET = "dotnet";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG = "erlang";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_GO = "go";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA = "java";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS = "nodejs";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_PHP = "php";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON = "python";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY = "ruby";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS = "webjs";
  exports.TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP;
  exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET;
  exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG;
  exports.TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO;
  exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA;
  exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS;
  exports.TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP;
  exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON;
  exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY;
  exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS;
  exports.TelemetrySdkLanguageValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_TELEMETRYSDKLANGUAGEVALUES_CPP,
    TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET,
    TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG,
    TMP_TELEMETRYSDKLANGUAGEVALUES_GO,
    TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA,
    TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS,
    TMP_TELEMETRYSDKLANGUAGEVALUES_PHP,
    TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON,
    TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY,
    TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS
  ]);
});

// ../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js
var require_resource2 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(require_SemanticResourceAttributes2(), exports);
});

// ../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/src/stable_attributes.js
var require_stable_attributes2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HTTP_REQUEST_METHOD_VALUE_POST = exports.HTTP_REQUEST_METHOD_VALUE_PATCH = exports.HTTP_REQUEST_METHOD_VALUE_OPTIONS = exports.HTTP_REQUEST_METHOD_VALUE_HEAD = exports.HTTP_REQUEST_METHOD_VALUE_GET = exports.HTTP_REQUEST_METHOD_VALUE_DELETE = exports.HTTP_REQUEST_METHOD_VALUE_CONNECT = exports.HTTP_REQUEST_METHOD_VALUE_OTHER = exports.ATTR_HTTP_REQUEST_METHOD = exports.ATTR_HTTP_REQUEST_HEADER = exports.ATTR_EXCEPTION_TYPE = exports.ATTR_EXCEPTION_STACKTRACE = exports.ATTR_EXCEPTION_MESSAGE = exports.ATTR_EXCEPTION_ESCAPED = exports.ERROR_TYPE_VALUE_OTHER = exports.ATTR_ERROR_TYPE = exports.ATTR_CLIENT_PORT = exports.ATTR_CLIENT_ADDRESS = exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = exports.ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = exports.ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = exports.ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = exports.ATTR_ASPNETCORE_RATE_LIMITING_POLICY = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = exports.ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = exports.ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = exports.ATTR_TELEMETRY_SDK_VERSION = exports.ATTR_TELEMETRY_SDK_NAME = exports.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = exports.TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUST = exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = exports.TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = exports.TELEMETRY_SDK_LANGUAGE_VALUE_PHP = exports.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = exports.TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = exports.TELEMETRY_SDK_LANGUAGE_VALUE_GO = exports.TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = exports.TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = exports.TELEMETRY_SDK_LANGUAGE_VALUE_CPP = exports.ATTR_TELEMETRY_SDK_LANGUAGE = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = exports.ATTR_ASPNETCORE_RATE_LIMITING_RESULT = undefined;
  exports.SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = exports.SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = exports.SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = exports.ATTR_SIGNALR_CONNECTION_STATUS = exports.ATTR_SERVICE_VERSION = exports.ATTR_SERVICE_NAME = exports.ATTR_SERVER_PORT = exports.ATTR_SERVER_ADDRESS = exports.ATTR_OTEL_STATUS_DESCRIPTION = exports.OTEL_STATUS_CODE_VALUE_OK = exports.OTEL_STATUS_CODE_VALUE_ERROR = exports.ATTR_OTEL_STATUS_CODE = exports.ATTR_OTEL_SCOPE_VERSION = exports.ATTR_OTEL_SCOPE_NAME = exports.NETWORK_TYPE_VALUE_IPV6 = exports.NETWORK_TYPE_VALUE_IPV4 = exports.ATTR_NETWORK_TYPE = exports.NETWORK_TRANSPORT_VALUE_UNIX = exports.NETWORK_TRANSPORT_VALUE_UDP = exports.NETWORK_TRANSPORT_VALUE_TCP = exports.NETWORK_TRANSPORT_VALUE_QUIC = exports.NETWORK_TRANSPORT_VALUE_PIPE = exports.ATTR_NETWORK_TRANSPORT = exports.ATTR_NETWORK_PROTOCOL_VERSION = exports.ATTR_NETWORK_PROTOCOL_NAME = exports.ATTR_NETWORK_PEER_PORT = exports.ATTR_NETWORK_PEER_ADDRESS = exports.ATTR_NETWORK_LOCAL_PORT = exports.ATTR_NETWORK_LOCAL_ADDRESS = exports.JVM_THREAD_STATE_VALUE_WAITING = exports.JVM_THREAD_STATE_VALUE_TIMED_WAITING = exports.JVM_THREAD_STATE_VALUE_TERMINATED = exports.JVM_THREAD_STATE_VALUE_RUNNABLE = exports.JVM_THREAD_STATE_VALUE_NEW = exports.JVM_THREAD_STATE_VALUE_BLOCKED = exports.ATTR_JVM_THREAD_STATE = exports.ATTR_JVM_THREAD_DAEMON = exports.JVM_MEMORY_TYPE_VALUE_NON_HEAP = exports.JVM_MEMORY_TYPE_VALUE_HEAP = exports.ATTR_JVM_MEMORY_TYPE = exports.ATTR_JVM_MEMORY_POOL_NAME = exports.ATTR_JVM_GC_NAME = exports.ATTR_JVM_GC_ACTION = exports.ATTR_HTTP_ROUTE = exports.ATTR_HTTP_RESPONSE_STATUS_CODE = exports.ATTR_HTTP_RESPONSE_HEADER = exports.ATTR_HTTP_REQUEST_RESEND_COUNT = exports.ATTR_HTTP_REQUEST_METHOD_ORIGINAL = exports.HTTP_REQUEST_METHOD_VALUE_TRACE = exports.HTTP_REQUEST_METHOD_VALUE_PUT = undefined;
  exports.ATTR_USER_AGENT_ORIGINAL = exports.ATTR_URL_SCHEME = exports.ATTR_URL_QUERY = exports.ATTR_URL_PATH = exports.ATTR_URL_FULL = exports.ATTR_URL_FRAGMENT = exports.SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = exports.SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = exports.SIGNALR_TRANSPORT_VALUE_LONG_POLLING = exports.ATTR_SIGNALR_TRANSPORT = undefined;
  exports.ATTR_ASPNETCORE_RATE_LIMITING_RESULT = "aspnetcore.rate_limiting.result";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = "acquired";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = "endpoint_limiter";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = "global_limiter";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = "request_canceled";
  exports.ATTR_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_CPP = "cpp";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = "dotnet";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = "erlang";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_GO = "go";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = "java";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = "nodejs";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_PHP = "php";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = "python";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = "ruby";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUST = "rust";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = "swift";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = "webjs";
  exports.ATTR_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
  exports.ATTR_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
  exports.ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = "aspnetcore.diagnostics.handler.type";
  exports.ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = "aspnetcore.diagnostics.exception.result";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = "aborted";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = "handled";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = "skipped";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = "unhandled";
  exports.ATTR_ASPNETCORE_RATE_LIMITING_POLICY = "aspnetcore.rate_limiting.policy";
  exports.ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = "aspnetcore.request.is_unhandled";
  exports.ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = "aspnetcore.routing.is_fallback";
  exports.ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = "aspnetcore.routing.match_status";
  exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = "failure";
  exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = "success";
  exports.ATTR_CLIENT_ADDRESS = "client.address";
  exports.ATTR_CLIENT_PORT = "client.port";
  exports.ATTR_ERROR_TYPE = "error.type";
  exports.ERROR_TYPE_VALUE_OTHER = "_OTHER";
  exports.ATTR_EXCEPTION_ESCAPED = "exception.escaped";
  exports.ATTR_EXCEPTION_MESSAGE = "exception.message";
  exports.ATTR_EXCEPTION_STACKTRACE = "exception.stacktrace";
  exports.ATTR_EXCEPTION_TYPE = "exception.type";
  var ATTR_HTTP_REQUEST_HEADER = (key) => `http.request.header.${key}`;
  exports.ATTR_HTTP_REQUEST_HEADER = ATTR_HTTP_REQUEST_HEADER;
  exports.ATTR_HTTP_REQUEST_METHOD = "http.request.method";
  exports.HTTP_REQUEST_METHOD_VALUE_OTHER = "_OTHER";
  exports.HTTP_REQUEST_METHOD_VALUE_CONNECT = "CONNECT";
  exports.HTTP_REQUEST_METHOD_VALUE_DELETE = "DELETE";
  exports.HTTP_REQUEST_METHOD_VALUE_GET = "GET";
  exports.HTTP_REQUEST_METHOD_VALUE_HEAD = "HEAD";
  exports.HTTP_REQUEST_METHOD_VALUE_OPTIONS = "OPTIONS";
  exports.HTTP_REQUEST_METHOD_VALUE_PATCH = "PATCH";
  exports.HTTP_REQUEST_METHOD_VALUE_POST = "POST";
  exports.HTTP_REQUEST_METHOD_VALUE_PUT = "PUT";
  exports.HTTP_REQUEST_METHOD_VALUE_TRACE = "TRACE";
  exports.ATTR_HTTP_REQUEST_METHOD_ORIGINAL = "http.request.method_original";
  exports.ATTR_HTTP_REQUEST_RESEND_COUNT = "http.request.resend_count";
  var ATTR_HTTP_RESPONSE_HEADER = (key) => `http.response.header.${key}`;
  exports.ATTR_HTTP_RESPONSE_HEADER = ATTR_HTTP_RESPONSE_HEADER;
  exports.ATTR_HTTP_RESPONSE_STATUS_CODE = "http.response.status_code";
  exports.ATTR_HTTP_ROUTE = "http.route";
  exports.ATTR_JVM_GC_ACTION = "jvm.gc.action";
  exports.ATTR_JVM_GC_NAME = "jvm.gc.name";
  exports.ATTR_JVM_MEMORY_POOL_NAME = "jvm.memory.pool.name";
  exports.ATTR_JVM_MEMORY_TYPE = "jvm.memory.type";
  exports.JVM_MEMORY_TYPE_VALUE_HEAP = "heap";
  exports.JVM_MEMORY_TYPE_VALUE_NON_HEAP = "non_heap";
  exports.ATTR_JVM_THREAD_DAEMON = "jvm.thread.daemon";
  exports.ATTR_JVM_THREAD_STATE = "jvm.thread.state";
  exports.JVM_THREAD_STATE_VALUE_BLOCKED = "blocked";
  exports.JVM_THREAD_STATE_VALUE_NEW = "new";
  exports.JVM_THREAD_STATE_VALUE_RUNNABLE = "runnable";
  exports.JVM_THREAD_STATE_VALUE_TERMINATED = "terminated";
  exports.JVM_THREAD_STATE_VALUE_TIMED_WAITING = "timed_waiting";
  exports.JVM_THREAD_STATE_VALUE_WAITING = "waiting";
  exports.ATTR_NETWORK_LOCAL_ADDRESS = "network.local.address";
  exports.ATTR_NETWORK_LOCAL_PORT = "network.local.port";
  exports.ATTR_NETWORK_PEER_ADDRESS = "network.peer.address";
  exports.ATTR_NETWORK_PEER_PORT = "network.peer.port";
  exports.ATTR_NETWORK_PROTOCOL_NAME = "network.protocol.name";
  exports.ATTR_NETWORK_PROTOCOL_VERSION = "network.protocol.version";
  exports.ATTR_NETWORK_TRANSPORT = "network.transport";
  exports.NETWORK_TRANSPORT_VALUE_PIPE = "pipe";
  exports.NETWORK_TRANSPORT_VALUE_QUIC = "quic";
  exports.NETWORK_TRANSPORT_VALUE_TCP = "tcp";
  exports.NETWORK_TRANSPORT_VALUE_UDP = "udp";
  exports.NETWORK_TRANSPORT_VALUE_UNIX = "unix";
  exports.ATTR_NETWORK_TYPE = "network.type";
  exports.NETWORK_TYPE_VALUE_IPV4 = "ipv4";
  exports.NETWORK_TYPE_VALUE_IPV6 = "ipv6";
  exports.ATTR_OTEL_SCOPE_NAME = "otel.scope.name";
  exports.ATTR_OTEL_SCOPE_VERSION = "otel.scope.version";
  exports.ATTR_OTEL_STATUS_CODE = "otel.status_code";
  exports.OTEL_STATUS_CODE_VALUE_ERROR = "ERROR";
  exports.OTEL_STATUS_CODE_VALUE_OK = "OK";
  exports.ATTR_OTEL_STATUS_DESCRIPTION = "otel.status_description";
  exports.ATTR_SERVER_ADDRESS = "server.address";
  exports.ATTR_SERVER_PORT = "server.port";
  exports.ATTR_SERVICE_NAME = "service.name";
  exports.ATTR_SERVICE_VERSION = "service.version";
  exports.ATTR_SIGNALR_CONNECTION_STATUS = "signalr.connection.status";
  exports.SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = "app_shutdown";
  exports.SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = "normal_closure";
  exports.SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = "timeout";
  exports.ATTR_SIGNALR_TRANSPORT = "signalr.transport";
  exports.SIGNALR_TRANSPORT_VALUE_LONG_POLLING = "long_polling";
  exports.SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = "server_sent_events";
  exports.SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = "web_sockets";
  exports.ATTR_URL_FRAGMENT = "url.fragment";
  exports.ATTR_URL_FULL = "url.full";
  exports.ATTR_URL_PATH = "url.path";
  exports.ATTR_URL_QUERY = "url.query";
  exports.ATTR_URL_SCHEME = "url.scheme";
  exports.ATTR_USER_AGENT_ORIGINAL = "user_agent.original";
});

// ../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/src/stable_metrics.js
var require_stable_metrics2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.METRIC_SIGNALR_SERVER_CONNECTION_DURATION = exports.METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = exports.METRIC_KESTREL_UPGRADED_CONNECTIONS = exports.METRIC_KESTREL_TLS_HANDSHAKE_DURATION = exports.METRIC_KESTREL_REJECTED_CONNECTIONS = exports.METRIC_KESTREL_QUEUED_REQUESTS = exports.METRIC_KESTREL_QUEUED_CONNECTIONS = exports.METRIC_KESTREL_CONNECTION_DURATION = exports.METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = exports.METRIC_KESTREL_ACTIVE_CONNECTIONS = exports.METRIC_JVM_THREAD_COUNT = exports.METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = exports.METRIC_JVM_MEMORY_USED = exports.METRIC_JVM_MEMORY_LIMIT = exports.METRIC_JVM_MEMORY_COMMITTED = exports.METRIC_JVM_GC_DURATION = exports.METRIC_JVM_CPU_TIME = exports.METRIC_JVM_CPU_RECENT_UTILIZATION = exports.METRIC_JVM_CPU_COUNT = exports.METRIC_JVM_CLASS_UNLOADED = exports.METRIC_JVM_CLASS_LOADED = exports.METRIC_JVM_CLASS_COUNT = exports.METRIC_HTTP_SERVER_REQUEST_DURATION = exports.METRIC_HTTP_CLIENT_REQUEST_DURATION = exports.METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = exports.METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = exports.METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = undefined;
  exports.METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = "aspnetcore.diagnostics.exceptions";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = "aspnetcore.rate_limiting.active_request_leases";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = "aspnetcore.rate_limiting.queued_requests";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = "aspnetcore.rate_limiting.request.time_in_queue";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = "aspnetcore.rate_limiting.request_lease.duration";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = "aspnetcore.rate_limiting.requests";
  exports.METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = "aspnetcore.routing.match_attempts";
  exports.METRIC_HTTP_CLIENT_REQUEST_DURATION = "http.client.request.duration";
  exports.METRIC_HTTP_SERVER_REQUEST_DURATION = "http.server.request.duration";
  exports.METRIC_JVM_CLASS_COUNT = "jvm.class.count";
  exports.METRIC_JVM_CLASS_LOADED = "jvm.class.loaded";
  exports.METRIC_JVM_CLASS_UNLOADED = "jvm.class.unloaded";
  exports.METRIC_JVM_CPU_COUNT = "jvm.cpu.count";
  exports.METRIC_JVM_CPU_RECENT_UTILIZATION = "jvm.cpu.recent_utilization";
  exports.METRIC_JVM_CPU_TIME = "jvm.cpu.time";
  exports.METRIC_JVM_GC_DURATION = "jvm.gc.duration";
  exports.METRIC_JVM_MEMORY_COMMITTED = "jvm.memory.committed";
  exports.METRIC_JVM_MEMORY_LIMIT = "jvm.memory.limit";
  exports.METRIC_JVM_MEMORY_USED = "jvm.memory.used";
  exports.METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = "jvm.memory.used_after_last_gc";
  exports.METRIC_JVM_THREAD_COUNT = "jvm.thread.count";
  exports.METRIC_KESTREL_ACTIVE_CONNECTIONS = "kestrel.active_connections";
  exports.METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = "kestrel.active_tls_handshakes";
  exports.METRIC_KESTREL_CONNECTION_DURATION = "kestrel.connection.duration";
  exports.METRIC_KESTREL_QUEUED_CONNECTIONS = "kestrel.queued_connections";
  exports.METRIC_KESTREL_QUEUED_REQUESTS = "kestrel.queued_requests";
  exports.METRIC_KESTREL_REJECTED_CONNECTIONS = "kestrel.rejected_connections";
  exports.METRIC_KESTREL_TLS_HANDSHAKE_DURATION = "kestrel.tls_handshake.duration";
  exports.METRIC_KESTREL_UPGRADED_CONNECTIONS = "kestrel.upgraded_connections";
  exports.METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = "signalr.server.active_connections";
  exports.METRIC_SIGNALR_SERVER_CONNECTION_DURATION = "signalr.server.connection.duration";
});

// ../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/src/index.js
var require_src7 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(require_trace3(), exports);
  __exportStar2(require_resource2(), exports);
  __exportStar2(require_stable_attributes2(), exports);
  __exportStar2(require_stable_metrics2(), exports);
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js
var require_sdk_info = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SDK_INFO = undefined;
  var version_1 = require_version3();
  var semantic_conventions_1 = require_src7();
  exports.SDK_INFO = {
    [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_NAME]: "opentelemetry",
    [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_NAME]: "node",
    [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE]: semantic_conventions_1.TELEMETRYSDKLANGUAGEVALUES_NODEJS,
    [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_VERSION]: version_1.VERSION
  };
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js
var require_timer_util = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unrefTimer = undefined;
  function unrefTimer(timer) {
    timer.unref();
  }
  exports.unrefTimer = unrefTimer;
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/index.js
var require_node5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unrefTimer = exports.SDK_INFO = exports.otperformance = exports.RandomIdGenerator = exports.hexToBase64 = exports._globalThis = exports.getEnv = exports.getEnvWithoutDefaults = undefined;
  var environment_1 = require_environment2();
  Object.defineProperty(exports, "getEnvWithoutDefaults", { enumerable: true, get: function() {
    return environment_1.getEnvWithoutDefaults;
  } });
  Object.defineProperty(exports, "getEnv", { enumerable: true, get: function() {
    return environment_1.getEnv;
  } });
  var globalThis_1 = require_globalThis3();
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return globalThis_1._globalThis;
  } });
  var hex_to_base64_1 = require_hex_to_base64();
  Object.defineProperty(exports, "hexToBase64", { enumerable: true, get: function() {
    return hex_to_base64_1.hexToBase64;
  } });
  var RandomIdGenerator_1 = require_RandomIdGenerator();
  Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
    return RandomIdGenerator_1.RandomIdGenerator;
  } });
  var performance_1 = require_performance();
  Object.defineProperty(exports, "otperformance", { enumerable: true, get: function() {
    return performance_1.otperformance;
  } });
  var sdk_info_1 = require_sdk_info();
  Object.defineProperty(exports, "SDK_INFO", { enumerable: true, get: function() {
    return sdk_info_1.SDK_INFO;
  } });
  var timer_util_1 = require_timer_util();
  Object.defineProperty(exports, "unrefTimer", { enumerable: true, get: function() {
    return timer_util_1.unrefTimer;
  } });
});

// ../../node_modules/@opentelemetry/core/build/src/platform/index.js
var require_platform4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unrefTimer = exports.otperformance = exports.hexToBase64 = exports.getEnvWithoutDefaults = exports.getEnv = exports._globalThis = exports.SDK_INFO = exports.RandomIdGenerator = undefined;
  var node_1 = require_node5();
  Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
    return node_1.RandomIdGenerator;
  } });
  Object.defineProperty(exports, "SDK_INFO", { enumerable: true, get: function() {
    return node_1.SDK_INFO;
  } });
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return node_1._globalThis;
  } });
  Object.defineProperty(exports, "getEnv", { enumerable: true, get: function() {
    return node_1.getEnv;
  } });
  Object.defineProperty(exports, "getEnvWithoutDefaults", { enumerable: true, get: function() {
    return node_1.getEnvWithoutDefaults;
  } });
  Object.defineProperty(exports, "hexToBase64", { enumerable: true, get: function() {
    return node_1.hexToBase64;
  } });
  Object.defineProperty(exports, "otperformance", { enumerable: true, get: function() {
    return node_1.otperformance;
  } });
  Object.defineProperty(exports, "unrefTimer", { enumerable: true, get: function() {
    return node_1.unrefTimer;
  } });
});

// ../../node_modules/@opentelemetry/core/build/src/common/time.js
var require_time = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.addHrTimes = exports.isTimeInput = exports.isTimeInputHrTime = exports.hrTimeToMicroseconds = exports.hrTimeToMilliseconds = exports.hrTimeToNanoseconds = exports.hrTimeToTimeStamp = exports.hrTimeDuration = exports.timeInputToHrTime = exports.hrTime = exports.getTimeOrigin = exports.millisToHrTime = undefined;
  var platform_1 = require_platform4();
  var NANOSECOND_DIGITS = 9;
  var NANOSECOND_DIGITS_IN_MILLIS = 6;
  var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
  var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
  function millisToHrTime(epochMillis) {
    const epochSeconds = epochMillis / 1000;
    const seconds = Math.trunc(epochSeconds);
    const nanos = Math.round(epochMillis % 1000 * MILLISECONDS_TO_NANOSECONDS);
    return [seconds, nanos];
  }
  exports.millisToHrTime = millisToHrTime;
  function getTimeOrigin() {
    let timeOrigin = platform_1.otperformance.timeOrigin;
    if (typeof timeOrigin !== "number") {
      const perf = platform_1.otperformance;
      timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
  }
  exports.getTimeOrigin = getTimeOrigin;
  function hrTime(performanceNow) {
    const timeOrigin = millisToHrTime(getTimeOrigin());
    const now = millisToHrTime(typeof performanceNow === "number" ? performanceNow : platform_1.otperformance.now());
    return addHrTimes(timeOrigin, now);
  }
  exports.hrTime = hrTime;
  function timeInputToHrTime(time) {
    if (isTimeInputHrTime(time)) {
      return time;
    } else if (typeof time === "number") {
      if (time < getTimeOrigin()) {
        return hrTime(time);
      } else {
        return millisToHrTime(time);
      }
    } else if (time instanceof Date) {
      return millisToHrTime(time.getTime());
    } else {
      throw TypeError("Invalid input type");
    }
  }
  exports.timeInputToHrTime = timeInputToHrTime;
  function hrTimeDuration(startTime, endTime) {
    let seconds = endTime[0] - startTime[0];
    let nanos = endTime[1] - startTime[1];
    if (nanos < 0) {
      seconds -= 1;
      nanos += SECOND_TO_NANOSECONDS;
    }
    return [seconds, nanos];
  }
  exports.hrTimeDuration = hrTimeDuration;
  function hrTimeToTimeStamp(time) {
    const precision = NANOSECOND_DIGITS;
    const tmp = `${"0".repeat(precision)}${time[1]}Z`;
    const nanoString = tmp.substring(tmp.length - precision - 1);
    const date = new Date(time[0] * 1000).toISOString();
    return date.replace("000Z", nanoString);
  }
  exports.hrTimeToTimeStamp = hrTimeToTimeStamp;
  function hrTimeToNanoseconds(time) {
    return time[0] * SECOND_TO_NANOSECONDS + time[1];
  }
  exports.hrTimeToNanoseconds = hrTimeToNanoseconds;
  function hrTimeToMilliseconds(time) {
    return time[0] * 1000 + time[1] / 1e6;
  }
  exports.hrTimeToMilliseconds = hrTimeToMilliseconds;
  function hrTimeToMicroseconds(time) {
    return time[0] * 1e6 + time[1] / 1000;
  }
  exports.hrTimeToMicroseconds = hrTimeToMicroseconds;
  function isTimeInputHrTime(value) {
    return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
  }
  exports.isTimeInputHrTime = isTimeInputHrTime;
  function isTimeInput(value) {
    return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
  }
  exports.isTimeInput = isTimeInput;
  function addHrTimes(time1, time2) {
    const out = [time1[0] + time2[0], time1[1] + time2[1]];
    if (out[1] >= SECOND_TO_NANOSECONDS) {
      out[1] -= SECOND_TO_NANOSECONDS;
      out[0] += 1;
    }
    return out;
  }
  exports.addHrTimes = addHrTimes;
});

// ../../node_modules/@opentelemetry/core/build/src/ExportResult.js
var require_ExportResult = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExportResultCode = undefined;
  var ExportResultCode;
  (function(ExportResultCode2) {
    ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
    ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
  })(ExportResultCode = exports.ExportResultCode || (exports.ExportResultCode = {}));
});

// ../../node_modules/@opentelemetry/core/build/src/propagation/composite.js
var require_composite = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CompositePropagator = undefined;
  var api_1 = require_src();

  class CompositePropagator {
    constructor(config5 = {}) {
      var _a2;
      this._propagators = (_a2 = config5.propagators) !== null && _a2 !== undefined ? _a2 : [];
      this._fields = Array.from(new Set(this._propagators.map((p5) => typeof p5.fields === "function" ? p5.fields() : []).reduce((x4, y4) => x4.concat(y4), [])));
    }
    inject(context, carrier, setter) {
      for (const propagator of this._propagators) {
        try {
          propagator.inject(context, carrier, setter);
        } catch (err) {
          api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
        }
      }
    }
    extract(context, carrier, getter) {
      return this._propagators.reduce((ctx, propagator) => {
        try {
          return propagator.extract(ctx, carrier, getter);
        } catch (err) {
          api_1.diag.warn(`Failed to extract with ${propagator.constructor.name}. Err: ${err.message}`);
        }
        return ctx;
      }, context);
    }
    fields() {
      return this._fields.slice();
    }
  }
  exports.CompositePropagator = CompositePropagator;
});

// ../../node_modules/@opentelemetry/core/build/src/internal/validators.js
var require_validators = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateValue = exports.validateKey = undefined;
  var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
  var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
  var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
  var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);
  var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
  var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
  }
  exports.validateKey = validateKey;
  function validateValue(value) {
    return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
  }
  exports.validateValue = validateValue;
});

// ../../node_modules/@opentelemetry/core/build/src/trace/TraceState.js
var require_TraceState = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceState = undefined;
  var validators_1 = require_validators();
  var MAX_TRACE_STATE_ITEMS = 32;
  var MAX_TRACE_STATE_LEN = 512;
  var LIST_MEMBERS_SEPARATOR = ",";
  var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";

  class TraceState {
    constructor(rawTraceState) {
      this._internalState = new Map;
      if (rawTraceState)
        this._parse(rawTraceState);
    }
    set(key, value) {
      const traceState = this._clone();
      if (traceState._internalState.has(key)) {
        traceState._internalState.delete(key);
      }
      traceState._internalState.set(key, value);
      return traceState;
    }
    unset(key) {
      const traceState = this._clone();
      traceState._internalState.delete(key);
      return traceState;
    }
    get(key) {
      return this._internalState.get(key);
    }
    serialize() {
      return this._keys().reduce((agg, key) => {
        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
        return agg;
      }, []).join(LIST_MEMBERS_SEPARATOR);
    }
    _parse(rawTraceState) {
      if (rawTraceState.length > MAX_TRACE_STATE_LEN)
        return;
      this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
        const listMember = part.trim();
        const i4 = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
        if (i4 !== -1) {
          const key = listMember.slice(0, i4);
          const value = listMember.slice(i4 + 1, part.length);
          if ((0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value)) {
            agg.set(key, value);
          } else {
          }
        }
        return agg;
      }, new Map);
      if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
      }
    }
    _keys() {
      return Array.from(this._internalState.keys()).reverse();
    }
    _clone() {
      const traceState = new TraceState;
      traceState._internalState = new Map(this._internalState);
      return traceState;
    }
  }
  exports.TraceState = TraceState;
});

// ../../node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js
var require_W3CTraceContextPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.W3CTraceContextPropagator = exports.parseTraceParent = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = undefined;
  var api_1 = require_src();
  var suppress_tracing_1 = require_suppress_tracing();
  var TraceState_1 = require_TraceState();
  exports.TRACE_PARENT_HEADER = "traceparent";
  exports.TRACE_STATE_HEADER = "tracestate";
  var VERSION = "00";
  var VERSION_PART = "(?!ff)[\\da-f]{2}";
  var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
  var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
  var FLAGS_PART = "[\\da-f]{2}";
  var TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
  function parseTraceParent(traceParent) {
    const match = TRACE_PARENT_REGEX.exec(traceParent);
    if (!match)
      return null;
    if (match[1] === "00" && match[5])
      return null;
    return {
      traceId: match[2],
      spanId: match[3],
      traceFlags: parseInt(match[4], 16)
    };
  }
  exports.parseTraceParent = parseTraceParent;

  class W3CTraceContextPropagator {
    inject(context, carrier, setter) {
      const spanContext = api_1.trace.getSpanContext(context);
      if (!spanContext || (0, suppress_tracing_1.isTracingSuppressed)(context) || !(0, api_1.isSpanContextValid)(spanContext))
        return;
      const traceParent = `${VERSION}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
      setter.set(carrier, exports.TRACE_PARENT_HEADER, traceParent);
      if (spanContext.traceState) {
        setter.set(carrier, exports.TRACE_STATE_HEADER, spanContext.traceState.serialize());
      }
    }
    extract(context, carrier, getter) {
      const traceParentHeader = getter.get(carrier, exports.TRACE_PARENT_HEADER);
      if (!traceParentHeader)
        return context;
      const traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
      if (typeof traceParent !== "string")
        return context;
      const spanContext = parseTraceParent(traceParent);
      if (!spanContext)
        return context;
      spanContext.isRemote = true;
      const traceStateHeader = getter.get(carrier, exports.TRACE_STATE_HEADER);
      if (traceStateHeader) {
        const state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
        spanContext.traceState = new TraceState_1.TraceState(typeof state === "string" ? state : undefined);
      }
      return api_1.trace.setSpanContext(context, spanContext);
    }
    fields() {
      return [exports.TRACE_PARENT_HEADER, exports.TRACE_STATE_HEADER];
    }
  }
  exports.W3CTraceContextPropagator = W3CTraceContextPropagator;
});

// ../../node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js
var require_rpc_metadata = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRPCMetadata = exports.deleteRPCMetadata = exports.setRPCMetadata = exports.RPCType = undefined;
  var api_1 = require_src();
  var RPC_METADATA_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key RPC_METADATA");
  var RPCType;
  (function(RPCType2) {
    RPCType2["HTTP"] = "http";
  })(RPCType = exports.RPCType || (exports.RPCType = {}));
  function setRPCMetadata(context, meta) {
    return context.setValue(RPC_METADATA_KEY, meta);
  }
  exports.setRPCMetadata = setRPCMetadata;
  function deleteRPCMetadata(context) {
    return context.deleteValue(RPC_METADATA_KEY);
  }
  exports.deleteRPCMetadata = deleteRPCMetadata;
  function getRPCMetadata(context) {
    return context.getValue(RPC_METADATA_KEY);
  }
  exports.getRPCMetadata = getRPCMetadata;
});

// ../../node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AlwaysOffSampler = undefined;
  var api_1 = require_src();

  class AlwaysOffSampler {
    shouldSample() {
      return {
        decision: api_1.SamplingDecision.NOT_RECORD
      };
    }
    toString() {
      return "AlwaysOffSampler";
    }
  }
  exports.AlwaysOffSampler = AlwaysOffSampler;
});

// ../../node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AlwaysOnSampler = undefined;
  var api_1 = require_src();

  class AlwaysOnSampler {
    shouldSample() {
      return {
        decision: api_1.SamplingDecision.RECORD_AND_SAMPLED
      };
    }
    toString() {
      return "AlwaysOnSampler";
    }
  }
  exports.AlwaysOnSampler = AlwaysOnSampler;
});

// ../../node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js
var require_ParentBasedSampler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ParentBasedSampler = undefined;
  var api_1 = require_src();
  var global_error_handler_1 = require_global_error_handler();
  var AlwaysOffSampler_1 = require_AlwaysOffSampler();
  var AlwaysOnSampler_1 = require_AlwaysOnSampler();

  class ParentBasedSampler {
    constructor(config5) {
      var _a2, _b2, _c2, _d2;
      this._root = config5.root;
      if (!this._root) {
        (0, global_error_handler_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured"));
        this._root = new AlwaysOnSampler_1.AlwaysOnSampler;
      }
      this._remoteParentSampled = (_a2 = config5.remoteParentSampled) !== null && _a2 !== undefined ? _a2 : new AlwaysOnSampler_1.AlwaysOnSampler;
      this._remoteParentNotSampled = (_b2 = config5.remoteParentNotSampled) !== null && _b2 !== undefined ? _b2 : new AlwaysOffSampler_1.AlwaysOffSampler;
      this._localParentSampled = (_c2 = config5.localParentSampled) !== null && _c2 !== undefined ? _c2 : new AlwaysOnSampler_1.AlwaysOnSampler;
      this._localParentNotSampled = (_d2 = config5.localParentNotSampled) !== null && _d2 !== undefined ? _d2 : new AlwaysOffSampler_1.AlwaysOffSampler;
    }
    shouldSample(context, traceId, spanName, spanKind, attributes, links) {
      const parentContext = api_1.trace.getSpanContext(context);
      if (!parentContext || !(0, api_1.isSpanContextValid)(parentContext)) {
        return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      }
      if (parentContext.isRemote) {
        if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
          return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      }
      if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
        return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      }
      return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    }
    toString() {
      return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
    }
  }
  exports.ParentBasedSampler = ParentBasedSampler;
});

// ../../node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceIdRatioBasedSampler = undefined;
  var api_1 = require_src();

  class TraceIdRatioBasedSampler {
    constructor(_ratio = 0) {
      this._ratio = _ratio;
      this._ratio = this._normalize(_ratio);
      this._upperBound = Math.floor(this._ratio * 4294967295);
    }
    shouldSample(context, traceId) {
      return {
        decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? api_1.SamplingDecision.RECORD_AND_SAMPLED : api_1.SamplingDecision.NOT_RECORD
      };
    }
    toString() {
      return `TraceIdRatioBased{${this._ratio}}`;
    }
    _normalize(ratio) {
      if (typeof ratio !== "number" || isNaN(ratio))
        return 0;
      return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    }
    _accumulate(traceId) {
      let accumulation = 0;
      for (let i4 = 0;i4 < traceId.length / 8; i4++) {
        const pos = i4 * 8;
        const part = parseInt(traceId.slice(pos, pos + 8), 16);
        accumulation = (accumulation ^ part) >>> 0;
      }
      return accumulation;
    }
  }
  exports.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
});

// ../../node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js
var require_lodash_merge = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isPlainObject = undefined;
  var objectTag = "[object Object]";
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  var objectCtorString = funcToString.call(Object);
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
  var nativeObjectToString = objectProto.toString;
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function isPlainObject3(value) {
    if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
      return false;
    }
    const proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    const Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
  }
  exports.isPlainObject = isPlainObject3;
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  function getRawTag(value) {
    const isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    let unmasked = false;
    try {
      value[symToStringTag] = undefined;
      unmasked = true;
    } catch (e4) {
    }
    const result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
});

// ../../node_modules/@opentelemetry/core/build/src/utils/merge.js
var require_merge = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.merge = undefined;
  var lodash_merge_1 = require_lodash_merge();
  var MAX_LEVEL = 20;
  function merge2(...args) {
    let result = args.shift();
    const objects = new WeakMap;
    while (args.length > 0) {
      result = mergeTwoObjects(result, args.shift(), 0, objects);
    }
    return result;
  }
  exports.merge = merge2;
  function takeValue(value) {
    if (isArray(value)) {
      return value.slice();
    }
    return value;
  }
  function mergeTwoObjects(one, two, level = 0, objects) {
    let result;
    if (level > MAX_LEVEL) {
      return;
    }
    level++;
    if (isPrimitive(one) || isPrimitive(two) || isFunction2(two)) {
      result = takeValue(two);
    } else if (isArray(one)) {
      result = one.slice();
      if (isArray(two)) {
        for (let i4 = 0, j4 = two.length;i4 < j4; i4++) {
          result.push(takeValue(two[i4]));
        }
      } else if (isObject2(two)) {
        const keys = Object.keys(two);
        for (let i4 = 0, j4 = keys.length;i4 < j4; i4++) {
          const key = keys[i4];
          result[key] = takeValue(two[key]);
        }
      }
    } else if (isObject2(one)) {
      if (isObject2(two)) {
        if (!shouldMerge(one, two)) {
          return two;
        }
        result = Object.assign({}, one);
        const keys = Object.keys(two);
        for (let i4 = 0, j4 = keys.length;i4 < j4; i4++) {
          const key = keys[i4];
          const twoValue = two[key];
          if (isPrimitive(twoValue)) {
            if (typeof twoValue === "undefined") {
              delete result[key];
            } else {
              result[key] = twoValue;
            }
          } else {
            const obj1 = result[key];
            const obj2 = twoValue;
            if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
              delete result[key];
            } else {
              if (isObject2(obj1) && isObject2(obj2)) {
                const arr1 = objects.get(obj1) || [];
                const arr2 = objects.get(obj2) || [];
                arr1.push({ obj: one, key });
                arr2.push({ obj: two, key });
                objects.set(obj1, arr1);
                objects.set(obj2, arr2);
              }
              result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
            }
          }
        }
      } else {
        result = two;
      }
    }
    return result;
  }
  function wasObjectReferenced(obj, key, objects) {
    const arr = objects.get(obj[key]) || [];
    for (let i4 = 0, j4 = arr.length;i4 < j4; i4++) {
      const info = arr[i4];
      if (info.key === key && info.obj === obj) {
        return true;
      }
    }
    return false;
  }
  function isArray(value) {
    return Array.isArray(value);
  }
  function isFunction2(value) {
    return typeof value === "function";
  }
  function isObject2(value) {
    return !isPrimitive(value) && !isArray(value) && !isFunction2(value) && typeof value === "object";
  }
  function isPrimitive(value) {
    return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
  }
  function shouldMerge(one, two) {
    if (!(0, lodash_merge_1.isPlainObject)(one) || !(0, lodash_merge_1.isPlainObject)(two)) {
      return false;
    }
    return true;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/utils/timeout.js
var require_timeout = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.callWithTimeout = exports.TimeoutError = undefined;

  class TimeoutError extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, TimeoutError.prototype);
    }
  }
  exports.TimeoutError = TimeoutError;
  function callWithTimeout(promise, timeout) {
    let timeoutHandle;
    const timeoutPromise = new Promise(function timeoutFunction(_resolve, reject) {
      timeoutHandle = setTimeout(function timeoutHandler() {
        reject(new TimeoutError("Operation timed out."));
      }, timeout);
    });
    return Promise.race([promise, timeoutPromise]).then((result) => {
      clearTimeout(timeoutHandle);
      return result;
    }, (reason) => {
      clearTimeout(timeoutHandle);
      throw reason;
    });
  }
  exports.callWithTimeout = callWithTimeout;
});

// ../../node_modules/@opentelemetry/core/build/src/utils/url.js
var require_url = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isUrlIgnored = exports.urlMatches = undefined;
  function urlMatches(url, urlToMatch) {
    if (typeof urlToMatch === "string") {
      return url === urlToMatch;
    } else {
      return !!url.match(urlToMatch);
    }
  }
  exports.urlMatches = urlMatches;
  function isUrlIgnored(url, ignoredUrls) {
    if (!ignoredUrls) {
      return false;
    }
    for (const ignoreUrl of ignoredUrls) {
      if (urlMatches(url, ignoreUrl)) {
        return true;
      }
    }
    return false;
  }
  exports.isUrlIgnored = isUrlIgnored;
});

// ../../node_modules/@opentelemetry/core/build/src/utils/wrap.js
var require_wrap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isWrapped = undefined;
  function isWrapped(func) {
    return typeof func === "function" && typeof func.__original === "function" && typeof func.__unwrap === "function" && func.__wrapped === true;
  }
  exports.isWrapped = isWrapped;
});

// ../../node_modules/@opentelemetry/core/build/src/utils/promise.js
var require_promise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Deferred = undefined;

  class Deferred {
    constructor() {
      this._promise = new Promise((resolve2, reject) => {
        this._resolve = resolve2;
        this._reject = reject;
      });
    }
    get promise() {
      return this._promise;
    }
    resolve(val2) {
      this._resolve(val2);
    }
    reject(err) {
      this._reject(err);
    }
  }
  exports.Deferred = Deferred;
});

// ../../node_modules/@opentelemetry/core/build/src/utils/callback.js
var require_callback = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BindOnceFuture = undefined;
  var promise_1 = require_promise();

  class BindOnceFuture {
    constructor(_callback, _that) {
      this._callback = _callback;
      this._that = _that;
      this._isCalled = false;
      this._deferred = new promise_1.Deferred;
    }
    get isCalled() {
      return this._isCalled;
    }
    get promise() {
      return this._deferred.promise;
    }
    call(...args) {
      if (!this._isCalled) {
        this._isCalled = true;
        try {
          Promise.resolve(this._callback.call(this._that, ...args)).then((val2) => this._deferred.resolve(val2), (err) => this._deferred.reject(err));
        } catch (err) {
          this._deferred.reject(err);
        }
      }
      return this._deferred.promise;
    }
  }
  exports.BindOnceFuture = BindOnceFuture;
});

// ../../node_modules/@opentelemetry/core/build/src/internal/exporter.js
var require_exporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._export = undefined;
  var api_1 = require_src();
  var suppress_tracing_1 = require_suppress_tracing();
  function _export(exporter, arg) {
    return new Promise((resolve2) => {
      api_1.context.with((0, suppress_tracing_1.suppressTracing)(api_1.context.active()), () => {
        exporter.export(arg, (result) => {
          resolve2(result);
        });
      });
    });
  }
  exports._export = _export;
});

// ../../node_modules/@opentelemetry/core/build/src/index.js
var require_src8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports.TraceState = exports.unsuppressTracing = exports.suppressTracing = exports.isTracingSuppressed = exports.TraceIdRatioBasedSampler = exports.ParentBasedSampler = exports.AlwaysOnSampler = exports.AlwaysOffSampler = exports.setRPCMetadata = exports.getRPCMetadata = exports.deleteRPCMetadata = exports.RPCType = exports.parseTraceParent = exports.W3CTraceContextPropagator = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = exports.CompositePropagator = exports.unrefTimer = exports.otperformance = exports.hexToBase64 = exports.getEnvWithoutDefaults = exports.getEnv = exports._globalThis = exports.SDK_INFO = exports.RandomIdGenerator = exports.baggageUtils = exports.ExportResultCode = exports.hexToBinary = exports.timeInputToHrTime = exports.millisToHrTime = exports.isTimeInputHrTime = exports.isTimeInput = exports.hrTimeToTimeStamp = exports.hrTimeToNanoseconds = exports.hrTimeToMilliseconds = exports.hrTimeToMicroseconds = exports.hrTimeDuration = exports.hrTime = exports.getTimeOrigin = exports.addHrTimes = exports.loggingErrorHandler = exports.setGlobalErrorHandler = exports.globalErrorHandler = exports.sanitizeAttributes = exports.isAttributeValue = exports.isAttributeKey = exports.AnchoredClock = exports.W3CBaggagePropagator = undefined;
  exports.internal = exports.VERSION = exports.BindOnceFuture = exports.isWrapped = exports.urlMatches = exports.isUrlIgnored = exports.callWithTimeout = exports.TimeoutError = exports.TracesSamplerValues = exports.merge = exports.parseEnvironment = exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports.DEFAULT_ENVIRONMENT = undefined;
  var W3CBaggagePropagator_1 = require_W3CBaggagePropagator();
  Object.defineProperty(exports, "W3CBaggagePropagator", { enumerable: true, get: function() {
    return W3CBaggagePropagator_1.W3CBaggagePropagator;
  } });
  var anchored_clock_1 = require_anchored_clock();
  Object.defineProperty(exports, "AnchoredClock", { enumerable: true, get: function() {
    return anchored_clock_1.AnchoredClock;
  } });
  var attributes_1 = require_attributes();
  Object.defineProperty(exports, "isAttributeKey", { enumerable: true, get: function() {
    return attributes_1.isAttributeKey;
  } });
  Object.defineProperty(exports, "isAttributeValue", { enumerable: true, get: function() {
    return attributes_1.isAttributeValue;
  } });
  Object.defineProperty(exports, "sanitizeAttributes", { enumerable: true, get: function() {
    return attributes_1.sanitizeAttributes;
  } });
  var global_error_handler_1 = require_global_error_handler();
  Object.defineProperty(exports, "globalErrorHandler", { enumerable: true, get: function() {
    return global_error_handler_1.globalErrorHandler;
  } });
  Object.defineProperty(exports, "setGlobalErrorHandler", { enumerable: true, get: function() {
    return global_error_handler_1.setGlobalErrorHandler;
  } });
  var logging_error_handler_1 = require_logging_error_handler();
  Object.defineProperty(exports, "loggingErrorHandler", { enumerable: true, get: function() {
    return logging_error_handler_1.loggingErrorHandler;
  } });
  var time_1 = require_time();
  Object.defineProperty(exports, "addHrTimes", { enumerable: true, get: function() {
    return time_1.addHrTimes;
  } });
  Object.defineProperty(exports, "getTimeOrigin", { enumerable: true, get: function() {
    return time_1.getTimeOrigin;
  } });
  Object.defineProperty(exports, "hrTime", { enumerable: true, get: function() {
    return time_1.hrTime;
  } });
  Object.defineProperty(exports, "hrTimeDuration", { enumerable: true, get: function() {
    return time_1.hrTimeDuration;
  } });
  Object.defineProperty(exports, "hrTimeToMicroseconds", { enumerable: true, get: function() {
    return time_1.hrTimeToMicroseconds;
  } });
  Object.defineProperty(exports, "hrTimeToMilliseconds", { enumerable: true, get: function() {
    return time_1.hrTimeToMilliseconds;
  } });
  Object.defineProperty(exports, "hrTimeToNanoseconds", { enumerable: true, get: function() {
    return time_1.hrTimeToNanoseconds;
  } });
  Object.defineProperty(exports, "hrTimeToTimeStamp", { enumerable: true, get: function() {
    return time_1.hrTimeToTimeStamp;
  } });
  Object.defineProperty(exports, "isTimeInput", { enumerable: true, get: function() {
    return time_1.isTimeInput;
  } });
  Object.defineProperty(exports, "isTimeInputHrTime", { enumerable: true, get: function() {
    return time_1.isTimeInputHrTime;
  } });
  Object.defineProperty(exports, "millisToHrTime", { enumerable: true, get: function() {
    return time_1.millisToHrTime;
  } });
  Object.defineProperty(exports, "timeInputToHrTime", { enumerable: true, get: function() {
    return time_1.timeInputToHrTime;
  } });
  var hex_to_binary_1 = require_hex_to_binary();
  Object.defineProperty(exports, "hexToBinary", { enumerable: true, get: function() {
    return hex_to_binary_1.hexToBinary;
  } });
  var ExportResult_1 = require_ExportResult();
  Object.defineProperty(exports, "ExportResultCode", { enumerable: true, get: function() {
    return ExportResult_1.ExportResultCode;
  } });
  var utils_1 = require_utils5();
  exports.baggageUtils = {
    getKeyPairs: utils_1.getKeyPairs,
    serializeKeyPairs: utils_1.serializeKeyPairs,
    parseKeyPairsIntoRecord: utils_1.parseKeyPairsIntoRecord,
    parsePairKeyValue: utils_1.parsePairKeyValue
  };
  var platform_1 = require_platform4();
  Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
    return platform_1.RandomIdGenerator;
  } });
  Object.defineProperty(exports, "SDK_INFO", { enumerable: true, get: function() {
    return platform_1.SDK_INFO;
  } });
  Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
    return platform_1._globalThis;
  } });
  Object.defineProperty(exports, "getEnv", { enumerable: true, get: function() {
    return platform_1.getEnv;
  } });
  Object.defineProperty(exports, "getEnvWithoutDefaults", { enumerable: true, get: function() {
    return platform_1.getEnvWithoutDefaults;
  } });
  Object.defineProperty(exports, "hexToBase64", { enumerable: true, get: function() {
    return platform_1.hexToBase64;
  } });
  Object.defineProperty(exports, "otperformance", { enumerable: true, get: function() {
    return platform_1.otperformance;
  } });
  Object.defineProperty(exports, "unrefTimer", { enumerable: true, get: function() {
    return platform_1.unrefTimer;
  } });
  var composite_1 = require_composite();
  Object.defineProperty(exports, "CompositePropagator", { enumerable: true, get: function() {
    return composite_1.CompositePropagator;
  } });
  var W3CTraceContextPropagator_1 = require_W3CTraceContextPropagator();
  Object.defineProperty(exports, "TRACE_PARENT_HEADER", { enumerable: true, get: function() {
    return W3CTraceContextPropagator_1.TRACE_PARENT_HEADER;
  } });
  Object.defineProperty(exports, "TRACE_STATE_HEADER", { enumerable: true, get: function() {
    return W3CTraceContextPropagator_1.TRACE_STATE_HEADER;
  } });
  Object.defineProperty(exports, "W3CTraceContextPropagator", { enumerable: true, get: function() {
    return W3CTraceContextPropagator_1.W3CTraceContextPropagator;
  } });
  Object.defineProperty(exports, "parseTraceParent", { enumerable: true, get: function() {
    return W3CTraceContextPropagator_1.parseTraceParent;
  } });
  var rpc_metadata_1 = require_rpc_metadata();
  Object.defineProperty(exports, "RPCType", { enumerable: true, get: function() {
    return rpc_metadata_1.RPCType;
  } });
  Object.defineProperty(exports, "deleteRPCMetadata", { enumerable: true, get: function() {
    return rpc_metadata_1.deleteRPCMetadata;
  } });
  Object.defineProperty(exports, "getRPCMetadata", { enumerable: true, get: function() {
    return rpc_metadata_1.getRPCMetadata;
  } });
  Object.defineProperty(exports, "setRPCMetadata", { enumerable: true, get: function() {
    return rpc_metadata_1.setRPCMetadata;
  } });
  var AlwaysOffSampler_1 = require_AlwaysOffSampler();
  Object.defineProperty(exports, "AlwaysOffSampler", { enumerable: true, get: function() {
    return AlwaysOffSampler_1.AlwaysOffSampler;
  } });
  var AlwaysOnSampler_1 = require_AlwaysOnSampler();
  Object.defineProperty(exports, "AlwaysOnSampler", { enumerable: true, get: function() {
    return AlwaysOnSampler_1.AlwaysOnSampler;
  } });
  var ParentBasedSampler_1 = require_ParentBasedSampler();
  Object.defineProperty(exports, "ParentBasedSampler", { enumerable: true, get: function() {
    return ParentBasedSampler_1.ParentBasedSampler;
  } });
  var TraceIdRatioBasedSampler_1 = require_TraceIdRatioBasedSampler();
  Object.defineProperty(exports, "TraceIdRatioBasedSampler", { enumerable: true, get: function() {
    return TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler;
  } });
  var suppress_tracing_1 = require_suppress_tracing();
  Object.defineProperty(exports, "isTracingSuppressed", { enumerable: true, get: function() {
    return suppress_tracing_1.isTracingSuppressed;
  } });
  Object.defineProperty(exports, "suppressTracing", { enumerable: true, get: function() {
    return suppress_tracing_1.suppressTracing;
  } });
  Object.defineProperty(exports, "unsuppressTracing", { enumerable: true, get: function() {
    return suppress_tracing_1.unsuppressTracing;
  } });
  var TraceState_1 = require_TraceState();
  Object.defineProperty(exports, "TraceState", { enumerable: true, get: function() {
    return TraceState_1.TraceState;
  } });
  var environment_1 = require_environment();
  Object.defineProperty(exports, "DEFAULT_ATTRIBUTE_COUNT_LIMIT", { enumerable: true, get: function() {
    return environment_1.DEFAULT_ATTRIBUTE_COUNT_LIMIT;
  } });
  Object.defineProperty(exports, "DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT", { enumerable: true, get: function() {
    return environment_1.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
  } });
  Object.defineProperty(exports, "DEFAULT_ENVIRONMENT", { enumerable: true, get: function() {
    return environment_1.DEFAULT_ENVIRONMENT;
  } });
  Object.defineProperty(exports, "DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", { enumerable: true, get: function() {
    return environment_1.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT;
  } });
  Object.defineProperty(exports, "DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT", { enumerable: true, get: function() {
    return environment_1.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT;
  } });
  Object.defineProperty(exports, "parseEnvironment", { enumerable: true, get: function() {
    return environment_1.parseEnvironment;
  } });
  var merge_1 = require_merge();
  Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
    return merge_1.merge;
  } });
  var sampling_1 = require_sampling();
  Object.defineProperty(exports, "TracesSamplerValues", { enumerable: true, get: function() {
    return sampling_1.TracesSamplerValues;
  } });
  var timeout_1 = require_timeout();
  Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
    return timeout_1.TimeoutError;
  } });
  Object.defineProperty(exports, "callWithTimeout", { enumerable: true, get: function() {
    return timeout_1.callWithTimeout;
  } });
  var url_1 = require_url();
  Object.defineProperty(exports, "isUrlIgnored", { enumerable: true, get: function() {
    return url_1.isUrlIgnored;
  } });
  Object.defineProperty(exports, "urlMatches", { enumerable: true, get: function() {
    return url_1.urlMatches;
  } });
  var wrap_1 = require_wrap();
  Object.defineProperty(exports, "isWrapped", { enumerable: true, get: function() {
    return wrap_1.isWrapped;
  } });
  var callback_1 = require_callback();
  Object.defineProperty(exports, "BindOnceFuture", { enumerable: true, get: function() {
    return callback_1.BindOnceFuture;
  } });
  var version_1 = require_version3();
  Object.defineProperty(exports, "VERSION", { enumerable: true, get: function() {
    return version_1.VERSION;
  } });
  var exporter_1 = require_exporter();
  exports.internal = {
    _export: exporter_1._export
  };
});

// ../../node_modules/@opentelemetry/resources/build/src/platform/node/default-service-name.js
var require_default_service_name = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultServiceName = undefined;
  function defaultServiceName() {
    return `unknown_service:${process.argv0}`;
  }
  exports.defaultServiceName = defaultServiceName;
});

// ../../node_modules/@opentelemetry/resources/build/src/platform/node/index.js
var require_node6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultServiceName = undefined;
  var default_service_name_1 = require_default_service_name();
  Object.defineProperty(exports, "defaultServiceName", { enumerable: true, get: function() {
    return default_service_name_1.defaultServiceName;
  } });
});

// ../../node_modules/@opentelemetry/resources/build/src/platform/index.js
var require_platform5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultServiceName = undefined;
  var node_1 = require_node6();
  Object.defineProperty(exports, "defaultServiceName", { enumerable: true, get: function() {
    return node_1.defaultServiceName;
  } });
});

// ../../node_modules/@opentelemetry/resources/build/src/Resource.js
var require_Resource = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Resource = undefined;
  var api_1 = require_src();
  var semantic_conventions_1 = require_src6();
  var core_1 = require_src8();
  var platform_1 = require_platform5();

  class Resource {
    constructor(attributes, asyncAttributesPromise) {
      var _a2;
      this._attributes = attributes;
      this.asyncAttributesPending = asyncAttributesPromise != null;
      this._syncAttributes = (_a2 = this._attributes) !== null && _a2 !== undefined ? _a2 : {};
      this._asyncAttributesPromise = asyncAttributesPromise === null || asyncAttributesPromise === undefined ? undefined : asyncAttributesPromise.then((asyncAttributes) => {
        this._attributes = Object.assign({}, this._attributes, asyncAttributes);
        this.asyncAttributesPending = false;
        return asyncAttributes;
      }, (err) => {
        api_1.diag.debug("a resource's async attributes promise rejected: %s", err);
        this.asyncAttributesPending = false;
        return {};
      });
    }
    static empty() {
      return Resource.EMPTY;
    }
    static default() {
      return new Resource({
        [semantic_conventions_1.SEMRESATTRS_SERVICE_NAME]: (0, platform_1.defaultServiceName)(),
        [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE]: core_1.SDK_INFO[semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE],
        [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_NAME]: core_1.SDK_INFO[semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_NAME],
        [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_VERSION]: core_1.SDK_INFO[semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_VERSION]
      });
    }
    get attributes() {
      var _a2;
      if (this.asyncAttributesPending) {
        api_1.diag.error("Accessing resource attributes before async attributes settled");
      }
      return (_a2 = this._attributes) !== null && _a2 !== undefined ? _a2 : {};
    }
    async waitForAsyncAttributes() {
      if (this.asyncAttributesPending) {
        await this._asyncAttributesPromise;
      }
    }
    merge(other) {
      var _a2;
      if (!other)
        return this;
      const mergedSyncAttributes = Object.assign(Object.assign({}, this._syncAttributes), (_a2 = other._syncAttributes) !== null && _a2 !== undefined ? _a2 : other.attributes);
      if (!this._asyncAttributesPromise && !other._asyncAttributesPromise) {
        return new Resource(mergedSyncAttributes);
      }
      const mergedAttributesPromise = Promise.all([
        this._asyncAttributesPromise,
        other._asyncAttributesPromise
      ]).then(([thisAsyncAttributes, otherAsyncAttributes]) => {
        var _a3;
        return Object.assign(Object.assign(Object.assign(Object.assign({}, this._syncAttributes), thisAsyncAttributes), (_a3 = other._syncAttributes) !== null && _a3 !== undefined ? _a3 : other.attributes), otherAsyncAttributes);
      });
      return new Resource(mergedSyncAttributes, mergedAttributesPromise);
    }
  }
  exports.Resource = Resource;
  Resource.EMPTY = new Resource({});
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/utils.js
var require_utils7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalizeType = exports.normalizeArch = undefined;
  var normalizeArch = (nodeArchString) => {
    switch (nodeArchString) {
      case "arm":
        return "arm32";
      case "ppc":
        return "ppc32";
      case "x64":
        return "amd64";
      default:
        return nodeArchString;
    }
  };
  exports.normalizeArch = normalizeArch;
  var normalizeType = (nodePlatform) => {
    switch (nodePlatform) {
      case "sunos":
        return "solaris";
      case "win32":
        return "windows";
      default:
        return nodePlatform;
    }
  };
  exports.normalizeType = normalizeType;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/execAsync.js
var require_execAsync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.execAsync = undefined;
  var child_process = __require("child_process");
  var util = __require("util");
  exports.execAsync = util.promisify(child_process.exec);
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-darwin.js
var require_getMachineId_darwin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMachineId = undefined;
  var execAsync_1 = require_execAsync();
  var api_1 = require_src();
  async function getMachineId() {
    try {
      const result = await (0, execAsync_1.execAsync)('ioreg -rd1 -c "IOPlatformExpertDevice"');
      const idLine = result.stdout.split(`
`).find((line) => line.includes("IOPlatformUUID"));
      if (!idLine) {
        return "";
      }
      const parts = idLine.split('" = "');
      if (parts.length === 2) {
        return parts[1].slice(0, -1);
      }
    } catch (e4) {
      api_1.diag.debug(`error reading machine id: ${e4}`);
    }
    return "";
  }
  exports.getMachineId = getMachineId;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-linux.js
var require_getMachineId_linux = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMachineId = undefined;
  var fs_1 = __require("fs");
  var api_1 = require_src();
  async function getMachineId() {
    const paths = ["/etc/machine-id", "/var/lib/dbus/machine-id"];
    for (const path of paths) {
      try {
        const result = await fs_1.promises.readFile(path, { encoding: "utf8" });
        return result.trim();
      } catch (e4) {
        api_1.diag.debug(`error reading machine id: ${e4}`);
      }
    }
    return "";
  }
  exports.getMachineId = getMachineId;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-bsd.js
var require_getMachineId_bsd = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMachineId = undefined;
  var fs_1 = __require("fs");
  var execAsync_1 = require_execAsync();
  var api_1 = require_src();
  async function getMachineId() {
    try {
      const result = await fs_1.promises.readFile("/etc/hostid", { encoding: "utf8" });
      return result.trim();
    } catch (e4) {
      api_1.diag.debug(`error reading machine id: ${e4}`);
    }
    try {
      const result = await (0, execAsync_1.execAsync)("kenv -q smbios.system.uuid");
      return result.stdout.trim();
    } catch (e4) {
      api_1.diag.debug(`error reading machine id: ${e4}`);
    }
    return "";
  }
  exports.getMachineId = getMachineId;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-win.js
var require_getMachineId_win = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMachineId = undefined;
  var process2 = __require("process");
  var execAsync_1 = require_execAsync();
  var api_1 = require_src();
  async function getMachineId() {
    const args = "QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid";
    let command2 = "%windir%\\System32\\REG.exe";
    if (process2.arch === "ia32" && "PROCESSOR_ARCHITEW6432" in process2.env) {
      command2 = "%windir%\\sysnative\\cmd.exe /c " + command2;
    }
    try {
      const result = await (0, execAsync_1.execAsync)(`${command2} ${args}`);
      const parts = result.stdout.split("REG_SZ");
      if (parts.length === 2) {
        return parts[1].trim();
      }
    } catch (e4) {
      api_1.diag.debug(`error reading machine id: ${e4}`);
    }
    return "";
  }
  exports.getMachineId = getMachineId;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-unsupported.js
var require_getMachineId_unsupported = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMachineId = undefined;
  var api_1 = require_src();
  async function getMachineId() {
    api_1.diag.debug("could not read machine-id: unsupported platform");
    return "";
  }
  exports.getMachineId = getMachineId;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId.js
var require_getMachineId = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMachineId = undefined;
  var process2 = __require("process");
  var getMachineId;
  exports.getMachineId = getMachineId;
  switch (process2.platform) {
    case "darwin":
      exports.getMachineId = getMachineId = require_getMachineId_darwin().getMachineId;
      break;
    case "linux":
      exports.getMachineId = getMachineId = require_getMachineId_linux().getMachineId;
      break;
    case "freebsd":
      exports.getMachineId = getMachineId = require_getMachineId_bsd().getMachineId;
      break;
    case "win32":
      exports.getMachineId = getMachineId = require_getMachineId_win().getMachineId;
      break;
    default:
      exports.getMachineId = getMachineId = require_getMachineId_unsupported().getMachineId;
  }
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetectorSync.js
var require_HostDetectorSync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hostDetectorSync = undefined;
  var semantic_conventions_1 = require_src6();
  var Resource_1 = require_Resource();
  var os_1 = __require("os");
  var utils_1 = require_utils7();
  var getMachineId_1 = require_getMachineId();

  class HostDetectorSync {
    detect(_config) {
      const attributes = {
        [semantic_conventions_1.SEMRESATTRS_HOST_NAME]: (0, os_1.hostname)(),
        [semantic_conventions_1.SEMRESATTRS_HOST_ARCH]: (0, utils_1.normalizeArch)((0, os_1.arch)())
      };
      return new Resource_1.Resource(attributes, this._getAsyncAttributes());
    }
    _getAsyncAttributes() {
      return (0, getMachineId_1.getMachineId)().then((machineId) => {
        const attributes = {};
        if (machineId) {
          attributes[semantic_conventions_1.SEMRESATTRS_HOST_ID] = machineId;
        }
        return attributes;
      });
    }
  }
  exports.hostDetectorSync = new HostDetectorSync;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetector.js
var require_HostDetector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hostDetector = undefined;
  var HostDetectorSync_1 = require_HostDetectorSync();

  class HostDetector {
    detect(_config) {
      return Promise.resolve(HostDetectorSync_1.hostDetectorSync.detect(_config));
    }
  }
  exports.hostDetector = new HostDetector;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetectorSync.js
var require_OSDetectorSync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.osDetectorSync = undefined;
  var semantic_conventions_1 = require_src6();
  var Resource_1 = require_Resource();
  var os_1 = __require("os");
  var utils_1 = require_utils7();

  class OSDetectorSync {
    detect(_config) {
      const attributes = {
        [semantic_conventions_1.SEMRESATTRS_OS_TYPE]: (0, utils_1.normalizeType)((0, os_1.platform)()),
        [semantic_conventions_1.SEMRESATTRS_OS_VERSION]: (0, os_1.release)()
      };
      return new Resource_1.Resource(attributes);
    }
  }
  exports.osDetectorSync = new OSDetectorSync;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetector.js
var require_OSDetector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.osDetector = undefined;
  var OSDetectorSync_1 = require_OSDetectorSync();

  class OSDetector {
    detect(_config) {
      return Promise.resolve(OSDetectorSync_1.osDetectorSync.detect(_config));
    }
  }
  exports.osDetector = new OSDetector;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetectorSync.js
var require_ProcessDetectorSync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.processDetectorSync = undefined;
  var api_1 = require_src();
  var semantic_conventions_1 = require_src6();
  var Resource_1 = require_Resource();
  var os = __require("os");

  class ProcessDetectorSync {
    detect(_config) {
      const attributes = {
        [semantic_conventions_1.SEMRESATTRS_PROCESS_PID]: process.pid,
        [semantic_conventions_1.SEMRESATTRS_PROCESS_EXECUTABLE_NAME]: process.title,
        [semantic_conventions_1.SEMRESATTRS_PROCESS_EXECUTABLE_PATH]: process.execPath,
        [semantic_conventions_1.SEMRESATTRS_PROCESS_COMMAND_ARGS]: [
          process.argv[0],
          ...process.execArgv,
          ...process.argv.slice(1)
        ],
        [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_VERSION]: process.versions.node,
        [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_NAME]: "nodejs",
        [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION]: "Node.js"
      };
      if (process.argv.length > 1) {
        attributes[semantic_conventions_1.SEMRESATTRS_PROCESS_COMMAND] = process.argv[1];
      }
      try {
        const userInfo = os.userInfo();
        attributes[semantic_conventions_1.SEMRESATTRS_PROCESS_OWNER] = userInfo.username;
      } catch (e4) {
        api_1.diag.debug(`error obtaining process owner: ${e4}`);
      }
      return new Resource_1.Resource(attributes);
    }
  }
  exports.processDetectorSync = new ProcessDetectorSync;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetector.js
var require_ProcessDetector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.processDetector = undefined;
  var ProcessDetectorSync_1 = require_ProcessDetectorSync();

  class ProcessDetector {
    detect(config5) {
      return Promise.resolve(ProcessDetectorSync_1.processDetectorSync.detect(config5));
    }
  }
  exports.processDetector = new ProcessDetector;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ServiceInstanceIdDetectorSync.js
var require_ServiceInstanceIdDetectorSync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serviceInstanceIdDetectorSync = undefined;
  var semantic_conventions_1 = require_src6();
  var Resource_1 = require_Resource();
  var crypto_1 = __require("crypto");

  class ServiceInstanceIdDetectorSync {
    detect(_config) {
      const attributes = {
        [semantic_conventions_1.SEMRESATTRS_SERVICE_INSTANCE_ID]: (0, crypto_1.randomUUID)()
      };
      return new Resource_1.Resource(attributes);
    }
  }
  exports.serviceInstanceIdDetectorSync = new ServiceInstanceIdDetectorSync;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/node/index.js
var require_node7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serviceInstanceIdDetectorSync = exports.processDetectorSync = exports.processDetector = exports.osDetectorSync = exports.osDetector = exports.hostDetectorSync = exports.hostDetector = undefined;
  var HostDetector_1 = require_HostDetector();
  Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
    return HostDetector_1.hostDetector;
  } });
  var HostDetectorSync_1 = require_HostDetectorSync();
  Object.defineProperty(exports, "hostDetectorSync", { enumerable: true, get: function() {
    return HostDetectorSync_1.hostDetectorSync;
  } });
  var OSDetector_1 = require_OSDetector();
  Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
    return OSDetector_1.osDetector;
  } });
  var OSDetectorSync_1 = require_OSDetectorSync();
  Object.defineProperty(exports, "osDetectorSync", { enumerable: true, get: function() {
    return OSDetectorSync_1.osDetectorSync;
  } });
  var ProcessDetector_1 = require_ProcessDetector();
  Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
    return ProcessDetector_1.processDetector;
  } });
  var ProcessDetectorSync_1 = require_ProcessDetectorSync();
  Object.defineProperty(exports, "processDetectorSync", { enumerable: true, get: function() {
    return ProcessDetectorSync_1.processDetectorSync;
  } });
  var ServiceInstanceIdDetectorSync_1 = require_ServiceInstanceIdDetectorSync();
  Object.defineProperty(exports, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
    return ServiceInstanceIdDetectorSync_1.serviceInstanceIdDetectorSync;
  } });
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/platform/index.js
var require_platform6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serviceInstanceIdDetectorSync = exports.processDetectorSync = exports.processDetector = exports.osDetectorSync = exports.osDetector = exports.hostDetectorSync = exports.hostDetector = undefined;
  var node_1 = require_node7();
  Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
    return node_1.hostDetector;
  } });
  Object.defineProperty(exports, "hostDetectorSync", { enumerable: true, get: function() {
    return node_1.hostDetectorSync;
  } });
  Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
    return node_1.osDetector;
  } });
  Object.defineProperty(exports, "osDetectorSync", { enumerable: true, get: function() {
    return node_1.osDetectorSync;
  } });
  Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
    return node_1.processDetector;
  } });
  Object.defineProperty(exports, "processDetectorSync", { enumerable: true, get: function() {
    return node_1.processDetectorSync;
  } });
  Object.defineProperty(exports, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
    return node_1.serviceInstanceIdDetectorSync;
  } });
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetectorSync.js
var require_BrowserDetectorSync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.browserDetectorSync = undefined;
  var semantic_conventions_1 = require_src6();
  var api_1 = require_src();
  var Resource_1 = require_Resource();

  class BrowserDetectorSync {
    detect(config5) {
      var _a2, _b2, _c2;
      const isBrowser = typeof navigator !== "undefined" && ((_b2 = (_a2 = global.process) === null || _a2 === undefined ? undefined : _a2.versions) === null || _b2 === undefined ? undefined : _b2.node) === undefined && ((_c2 = global.Bun) === null || _c2 === undefined ? undefined : _c2.version) === undefined;
      if (!isBrowser) {
        return Resource_1.Resource.empty();
      }
      const browserResource = {
        [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_NAME]: "browser",
        [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION]: "Web Browser",
        [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_VERSION]: navigator.userAgent
      };
      return this._getResourceAttributes(browserResource, config5);
    }
    _getResourceAttributes(browserResource, _config) {
      if (browserResource[semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_VERSION] === "") {
        api_1.diag.debug("BrowserDetector failed: Unable to find required browser resources. ");
        return Resource_1.Resource.empty();
      } else {
        return new Resource_1.Resource(Object.assign({}, browserResource));
      }
    }
  }
  exports.browserDetectorSync = new BrowserDetectorSync;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetector.js
var require_BrowserDetector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.browserDetector = undefined;
  var BrowserDetectorSync_1 = require_BrowserDetectorSync();

  class BrowserDetector {
    detect(config5) {
      return Promise.resolve(BrowserDetectorSync_1.browserDetectorSync.detect(config5));
    }
  }
  exports.browserDetector = new BrowserDetector;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/EnvDetectorSync.js
var require_EnvDetectorSync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.envDetectorSync = undefined;
  var api_1 = require_src();
  var core_1 = require_src8();
  var semantic_conventions_1 = require_src6();
  var Resource_1 = require_Resource();

  class EnvDetectorSync {
    constructor() {
      this._MAX_LENGTH = 255;
      this._COMMA_SEPARATOR = ",";
      this._LABEL_KEY_VALUE_SPLITTER = "=";
      this._ERROR_MESSAGE_INVALID_CHARS = "should be a ASCII string with a length greater than 0 and not exceed " + this._MAX_LENGTH + " characters.";
      this._ERROR_MESSAGE_INVALID_VALUE = "should be a ASCII string with a length not exceed " + this._MAX_LENGTH + " characters.";
    }
    detect(_config) {
      const attributes = {};
      const env3 = (0, core_1.getEnv)();
      const rawAttributes = env3.OTEL_RESOURCE_ATTRIBUTES;
      const serviceName = env3.OTEL_SERVICE_NAME;
      if (rawAttributes) {
        try {
          const parsedAttributes = this._parseResourceAttributes(rawAttributes);
          Object.assign(attributes, parsedAttributes);
        } catch (e4) {
          api_1.diag.debug(`EnvDetector failed: ${e4.message}`);
        }
      }
      if (serviceName) {
        attributes[semantic_conventions_1.SEMRESATTRS_SERVICE_NAME] = serviceName;
      }
      return new Resource_1.Resource(attributes);
    }
    _parseResourceAttributes(rawEnvAttributes) {
      if (!rawEnvAttributes)
        return {};
      const attributes = {};
      const rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);
      for (const rawAttribute of rawAttributes) {
        const keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);
        if (keyValuePair.length !== 2) {
          continue;
        }
        let [key, value] = keyValuePair;
        key = key.trim();
        value = value.trim().split(/^"|"$/).join("");
        if (!this._isValidAndNotEmpty(key)) {
          throw new Error(`Attribute key ${this._ERROR_MESSAGE_INVALID_CHARS}`);
        }
        if (!this._isValid(value)) {
          throw new Error(`Attribute value ${this._ERROR_MESSAGE_INVALID_VALUE}`);
        }
        attributes[key] = decodeURIComponent(value);
      }
      return attributes;
    }
    _isValid(name) {
      return name.length <= this._MAX_LENGTH && this._isBaggageOctetString(name);
    }
    _isBaggageOctetString(str) {
      for (let i4 = 0;i4 < str.length; i4++) {
        const ch2 = str.charCodeAt(i4);
        if (ch2 < 33 || ch2 === 44 || ch2 === 59 || ch2 === 92 || ch2 > 126) {
          return false;
        }
      }
      return true;
    }
    _isValidAndNotEmpty(str) {
      return str.length > 0 && this._isValid(str);
    }
  }
  exports.envDetectorSync = new EnvDetectorSync;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/EnvDetector.js
var require_EnvDetector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.envDetector = undefined;
  var EnvDetectorSync_1 = require_EnvDetectorSync();

  class EnvDetector {
    detect(config5) {
      return Promise.resolve(EnvDetectorSync_1.envDetectorSync.detect(config5));
    }
  }
  exports.envDetector = new EnvDetector;
});

// ../../node_modules/@opentelemetry/resources/build/src/detectors/index.js
var require_detectors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.envDetectorSync = exports.browserDetectorSync = exports.envDetector = exports.browserDetector = exports.serviceInstanceIdDetectorSync = exports.processDetectorSync = exports.processDetector = exports.osDetectorSync = exports.osDetector = exports.hostDetectorSync = exports.hostDetector = undefined;
  var platform_1 = require_platform6();
  Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
    return platform_1.hostDetector;
  } });
  Object.defineProperty(exports, "hostDetectorSync", { enumerable: true, get: function() {
    return platform_1.hostDetectorSync;
  } });
  Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
    return platform_1.osDetector;
  } });
  Object.defineProperty(exports, "osDetectorSync", { enumerable: true, get: function() {
    return platform_1.osDetectorSync;
  } });
  Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
    return platform_1.processDetector;
  } });
  Object.defineProperty(exports, "processDetectorSync", { enumerable: true, get: function() {
    return platform_1.processDetectorSync;
  } });
  Object.defineProperty(exports, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
    return platform_1.serviceInstanceIdDetectorSync;
  } });
  var BrowserDetector_1 = require_BrowserDetector();
  Object.defineProperty(exports, "browserDetector", { enumerable: true, get: function() {
    return BrowserDetector_1.browserDetector;
  } });
  var EnvDetector_1 = require_EnvDetector();
  Object.defineProperty(exports, "envDetector", { enumerable: true, get: function() {
    return EnvDetector_1.envDetector;
  } });
  var BrowserDetectorSync_1 = require_BrowserDetectorSync();
  Object.defineProperty(exports, "browserDetectorSync", { enumerable: true, get: function() {
    return BrowserDetectorSync_1.browserDetectorSync;
  } });
  var EnvDetectorSync_1 = require_EnvDetectorSync();
  Object.defineProperty(exports, "envDetectorSync", { enumerable: true, get: function() {
    return EnvDetectorSync_1.envDetectorSync;
  } });
});

// ../../node_modules/@opentelemetry/resources/build/src/utils.js
var require_utils8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isPromiseLike = undefined;
  var isPromiseLike = (val2) => {
    return val2 !== null && typeof val2 === "object" && typeof val2.then === "function";
  };
  exports.isPromiseLike = isPromiseLike;
});

// ../../node_modules/@opentelemetry/resources/build/src/detect-resources.js
var require_detect_resources = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.detectResourcesSync = exports.detectResources = undefined;
  var Resource_1 = require_Resource();
  var api_1 = require_src();
  var utils_1 = require_utils8();
  var detectResources = async (config5 = {}) => {
    const resources = await Promise.all((config5.detectors || []).map(async (d4) => {
      try {
        const resource = await d4.detect(config5);
        api_1.diag.debug(`${d4.constructor.name} found resource.`, resource);
        return resource;
      } catch (e4) {
        api_1.diag.debug(`${d4.constructor.name} failed: ${e4.message}`);
        return Resource_1.Resource.empty();
      }
    }));
    logResources(resources);
    return resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
  };
  exports.detectResources = detectResources;
  var detectResourcesSync = (config5 = {}) => {
    var _a2;
    const resources = ((_a2 = config5.detectors) !== null && _a2 !== undefined ? _a2 : []).map((d4) => {
      try {
        const resourceOrPromise = d4.detect(config5);
        let resource;
        if ((0, utils_1.isPromiseLike)(resourceOrPromise)) {
          const createPromise = async () => {
            var _a3;
            const resolvedResource = await resourceOrPromise;
            await ((_a3 = resolvedResource.waitForAsyncAttributes) === null || _a3 === undefined ? undefined : _a3.call(resolvedResource));
            return resolvedResource.attributes;
          };
          resource = new Resource_1.Resource({}, createPromise());
        } else {
          resource = resourceOrPromise;
        }
        if (resource.waitForAsyncAttributes) {
          resource.waitForAsyncAttributes().then(() => api_1.diag.debug(`${d4.constructor.name} found resource.`, resource));
        } else {
          api_1.diag.debug(`${d4.constructor.name} found resource.`, resource);
        }
        return resource;
      } catch (e4) {
        api_1.diag.error(`${d4.constructor.name} failed: ${e4.message}`);
        return Resource_1.Resource.empty();
      }
    });
    const mergedResources = resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
    if (mergedResources.waitForAsyncAttributes) {
      mergedResources.waitForAsyncAttributes().then(() => {
        logResources(resources);
      });
    }
    return mergedResources;
  };
  exports.detectResourcesSync = detectResourcesSync;
  var logResources = (resources) => {
    resources.forEach((resource) => {
      if (Object.keys(resource.attributes).length > 0) {
        const resourceDebugString = JSON.stringify(resource.attributes, null, 4);
        api_1.diag.verbose(resourceDebugString);
      }
    });
  };
});

// ../../node_modules/@opentelemetry/resources/build/src/index.js
var require_src9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.detectResources = exports.detectResourcesSync = exports.serviceInstanceIdDetectorSync = exports.processDetectorSync = exports.processDetector = exports.osDetectorSync = exports.osDetector = exports.hostDetectorSync = exports.hostDetector = exports.envDetectorSync = exports.envDetector = exports.browserDetectorSync = exports.browserDetector = exports.defaultServiceName = exports.Resource = undefined;
  var Resource_1 = require_Resource();
  Object.defineProperty(exports, "Resource", { enumerable: true, get: function() {
    return Resource_1.Resource;
  } });
  var platform_1 = require_platform5();
  Object.defineProperty(exports, "defaultServiceName", { enumerable: true, get: function() {
    return platform_1.defaultServiceName;
  } });
  var detectors_1 = require_detectors();
  Object.defineProperty(exports, "browserDetector", { enumerable: true, get: function() {
    return detectors_1.browserDetector;
  } });
  Object.defineProperty(exports, "browserDetectorSync", { enumerable: true, get: function() {
    return detectors_1.browserDetectorSync;
  } });
  Object.defineProperty(exports, "envDetector", { enumerable: true, get: function() {
    return detectors_1.envDetector;
  } });
  Object.defineProperty(exports, "envDetectorSync", { enumerable: true, get: function() {
    return detectors_1.envDetectorSync;
  } });
  Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
    return detectors_1.hostDetector;
  } });
  Object.defineProperty(exports, "hostDetectorSync", { enumerable: true, get: function() {
    return detectors_1.hostDetectorSync;
  } });
  Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
    return detectors_1.osDetector;
  } });
  Object.defineProperty(exports, "osDetectorSync", { enumerable: true, get: function() {
    return detectors_1.osDetectorSync;
  } });
  Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
    return detectors_1.processDetector;
  } });
  Object.defineProperty(exports, "processDetectorSync", { enumerable: true, get: function() {
    return detectors_1.processDetectorSync;
  } });
  Object.defineProperty(exports, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
    return detectors_1.serviceInstanceIdDetectorSync;
  } });
  var detect_resources_1 = require_detect_resources();
  Object.defineProperty(exports, "detectResourcesSync", { enumerable: true, get: function() {
    return detect_resources_1.detectResourcesSync;
  } });
  Object.defineProperty(exports, "detectResources", { enumerable: true, get: function() {
    return detect_resources_1.detectResources;
  } });
});

// ../../node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js
var require_utils9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createConstMap = undefined;
  function createConstMap(values) {
    let res = {};
    const len = values.length;
    for (let lp = 0;lp < len; lp++) {
      const val2 = values[lp];
      if (val2) {
        res[String(val2).toUpperCase().replace(/[-.]/g, "_")] = val2;
      }
    }
    return res;
  }
  exports.createConstMap = createConstMap;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js
var require_SemanticAttributes3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SEMATTRS_NET_HOST_CARRIER_ICC = exports.SEMATTRS_NET_HOST_CARRIER_MNC = exports.SEMATTRS_NET_HOST_CARRIER_MCC = exports.SEMATTRS_NET_HOST_CARRIER_NAME = exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = exports.SEMATTRS_NET_HOST_NAME = exports.SEMATTRS_NET_HOST_PORT = exports.SEMATTRS_NET_HOST_IP = exports.SEMATTRS_NET_PEER_NAME = exports.SEMATTRS_NET_PEER_PORT = exports.SEMATTRS_NET_PEER_IP = exports.SEMATTRS_NET_TRANSPORT = exports.SEMATTRS_FAAS_INVOKED_REGION = exports.SEMATTRS_FAAS_INVOKED_PROVIDER = exports.SEMATTRS_FAAS_INVOKED_NAME = exports.SEMATTRS_FAAS_COLDSTART = exports.SEMATTRS_FAAS_CRON = exports.SEMATTRS_FAAS_TIME = exports.SEMATTRS_FAAS_DOCUMENT_NAME = exports.SEMATTRS_FAAS_DOCUMENT_TIME = exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = exports.SEMATTRS_FAAS_EXECUTION = exports.SEMATTRS_FAAS_TRIGGER = exports.SEMATTRS_EXCEPTION_ESCAPED = exports.SEMATTRS_EXCEPTION_STACKTRACE = exports.SEMATTRS_EXCEPTION_MESSAGE = exports.SEMATTRS_EXCEPTION_TYPE = exports.SEMATTRS_DB_SQL_TABLE = exports.SEMATTRS_DB_MONGODB_COLLECTION = exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = exports.SEMATTRS_DB_HBASE_NAMESPACE = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = exports.SEMATTRS_DB_CASSANDRA_TABLE = exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = exports.SEMATTRS_DB_OPERATION = exports.SEMATTRS_DB_STATEMENT = exports.SEMATTRS_DB_NAME = exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = exports.SEMATTRS_DB_USER = exports.SEMATTRS_DB_CONNECTION_STRING = exports.SEMATTRS_DB_SYSTEM = exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = undefined;
  exports.SEMATTRS_MESSAGING_DESTINATION_KIND = exports.SEMATTRS_MESSAGING_DESTINATION = exports.SEMATTRS_MESSAGING_SYSTEM = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = exports.SEMATTRS_AWS_DYNAMODB_COUNT = exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_SELECT = exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = exports.SEMATTRS_AWS_DYNAMODB_LIMIT = exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = exports.SEMATTRS_HTTP_CLIENT_IP = exports.SEMATTRS_HTTP_ROUTE = exports.SEMATTRS_HTTP_SERVER_NAME = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = exports.SEMATTRS_HTTP_USER_AGENT = exports.SEMATTRS_HTTP_FLAVOR = exports.SEMATTRS_HTTP_STATUS_CODE = exports.SEMATTRS_HTTP_SCHEME = exports.SEMATTRS_HTTP_HOST = exports.SEMATTRS_HTTP_TARGET = exports.SEMATTRS_HTTP_URL = exports.SEMATTRS_HTTP_METHOD = exports.SEMATTRS_CODE_LINENO = exports.SEMATTRS_CODE_FILEPATH = exports.SEMATTRS_CODE_NAMESPACE = exports.SEMATTRS_CODE_FUNCTION = exports.SEMATTRS_THREAD_NAME = exports.SEMATTRS_THREAD_ID = exports.SEMATTRS_ENDUSER_SCOPE = exports.SEMATTRS_ENDUSER_ROLE = exports.SEMATTRS_ENDUSER_ID = exports.SEMATTRS_PEER_SERVICE = undefined;
  exports.DBSYSTEMVALUES_FILEMAKER = exports.DBSYSTEMVALUES_DERBY = exports.DBSYSTEMVALUES_FIREBIRD = exports.DBSYSTEMVALUES_ADABAS = exports.DBSYSTEMVALUES_CACHE = exports.DBSYSTEMVALUES_EDB = exports.DBSYSTEMVALUES_FIRSTSQL = exports.DBSYSTEMVALUES_INGRES = exports.DBSYSTEMVALUES_HANADB = exports.DBSYSTEMVALUES_MAXDB = exports.DBSYSTEMVALUES_PROGRESS = exports.DBSYSTEMVALUES_HSQLDB = exports.DBSYSTEMVALUES_CLOUDSCAPE = exports.DBSYSTEMVALUES_HIVE = exports.DBSYSTEMVALUES_REDSHIFT = exports.DBSYSTEMVALUES_POSTGRESQL = exports.DBSYSTEMVALUES_DB2 = exports.DBSYSTEMVALUES_ORACLE = exports.DBSYSTEMVALUES_MYSQL = exports.DBSYSTEMVALUES_MSSQL = exports.DBSYSTEMVALUES_OTHER_SQL = exports.SemanticAttributes = exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_ID = exports.SEMATTRS_MESSAGE_TYPE = exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = exports.SEMATTRS_RPC_JSONRPC_VERSION = exports.SEMATTRS_RPC_GRPC_STATUS_CODE = exports.SEMATTRS_RPC_METHOD = exports.SEMATTRS_RPC_SERVICE = exports.SEMATTRS_RPC_SYSTEM = exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = exports.SEMATTRS_MESSAGING_CONSUMER_ID = exports.SEMATTRS_MESSAGING_OPERATION = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = exports.SEMATTRS_MESSAGING_CONVERSATION_ID = exports.SEMATTRS_MESSAGING_MESSAGE_ID = exports.SEMATTRS_MESSAGING_URL = exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = exports.SEMATTRS_MESSAGING_PROTOCOL = exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = undefined;
  exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = exports.FaasDocumentOperationValues = exports.FAASDOCUMENTOPERATIONVALUES_DELETE = exports.FAASDOCUMENTOPERATIONVALUES_EDIT = exports.FAASDOCUMENTOPERATIONVALUES_INSERT = exports.FaasTriggerValues = exports.FAASTRIGGERVALUES_OTHER = exports.FAASTRIGGERVALUES_TIMER = exports.FAASTRIGGERVALUES_PUBSUB = exports.FAASTRIGGERVALUES_HTTP = exports.FAASTRIGGERVALUES_DATASOURCE = exports.DbCassandraConsistencyLevelValues = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = exports.DbSystemValues = exports.DBSYSTEMVALUES_COCKROACHDB = exports.DBSYSTEMVALUES_MEMCACHED = exports.DBSYSTEMVALUES_ELASTICSEARCH = exports.DBSYSTEMVALUES_GEODE = exports.DBSYSTEMVALUES_NEO4J = exports.DBSYSTEMVALUES_DYNAMODB = exports.DBSYSTEMVALUES_COSMOSDB = exports.DBSYSTEMVALUES_COUCHDB = exports.DBSYSTEMVALUES_COUCHBASE = exports.DBSYSTEMVALUES_REDIS = exports.DBSYSTEMVALUES_MONGODB = exports.DBSYSTEMVALUES_HBASE = exports.DBSYSTEMVALUES_CASSANDRA = exports.DBSYSTEMVALUES_COLDFUSION = exports.DBSYSTEMVALUES_H2 = exports.DBSYSTEMVALUES_VERTICA = exports.DBSYSTEMVALUES_TERADATA = exports.DBSYSTEMVALUES_SYBASE = exports.DBSYSTEMVALUES_SQLITE = exports.DBSYSTEMVALUES_POINTBASE = exports.DBSYSTEMVALUES_PERVASIVE = exports.DBSYSTEMVALUES_NETEZZA = exports.DBSYSTEMVALUES_MARIADB = exports.DBSYSTEMVALUES_INTERBASE = exports.DBSYSTEMVALUES_INSTANTDB = exports.DBSYSTEMVALUES_INFORMIX = undefined;
  exports.MESSAGINGOPERATIONVALUES_RECEIVE = exports.MessagingDestinationKindValues = exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = exports.HttpFlavorValues = exports.HTTPFLAVORVALUES_QUIC = exports.HTTPFLAVORVALUES_SPDY = exports.HTTPFLAVORVALUES_HTTP_2_0 = exports.HTTPFLAVORVALUES_HTTP_1_1 = exports.HTTPFLAVORVALUES_HTTP_1_0 = exports.NetHostConnectionSubtypeValues = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = exports.NetHostConnectionTypeValues = exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = exports.NETHOSTCONNECTIONTYPEVALUES_CELL = exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = exports.NetTransportValues = exports.NETTRANSPORTVALUES_OTHER = exports.NETTRANSPORTVALUES_INPROC = exports.NETTRANSPORTVALUES_PIPE = exports.NETTRANSPORTVALUES_UNIX = exports.NETTRANSPORTVALUES_IP = exports.NETTRANSPORTVALUES_IP_UDP = exports.NETTRANSPORTVALUES_IP_TCP = exports.FaasInvokedProviderValues = exports.FAASINVOKEDPROVIDERVALUES_GCP = exports.FAASINVOKEDPROVIDERVALUES_AZURE = exports.FAASINVOKEDPROVIDERVALUES_AWS = undefined;
  exports.MessageTypeValues = exports.MESSAGETYPEVALUES_RECEIVED = exports.MESSAGETYPEVALUES_SENT = exports.RpcGrpcStatusCodeValues = exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = exports.RPCGRPCSTATUSCODEVALUES_ABORTED = exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = exports.RPCGRPCSTATUSCODEVALUES_OK = exports.MessagingOperationValues = exports.MESSAGINGOPERATIONVALUES_PROCESS = undefined;
  var utils_1 = require_utils9();
  var TMP_AWS_LAMBDA_INVOKED_ARN = "aws.lambda.invoked_arn";
  var TMP_DB_SYSTEM = "db.system";
  var TMP_DB_CONNECTION_STRING = "db.connection_string";
  var TMP_DB_USER = "db.user";
  var TMP_DB_JDBC_DRIVER_CLASSNAME = "db.jdbc.driver_classname";
  var TMP_DB_NAME = "db.name";
  var TMP_DB_STATEMENT = "db.statement";
  var TMP_DB_OPERATION = "db.operation";
  var TMP_DB_MSSQL_INSTANCE_NAME = "db.mssql.instance_name";
  var TMP_DB_CASSANDRA_KEYSPACE = "db.cassandra.keyspace";
  var TMP_DB_CASSANDRA_PAGE_SIZE = "db.cassandra.page_size";
  var TMP_DB_CASSANDRA_CONSISTENCY_LEVEL = "db.cassandra.consistency_level";
  var TMP_DB_CASSANDRA_TABLE = "db.cassandra.table";
  var TMP_DB_CASSANDRA_IDEMPOTENCE = "db.cassandra.idempotence";
  var TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = "db.cassandra.speculative_execution_count";
  var TMP_DB_CASSANDRA_COORDINATOR_ID = "db.cassandra.coordinator.id";
  var TMP_DB_CASSANDRA_COORDINATOR_DC = "db.cassandra.coordinator.dc";
  var TMP_DB_HBASE_NAMESPACE = "db.hbase.namespace";
  var TMP_DB_REDIS_DATABASE_INDEX = "db.redis.database_index";
  var TMP_DB_MONGODB_COLLECTION = "db.mongodb.collection";
  var TMP_DB_SQL_TABLE = "db.sql.table";
  var TMP_EXCEPTION_TYPE = "exception.type";
  var TMP_EXCEPTION_MESSAGE = "exception.message";
  var TMP_EXCEPTION_STACKTRACE = "exception.stacktrace";
  var TMP_EXCEPTION_ESCAPED = "exception.escaped";
  var TMP_FAAS_TRIGGER = "faas.trigger";
  var TMP_FAAS_EXECUTION = "faas.execution";
  var TMP_FAAS_DOCUMENT_COLLECTION = "faas.document.collection";
  var TMP_FAAS_DOCUMENT_OPERATION = "faas.document.operation";
  var TMP_FAAS_DOCUMENT_TIME = "faas.document.time";
  var TMP_FAAS_DOCUMENT_NAME = "faas.document.name";
  var TMP_FAAS_TIME = "faas.time";
  var TMP_FAAS_CRON = "faas.cron";
  var TMP_FAAS_COLDSTART = "faas.coldstart";
  var TMP_FAAS_INVOKED_NAME = "faas.invoked_name";
  var TMP_FAAS_INVOKED_PROVIDER = "faas.invoked_provider";
  var TMP_FAAS_INVOKED_REGION = "faas.invoked_region";
  var TMP_NET_TRANSPORT = "net.transport";
  var TMP_NET_PEER_IP = "net.peer.ip";
  var TMP_NET_PEER_PORT = "net.peer.port";
  var TMP_NET_PEER_NAME = "net.peer.name";
  var TMP_NET_HOST_IP = "net.host.ip";
  var TMP_NET_HOST_PORT = "net.host.port";
  var TMP_NET_HOST_NAME = "net.host.name";
  var TMP_NET_HOST_CONNECTION_TYPE = "net.host.connection.type";
  var TMP_NET_HOST_CONNECTION_SUBTYPE = "net.host.connection.subtype";
  var TMP_NET_HOST_CARRIER_NAME = "net.host.carrier.name";
  var TMP_NET_HOST_CARRIER_MCC = "net.host.carrier.mcc";
  var TMP_NET_HOST_CARRIER_MNC = "net.host.carrier.mnc";
  var TMP_NET_HOST_CARRIER_ICC = "net.host.carrier.icc";
  var TMP_PEER_SERVICE = "peer.service";
  var TMP_ENDUSER_ID = "enduser.id";
  var TMP_ENDUSER_ROLE = "enduser.role";
  var TMP_ENDUSER_SCOPE = "enduser.scope";
  var TMP_THREAD_ID = "thread.id";
  var TMP_THREAD_NAME = "thread.name";
  var TMP_CODE_FUNCTION = "code.function";
  var TMP_CODE_NAMESPACE = "code.namespace";
  var TMP_CODE_FILEPATH = "code.filepath";
  var TMP_CODE_LINENO = "code.lineno";
  var TMP_HTTP_METHOD = "http.method";
  var TMP_HTTP_URL = "http.url";
  var TMP_HTTP_TARGET = "http.target";
  var TMP_HTTP_HOST = "http.host";
  var TMP_HTTP_SCHEME = "http.scheme";
  var TMP_HTTP_STATUS_CODE = "http.status_code";
  var TMP_HTTP_FLAVOR = "http.flavor";
  var TMP_HTTP_USER_AGENT = "http.user_agent";
  var TMP_HTTP_REQUEST_CONTENT_LENGTH = "http.request_content_length";
  var TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = "http.request_content_length_uncompressed";
  var TMP_HTTP_RESPONSE_CONTENT_LENGTH = "http.response_content_length";
  var TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = "http.response_content_length_uncompressed";
  var TMP_HTTP_SERVER_NAME = "http.server_name";
  var TMP_HTTP_ROUTE = "http.route";
  var TMP_HTTP_CLIENT_IP = "http.client_ip";
  var TMP_AWS_DYNAMODB_TABLE_NAMES = "aws.dynamodb.table_names";
  var TMP_AWS_DYNAMODB_CONSUMED_CAPACITY = "aws.dynamodb.consumed_capacity";
  var TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = "aws.dynamodb.item_collection_metrics";
  var TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = "aws.dynamodb.provisioned_read_capacity";
  var TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = "aws.dynamodb.provisioned_write_capacity";
  var TMP_AWS_DYNAMODB_CONSISTENT_READ = "aws.dynamodb.consistent_read";
  var TMP_AWS_DYNAMODB_PROJECTION = "aws.dynamodb.projection";
  var TMP_AWS_DYNAMODB_LIMIT = "aws.dynamodb.limit";
  var TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET = "aws.dynamodb.attributes_to_get";
  var TMP_AWS_DYNAMODB_INDEX_NAME = "aws.dynamodb.index_name";
  var TMP_AWS_DYNAMODB_SELECT = "aws.dynamodb.select";
  var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = "aws.dynamodb.global_secondary_indexes";
  var TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = "aws.dynamodb.local_secondary_indexes";
  var TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = "aws.dynamodb.exclusive_start_table";
  var TMP_AWS_DYNAMODB_TABLE_COUNT = "aws.dynamodb.table_count";
  var TMP_AWS_DYNAMODB_SCAN_FORWARD = "aws.dynamodb.scan_forward";
  var TMP_AWS_DYNAMODB_SEGMENT = "aws.dynamodb.segment";
  var TMP_AWS_DYNAMODB_TOTAL_SEGMENTS = "aws.dynamodb.total_segments";
  var TMP_AWS_DYNAMODB_COUNT = "aws.dynamodb.count";
  var TMP_AWS_DYNAMODB_SCANNED_COUNT = "aws.dynamodb.scanned_count";
  var TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = "aws.dynamodb.attribute_definitions";
  var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = "aws.dynamodb.global_secondary_index_updates";
  var TMP_MESSAGING_SYSTEM = "messaging.system";
  var TMP_MESSAGING_DESTINATION = "messaging.destination";
  var TMP_MESSAGING_DESTINATION_KIND = "messaging.destination_kind";
  var TMP_MESSAGING_TEMP_DESTINATION = "messaging.temp_destination";
  var TMP_MESSAGING_PROTOCOL = "messaging.protocol";
  var TMP_MESSAGING_PROTOCOL_VERSION = "messaging.protocol_version";
  var TMP_MESSAGING_URL = "messaging.url";
  var TMP_MESSAGING_MESSAGE_ID = "messaging.message_id";
  var TMP_MESSAGING_CONVERSATION_ID = "messaging.conversation_id";
  var TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = "messaging.message_payload_size_bytes";
  var TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = "messaging.message_payload_compressed_size_bytes";
  var TMP_MESSAGING_OPERATION = "messaging.operation";
  var TMP_MESSAGING_CONSUMER_ID = "messaging.consumer_id";
  var TMP_MESSAGING_RABBITMQ_ROUTING_KEY = "messaging.rabbitmq.routing_key";
  var TMP_MESSAGING_KAFKA_MESSAGE_KEY = "messaging.kafka.message_key";
  var TMP_MESSAGING_KAFKA_CONSUMER_GROUP = "messaging.kafka.consumer_group";
  var TMP_MESSAGING_KAFKA_CLIENT_ID = "messaging.kafka.client_id";
  var TMP_MESSAGING_KAFKA_PARTITION = "messaging.kafka.partition";
  var TMP_MESSAGING_KAFKA_TOMBSTONE = "messaging.kafka.tombstone";
  var TMP_RPC_SYSTEM = "rpc.system";
  var TMP_RPC_SERVICE = "rpc.service";
  var TMP_RPC_METHOD = "rpc.method";
  var TMP_RPC_GRPC_STATUS_CODE = "rpc.grpc.status_code";
  var TMP_RPC_JSONRPC_VERSION = "rpc.jsonrpc.version";
  var TMP_RPC_JSONRPC_REQUEST_ID = "rpc.jsonrpc.request_id";
  var TMP_RPC_JSONRPC_ERROR_CODE = "rpc.jsonrpc.error_code";
  var TMP_RPC_JSONRPC_ERROR_MESSAGE = "rpc.jsonrpc.error_message";
  var TMP_MESSAGE_TYPE = "message.type";
  var TMP_MESSAGE_ID = "message.id";
  var TMP_MESSAGE_COMPRESSED_SIZE = "message.compressed_size";
  var TMP_MESSAGE_UNCOMPRESSED_SIZE = "message.uncompressed_size";
  exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN;
  exports.SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM;
  exports.SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING;
  exports.SEMATTRS_DB_USER = TMP_DB_USER;
  exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME;
  exports.SEMATTRS_DB_NAME = TMP_DB_NAME;
  exports.SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT;
  exports.SEMATTRS_DB_OPERATION = TMP_DB_OPERATION;
  exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME;
  exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE;
  exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE;
  exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL;
  exports.SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE;
  exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE;
  exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT;
  exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID;
  exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC;
  exports.SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE;
  exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX;
  exports.SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION;
  exports.SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE;
  exports.SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;
  exports.SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;
  exports.SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;
  exports.SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED;
  exports.SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER;
  exports.SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION;
  exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION;
  exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION;
  exports.SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME;
  exports.SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME;
  exports.SEMATTRS_FAAS_TIME = TMP_FAAS_TIME;
  exports.SEMATTRS_FAAS_CRON = TMP_FAAS_CRON;
  exports.SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART;
  exports.SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME;
  exports.SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER;
  exports.SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION;
  exports.SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT;
  exports.SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP;
  exports.SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT;
  exports.SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME;
  exports.SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP;
  exports.SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT;
  exports.SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME;
  exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE;
  exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE;
  exports.SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME;
  exports.SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC;
  exports.SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC;
  exports.SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC;
  exports.SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE;
  exports.SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID;
  exports.SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE;
  exports.SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE;
  exports.SEMATTRS_THREAD_ID = TMP_THREAD_ID;
  exports.SEMATTRS_THREAD_NAME = TMP_THREAD_NAME;
  exports.SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION;
  exports.SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE;
  exports.SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH;
  exports.SEMATTRS_CODE_LINENO = TMP_CODE_LINENO;
  exports.SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD;
  exports.SEMATTRS_HTTP_URL = TMP_HTTP_URL;
  exports.SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET;
  exports.SEMATTRS_HTTP_HOST = TMP_HTTP_HOST;
  exports.SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME;
  exports.SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE;
  exports.SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR;
  exports.SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT;
  exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH;
  exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED;
  exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH;
  exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED;
  exports.SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME;
  exports.SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE;
  exports.SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP;
  exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES;
  exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS;
  exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ;
  exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION;
  exports.SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT;
  exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET;
  exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME;
  exports.SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT;
  exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES;
  exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES;
  exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE;
  exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD;
  exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT;
  exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS;
  exports.SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS;
  exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES;
  exports.SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM;
  exports.SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION;
  exports.SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND;
  exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION;
  exports.SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL;
  exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION;
  exports.SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL;
  exports.SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID;
  exports.SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID;
  exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES;
  exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES;
  exports.SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION;
  exports.SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID;
  exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY;
  exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY;
  exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP;
  exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID;
  exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION;
  exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE;
  exports.SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM;
  exports.SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE;
  exports.SEMATTRS_RPC_METHOD = TMP_RPC_METHOD;
  exports.SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE;
  exports.SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION;
  exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID;
  exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE;
  exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE;
  exports.SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE;
  exports.SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID;
  exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE;
  exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE;
  exports.SemanticAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_AWS_LAMBDA_INVOKED_ARN,
    TMP_DB_SYSTEM,
    TMP_DB_CONNECTION_STRING,
    TMP_DB_USER,
    TMP_DB_JDBC_DRIVER_CLASSNAME,
    TMP_DB_NAME,
    TMP_DB_STATEMENT,
    TMP_DB_OPERATION,
    TMP_DB_MSSQL_INSTANCE_NAME,
    TMP_DB_CASSANDRA_KEYSPACE,
    TMP_DB_CASSANDRA_PAGE_SIZE,
    TMP_DB_CASSANDRA_CONSISTENCY_LEVEL,
    TMP_DB_CASSANDRA_TABLE,
    TMP_DB_CASSANDRA_IDEMPOTENCE,
    TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
    TMP_DB_CASSANDRA_COORDINATOR_ID,
    TMP_DB_CASSANDRA_COORDINATOR_DC,
    TMP_DB_HBASE_NAMESPACE,
    TMP_DB_REDIS_DATABASE_INDEX,
    TMP_DB_MONGODB_COLLECTION,
    TMP_DB_SQL_TABLE,
    TMP_EXCEPTION_TYPE,
    TMP_EXCEPTION_MESSAGE,
    TMP_EXCEPTION_STACKTRACE,
    TMP_EXCEPTION_ESCAPED,
    TMP_FAAS_TRIGGER,
    TMP_FAAS_EXECUTION,
    TMP_FAAS_DOCUMENT_COLLECTION,
    TMP_FAAS_DOCUMENT_OPERATION,
    TMP_FAAS_DOCUMENT_TIME,
    TMP_FAAS_DOCUMENT_NAME,
    TMP_FAAS_TIME,
    TMP_FAAS_CRON,
    TMP_FAAS_COLDSTART,
    TMP_FAAS_INVOKED_NAME,
    TMP_FAAS_INVOKED_PROVIDER,
    TMP_FAAS_INVOKED_REGION,
    TMP_NET_TRANSPORT,
    TMP_NET_PEER_IP,
    TMP_NET_PEER_PORT,
    TMP_NET_PEER_NAME,
    TMP_NET_HOST_IP,
    TMP_NET_HOST_PORT,
    TMP_NET_HOST_NAME,
    TMP_NET_HOST_CONNECTION_TYPE,
    TMP_NET_HOST_CONNECTION_SUBTYPE,
    TMP_NET_HOST_CARRIER_NAME,
    TMP_NET_HOST_CARRIER_MCC,
    TMP_NET_HOST_CARRIER_MNC,
    TMP_NET_HOST_CARRIER_ICC,
    TMP_PEER_SERVICE,
    TMP_ENDUSER_ID,
    TMP_ENDUSER_ROLE,
    TMP_ENDUSER_SCOPE,
    TMP_THREAD_ID,
    TMP_THREAD_NAME,
    TMP_CODE_FUNCTION,
    TMP_CODE_NAMESPACE,
    TMP_CODE_FILEPATH,
    TMP_CODE_LINENO,
    TMP_HTTP_METHOD,
    TMP_HTTP_URL,
    TMP_HTTP_TARGET,
    TMP_HTTP_HOST,
    TMP_HTTP_SCHEME,
    TMP_HTTP_STATUS_CODE,
    TMP_HTTP_FLAVOR,
    TMP_HTTP_USER_AGENT,
    TMP_HTTP_REQUEST_CONTENT_LENGTH,
    TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
    TMP_HTTP_RESPONSE_CONTENT_LENGTH,
    TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
    TMP_HTTP_SERVER_NAME,
    TMP_HTTP_ROUTE,
    TMP_HTTP_CLIENT_IP,
    TMP_AWS_DYNAMODB_TABLE_NAMES,
    TMP_AWS_DYNAMODB_CONSUMED_CAPACITY,
    TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
    TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
    TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
    TMP_AWS_DYNAMODB_CONSISTENT_READ,
    TMP_AWS_DYNAMODB_PROJECTION,
    TMP_AWS_DYNAMODB_LIMIT,
    TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
    TMP_AWS_DYNAMODB_INDEX_NAME,
    TMP_AWS_DYNAMODB_SELECT,
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
    TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
    TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
    TMP_AWS_DYNAMODB_TABLE_COUNT,
    TMP_AWS_DYNAMODB_SCAN_FORWARD,
    TMP_AWS_DYNAMODB_SEGMENT,
    TMP_AWS_DYNAMODB_TOTAL_SEGMENTS,
    TMP_AWS_DYNAMODB_COUNT,
    TMP_AWS_DYNAMODB_SCANNED_COUNT,
    TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
    TMP_MESSAGING_SYSTEM,
    TMP_MESSAGING_DESTINATION,
    TMP_MESSAGING_DESTINATION_KIND,
    TMP_MESSAGING_TEMP_DESTINATION,
    TMP_MESSAGING_PROTOCOL,
    TMP_MESSAGING_PROTOCOL_VERSION,
    TMP_MESSAGING_URL,
    TMP_MESSAGING_MESSAGE_ID,
    TMP_MESSAGING_CONVERSATION_ID,
    TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
    TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
    TMP_MESSAGING_OPERATION,
    TMP_MESSAGING_CONSUMER_ID,
    TMP_MESSAGING_RABBITMQ_ROUTING_KEY,
    TMP_MESSAGING_KAFKA_MESSAGE_KEY,
    TMP_MESSAGING_KAFKA_CONSUMER_GROUP,
    TMP_MESSAGING_KAFKA_CLIENT_ID,
    TMP_MESSAGING_KAFKA_PARTITION,
    TMP_MESSAGING_KAFKA_TOMBSTONE,
    TMP_RPC_SYSTEM,
    TMP_RPC_SERVICE,
    TMP_RPC_METHOD,
    TMP_RPC_GRPC_STATUS_CODE,
    TMP_RPC_JSONRPC_VERSION,
    TMP_RPC_JSONRPC_REQUEST_ID,
    TMP_RPC_JSONRPC_ERROR_CODE,
    TMP_RPC_JSONRPC_ERROR_MESSAGE,
    TMP_MESSAGE_TYPE,
    TMP_MESSAGE_ID,
    TMP_MESSAGE_COMPRESSED_SIZE,
    TMP_MESSAGE_UNCOMPRESSED_SIZE
  ]);
  var TMP_DBSYSTEMVALUES_OTHER_SQL = "other_sql";
  var TMP_DBSYSTEMVALUES_MSSQL = "mssql";
  var TMP_DBSYSTEMVALUES_MYSQL = "mysql";
  var TMP_DBSYSTEMVALUES_ORACLE = "oracle";
  var TMP_DBSYSTEMVALUES_DB2 = "db2";
  var TMP_DBSYSTEMVALUES_POSTGRESQL = "postgresql";
  var TMP_DBSYSTEMVALUES_REDSHIFT = "redshift";
  var TMP_DBSYSTEMVALUES_HIVE = "hive";
  var TMP_DBSYSTEMVALUES_CLOUDSCAPE = "cloudscape";
  var TMP_DBSYSTEMVALUES_HSQLDB = "hsqldb";
  var TMP_DBSYSTEMVALUES_PROGRESS = "progress";
  var TMP_DBSYSTEMVALUES_MAXDB = "maxdb";
  var TMP_DBSYSTEMVALUES_HANADB = "hanadb";
  var TMP_DBSYSTEMVALUES_INGRES = "ingres";
  var TMP_DBSYSTEMVALUES_FIRSTSQL = "firstsql";
  var TMP_DBSYSTEMVALUES_EDB = "edb";
  var TMP_DBSYSTEMVALUES_CACHE = "cache";
  var TMP_DBSYSTEMVALUES_ADABAS = "adabas";
  var TMP_DBSYSTEMVALUES_FIREBIRD = "firebird";
  var TMP_DBSYSTEMVALUES_DERBY = "derby";
  var TMP_DBSYSTEMVALUES_FILEMAKER = "filemaker";
  var TMP_DBSYSTEMVALUES_INFORMIX = "informix";
  var TMP_DBSYSTEMVALUES_INSTANTDB = "instantdb";
  var TMP_DBSYSTEMVALUES_INTERBASE = "interbase";
  var TMP_DBSYSTEMVALUES_MARIADB = "mariadb";
  var TMP_DBSYSTEMVALUES_NETEZZA = "netezza";
  var TMP_DBSYSTEMVALUES_PERVASIVE = "pervasive";
  var TMP_DBSYSTEMVALUES_POINTBASE = "pointbase";
  var TMP_DBSYSTEMVALUES_SQLITE = "sqlite";
  var TMP_DBSYSTEMVALUES_SYBASE = "sybase";
  var TMP_DBSYSTEMVALUES_TERADATA = "teradata";
  var TMP_DBSYSTEMVALUES_VERTICA = "vertica";
  var TMP_DBSYSTEMVALUES_H2 = "h2";
  var TMP_DBSYSTEMVALUES_COLDFUSION = "coldfusion";
  var TMP_DBSYSTEMVALUES_CASSANDRA = "cassandra";
  var TMP_DBSYSTEMVALUES_HBASE = "hbase";
  var TMP_DBSYSTEMVALUES_MONGODB = "mongodb";
  var TMP_DBSYSTEMVALUES_REDIS = "redis";
  var TMP_DBSYSTEMVALUES_COUCHBASE = "couchbase";
  var TMP_DBSYSTEMVALUES_COUCHDB = "couchdb";
  var TMP_DBSYSTEMVALUES_COSMOSDB = "cosmosdb";
  var TMP_DBSYSTEMVALUES_DYNAMODB = "dynamodb";
  var TMP_DBSYSTEMVALUES_NEO4J = "neo4j";
  var TMP_DBSYSTEMVALUES_GEODE = "geode";
  var TMP_DBSYSTEMVALUES_ELASTICSEARCH = "elasticsearch";
  var TMP_DBSYSTEMVALUES_MEMCACHED = "memcached";
  var TMP_DBSYSTEMVALUES_COCKROACHDB = "cockroachdb";
  exports.DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL;
  exports.DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL;
  exports.DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL;
  exports.DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE;
  exports.DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB2;
  exports.DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL;
  exports.DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT;
  exports.DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE;
  exports.DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE;
  exports.DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB;
  exports.DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS;
  exports.DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB;
  exports.DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB;
  exports.DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES;
  exports.DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL;
  exports.DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB;
  exports.DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE;
  exports.DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS;
  exports.DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD;
  exports.DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY;
  exports.DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER;
  exports.DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX;
  exports.DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB;
  exports.DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE;
  exports.DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB;
  exports.DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA;
  exports.DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE;
  exports.DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE;
  exports.DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE;
  exports.DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE;
  exports.DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA;
  exports.DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA;
  exports.DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H2;
  exports.DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION;
  exports.DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA;
  exports.DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE;
  exports.DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB;
  exports.DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS;
  exports.DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE;
  exports.DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB;
  exports.DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB;
  exports.DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB;
  exports.DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J;
  exports.DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE;
  exports.DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH;
  exports.DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED;
  exports.DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB;
  exports.DbSystemValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_DBSYSTEMVALUES_OTHER_SQL,
    TMP_DBSYSTEMVALUES_MSSQL,
    TMP_DBSYSTEMVALUES_MYSQL,
    TMP_DBSYSTEMVALUES_ORACLE,
    TMP_DBSYSTEMVALUES_DB2,
    TMP_DBSYSTEMVALUES_POSTGRESQL,
    TMP_DBSYSTEMVALUES_REDSHIFT,
    TMP_DBSYSTEMVALUES_HIVE,
    TMP_DBSYSTEMVALUES_CLOUDSCAPE,
    TMP_DBSYSTEMVALUES_HSQLDB,
    TMP_DBSYSTEMVALUES_PROGRESS,
    TMP_DBSYSTEMVALUES_MAXDB,
    TMP_DBSYSTEMVALUES_HANADB,
    TMP_DBSYSTEMVALUES_INGRES,
    TMP_DBSYSTEMVALUES_FIRSTSQL,
    TMP_DBSYSTEMVALUES_EDB,
    TMP_DBSYSTEMVALUES_CACHE,
    TMP_DBSYSTEMVALUES_ADABAS,
    TMP_DBSYSTEMVALUES_FIREBIRD,
    TMP_DBSYSTEMVALUES_DERBY,
    TMP_DBSYSTEMVALUES_FILEMAKER,
    TMP_DBSYSTEMVALUES_INFORMIX,
    TMP_DBSYSTEMVALUES_INSTANTDB,
    TMP_DBSYSTEMVALUES_INTERBASE,
    TMP_DBSYSTEMVALUES_MARIADB,
    TMP_DBSYSTEMVALUES_NETEZZA,
    TMP_DBSYSTEMVALUES_PERVASIVE,
    TMP_DBSYSTEMVALUES_POINTBASE,
    TMP_DBSYSTEMVALUES_SQLITE,
    TMP_DBSYSTEMVALUES_SYBASE,
    TMP_DBSYSTEMVALUES_TERADATA,
    TMP_DBSYSTEMVALUES_VERTICA,
    TMP_DBSYSTEMVALUES_H2,
    TMP_DBSYSTEMVALUES_COLDFUSION,
    TMP_DBSYSTEMVALUES_CASSANDRA,
    TMP_DBSYSTEMVALUES_HBASE,
    TMP_DBSYSTEMVALUES_MONGODB,
    TMP_DBSYSTEMVALUES_REDIS,
    TMP_DBSYSTEMVALUES_COUCHBASE,
    TMP_DBSYSTEMVALUES_COUCHDB,
    TMP_DBSYSTEMVALUES_COSMOSDB,
    TMP_DBSYSTEMVALUES_DYNAMODB,
    TMP_DBSYSTEMVALUES_NEO4J,
    TMP_DBSYSTEMVALUES_GEODE,
    TMP_DBSYSTEMVALUES_ELASTICSEARCH,
    TMP_DBSYSTEMVALUES_MEMCACHED,
    TMP_DBSYSTEMVALUES_COCKROACHDB
  ]);
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL = "all";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = "each_quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = "quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = "local_quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE = "one";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO = "two";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE = "three";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = "local_one";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY = "any";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = "serial";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = "local_serial";
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL;
  exports.DbCassandraConsistencyLevelValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL
  ]);
  var TMP_FAASTRIGGERVALUES_DATASOURCE = "datasource";
  var TMP_FAASTRIGGERVALUES_HTTP = "http";
  var TMP_FAASTRIGGERVALUES_PUBSUB = "pubsub";
  var TMP_FAASTRIGGERVALUES_TIMER = "timer";
  var TMP_FAASTRIGGERVALUES_OTHER = "other";
  exports.FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE;
  exports.FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP;
  exports.FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB;
  exports.FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER;
  exports.FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER;
  exports.FaasTriggerValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASTRIGGERVALUES_DATASOURCE,
    TMP_FAASTRIGGERVALUES_HTTP,
    TMP_FAASTRIGGERVALUES_PUBSUB,
    TMP_FAASTRIGGERVALUES_TIMER,
    TMP_FAASTRIGGERVALUES_OTHER
  ]);
  var TMP_FAASDOCUMENTOPERATIONVALUES_INSERT = "insert";
  var TMP_FAASDOCUMENTOPERATIONVALUES_EDIT = "edit";
  var TMP_FAASDOCUMENTOPERATIONVALUES_DELETE = "delete";
  exports.FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT;
  exports.FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT;
  exports.FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE;
  exports.FaasDocumentOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASDOCUMENTOPERATIONVALUES_INSERT,
    TMP_FAASDOCUMENTOPERATIONVALUES_EDIT,
    TMP_FAASDOCUMENTOPERATIONVALUES_DELETE
  ]);
  var TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
  var TMP_FAASINVOKEDPROVIDERVALUES_AWS = "aws";
  var TMP_FAASINVOKEDPROVIDERVALUES_AZURE = "azure";
  var TMP_FAASINVOKEDPROVIDERVALUES_GCP = "gcp";
  exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD;
  exports.FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS;
  exports.FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE;
  exports.FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP;
  exports.FaasInvokedProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
    TMP_FAASINVOKEDPROVIDERVALUES_AWS,
    TMP_FAASINVOKEDPROVIDERVALUES_AZURE,
    TMP_FAASINVOKEDPROVIDERVALUES_GCP
  ]);
  var TMP_NETTRANSPORTVALUES_IP_TCP = "ip_tcp";
  var TMP_NETTRANSPORTVALUES_IP_UDP = "ip_udp";
  var TMP_NETTRANSPORTVALUES_IP = "ip";
  var TMP_NETTRANSPORTVALUES_UNIX = "unix";
  var TMP_NETTRANSPORTVALUES_PIPE = "pipe";
  var TMP_NETTRANSPORTVALUES_INPROC = "inproc";
  var TMP_NETTRANSPORTVALUES_OTHER = "other";
  exports.NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP;
  exports.NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP;
  exports.NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP;
  exports.NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX;
  exports.NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE;
  exports.NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC;
  exports.NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER;
  exports.NetTransportValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETTRANSPORTVALUES_IP_TCP,
    TMP_NETTRANSPORTVALUES_IP_UDP,
    TMP_NETTRANSPORTVALUES_IP,
    TMP_NETTRANSPORTVALUES_UNIX,
    TMP_NETTRANSPORTVALUES_PIPE,
    TMP_NETTRANSPORTVALUES_INPROC,
    TMP_NETTRANSPORTVALUES_OTHER
  ]);
  var TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI = "wifi";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED = "wired";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_CELL = "cell";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = "unavailable";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = "unknown";
  exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI;
  exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED;
  exports.NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL;
  exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE;
  exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN;
  exports.NetHostConnectionTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI,
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED,
    TMP_NETHOSTCONNECTIONTYPEVALUES_CELL,
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN
  ]);
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = "gprs";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = "edge";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = "umts";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = "cdma";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = "evdo_0";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = "evdo_a";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = "cdma2000_1xrtt";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = "hsdpa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = "hsupa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = "hspa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = "iden";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = "evdo_b";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE = "lte";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = "ehrpd";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = "hspap";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM = "gsm";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = "td_scdma";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = "iwlan";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR = "nr";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = "nrnsa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = "lte_ca";
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA;
  exports.NetHostConnectionSubtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA
  ]);
  var TMP_HTTPFLAVORVALUES_HTTP_1_0 = "1.0";
  var TMP_HTTPFLAVORVALUES_HTTP_1_1 = "1.1";
  var TMP_HTTPFLAVORVALUES_HTTP_2_0 = "2.0";
  var TMP_HTTPFLAVORVALUES_SPDY = "SPDY";
  var TMP_HTTPFLAVORVALUES_QUIC = "QUIC";
  exports.HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_0;
  exports.HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_1;
  exports.HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_0;
  exports.HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY;
  exports.HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC;
  exports.HttpFlavorValues = {
    HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_0,
    HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_1,
    HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_0,
    SPDY: TMP_HTTPFLAVORVALUES_SPDY,
    QUIC: TMP_HTTPFLAVORVALUES_QUIC
  };
  var TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE = "queue";
  var TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC = "topic";
  exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE;
  exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC;
  exports.MessagingDestinationKindValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE,
    TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC
  ]);
  var TMP_MESSAGINGOPERATIONVALUES_RECEIVE = "receive";
  var TMP_MESSAGINGOPERATIONVALUES_PROCESS = "process";
  exports.MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE;
  exports.MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS;
  exports.MessagingOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGINGOPERATIONVALUES_RECEIVE,
    TMP_MESSAGINGOPERATIONVALUES_PROCESS
  ]);
  var TMP_RPCGRPCSTATUSCODEVALUES_OK = 0;
  var TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED = 1;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN = 2;
  var TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = 3;
  var TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = 4;
  var TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND = 5;
  var TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = 6;
  var TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = 7;
  var TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = 8;
  var TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = 9;
  var TMP_RPCGRPCSTATUSCODEVALUES_ABORTED = 10;
  var TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = 11;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = 12;
  var TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL = 13;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = 14;
  var TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS = 15;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = 16;
  exports.RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK;
  exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED;
  exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN;
  exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT;
  exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED;
  exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND;
  exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS;
  exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED;
  exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED;
  exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION;
  exports.RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED;
  exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE;
  exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED;
  exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL;
  exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE;
  exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS;
  exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED;
  exports.RpcGrpcStatusCodeValues = {
    OK: TMP_RPCGRPCSTATUSCODEVALUES_OK,
    CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED,
    UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN,
    INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
    DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
    NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
    ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
    PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
    RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
    FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
    ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED,
    OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
    UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
    INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL,
    UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
    DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
    UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED
  };
  var TMP_MESSAGETYPEVALUES_SENT = "SENT";
  var TMP_MESSAGETYPEVALUES_RECEIVED = "RECEIVED";
  exports.MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT;
  exports.MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED;
  exports.MessageTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGETYPEVALUES_SENT,
    TMP_MESSAGETYPEVALUES_RECEIVED
  ]);
});

// ../../node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js
var require_trace4 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(require_SemanticAttributes3(), exports);
});

// ../../node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js
var require_SemanticResourceAttributes3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SEMRESATTRS_K8S_STATEFULSET_NAME = exports.SEMRESATTRS_K8S_STATEFULSET_UID = exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = exports.SEMRESATTRS_K8S_REPLICASET_NAME = exports.SEMRESATTRS_K8S_REPLICASET_UID = exports.SEMRESATTRS_K8S_CONTAINER_NAME = exports.SEMRESATTRS_K8S_POD_NAME = exports.SEMRESATTRS_K8S_POD_UID = exports.SEMRESATTRS_K8S_NAMESPACE_NAME = exports.SEMRESATTRS_K8S_NODE_UID = exports.SEMRESATTRS_K8S_NODE_NAME = exports.SEMRESATTRS_K8S_CLUSTER_NAME = exports.SEMRESATTRS_HOST_IMAGE_VERSION = exports.SEMRESATTRS_HOST_IMAGE_ID = exports.SEMRESATTRS_HOST_IMAGE_NAME = exports.SEMRESATTRS_HOST_ARCH = exports.SEMRESATTRS_HOST_TYPE = exports.SEMRESATTRS_HOST_NAME = exports.SEMRESATTRS_HOST_ID = exports.SEMRESATTRS_FAAS_MAX_MEMORY = exports.SEMRESATTRS_FAAS_INSTANCE = exports.SEMRESATTRS_FAAS_VERSION = exports.SEMRESATTRS_FAAS_ID = exports.SEMRESATTRS_FAAS_NAME = exports.SEMRESATTRS_DEVICE_MODEL_NAME = exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = exports.SEMRESATTRS_DEVICE_ID = exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = exports.SEMRESATTRS_CONTAINER_RUNTIME = exports.SEMRESATTRS_CONTAINER_ID = exports.SEMRESATTRS_CONTAINER_NAME = exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = exports.SEMRESATTRS_AWS_ECS_TASK_ARN = exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = exports.SEMRESATTRS_CLOUD_PLATFORM = exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = exports.SEMRESATTRS_CLOUD_REGION = exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = exports.SEMRESATTRS_CLOUD_PROVIDER = undefined;
  exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = exports.CLOUDPLATFORMVALUES_AZURE_AKS = exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = exports.CLOUDPLATFORMVALUES_AZURE_VM = exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = exports.CLOUDPLATFORMVALUES_AWS_EKS = exports.CLOUDPLATFORMVALUES_AWS_ECS = exports.CLOUDPLATFORMVALUES_AWS_EC2 = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = exports.CloudProviderValues = exports.CLOUDPROVIDERVALUES_GCP = exports.CLOUDPROVIDERVALUES_AZURE = exports.CLOUDPROVIDERVALUES_AWS = exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = exports.SemanticResourceAttributes = exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = exports.SEMRESATTRS_WEBENGINE_VERSION = exports.SEMRESATTRS_WEBENGINE_NAME = exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = exports.SEMRESATTRS_TELEMETRY_SDK_NAME = exports.SEMRESATTRS_SERVICE_VERSION = exports.SEMRESATTRS_SERVICE_INSTANCE_ID = exports.SEMRESATTRS_SERVICE_NAMESPACE = exports.SEMRESATTRS_SERVICE_NAME = exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = exports.SEMRESATTRS_PROCESS_OWNER = exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = exports.SEMRESATTRS_PROCESS_COMMAND_LINE = exports.SEMRESATTRS_PROCESS_COMMAND = exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = exports.SEMRESATTRS_PROCESS_PID = exports.SEMRESATTRS_OS_VERSION = exports.SEMRESATTRS_OS_NAME = exports.SEMRESATTRS_OS_DESCRIPTION = exports.SEMRESATTRS_OS_TYPE = exports.SEMRESATTRS_K8S_CRONJOB_NAME = exports.SEMRESATTRS_K8S_CRONJOB_UID = exports.SEMRESATTRS_K8S_JOB_NAME = exports.SEMRESATTRS_K8S_JOB_UID = exports.SEMRESATTRS_K8S_DAEMONSET_NAME = exports.SEMRESATTRS_K8S_DAEMONSET_UID = undefined;
  exports.TelemetrySdkLanguageValues = exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = exports.TELEMETRYSDKLANGUAGEVALUES_PHP = exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = exports.TELEMETRYSDKLANGUAGEVALUES_GO = exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = exports.TELEMETRYSDKLANGUAGEVALUES_CPP = exports.OsTypeValues = exports.OSTYPEVALUES_Z_OS = exports.OSTYPEVALUES_SOLARIS = exports.OSTYPEVALUES_AIX = exports.OSTYPEVALUES_HPUX = exports.OSTYPEVALUES_DRAGONFLYBSD = exports.OSTYPEVALUES_OPENBSD = exports.OSTYPEVALUES_NETBSD = exports.OSTYPEVALUES_FREEBSD = exports.OSTYPEVALUES_DARWIN = exports.OSTYPEVALUES_LINUX = exports.OSTYPEVALUES_WINDOWS = exports.HostArchValues = exports.HOSTARCHVALUES_X86 = exports.HOSTARCHVALUES_PPC64 = exports.HOSTARCHVALUES_PPC32 = exports.HOSTARCHVALUES_IA64 = exports.HOSTARCHVALUES_ARM64 = exports.HOSTARCHVALUES_ARM32 = exports.HOSTARCHVALUES_AMD64 = exports.AwsEcsLaunchtypeValues = exports.AWSECSLAUNCHTYPEVALUES_FARGATE = exports.AWSECSLAUNCHTYPEVALUES_EC2 = exports.CloudPlatformValues = exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = undefined;
  var utils_1 = require_utils9();
  var TMP_CLOUD_PROVIDER = "cloud.provider";
  var TMP_CLOUD_ACCOUNT_ID = "cloud.account.id";
  var TMP_CLOUD_REGION = "cloud.region";
  var TMP_CLOUD_AVAILABILITY_ZONE = "cloud.availability_zone";
  var TMP_CLOUD_PLATFORM = "cloud.platform";
  var TMP_AWS_ECS_CONTAINER_ARN = "aws.ecs.container.arn";
  var TMP_AWS_ECS_CLUSTER_ARN = "aws.ecs.cluster.arn";
  var TMP_AWS_ECS_LAUNCHTYPE = "aws.ecs.launchtype";
  var TMP_AWS_ECS_TASK_ARN = "aws.ecs.task.arn";
  var TMP_AWS_ECS_TASK_FAMILY = "aws.ecs.task.family";
  var TMP_AWS_ECS_TASK_REVISION = "aws.ecs.task.revision";
  var TMP_AWS_EKS_CLUSTER_ARN = "aws.eks.cluster.arn";
  var TMP_AWS_LOG_GROUP_NAMES = "aws.log.group.names";
  var TMP_AWS_LOG_GROUP_ARNS = "aws.log.group.arns";
  var TMP_AWS_LOG_STREAM_NAMES = "aws.log.stream.names";
  var TMP_AWS_LOG_STREAM_ARNS = "aws.log.stream.arns";
  var TMP_CONTAINER_NAME = "container.name";
  var TMP_CONTAINER_ID = "container.id";
  var TMP_CONTAINER_RUNTIME = "container.runtime";
  var TMP_CONTAINER_IMAGE_NAME = "container.image.name";
  var TMP_CONTAINER_IMAGE_TAG = "container.image.tag";
  var TMP_DEPLOYMENT_ENVIRONMENT = "deployment.environment";
  var TMP_DEVICE_ID = "device.id";
  var TMP_DEVICE_MODEL_IDENTIFIER = "device.model.identifier";
  var TMP_DEVICE_MODEL_NAME = "device.model.name";
  var TMP_FAAS_NAME = "faas.name";
  var TMP_FAAS_ID = "faas.id";
  var TMP_FAAS_VERSION = "faas.version";
  var TMP_FAAS_INSTANCE = "faas.instance";
  var TMP_FAAS_MAX_MEMORY = "faas.max_memory";
  var TMP_HOST_ID = "host.id";
  var TMP_HOST_NAME = "host.name";
  var TMP_HOST_TYPE = "host.type";
  var TMP_HOST_ARCH = "host.arch";
  var TMP_HOST_IMAGE_NAME = "host.image.name";
  var TMP_HOST_IMAGE_ID = "host.image.id";
  var TMP_HOST_IMAGE_VERSION = "host.image.version";
  var TMP_K8S_CLUSTER_NAME = "k8s.cluster.name";
  var TMP_K8S_NODE_NAME = "k8s.node.name";
  var TMP_K8S_NODE_UID = "k8s.node.uid";
  var TMP_K8S_NAMESPACE_NAME = "k8s.namespace.name";
  var TMP_K8S_POD_UID = "k8s.pod.uid";
  var TMP_K8S_POD_NAME = "k8s.pod.name";
  var TMP_K8S_CONTAINER_NAME = "k8s.container.name";
  var TMP_K8S_REPLICASET_UID = "k8s.replicaset.uid";
  var TMP_K8S_REPLICASET_NAME = "k8s.replicaset.name";
  var TMP_K8S_DEPLOYMENT_UID = "k8s.deployment.uid";
  var TMP_K8S_DEPLOYMENT_NAME = "k8s.deployment.name";
  var TMP_K8S_STATEFULSET_UID = "k8s.statefulset.uid";
  var TMP_K8S_STATEFULSET_NAME = "k8s.statefulset.name";
  var TMP_K8S_DAEMONSET_UID = "k8s.daemonset.uid";
  var TMP_K8S_DAEMONSET_NAME = "k8s.daemonset.name";
  var TMP_K8S_JOB_UID = "k8s.job.uid";
  var TMP_K8S_JOB_NAME = "k8s.job.name";
  var TMP_K8S_CRONJOB_UID = "k8s.cronjob.uid";
  var TMP_K8S_CRONJOB_NAME = "k8s.cronjob.name";
  var TMP_OS_TYPE = "os.type";
  var TMP_OS_DESCRIPTION = "os.description";
  var TMP_OS_NAME = "os.name";
  var TMP_OS_VERSION = "os.version";
  var TMP_PROCESS_PID = "process.pid";
  var TMP_PROCESS_EXECUTABLE_NAME = "process.executable.name";
  var TMP_PROCESS_EXECUTABLE_PATH = "process.executable.path";
  var TMP_PROCESS_COMMAND = "process.command";
  var TMP_PROCESS_COMMAND_LINE = "process.command_line";
  var TMP_PROCESS_COMMAND_ARGS = "process.command_args";
  var TMP_PROCESS_OWNER = "process.owner";
  var TMP_PROCESS_RUNTIME_NAME = "process.runtime.name";
  var TMP_PROCESS_RUNTIME_VERSION = "process.runtime.version";
  var TMP_PROCESS_RUNTIME_DESCRIPTION = "process.runtime.description";
  var TMP_SERVICE_NAME = "service.name";
  var TMP_SERVICE_NAMESPACE = "service.namespace";
  var TMP_SERVICE_INSTANCE_ID = "service.instance.id";
  var TMP_SERVICE_VERSION = "service.version";
  var TMP_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
  var TMP_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
  var TMP_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
  var TMP_TELEMETRY_AUTO_VERSION = "telemetry.auto.version";
  var TMP_WEBENGINE_NAME = "webengine.name";
  var TMP_WEBENGINE_VERSION = "webengine.version";
  var TMP_WEBENGINE_DESCRIPTION = "webengine.description";
  exports.SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER;
  exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID;
  exports.SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION;
  exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE;
  exports.SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM;
  exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN;
  exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN;
  exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE;
  exports.SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN;
  exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY;
  exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION;
  exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN;
  exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES;
  exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS;
  exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES;
  exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS;
  exports.SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME;
  exports.SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID;
  exports.SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME;
  exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME;
  exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG;
  exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT;
  exports.SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID;
  exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER;
  exports.SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME;
  exports.SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME;
  exports.SEMRESATTRS_FAAS_ID = TMP_FAAS_ID;
  exports.SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION;
  exports.SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE;
  exports.SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY;
  exports.SEMRESATTRS_HOST_ID = TMP_HOST_ID;
  exports.SEMRESATTRS_HOST_NAME = TMP_HOST_NAME;
  exports.SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE;
  exports.SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH;
  exports.SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME;
  exports.SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID;
  exports.SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION;
  exports.SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME;
  exports.SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME;
  exports.SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID;
  exports.SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME;
  exports.SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID;
  exports.SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME;
  exports.SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME;
  exports.SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID;
  exports.SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME;
  exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID;
  exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME;
  exports.SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID;
  exports.SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME;
  exports.SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID;
  exports.SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME;
  exports.SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID;
  exports.SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME;
  exports.SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID;
  exports.SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME;
  exports.SEMRESATTRS_OS_TYPE = TMP_OS_TYPE;
  exports.SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION;
  exports.SEMRESATTRS_OS_NAME = TMP_OS_NAME;
  exports.SEMRESATTRS_OS_VERSION = TMP_OS_VERSION;
  exports.SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID;
  exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME;
  exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH;
  exports.SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND;
  exports.SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE;
  exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS;
  exports.SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER;
  exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME;
  exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION;
  exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION;
  exports.SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME;
  exports.SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE;
  exports.SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID;
  exports.SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION;
  exports.SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME;
  exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE;
  exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION;
  exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION;
  exports.SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME;
  exports.SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION;
  exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION;
  exports.SemanticResourceAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUD_PROVIDER,
    TMP_CLOUD_ACCOUNT_ID,
    TMP_CLOUD_REGION,
    TMP_CLOUD_AVAILABILITY_ZONE,
    TMP_CLOUD_PLATFORM,
    TMP_AWS_ECS_CONTAINER_ARN,
    TMP_AWS_ECS_CLUSTER_ARN,
    TMP_AWS_ECS_LAUNCHTYPE,
    TMP_AWS_ECS_TASK_ARN,
    TMP_AWS_ECS_TASK_FAMILY,
    TMP_AWS_ECS_TASK_REVISION,
    TMP_AWS_EKS_CLUSTER_ARN,
    TMP_AWS_LOG_GROUP_NAMES,
    TMP_AWS_LOG_GROUP_ARNS,
    TMP_AWS_LOG_STREAM_NAMES,
    TMP_AWS_LOG_STREAM_ARNS,
    TMP_CONTAINER_NAME,
    TMP_CONTAINER_ID,
    TMP_CONTAINER_RUNTIME,
    TMP_CONTAINER_IMAGE_NAME,
    TMP_CONTAINER_IMAGE_TAG,
    TMP_DEPLOYMENT_ENVIRONMENT,
    TMP_DEVICE_ID,
    TMP_DEVICE_MODEL_IDENTIFIER,
    TMP_DEVICE_MODEL_NAME,
    TMP_FAAS_NAME,
    TMP_FAAS_ID,
    TMP_FAAS_VERSION,
    TMP_FAAS_INSTANCE,
    TMP_FAAS_MAX_MEMORY,
    TMP_HOST_ID,
    TMP_HOST_NAME,
    TMP_HOST_TYPE,
    TMP_HOST_ARCH,
    TMP_HOST_IMAGE_NAME,
    TMP_HOST_IMAGE_ID,
    TMP_HOST_IMAGE_VERSION,
    TMP_K8S_CLUSTER_NAME,
    TMP_K8S_NODE_NAME,
    TMP_K8S_NODE_UID,
    TMP_K8S_NAMESPACE_NAME,
    TMP_K8S_POD_UID,
    TMP_K8S_POD_NAME,
    TMP_K8S_CONTAINER_NAME,
    TMP_K8S_REPLICASET_UID,
    TMP_K8S_REPLICASET_NAME,
    TMP_K8S_DEPLOYMENT_UID,
    TMP_K8S_DEPLOYMENT_NAME,
    TMP_K8S_STATEFULSET_UID,
    TMP_K8S_STATEFULSET_NAME,
    TMP_K8S_DAEMONSET_UID,
    TMP_K8S_DAEMONSET_NAME,
    TMP_K8S_JOB_UID,
    TMP_K8S_JOB_NAME,
    TMP_K8S_CRONJOB_UID,
    TMP_K8S_CRONJOB_NAME,
    TMP_OS_TYPE,
    TMP_OS_DESCRIPTION,
    TMP_OS_NAME,
    TMP_OS_VERSION,
    TMP_PROCESS_PID,
    TMP_PROCESS_EXECUTABLE_NAME,
    TMP_PROCESS_EXECUTABLE_PATH,
    TMP_PROCESS_COMMAND,
    TMP_PROCESS_COMMAND_LINE,
    TMP_PROCESS_COMMAND_ARGS,
    TMP_PROCESS_OWNER,
    TMP_PROCESS_RUNTIME_NAME,
    TMP_PROCESS_RUNTIME_VERSION,
    TMP_PROCESS_RUNTIME_DESCRIPTION,
    TMP_SERVICE_NAME,
    TMP_SERVICE_NAMESPACE,
    TMP_SERVICE_INSTANCE_ID,
    TMP_SERVICE_VERSION,
    TMP_TELEMETRY_SDK_NAME,
    TMP_TELEMETRY_SDK_LANGUAGE,
    TMP_TELEMETRY_SDK_VERSION,
    TMP_TELEMETRY_AUTO_VERSION,
    TMP_WEBENGINE_NAME,
    TMP_WEBENGINE_VERSION,
    TMP_WEBENGINE_DESCRIPTION
  ]);
  var TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
  var TMP_CLOUDPROVIDERVALUES_AWS = "aws";
  var TMP_CLOUDPROVIDERVALUES_AZURE = "azure";
  var TMP_CLOUDPROVIDERVALUES_GCP = "gcp";
  exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD;
  exports.CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS;
  exports.CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE;
  exports.CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP;
  exports.CloudProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
    TMP_CLOUDPROVIDERVALUES_AWS,
    TMP_CLOUDPROVIDERVALUES_AZURE,
    TMP_CLOUDPROVIDERVALUES_GCP
  ]);
  var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = "alibaba_cloud_ecs";
  var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = "alibaba_cloud_fc";
  var TMP_CLOUDPLATFORMVALUES_AWS_EC2 = "aws_ec2";
  var TMP_CLOUDPLATFORMVALUES_AWS_ECS = "aws_ecs";
  var TMP_CLOUDPLATFORMVALUES_AWS_EKS = "aws_eks";
  var TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA = "aws_lambda";
  var TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = "aws_elastic_beanstalk";
  var TMP_CLOUDPLATFORMVALUES_AZURE_VM = "azure_vm";
  var TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = "azure_container_instances";
  var TMP_CLOUDPLATFORMVALUES_AZURE_AKS = "azure_aks";
  var TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = "azure_functions";
  var TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = "azure_app_service";
  var TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = "gcp_compute_engine";
  var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = "gcp_cloud_run";
  var TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = "gcp_kubernetes_engine";
  var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = "gcp_cloud_functions";
  var TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE = "gcp_app_engine";
  exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS;
  exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC;
  exports.CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC2;
  exports.CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS;
  exports.CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS;
  exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA;
  exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK;
  exports.CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM;
  exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES;
  exports.CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS;
  exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS;
  exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE;
  exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE;
  exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN;
  exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE;
  exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS;
  exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE;
  exports.CloudPlatformValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
    TMP_CLOUDPLATFORMVALUES_AWS_EC2,
    TMP_CLOUDPLATFORMVALUES_AWS_ECS,
    TMP_CLOUDPLATFORMVALUES_AWS_EKS,
    TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA,
    TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
    TMP_CLOUDPLATFORMVALUES_AZURE_VM,
    TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
    TMP_CLOUDPLATFORMVALUES_AZURE_AKS,
    TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
    TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
    TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
    TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
    TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE
  ]);
  var TMP_AWSECSLAUNCHTYPEVALUES_EC2 = "ec2";
  var TMP_AWSECSLAUNCHTYPEVALUES_FARGATE = "fargate";
  exports.AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC2;
  exports.AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE;
  exports.AwsEcsLaunchtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_AWSECSLAUNCHTYPEVALUES_EC2,
    TMP_AWSECSLAUNCHTYPEVALUES_FARGATE
  ]);
  var TMP_HOSTARCHVALUES_AMD64 = "amd64";
  var TMP_HOSTARCHVALUES_ARM32 = "arm32";
  var TMP_HOSTARCHVALUES_ARM64 = "arm64";
  var TMP_HOSTARCHVALUES_IA64 = "ia64";
  var TMP_HOSTARCHVALUES_PPC32 = "ppc32";
  var TMP_HOSTARCHVALUES_PPC64 = "ppc64";
  var TMP_HOSTARCHVALUES_X86 = "x86";
  exports.HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD64;
  exports.HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM32;
  exports.HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM64;
  exports.HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA64;
  exports.HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC32;
  exports.HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC64;
  exports.HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X86;
  exports.HostArchValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_HOSTARCHVALUES_AMD64,
    TMP_HOSTARCHVALUES_ARM32,
    TMP_HOSTARCHVALUES_ARM64,
    TMP_HOSTARCHVALUES_IA64,
    TMP_HOSTARCHVALUES_PPC32,
    TMP_HOSTARCHVALUES_PPC64,
    TMP_HOSTARCHVALUES_X86
  ]);
  var TMP_OSTYPEVALUES_WINDOWS = "windows";
  var TMP_OSTYPEVALUES_LINUX = "linux";
  var TMP_OSTYPEVALUES_DARWIN = "darwin";
  var TMP_OSTYPEVALUES_FREEBSD = "freebsd";
  var TMP_OSTYPEVALUES_NETBSD = "netbsd";
  var TMP_OSTYPEVALUES_OPENBSD = "openbsd";
  var TMP_OSTYPEVALUES_DRAGONFLYBSD = "dragonflybsd";
  var TMP_OSTYPEVALUES_HPUX = "hpux";
  var TMP_OSTYPEVALUES_AIX = "aix";
  var TMP_OSTYPEVALUES_SOLARIS = "solaris";
  var TMP_OSTYPEVALUES_Z_OS = "z_os";
  exports.OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS;
  exports.OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX;
  exports.OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN;
  exports.OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD;
  exports.OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD;
  exports.OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD;
  exports.OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD;
  exports.OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX;
  exports.OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX;
  exports.OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS;
  exports.OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS;
  exports.OsTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_OSTYPEVALUES_WINDOWS,
    TMP_OSTYPEVALUES_LINUX,
    TMP_OSTYPEVALUES_DARWIN,
    TMP_OSTYPEVALUES_FREEBSD,
    TMP_OSTYPEVALUES_NETBSD,
    TMP_OSTYPEVALUES_OPENBSD,
    TMP_OSTYPEVALUES_DRAGONFLYBSD,
    TMP_OSTYPEVALUES_HPUX,
    TMP_OSTYPEVALUES_AIX,
    TMP_OSTYPEVALUES_SOLARIS,
    TMP_OSTYPEVALUES_Z_OS
  ]);
  var TMP_TELEMETRYSDKLANGUAGEVALUES_CPP = "cpp";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET = "dotnet";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG = "erlang";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_GO = "go";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA = "java";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS = "nodejs";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_PHP = "php";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON = "python";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY = "ruby";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS = "webjs";
  exports.TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP;
  exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET;
  exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG;
  exports.TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO;
  exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA;
  exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS;
  exports.TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP;
  exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON;
  exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY;
  exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS;
  exports.TelemetrySdkLanguageValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_TELEMETRYSDKLANGUAGEVALUES_CPP,
    TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET,
    TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG,
    TMP_TELEMETRYSDKLANGUAGEVALUES_GO,
    TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA,
    TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS,
    TMP_TELEMETRYSDKLANGUAGEVALUES_PHP,
    TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON,
    TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY,
    TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS
  ]);
});

// ../../node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js
var require_resource3 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(require_SemanticResourceAttributes3(), exports);
});

// ../../node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/src/stable_attributes.js
var require_stable_attributes3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HTTP_REQUEST_METHOD_VALUE_POST = exports.HTTP_REQUEST_METHOD_VALUE_PATCH = exports.HTTP_REQUEST_METHOD_VALUE_OPTIONS = exports.HTTP_REQUEST_METHOD_VALUE_HEAD = exports.HTTP_REQUEST_METHOD_VALUE_GET = exports.HTTP_REQUEST_METHOD_VALUE_DELETE = exports.HTTP_REQUEST_METHOD_VALUE_CONNECT = exports.HTTP_REQUEST_METHOD_VALUE_OTHER = exports.ATTR_HTTP_REQUEST_METHOD = exports.ATTR_HTTP_REQUEST_HEADER = exports.ATTR_EXCEPTION_TYPE = exports.ATTR_EXCEPTION_STACKTRACE = exports.ATTR_EXCEPTION_MESSAGE = exports.ATTR_EXCEPTION_ESCAPED = exports.ERROR_TYPE_VALUE_OTHER = exports.ATTR_ERROR_TYPE = exports.ATTR_CLIENT_PORT = exports.ATTR_CLIENT_ADDRESS = exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = exports.ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = exports.ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = exports.ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = exports.ATTR_ASPNETCORE_RATE_LIMITING_POLICY = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = exports.ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = exports.ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = exports.ATTR_TELEMETRY_SDK_VERSION = exports.ATTR_TELEMETRY_SDK_NAME = exports.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = exports.TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUST = exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = exports.TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = exports.TELEMETRY_SDK_LANGUAGE_VALUE_PHP = exports.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = exports.TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = exports.TELEMETRY_SDK_LANGUAGE_VALUE_GO = exports.TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = exports.TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = exports.TELEMETRY_SDK_LANGUAGE_VALUE_CPP = exports.ATTR_TELEMETRY_SDK_LANGUAGE = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = exports.ATTR_ASPNETCORE_RATE_LIMITING_RESULT = undefined;
  exports.SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = exports.SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = exports.SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = exports.ATTR_SIGNALR_CONNECTION_STATUS = exports.ATTR_SERVICE_VERSION = exports.ATTR_SERVICE_NAME = exports.ATTR_SERVER_PORT = exports.ATTR_SERVER_ADDRESS = exports.ATTR_OTEL_STATUS_DESCRIPTION = exports.OTEL_STATUS_CODE_VALUE_OK = exports.OTEL_STATUS_CODE_VALUE_ERROR = exports.ATTR_OTEL_STATUS_CODE = exports.ATTR_OTEL_SCOPE_VERSION = exports.ATTR_OTEL_SCOPE_NAME = exports.NETWORK_TYPE_VALUE_IPV6 = exports.NETWORK_TYPE_VALUE_IPV4 = exports.ATTR_NETWORK_TYPE = exports.NETWORK_TRANSPORT_VALUE_UNIX = exports.NETWORK_TRANSPORT_VALUE_UDP = exports.NETWORK_TRANSPORT_VALUE_TCP = exports.NETWORK_TRANSPORT_VALUE_QUIC = exports.NETWORK_TRANSPORT_VALUE_PIPE = exports.ATTR_NETWORK_TRANSPORT = exports.ATTR_NETWORK_PROTOCOL_VERSION = exports.ATTR_NETWORK_PROTOCOL_NAME = exports.ATTR_NETWORK_PEER_PORT = exports.ATTR_NETWORK_PEER_ADDRESS = exports.ATTR_NETWORK_LOCAL_PORT = exports.ATTR_NETWORK_LOCAL_ADDRESS = exports.JVM_THREAD_STATE_VALUE_WAITING = exports.JVM_THREAD_STATE_VALUE_TIMED_WAITING = exports.JVM_THREAD_STATE_VALUE_TERMINATED = exports.JVM_THREAD_STATE_VALUE_RUNNABLE = exports.JVM_THREAD_STATE_VALUE_NEW = exports.JVM_THREAD_STATE_VALUE_BLOCKED = exports.ATTR_JVM_THREAD_STATE = exports.ATTR_JVM_THREAD_DAEMON = exports.JVM_MEMORY_TYPE_VALUE_NON_HEAP = exports.JVM_MEMORY_TYPE_VALUE_HEAP = exports.ATTR_JVM_MEMORY_TYPE = exports.ATTR_JVM_MEMORY_POOL_NAME = exports.ATTR_JVM_GC_NAME = exports.ATTR_JVM_GC_ACTION = exports.ATTR_HTTP_ROUTE = exports.ATTR_HTTP_RESPONSE_STATUS_CODE = exports.ATTR_HTTP_RESPONSE_HEADER = exports.ATTR_HTTP_REQUEST_RESEND_COUNT = exports.ATTR_HTTP_REQUEST_METHOD_ORIGINAL = exports.HTTP_REQUEST_METHOD_VALUE_TRACE = exports.HTTP_REQUEST_METHOD_VALUE_PUT = undefined;
  exports.ATTR_USER_AGENT_ORIGINAL = exports.ATTR_URL_SCHEME = exports.ATTR_URL_QUERY = exports.ATTR_URL_PATH = exports.ATTR_URL_FULL = exports.ATTR_URL_FRAGMENT = exports.SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = exports.SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = exports.SIGNALR_TRANSPORT_VALUE_LONG_POLLING = exports.ATTR_SIGNALR_TRANSPORT = undefined;
  exports.ATTR_ASPNETCORE_RATE_LIMITING_RESULT = "aspnetcore.rate_limiting.result";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = "acquired";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = "endpoint_limiter";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = "global_limiter";
  exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = "request_canceled";
  exports.ATTR_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_CPP = "cpp";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = "dotnet";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = "erlang";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_GO = "go";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = "java";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = "nodejs";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_PHP = "php";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = "python";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = "ruby";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUST = "rust";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = "swift";
  exports.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = "webjs";
  exports.ATTR_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
  exports.ATTR_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
  exports.ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = "aspnetcore.diagnostics.handler.type";
  exports.ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = "aspnetcore.diagnostics.exception.result";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = "aborted";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = "handled";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = "skipped";
  exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = "unhandled";
  exports.ATTR_ASPNETCORE_RATE_LIMITING_POLICY = "aspnetcore.rate_limiting.policy";
  exports.ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = "aspnetcore.request.is_unhandled";
  exports.ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = "aspnetcore.routing.is_fallback";
  exports.ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = "aspnetcore.routing.match_status";
  exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = "failure";
  exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = "success";
  exports.ATTR_CLIENT_ADDRESS = "client.address";
  exports.ATTR_CLIENT_PORT = "client.port";
  exports.ATTR_ERROR_TYPE = "error.type";
  exports.ERROR_TYPE_VALUE_OTHER = "_OTHER";
  exports.ATTR_EXCEPTION_ESCAPED = "exception.escaped";
  exports.ATTR_EXCEPTION_MESSAGE = "exception.message";
  exports.ATTR_EXCEPTION_STACKTRACE = "exception.stacktrace";
  exports.ATTR_EXCEPTION_TYPE = "exception.type";
  var ATTR_HTTP_REQUEST_HEADER = (key) => `http.request.header.${key}`;
  exports.ATTR_HTTP_REQUEST_HEADER = ATTR_HTTP_REQUEST_HEADER;
  exports.ATTR_HTTP_REQUEST_METHOD = "http.request.method";
  exports.HTTP_REQUEST_METHOD_VALUE_OTHER = "_OTHER";
  exports.HTTP_REQUEST_METHOD_VALUE_CONNECT = "CONNECT";
  exports.HTTP_REQUEST_METHOD_VALUE_DELETE = "DELETE";
  exports.HTTP_REQUEST_METHOD_VALUE_GET = "GET";
  exports.HTTP_REQUEST_METHOD_VALUE_HEAD = "HEAD";
  exports.HTTP_REQUEST_METHOD_VALUE_OPTIONS = "OPTIONS";
  exports.HTTP_REQUEST_METHOD_VALUE_PATCH = "PATCH";
  exports.HTTP_REQUEST_METHOD_VALUE_POST = "POST";
  exports.HTTP_REQUEST_METHOD_VALUE_PUT = "PUT";
  exports.HTTP_REQUEST_METHOD_VALUE_TRACE = "TRACE";
  exports.ATTR_HTTP_REQUEST_METHOD_ORIGINAL = "http.request.method_original";
  exports.ATTR_HTTP_REQUEST_RESEND_COUNT = "http.request.resend_count";
  var ATTR_HTTP_RESPONSE_HEADER = (key) => `http.response.header.${key}`;
  exports.ATTR_HTTP_RESPONSE_HEADER = ATTR_HTTP_RESPONSE_HEADER;
  exports.ATTR_HTTP_RESPONSE_STATUS_CODE = "http.response.status_code";
  exports.ATTR_HTTP_ROUTE = "http.route";
  exports.ATTR_JVM_GC_ACTION = "jvm.gc.action";
  exports.ATTR_JVM_GC_NAME = "jvm.gc.name";
  exports.ATTR_JVM_MEMORY_POOL_NAME = "jvm.memory.pool.name";
  exports.ATTR_JVM_MEMORY_TYPE = "jvm.memory.type";
  exports.JVM_MEMORY_TYPE_VALUE_HEAP = "heap";
  exports.JVM_MEMORY_TYPE_VALUE_NON_HEAP = "non_heap";
  exports.ATTR_JVM_THREAD_DAEMON = "jvm.thread.daemon";
  exports.ATTR_JVM_THREAD_STATE = "jvm.thread.state";
  exports.JVM_THREAD_STATE_VALUE_BLOCKED = "blocked";
  exports.JVM_THREAD_STATE_VALUE_NEW = "new";
  exports.JVM_THREAD_STATE_VALUE_RUNNABLE = "runnable";
  exports.JVM_THREAD_STATE_VALUE_TERMINATED = "terminated";
  exports.JVM_THREAD_STATE_VALUE_TIMED_WAITING = "timed_waiting";
  exports.JVM_THREAD_STATE_VALUE_WAITING = "waiting";
  exports.ATTR_NETWORK_LOCAL_ADDRESS = "network.local.address";
  exports.ATTR_NETWORK_LOCAL_PORT = "network.local.port";
  exports.ATTR_NETWORK_PEER_ADDRESS = "network.peer.address";
  exports.ATTR_NETWORK_PEER_PORT = "network.peer.port";
  exports.ATTR_NETWORK_PROTOCOL_NAME = "network.protocol.name";
  exports.ATTR_NETWORK_PROTOCOL_VERSION = "network.protocol.version";
  exports.ATTR_NETWORK_TRANSPORT = "network.transport";
  exports.NETWORK_TRANSPORT_VALUE_PIPE = "pipe";
  exports.NETWORK_TRANSPORT_VALUE_QUIC = "quic";
  exports.NETWORK_TRANSPORT_VALUE_TCP = "tcp";
  exports.NETWORK_TRANSPORT_VALUE_UDP = "udp";
  exports.NETWORK_TRANSPORT_VALUE_UNIX = "unix";
  exports.ATTR_NETWORK_TYPE = "network.type";
  exports.NETWORK_TYPE_VALUE_IPV4 = "ipv4";
  exports.NETWORK_TYPE_VALUE_IPV6 = "ipv6";
  exports.ATTR_OTEL_SCOPE_NAME = "otel.scope.name";
  exports.ATTR_OTEL_SCOPE_VERSION = "otel.scope.version";
  exports.ATTR_OTEL_STATUS_CODE = "otel.status_code";
  exports.OTEL_STATUS_CODE_VALUE_ERROR = "ERROR";
  exports.OTEL_STATUS_CODE_VALUE_OK = "OK";
  exports.ATTR_OTEL_STATUS_DESCRIPTION = "otel.status_description";
  exports.ATTR_SERVER_ADDRESS = "server.address";
  exports.ATTR_SERVER_PORT = "server.port";
  exports.ATTR_SERVICE_NAME = "service.name";
  exports.ATTR_SERVICE_VERSION = "service.version";
  exports.ATTR_SIGNALR_CONNECTION_STATUS = "signalr.connection.status";
  exports.SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = "app_shutdown";
  exports.SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = "normal_closure";
  exports.SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = "timeout";
  exports.ATTR_SIGNALR_TRANSPORT = "signalr.transport";
  exports.SIGNALR_TRANSPORT_VALUE_LONG_POLLING = "long_polling";
  exports.SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = "server_sent_events";
  exports.SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = "web_sockets";
  exports.ATTR_URL_FRAGMENT = "url.fragment";
  exports.ATTR_URL_FULL = "url.full";
  exports.ATTR_URL_PATH = "url.path";
  exports.ATTR_URL_QUERY = "url.query";
  exports.ATTR_URL_SCHEME = "url.scheme";
  exports.ATTR_USER_AGENT_ORIGINAL = "user_agent.original";
});

// ../../node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/src/stable_metrics.js
var require_stable_metrics3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.METRIC_SIGNALR_SERVER_CONNECTION_DURATION = exports.METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = exports.METRIC_KESTREL_UPGRADED_CONNECTIONS = exports.METRIC_KESTREL_TLS_HANDSHAKE_DURATION = exports.METRIC_KESTREL_REJECTED_CONNECTIONS = exports.METRIC_KESTREL_QUEUED_REQUESTS = exports.METRIC_KESTREL_QUEUED_CONNECTIONS = exports.METRIC_KESTREL_CONNECTION_DURATION = exports.METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = exports.METRIC_KESTREL_ACTIVE_CONNECTIONS = exports.METRIC_JVM_THREAD_COUNT = exports.METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = exports.METRIC_JVM_MEMORY_USED = exports.METRIC_JVM_MEMORY_LIMIT = exports.METRIC_JVM_MEMORY_COMMITTED = exports.METRIC_JVM_GC_DURATION = exports.METRIC_JVM_CPU_TIME = exports.METRIC_JVM_CPU_RECENT_UTILIZATION = exports.METRIC_JVM_CPU_COUNT = exports.METRIC_JVM_CLASS_UNLOADED = exports.METRIC_JVM_CLASS_LOADED = exports.METRIC_JVM_CLASS_COUNT = exports.METRIC_HTTP_SERVER_REQUEST_DURATION = exports.METRIC_HTTP_CLIENT_REQUEST_DURATION = exports.METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = exports.METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = exports.METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = undefined;
  exports.METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = "aspnetcore.diagnostics.exceptions";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = "aspnetcore.rate_limiting.active_request_leases";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = "aspnetcore.rate_limiting.queued_requests";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = "aspnetcore.rate_limiting.request.time_in_queue";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = "aspnetcore.rate_limiting.request_lease.duration";
  exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = "aspnetcore.rate_limiting.requests";
  exports.METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = "aspnetcore.routing.match_attempts";
  exports.METRIC_HTTP_CLIENT_REQUEST_DURATION = "http.client.request.duration";
  exports.METRIC_HTTP_SERVER_REQUEST_DURATION = "http.server.request.duration";
  exports.METRIC_JVM_CLASS_COUNT = "jvm.class.count";
  exports.METRIC_JVM_CLASS_LOADED = "jvm.class.loaded";
  exports.METRIC_JVM_CLASS_UNLOADED = "jvm.class.unloaded";
  exports.METRIC_JVM_CPU_COUNT = "jvm.cpu.count";
  exports.METRIC_JVM_CPU_RECENT_UTILIZATION = "jvm.cpu.recent_utilization";
  exports.METRIC_JVM_CPU_TIME = "jvm.cpu.time";
  exports.METRIC_JVM_GC_DURATION = "jvm.gc.duration";
  exports.METRIC_JVM_MEMORY_COMMITTED = "jvm.memory.committed";
  exports.METRIC_JVM_MEMORY_LIMIT = "jvm.memory.limit";
  exports.METRIC_JVM_MEMORY_USED = "jvm.memory.used";
  exports.METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = "jvm.memory.used_after_last_gc";
  exports.METRIC_JVM_THREAD_COUNT = "jvm.thread.count";
  exports.METRIC_KESTREL_ACTIVE_CONNECTIONS = "kestrel.active_connections";
  exports.METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = "kestrel.active_tls_handshakes";
  exports.METRIC_KESTREL_CONNECTION_DURATION = "kestrel.connection.duration";
  exports.METRIC_KESTREL_QUEUED_CONNECTIONS = "kestrel.queued_connections";
  exports.METRIC_KESTREL_QUEUED_REQUESTS = "kestrel.queued_requests";
  exports.METRIC_KESTREL_REJECTED_CONNECTIONS = "kestrel.rejected_connections";
  exports.METRIC_KESTREL_TLS_HANDSHAKE_DURATION = "kestrel.tls_handshake.duration";
  exports.METRIC_KESTREL_UPGRADED_CONNECTIONS = "kestrel.upgraded_connections";
  exports.METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = "signalr.server.active_connections";
  exports.METRIC_SIGNALR_SERVER_CONNECTION_DURATION = "signalr.server.connection.duration";
});

// ../../node_modules/@opentelemetry/sdk-trace-base/node_modules/@opentelemetry/semantic-conventions/build/src/index.js
var require_src10 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(require_trace4(), exports);
  __exportStar2(require_resource3(), exports);
  __exportStar2(require_stable_attributes3(), exports);
  __exportStar2(require_stable_metrics3(), exports);
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/enums.js
var require_enums = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExceptionEventName = undefined;
  exports.ExceptionEventName = "exception";
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/Span.js
var require_Span = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Span = undefined;
  var api_1 = require_src();
  var core_1 = require_src8();
  var semantic_conventions_1 = require_src10();
  var enums_1 = require_enums();

  class Span {
    constructor(parentTracer, context, spanName, spanContext, kind, parentSpanId, links = [], startTime, _deprecatedClock, attributes) {
      this.attributes = {};
      this.links = [];
      this.events = [];
      this._droppedAttributesCount = 0;
      this._droppedEventsCount = 0;
      this._droppedLinksCount = 0;
      this.status = {
        code: api_1.SpanStatusCode.UNSET
      };
      this.endTime = [0, 0];
      this._ended = false;
      this._duration = [-1, -1];
      this.name = spanName;
      this._spanContext = spanContext;
      this.parentSpanId = parentSpanId;
      this.kind = kind;
      this.links = links;
      const now = Date.now();
      this._performanceStartTime = core_1.otperformance.now();
      this._performanceOffset = now - (this._performanceStartTime + (0, core_1.getTimeOrigin)());
      this._startTimeProvided = startTime != null;
      this.startTime = this._getTime(startTime !== null && startTime !== undefined ? startTime : now);
      this.resource = parentTracer.resource;
      this.instrumentationLibrary = parentTracer.instrumentationLibrary;
      this._spanLimits = parentTracer.getSpanLimits();
      this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;
      if (attributes != null) {
        this.setAttributes(attributes);
      }
      this._spanProcessor = parentTracer.getActiveSpanProcessor();
      this._spanProcessor.onStart(this, context);
    }
    spanContext() {
      return this._spanContext;
    }
    setAttribute(key, value) {
      if (value == null || this._isSpanEnded())
        return this;
      if (key.length === 0) {
        api_1.diag.warn(`Invalid attribute key: ${key}`);
        return this;
      }
      if (!(0, core_1.isAttributeValue)(value)) {
        api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
        return this;
      }
      if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
        this._droppedAttributesCount++;
        return this;
      }
      this.attributes[key] = this._truncateToSize(value);
      return this;
    }
    setAttributes(attributes) {
      for (const [k4, v7] of Object.entries(attributes)) {
        this.setAttribute(k4, v7);
      }
      return this;
    }
    addEvent(name, attributesOrStartTime, timeStamp) {
      if (this._isSpanEnded())
        return this;
      if (this._spanLimits.eventCountLimit === 0) {
        api_1.diag.warn("No events allowed.");
        this._droppedEventsCount++;
        return this;
      }
      if (this.events.length >= this._spanLimits.eventCountLimit) {
        if (this._droppedEventsCount === 0) {
          api_1.diag.debug("Dropping extra events.");
        }
        this.events.shift();
        this._droppedEventsCount++;
      }
      if ((0, core_1.isTimeInput)(attributesOrStartTime)) {
        if (!(0, core_1.isTimeInput)(timeStamp)) {
          timeStamp = attributesOrStartTime;
        }
        attributesOrStartTime = undefined;
      }
      const attributes = (0, core_1.sanitizeAttributes)(attributesOrStartTime);
      this.events.push({
        name,
        attributes,
        time: this._getTime(timeStamp),
        droppedAttributesCount: 0
      });
      return this;
    }
    addLink(link) {
      this.links.push(link);
      return this;
    }
    addLinks(links) {
      this.links.push(...links);
      return this;
    }
    setStatus(status) {
      if (this._isSpanEnded())
        return this;
      this.status = Object.assign({}, status);
      if (this.status.message != null && typeof status.message !== "string") {
        api_1.diag.warn(`Dropping invalid status.message of type '${typeof status.message}', expected 'string'`);
        delete this.status.message;
      }
      return this;
    }
    updateName(name) {
      if (this._isSpanEnded())
        return this;
      this.name = name;
      return this;
    }
    end(endTime) {
      if (this._isSpanEnded()) {
        api_1.diag.error(`${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`);
        return;
      }
      this._ended = true;
      this.endTime = this._getTime(endTime);
      this._duration = (0, core_1.hrTimeDuration)(this.startTime, this.endTime);
      if (this._duration[0] < 0) {
        api_1.diag.warn("Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.", this.startTime, this.endTime);
        this.endTime = this.startTime.slice();
        this._duration = [0, 0];
      }
      if (this._droppedEventsCount > 0) {
        api_1.diag.warn(`Dropped ${this._droppedEventsCount} events because eventCountLimit reached`);
      }
      this._spanProcessor.onEnd(this);
    }
    _getTime(inp) {
      if (typeof inp === "number" && inp <= core_1.otperformance.now()) {
        return (0, core_1.hrTime)(inp + this._performanceOffset);
      }
      if (typeof inp === "number") {
        return (0, core_1.millisToHrTime)(inp);
      }
      if (inp instanceof Date) {
        return (0, core_1.millisToHrTime)(inp.getTime());
      }
      if ((0, core_1.isTimeInputHrTime)(inp)) {
        return inp;
      }
      if (this._startTimeProvided) {
        return (0, core_1.millisToHrTime)(Date.now());
      }
      const msDuration = core_1.otperformance.now() - this._performanceStartTime;
      return (0, core_1.addHrTimes)(this.startTime, (0, core_1.millisToHrTime)(msDuration));
    }
    isRecording() {
      return this._ended === false;
    }
    recordException(exception, time) {
      const attributes = {};
      if (typeof exception === "string") {
        attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_MESSAGE] = exception;
      } else if (exception) {
        if (exception.code) {
          attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_TYPE] = exception.code.toString();
        } else if (exception.name) {
          attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_TYPE] = exception.name;
        }
        if (exception.message) {
          attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_MESSAGE] = exception.message;
        }
        if (exception.stack) {
          attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_STACKTRACE] = exception.stack;
        }
      }
      if (attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_TYPE] || attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_MESSAGE]) {
        this.addEvent(enums_1.ExceptionEventName, attributes, time);
      } else {
        api_1.diag.warn(`Failed to record an exception ${exception}`);
      }
    }
    get duration() {
      return this._duration;
    }
    get ended() {
      return this._ended;
    }
    get droppedAttributesCount() {
      return this._droppedAttributesCount;
    }
    get droppedEventsCount() {
      return this._droppedEventsCount;
    }
    get droppedLinksCount() {
      return this._droppedLinksCount;
    }
    _isSpanEnded() {
      if (this._ended) {
        api_1.diag.warn(`Can not execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`);
      }
      return this._ended;
    }
    _truncateToLimitUtil(value, limit) {
      if (value.length <= limit) {
        return value;
      }
      return value.substring(0, limit);
    }
    _truncateToSize(value) {
      const limit = this._attributeValueLengthLimit;
      if (limit <= 0) {
        api_1.diag.warn(`Attribute value limit must be positive, got ${limit}`);
        return value;
      }
      if (typeof value === "string") {
        return this._truncateToLimitUtil(value, limit);
      }
      if (Array.isArray(value)) {
        return value.map((val2) => typeof val2 === "string" ? this._truncateToLimitUtil(val2, limit) : val2);
      }
      return value;
    }
  }
  exports.Span = Span;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/Sampler.js
var require_Sampler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SamplingDecision = undefined;
  var SamplingDecision;
  (function(SamplingDecision2) {
    SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
    SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
    SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
  })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AlwaysOffSampler = undefined;
  var Sampler_1 = require_Sampler();

  class AlwaysOffSampler {
    shouldSample() {
      return {
        decision: Sampler_1.SamplingDecision.NOT_RECORD
      };
    }
    toString() {
      return "AlwaysOffSampler";
    }
  }
  exports.AlwaysOffSampler = AlwaysOffSampler;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AlwaysOnSampler = undefined;
  var Sampler_1 = require_Sampler();

  class AlwaysOnSampler {
    shouldSample() {
      return {
        decision: Sampler_1.SamplingDecision.RECORD_AND_SAMPLED
      };
    }
    toString() {
      return "AlwaysOnSampler";
    }
  }
  exports.AlwaysOnSampler = AlwaysOnSampler;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/ParentBasedSampler.js
var require_ParentBasedSampler2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ParentBasedSampler = undefined;
  var api_1 = require_src();
  var core_1 = require_src8();
  var AlwaysOffSampler_1 = require_AlwaysOffSampler2();
  var AlwaysOnSampler_1 = require_AlwaysOnSampler2();

  class ParentBasedSampler {
    constructor(config5) {
      var _a2, _b2, _c2, _d2;
      this._root = config5.root;
      if (!this._root) {
        (0, core_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured"));
        this._root = new AlwaysOnSampler_1.AlwaysOnSampler;
      }
      this._remoteParentSampled = (_a2 = config5.remoteParentSampled) !== null && _a2 !== undefined ? _a2 : new AlwaysOnSampler_1.AlwaysOnSampler;
      this._remoteParentNotSampled = (_b2 = config5.remoteParentNotSampled) !== null && _b2 !== undefined ? _b2 : new AlwaysOffSampler_1.AlwaysOffSampler;
      this._localParentSampled = (_c2 = config5.localParentSampled) !== null && _c2 !== undefined ? _c2 : new AlwaysOnSampler_1.AlwaysOnSampler;
      this._localParentNotSampled = (_d2 = config5.localParentNotSampled) !== null && _d2 !== undefined ? _d2 : new AlwaysOffSampler_1.AlwaysOffSampler;
    }
    shouldSample(context, traceId, spanName, spanKind, attributes, links) {
      const parentContext = api_1.trace.getSpanContext(context);
      if (!parentContext || !(0, api_1.isSpanContextValid)(parentContext)) {
        return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      }
      if (parentContext.isRemote) {
        if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
          return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      }
      if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
        return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      }
      return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    }
    toString() {
      return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
    }
  }
  exports.ParentBasedSampler = ParentBasedSampler;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceIdRatioBasedSampler = undefined;
  var api_1 = require_src();
  var Sampler_1 = require_Sampler();

  class TraceIdRatioBasedSampler {
    constructor(_ratio = 0) {
      this._ratio = _ratio;
      this._ratio = this._normalize(_ratio);
      this._upperBound = Math.floor(this._ratio * 4294967295);
    }
    shouldSample(context, traceId) {
      return {
        decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? Sampler_1.SamplingDecision.RECORD_AND_SAMPLED : Sampler_1.SamplingDecision.NOT_RECORD
      };
    }
    toString() {
      return `TraceIdRatioBased{${this._ratio}}`;
    }
    _normalize(ratio) {
      if (typeof ratio !== "number" || isNaN(ratio))
        return 0;
      return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    }
    _accumulate(traceId) {
      let accumulation = 0;
      for (let i4 = 0;i4 < traceId.length / 8; i4++) {
        const pos = i4 * 8;
        const part = parseInt(traceId.slice(pos, pos + 8), 16);
        accumulation = (accumulation ^ part) >>> 0;
      }
      return accumulation;
    }
  }
  exports.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/config.js
var require_config = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildSamplerFromEnv = exports.loadDefaultConfig = undefined;
  var api_1 = require_src();
  var core_1 = require_src8();
  var AlwaysOffSampler_1 = require_AlwaysOffSampler2();
  var AlwaysOnSampler_1 = require_AlwaysOnSampler2();
  var ParentBasedSampler_1 = require_ParentBasedSampler2();
  var TraceIdRatioBasedSampler_1 = require_TraceIdRatioBasedSampler2();
  var FALLBACK_OTEL_TRACES_SAMPLER = core_1.TracesSamplerValues.AlwaysOn;
  var DEFAULT_RATIO = 1;
  function loadDefaultConfig() {
    const env3 = (0, core_1.getEnv)();
    return {
      sampler: buildSamplerFromEnv(env3),
      forceFlushTimeoutMillis: 30000,
      generalLimits: {
        attributeValueLengthLimit: env3.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,
        attributeCountLimit: env3.OTEL_ATTRIBUTE_COUNT_LIMIT
      },
      spanLimits: {
        attributeValueLengthLimit: env3.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
        attributeCountLimit: env3.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
        linkCountLimit: env3.OTEL_SPAN_LINK_COUNT_LIMIT,
        eventCountLimit: env3.OTEL_SPAN_EVENT_COUNT_LIMIT,
        attributePerEventCountLimit: env3.OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
        attributePerLinkCountLimit: env3.OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT
      },
      mergeResourceWithDefaults: true
    };
  }
  exports.loadDefaultConfig = loadDefaultConfig;
  function buildSamplerFromEnv(environment = (0, core_1.getEnv)()) {
    switch (environment.OTEL_TRACES_SAMPLER) {
      case core_1.TracesSamplerValues.AlwaysOn:
        return new AlwaysOnSampler_1.AlwaysOnSampler;
      case core_1.TracesSamplerValues.AlwaysOff:
        return new AlwaysOffSampler_1.AlwaysOffSampler;
      case core_1.TracesSamplerValues.ParentBasedAlwaysOn:
        return new ParentBasedSampler_1.ParentBasedSampler({
          root: new AlwaysOnSampler_1.AlwaysOnSampler
        });
      case core_1.TracesSamplerValues.ParentBasedAlwaysOff:
        return new ParentBasedSampler_1.ParentBasedSampler({
          root: new AlwaysOffSampler_1.AlwaysOffSampler
        });
      case core_1.TracesSamplerValues.TraceIdRatio:
        return new TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment));
      case core_1.TracesSamplerValues.ParentBasedTraceIdRatio:
        return new ParentBasedSampler_1.ParentBasedSampler({
          root: new TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment))
        });
      default:
        api_1.diag.error(`OTEL_TRACES_SAMPLER value "${environment.OTEL_TRACES_SAMPLER} invalid, defaulting to ${FALLBACK_OTEL_TRACES_SAMPLER}".`);
        return new AlwaysOnSampler_1.AlwaysOnSampler;
    }
  }
  exports.buildSamplerFromEnv = buildSamplerFromEnv;
  function getSamplerProbabilityFromEnv(environment) {
    if (environment.OTEL_TRACES_SAMPLER_ARG === undefined || environment.OTEL_TRACES_SAMPLER_ARG === "") {
      api_1.diag.error(`OTEL_TRACES_SAMPLER_ARG is blank, defaulting to ${DEFAULT_RATIO}.`);
      return DEFAULT_RATIO;
    }
    const probability = Number(environment.OTEL_TRACES_SAMPLER_ARG);
    if (isNaN(probability)) {
      api_1.diag.error(`OTEL_TRACES_SAMPLER_ARG=${environment.OTEL_TRACES_SAMPLER_ARG} was given, but it is invalid, defaulting to ${DEFAULT_RATIO}.`);
      return DEFAULT_RATIO;
    }
    if (probability < 0 || probability > 1) {
      api_1.diag.error(`OTEL_TRACES_SAMPLER_ARG=${environment.OTEL_TRACES_SAMPLER_ARG} was given, but it is out of range ([0..1]), defaulting to ${DEFAULT_RATIO}.`);
      return DEFAULT_RATIO;
    }
    return probability;
  }
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/utility.js
var require_utility = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reconfigureLimits = exports.mergeConfig = undefined;
  var config_1 = require_config();
  var core_1 = require_src8();
  function mergeConfig(userConfig) {
    const perInstanceDefaults = {
      sampler: (0, config_1.buildSamplerFromEnv)()
    };
    const DEFAULT_CONFIG = (0, config_1.loadDefaultConfig)();
    const target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);
    target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});
    target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});
    return target;
  }
  exports.mergeConfig = mergeConfig;
  function reconfigureLimits(userConfig) {
    var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _j, _k, _l, _m;
    const spanLimits = Object.assign({}, userConfig.spanLimits);
    const parsedEnvConfig = (0, core_1.getEnvWithoutDefaults)();
    spanLimits.attributeCountLimit = (_f = (_e2 = (_d2 = (_b2 = (_a2 = userConfig.spanLimits) === null || _a2 === undefined ? undefined : _a2.attributeCountLimit) !== null && _b2 !== undefined ? _b2 : (_c2 = userConfig.generalLimits) === null || _c2 === undefined ? undefined : _c2.attributeCountLimit) !== null && _d2 !== undefined ? _d2 : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) !== null && _e2 !== undefined ? _e2 : parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT) !== null && _f !== undefined ? _f : core_1.DEFAULT_ATTRIBUTE_COUNT_LIMIT;
    spanLimits.attributeValueLengthLimit = (_m = (_l = (_k = (_h = (_g = userConfig.spanLimits) === null || _g === undefined ? undefined : _g.attributeValueLengthLimit) !== null && _h !== undefined ? _h : (_j = userConfig.generalLimits) === null || _j === undefined ? undefined : _j.attributeValueLengthLimit) !== null && _k !== undefined ? _k : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _l !== undefined ? _l : parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _m !== undefined ? _m : core_1.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
    return Object.assign({}, userConfig, { spanLimits });
  }
  exports.reconfigureLimits = reconfigureLimits;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/export/BatchSpanProcessorBase.js
var require_BatchSpanProcessorBase = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BatchSpanProcessorBase = undefined;
  var api_1 = require_src();
  var core_1 = require_src8();

  class BatchSpanProcessorBase {
    constructor(_exporter, config5) {
      this._exporter = _exporter;
      this._isExporting = false;
      this._finishedSpans = [];
      this._droppedSpansCount = 0;
      const env3 = (0, core_1.getEnv)();
      this._maxExportBatchSize = typeof (config5 === null || config5 === undefined ? undefined : config5.maxExportBatchSize) === "number" ? config5.maxExportBatchSize : env3.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;
      this._maxQueueSize = typeof (config5 === null || config5 === undefined ? undefined : config5.maxQueueSize) === "number" ? config5.maxQueueSize : env3.OTEL_BSP_MAX_QUEUE_SIZE;
      this._scheduledDelayMillis = typeof (config5 === null || config5 === undefined ? undefined : config5.scheduledDelayMillis) === "number" ? config5.scheduledDelayMillis : env3.OTEL_BSP_SCHEDULE_DELAY;
      this._exportTimeoutMillis = typeof (config5 === null || config5 === undefined ? undefined : config5.exportTimeoutMillis) === "number" ? config5.exportTimeoutMillis : env3.OTEL_BSP_EXPORT_TIMEOUT;
      this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this);
      if (this._maxExportBatchSize > this._maxQueueSize) {
        api_1.diag.warn("BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize");
        this._maxExportBatchSize = this._maxQueueSize;
      }
    }
    forceFlush() {
      if (this._shutdownOnce.isCalled) {
        return this._shutdownOnce.promise;
      }
      return this._flushAll();
    }
    onStart(_span, _parentContext) {
    }
    onEnd(span) {
      if (this._shutdownOnce.isCalled) {
        return;
      }
      if ((span.spanContext().traceFlags & api_1.TraceFlags.SAMPLED) === 0) {
        return;
      }
      this._addToBuffer(span);
    }
    shutdown() {
      return this._shutdownOnce.call();
    }
    _shutdown() {
      return Promise.resolve().then(() => {
        return this.onShutdown();
      }).then(() => {
        return this._flushAll();
      }).then(() => {
        return this._exporter.shutdown();
      });
    }
    _addToBuffer(span) {
      if (this._finishedSpans.length >= this._maxQueueSize) {
        if (this._droppedSpansCount === 0) {
          api_1.diag.debug("maxQueueSize reached, dropping spans");
        }
        this._droppedSpansCount++;
        return;
      }
      if (this._droppedSpansCount > 0) {
        api_1.diag.warn(`Dropped ${this._droppedSpansCount} spans because maxQueueSize reached`);
        this._droppedSpansCount = 0;
      }
      this._finishedSpans.push(span);
      this._maybeStartTimer();
    }
    _flushAll() {
      return new Promise((resolve2, reject) => {
        const promises = [];
        const count = Math.ceil(this._finishedSpans.length / this._maxExportBatchSize);
        for (let i4 = 0, j4 = count;i4 < j4; i4++) {
          promises.push(this._flushOneBatch());
        }
        Promise.all(promises).then(() => {
          resolve2();
        }).catch(reject);
      });
    }
    _flushOneBatch() {
      this._clearTimer();
      if (this._finishedSpans.length === 0) {
        return Promise.resolve();
      }
      return new Promise((resolve2, reject) => {
        const timer = setTimeout(() => {
          reject(new Error("Timeout"));
        }, this._exportTimeoutMillis);
        api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), () => {
          let spans;
          if (this._finishedSpans.length <= this._maxExportBatchSize) {
            spans = this._finishedSpans;
            this._finishedSpans = [];
          } else {
            spans = this._finishedSpans.splice(0, this._maxExportBatchSize);
          }
          const doExport = () => this._exporter.export(spans, (result) => {
            var _a2;
            clearTimeout(timer);
            if (result.code === core_1.ExportResultCode.SUCCESS) {
              resolve2();
            } else {
              reject((_a2 = result.error) !== null && _a2 !== undefined ? _a2 : new Error("BatchSpanProcessor: span export failed"));
            }
          });
          let pendingResources = null;
          for (let i4 = 0, len = spans.length;i4 < len; i4++) {
            const span = spans[i4];
            if (span.resource.asyncAttributesPending && span.resource.waitForAsyncAttributes) {
              pendingResources !== null && pendingResources !== undefined || (pendingResources = []);
              pendingResources.push(span.resource.waitForAsyncAttributes());
            }
          }
          if (pendingResources === null) {
            doExport();
          } else {
            Promise.all(pendingResources).then(doExport, (err) => {
              (0, core_1.globalErrorHandler)(err);
              reject(err);
            });
          }
        });
      });
    }
    _maybeStartTimer() {
      if (this._isExporting)
        return;
      const flush = () => {
        this._isExporting = true;
        this._flushOneBatch().finally(() => {
          this._isExporting = false;
          if (this._finishedSpans.length > 0) {
            this._clearTimer();
            this._maybeStartTimer();
          }
        }).catch((e4) => {
          this._isExporting = false;
          (0, core_1.globalErrorHandler)(e4);
        });
      };
      if (this._finishedSpans.length >= this._maxExportBatchSize) {
        return flush();
      }
      if (this._timer !== undefined)
        return;
      this._timer = setTimeout(() => flush(), this._scheduledDelayMillis);
      (0, core_1.unrefTimer)(this._timer);
    }
    _clearTimer() {
      if (this._timer !== undefined) {
        clearTimeout(this._timer);
        this._timer = undefined;
      }
    }
  }
  exports.BatchSpanProcessorBase = BatchSpanProcessorBase;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/export/BatchSpanProcessor.js
var require_BatchSpanProcessor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BatchSpanProcessor = undefined;
  var BatchSpanProcessorBase_1 = require_BatchSpanProcessorBase();

  class BatchSpanProcessor extends BatchSpanProcessorBase_1.BatchSpanProcessorBase {
    onShutdown() {
    }
  }
  exports.BatchSpanProcessor = BatchSpanProcessor;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RandomIdGenerator = undefined;
  var SPAN_ID_BYTES = 8;
  var TRACE_ID_BYTES = 16;

  class RandomIdGenerator {
    constructor() {
      this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
      this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
    }
  }
  exports.RandomIdGenerator = RandomIdGenerator;
  var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
  function getIdGenerator(bytes) {
    return function generateId() {
      for (let i4 = 0;i4 < bytes / 4; i4++) {
        SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i4 * 4);
      }
      for (let i4 = 0;i4 < bytes; i4++) {
        if (SHARED_BUFFER[i4] > 0) {
          break;
        } else if (i4 === bytes - 1) {
          SHARED_BUFFER[bytes - 1] = 1;
        }
      }
      return SHARED_BUFFER.toString("hex", 0, bytes);
    };
  }
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/index.js
var require_node8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RandomIdGenerator = exports.BatchSpanProcessor = undefined;
  var BatchSpanProcessor_1 = require_BatchSpanProcessor();
  Object.defineProperty(exports, "BatchSpanProcessor", { enumerable: true, get: function() {
    return BatchSpanProcessor_1.BatchSpanProcessor;
  } });
  var RandomIdGenerator_1 = require_RandomIdGenerator2();
  Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
    return RandomIdGenerator_1.RandomIdGenerator;
  } });
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/platform/index.js
var require_platform7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RandomIdGenerator = exports.BatchSpanProcessor = undefined;
  var node_1 = require_node8();
  Object.defineProperty(exports, "BatchSpanProcessor", { enumerable: true, get: function() {
    return node_1.BatchSpanProcessor;
  } });
  Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
    return node_1.RandomIdGenerator;
  } });
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/Tracer.js
var require_Tracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Tracer = undefined;
  var api = require_src();
  var core_1 = require_src8();
  var Span_1 = require_Span();
  var utility_1 = require_utility();
  var platform_1 = require_platform7();

  class Tracer {
    constructor(instrumentationLibrary, config5, _tracerProvider) {
      this._tracerProvider = _tracerProvider;
      const localConfig = (0, utility_1.mergeConfig)(config5);
      this._sampler = localConfig.sampler;
      this._generalLimits = localConfig.generalLimits;
      this._spanLimits = localConfig.spanLimits;
      this._idGenerator = config5.idGenerator || new platform_1.RandomIdGenerator;
      this.resource = _tracerProvider.resource;
      this.instrumentationLibrary = instrumentationLibrary;
    }
    startSpan(name, options = {}, context = api.context.active()) {
      var _a2, _b2, _c2;
      if (options.root) {
        context = api.trace.deleteSpan(context);
      }
      const parentSpan = api.trace.getSpan(context);
      if ((0, core_1.isTracingSuppressed)(context)) {
        api.diag.debug("Instrumentation suppressed, returning Noop Span");
        const nonRecordingSpan = api.trace.wrapSpanContext(api.INVALID_SPAN_CONTEXT);
        return nonRecordingSpan;
      }
      const parentSpanContext = parentSpan === null || parentSpan === undefined ? undefined : parentSpan.spanContext();
      const spanId = this._idGenerator.generateSpanId();
      let traceId;
      let traceState;
      let parentSpanId;
      if (!parentSpanContext || !api.trace.isSpanContextValid(parentSpanContext)) {
        traceId = this._idGenerator.generateTraceId();
      } else {
        traceId = parentSpanContext.traceId;
        traceState = parentSpanContext.traceState;
        parentSpanId = parentSpanContext.spanId;
      }
      const spanKind = (_a2 = options.kind) !== null && _a2 !== undefined ? _a2 : api.SpanKind.INTERNAL;
      const links = ((_b2 = options.links) !== null && _b2 !== undefined ? _b2 : []).map((link) => {
        return {
          context: link.context,
          attributes: (0, core_1.sanitizeAttributes)(link.attributes)
        };
      });
      const attributes = (0, core_1.sanitizeAttributes)(options.attributes);
      const samplingResult = this._sampler.shouldSample(context, traceId, name, spanKind, attributes, links);
      traceState = (_c2 = samplingResult.traceState) !== null && _c2 !== undefined ? _c2 : traceState;
      const traceFlags = samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE;
      const spanContext = { traceId, spanId, traceFlags, traceState };
      if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {
        api.diag.debug("Recording is off, propagating context in a non-recording span");
        const nonRecordingSpan = api.trace.wrapSpanContext(spanContext);
        return nonRecordingSpan;
      }
      const initAttributes = (0, core_1.sanitizeAttributes)(Object.assign(attributes, samplingResult.attributes));
      const span = new Span_1.Span(this, context, name, spanContext, spanKind, parentSpanId, links, options.startTime, undefined, initAttributes);
      return span;
    }
    startActiveSpan(name, arg2, arg3, arg4) {
      let opts;
      let ctx;
      let fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      const parentContext = ctx !== null && ctx !== undefined ? ctx : api.context.active();
      const span = this.startSpan(name, opts, parentContext);
      const contextWithSpanSet = api.trace.setSpan(parentContext, span);
      return api.context.with(contextWithSpanSet, fn, undefined, span);
    }
    getGeneralLimits() {
      return this._generalLimits;
    }
    getSpanLimits() {
      return this._spanLimits;
    }
    getActiveSpanProcessor() {
      return this._tracerProvider.getActiveSpanProcessor();
    }
  }
  exports.Tracer = Tracer;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/MultiSpanProcessor.js
var require_MultiSpanProcessor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MultiSpanProcessor = undefined;
  var core_1 = require_src8();

  class MultiSpanProcessor {
    constructor(_spanProcessors) {
      this._spanProcessors = _spanProcessors;
    }
    forceFlush() {
      const promises = [];
      for (const spanProcessor of this._spanProcessors) {
        promises.push(spanProcessor.forceFlush());
      }
      return new Promise((resolve2) => {
        Promise.all(promises).then(() => {
          resolve2();
        }).catch((error) => {
          (0, core_1.globalErrorHandler)(error || new Error("MultiSpanProcessor: forceFlush failed"));
          resolve2();
        });
      });
    }
    onStart(span, context) {
      for (const spanProcessor of this._spanProcessors) {
        spanProcessor.onStart(span, context);
      }
    }
    onEnd(span) {
      for (const spanProcessor of this._spanProcessors) {
        spanProcessor.onEnd(span);
      }
    }
    shutdown() {
      const promises = [];
      for (const spanProcessor of this._spanProcessors) {
        promises.push(spanProcessor.shutdown());
      }
      return new Promise((resolve2, reject) => {
        Promise.all(promises).then(() => {
          resolve2();
        }, reject);
      });
    }
  }
  exports.MultiSpanProcessor = MultiSpanProcessor;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/export/NoopSpanProcessor.js
var require_NoopSpanProcessor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopSpanProcessor = undefined;

  class NoopSpanProcessor {
    onStart(_span, _context) {
    }
    onEnd(_span) {
    }
    shutdown() {
      return Promise.resolve();
    }
    forceFlush() {
      return Promise.resolve();
    }
  }
  exports.NoopSpanProcessor = NoopSpanProcessor;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/BasicTracerProvider.js
var require_BasicTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BasicTracerProvider = exports.ForceFlushState = undefined;
  var api_1 = require_src();
  var core_1 = require_src8();
  var resources_1 = require_src9();
  var Tracer_1 = require_Tracer();
  var config_1 = require_config();
  var MultiSpanProcessor_1 = require_MultiSpanProcessor();
  var NoopSpanProcessor_1 = require_NoopSpanProcessor();
  var platform_1 = require_platform7();
  var utility_1 = require_utility();
  var ForceFlushState;
  (function(ForceFlushState2) {
    ForceFlushState2[ForceFlushState2["resolved"] = 0] = "resolved";
    ForceFlushState2[ForceFlushState2["timeout"] = 1] = "timeout";
    ForceFlushState2[ForceFlushState2["error"] = 2] = "error";
    ForceFlushState2[ForceFlushState2["unresolved"] = 3] = "unresolved";
  })(ForceFlushState = exports.ForceFlushState || (exports.ForceFlushState = {}));

  class BasicTracerProvider {
    constructor(config5 = {}) {
      var _a2, _b2;
      this._registeredSpanProcessors = [];
      this._tracers = new Map;
      const mergedConfig = (0, core_1.merge)({}, (0, config_1.loadDefaultConfig)(), (0, utility_1.reconfigureLimits)(config5));
      this.resource = (_a2 = mergedConfig.resource) !== null && _a2 !== undefined ? _a2 : resources_1.Resource.empty();
      if (mergedConfig.mergeResourceWithDefaults) {
        this.resource = resources_1.Resource.default().merge(this.resource);
      }
      this._config = Object.assign({}, mergedConfig, {
        resource: this.resource
      });
      if ((_b2 = config5.spanProcessors) === null || _b2 === undefined ? undefined : _b2.length) {
        this._registeredSpanProcessors = [...config5.spanProcessors];
        this.activeSpanProcessor = new MultiSpanProcessor_1.MultiSpanProcessor(this._registeredSpanProcessors);
      } else {
        const defaultExporter = this._buildExporterFromEnv();
        if (defaultExporter !== undefined) {
          const batchProcessor = new platform_1.BatchSpanProcessor(defaultExporter);
          this.activeSpanProcessor = batchProcessor;
        } else {
          this.activeSpanProcessor = new NoopSpanProcessor_1.NoopSpanProcessor;
        }
      }
    }
    getTracer(name, version2, options) {
      const key = `${name}@${version2 || ""}:${(options === null || options === undefined ? undefined : options.schemaUrl) || ""}`;
      if (!this._tracers.has(key)) {
        this._tracers.set(key, new Tracer_1.Tracer({ name, version: version2, schemaUrl: options === null || options === undefined ? undefined : options.schemaUrl }, this._config, this));
      }
      return this._tracers.get(key);
    }
    addSpanProcessor(spanProcessor) {
      if (this._registeredSpanProcessors.length === 0) {
        this.activeSpanProcessor.shutdown().catch((err) => api_1.diag.error("Error while trying to shutdown current span processor", err));
      }
      this._registeredSpanProcessors.push(spanProcessor);
      this.activeSpanProcessor = new MultiSpanProcessor_1.MultiSpanProcessor(this._registeredSpanProcessors);
    }
    getActiveSpanProcessor() {
      return this.activeSpanProcessor;
    }
    register(config5 = {}) {
      api_1.trace.setGlobalTracerProvider(this);
      if (config5.propagator === undefined) {
        config5.propagator = this._buildPropagatorFromEnv();
      }
      if (config5.contextManager) {
        api_1.context.setGlobalContextManager(config5.contextManager);
      }
      if (config5.propagator) {
        api_1.propagation.setGlobalPropagator(config5.propagator);
      }
    }
    forceFlush() {
      const timeout = this._config.forceFlushTimeoutMillis;
      const promises = this._registeredSpanProcessors.map((spanProcessor) => {
        return new Promise((resolve2) => {
          let state;
          const timeoutInterval = setTimeout(() => {
            resolve2(new Error(`Span processor did not completed within timeout period of ${timeout} ms`));
            state = ForceFlushState.timeout;
          }, timeout);
          spanProcessor.forceFlush().then(() => {
            clearTimeout(timeoutInterval);
            if (state !== ForceFlushState.timeout) {
              state = ForceFlushState.resolved;
              resolve2(state);
            }
          }).catch((error) => {
            clearTimeout(timeoutInterval);
            state = ForceFlushState.error;
            resolve2(error);
          });
        });
      });
      return new Promise((resolve2, reject) => {
        Promise.all(promises).then((results) => {
          const errors3 = results.filter((result) => result !== ForceFlushState.resolved);
          if (errors3.length > 0) {
            reject(errors3);
          } else {
            resolve2();
          }
        }).catch((error) => reject([error]));
      });
    }
    shutdown() {
      return this.activeSpanProcessor.shutdown();
    }
    _getPropagator(name) {
      var _a2;
      return (_a2 = this.constructor._registeredPropagators.get(name)) === null || _a2 === undefined ? undefined : _a2();
    }
    _getSpanExporter(name) {
      var _a2;
      return (_a2 = this.constructor._registeredExporters.get(name)) === null || _a2 === undefined ? undefined : _a2();
    }
    _buildPropagatorFromEnv() {
      const uniquePropagatorNames = Array.from(new Set((0, core_1.getEnv)().OTEL_PROPAGATORS));
      const propagators = uniquePropagatorNames.map((name) => {
        const propagator = this._getPropagator(name);
        if (!propagator) {
          api_1.diag.warn(`Propagator "${name}" requested through environment variable is unavailable.`);
        }
        return propagator;
      });
      const validPropagators = propagators.reduce((list, item) => {
        if (item) {
          list.push(item);
        }
        return list;
      }, []);
      if (validPropagators.length === 0) {
        return;
      } else if (uniquePropagatorNames.length === 1) {
        return validPropagators[0];
      } else {
        return new core_1.CompositePropagator({
          propagators: validPropagators
        });
      }
    }
    _buildExporterFromEnv() {
      const exporterName = (0, core_1.getEnv)().OTEL_TRACES_EXPORTER;
      if (exporterName === "none" || exporterName === "")
        return;
      const exporter = this._getSpanExporter(exporterName);
      if (!exporter) {
        api_1.diag.error(`Exporter "${exporterName}" requested through environment variable is unavailable.`);
      }
      return exporter;
    }
  }
  exports.BasicTracerProvider = BasicTracerProvider;
  BasicTracerProvider._registeredPropagators = new Map([
    ["tracecontext", () => new core_1.W3CTraceContextPropagator],
    ["baggage", () => new core_1.W3CBaggagePropagator]
  ]);
  BasicTracerProvider._registeredExporters = new Map;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/export/ConsoleSpanExporter.js
var require_ConsoleSpanExporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConsoleSpanExporter = undefined;
  var core_1 = require_src8();

  class ConsoleSpanExporter {
    export(spans, resultCallback) {
      return this._sendSpans(spans, resultCallback);
    }
    shutdown() {
      this._sendSpans([]);
      return this.forceFlush();
    }
    forceFlush() {
      return Promise.resolve();
    }
    _exportInfo(span) {
      var _a2;
      return {
        resource: {
          attributes: span.resource.attributes
        },
        instrumentationScope: span.instrumentationLibrary,
        traceId: span.spanContext().traceId,
        parentId: span.parentSpanId,
        traceState: (_a2 = span.spanContext().traceState) === null || _a2 === undefined ? undefined : _a2.serialize(),
        name: span.name,
        id: span.spanContext().spanId,
        kind: span.kind,
        timestamp: (0, core_1.hrTimeToMicroseconds)(span.startTime),
        duration: (0, core_1.hrTimeToMicroseconds)(span.duration),
        attributes: span.attributes,
        status: span.status,
        events: span.events,
        links: span.links
      };
    }
    _sendSpans(spans, done) {
      for (const span of spans) {
        console.dir(this._exportInfo(span), { depth: 3 });
      }
      if (done) {
        return done({ code: core_1.ExportResultCode.SUCCESS });
      }
    }
  }
  exports.ConsoleSpanExporter = ConsoleSpanExporter;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/export/InMemorySpanExporter.js
var require_InMemorySpanExporter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InMemorySpanExporter = undefined;
  var core_1 = require_src8();

  class InMemorySpanExporter {
    constructor() {
      this._finishedSpans = [];
      this._stopped = false;
    }
    export(spans, resultCallback) {
      if (this._stopped)
        return resultCallback({
          code: core_1.ExportResultCode.FAILED,
          error: new Error("Exporter has been stopped")
        });
      this._finishedSpans.push(...spans);
      setTimeout(() => resultCallback({ code: core_1.ExportResultCode.SUCCESS }), 0);
    }
    shutdown() {
      this._stopped = true;
      this._finishedSpans = [];
      return this.forceFlush();
    }
    forceFlush() {
      return Promise.resolve();
    }
    reset() {
      this._finishedSpans = [];
    }
    getFinishedSpans() {
      return this._finishedSpans;
    }
  }
  exports.InMemorySpanExporter = InMemorySpanExporter;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/export/SimpleSpanProcessor.js
var require_SimpleSpanProcessor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SimpleSpanProcessor = undefined;
  var api_1 = require_src();
  var core_1 = require_src8();

  class SimpleSpanProcessor {
    constructor(_exporter) {
      this._exporter = _exporter;
      this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this);
      this._unresolvedExports = new Set;
    }
    async forceFlush() {
      await Promise.all(Array.from(this._unresolvedExports));
      if (this._exporter.forceFlush) {
        await this._exporter.forceFlush();
      }
    }
    onStart(_span, _parentContext) {
    }
    onEnd(span) {
      var _a2, _b2;
      if (this._shutdownOnce.isCalled) {
        return;
      }
      if ((span.spanContext().traceFlags & api_1.TraceFlags.SAMPLED) === 0) {
        return;
      }
      const doExport = () => core_1.internal._export(this._exporter, [span]).then((result) => {
        var _a3;
        if (result.code !== core_1.ExportResultCode.SUCCESS) {
          (0, core_1.globalErrorHandler)((_a3 = result.error) !== null && _a3 !== undefined ? _a3 : new Error(`SimpleSpanProcessor: span export failed (status ${result})`));
        }
      }).catch((error) => {
        (0, core_1.globalErrorHandler)(error);
      });
      if (span.resource.asyncAttributesPending) {
        const exportPromise = (_b2 = (_a2 = span.resource).waitForAsyncAttributes) === null || _b2 === undefined ? undefined : _b2.call(_a2).then(() => {
          if (exportPromise != null) {
            this._unresolvedExports.delete(exportPromise);
          }
          return doExport();
        }, (err) => (0, core_1.globalErrorHandler)(err));
        if (exportPromise != null) {
          this._unresolvedExports.add(exportPromise);
        }
      } else {
        doExport();
      }
    }
    shutdown() {
      return this._shutdownOnce.call();
    }
    _shutdown() {
      return this._exporter.shutdown();
    }
  }
  exports.SimpleSpanProcessor = SimpleSpanProcessor;
});

// ../../node_modules/@opentelemetry/sdk-trace-base/build/src/index.js
var require_src11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Span = exports.SamplingDecision = exports.TraceIdRatioBasedSampler = exports.ParentBasedSampler = exports.AlwaysOnSampler = exports.AlwaysOffSampler = exports.NoopSpanProcessor = exports.SimpleSpanProcessor = exports.InMemorySpanExporter = exports.ConsoleSpanExporter = exports.RandomIdGenerator = exports.BatchSpanProcessor = exports.ForceFlushState = exports.BasicTracerProvider = exports.Tracer = undefined;
  var Tracer_1 = require_Tracer();
  Object.defineProperty(exports, "Tracer", { enumerable: true, get: function() {
    return Tracer_1.Tracer;
  } });
  var BasicTracerProvider_1 = require_BasicTracerProvider();
  Object.defineProperty(exports, "BasicTracerProvider", { enumerable: true, get: function() {
    return BasicTracerProvider_1.BasicTracerProvider;
  } });
  Object.defineProperty(exports, "ForceFlushState", { enumerable: true, get: function() {
    return BasicTracerProvider_1.ForceFlushState;
  } });
  var platform_1 = require_platform7();
  Object.defineProperty(exports, "BatchSpanProcessor", { enumerable: true, get: function() {
    return platform_1.BatchSpanProcessor;
  } });
  Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
    return platform_1.RandomIdGenerator;
  } });
  var ConsoleSpanExporter_1 = require_ConsoleSpanExporter();
  Object.defineProperty(exports, "ConsoleSpanExporter", { enumerable: true, get: function() {
    return ConsoleSpanExporter_1.ConsoleSpanExporter;
  } });
  var InMemorySpanExporter_1 = require_InMemorySpanExporter();
  Object.defineProperty(exports, "InMemorySpanExporter", { enumerable: true, get: function() {
    return InMemorySpanExporter_1.InMemorySpanExporter;
  } });
  var SimpleSpanProcessor_1 = require_SimpleSpanProcessor();
  Object.defineProperty(exports, "SimpleSpanProcessor", { enumerable: true, get: function() {
    return SimpleSpanProcessor_1.SimpleSpanProcessor;
  } });
  var NoopSpanProcessor_1 = require_NoopSpanProcessor();
  Object.defineProperty(exports, "NoopSpanProcessor", { enumerable: true, get: function() {
    return NoopSpanProcessor_1.NoopSpanProcessor;
  } });
  var AlwaysOffSampler_1 = require_AlwaysOffSampler2();
  Object.defineProperty(exports, "AlwaysOffSampler", { enumerable: true, get: function() {
    return AlwaysOffSampler_1.AlwaysOffSampler;
  } });
  var AlwaysOnSampler_1 = require_AlwaysOnSampler2();
  Object.defineProperty(exports, "AlwaysOnSampler", { enumerable: true, get: function() {
    return AlwaysOnSampler_1.AlwaysOnSampler;
  } });
  var ParentBasedSampler_1 = require_ParentBasedSampler2();
  Object.defineProperty(exports, "ParentBasedSampler", { enumerable: true, get: function() {
    return ParentBasedSampler_1.ParentBasedSampler;
  } });
  var TraceIdRatioBasedSampler_1 = require_TraceIdRatioBasedSampler2();
  Object.defineProperty(exports, "TraceIdRatioBasedSampler", { enumerable: true, get: function() {
    return TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler;
  } });
  var Sampler_1 = require_Sampler();
  Object.defineProperty(exports, "SamplingDecision", { enumerable: true, get: function() {
    return Sampler_1.SamplingDecision;
  } });
  var Span_1 = require_Span();
  Object.defineProperty(exports, "Span", { enumerable: true, get: function() {
    return Span_1.Span;
  } });
});

// ../../node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js
var require_utils10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createConstMap = undefined;
  function createConstMap(values) {
    let res = {};
    const len = values.length;
    for (let lp = 0;lp < len; lp++) {
      const val2 = values[lp];
      if (val2) {
        res[String(val2).toUpperCase().replace(/[-.]/g, "_")] = val2;
      }
    }
    return res;
  }
  exports.createConstMap = createConstMap;
});

// ../../node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js
var require_SemanticAttributes4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SEMATTRS_NET_HOST_CARRIER_ICC = exports.SEMATTRS_NET_HOST_CARRIER_MNC = exports.SEMATTRS_NET_HOST_CARRIER_MCC = exports.SEMATTRS_NET_HOST_CARRIER_NAME = exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = exports.SEMATTRS_NET_HOST_NAME = exports.SEMATTRS_NET_HOST_PORT = exports.SEMATTRS_NET_HOST_IP = exports.SEMATTRS_NET_PEER_NAME = exports.SEMATTRS_NET_PEER_PORT = exports.SEMATTRS_NET_PEER_IP = exports.SEMATTRS_NET_TRANSPORT = exports.SEMATTRS_FAAS_INVOKED_REGION = exports.SEMATTRS_FAAS_INVOKED_PROVIDER = exports.SEMATTRS_FAAS_INVOKED_NAME = exports.SEMATTRS_FAAS_COLDSTART = exports.SEMATTRS_FAAS_CRON = exports.SEMATTRS_FAAS_TIME = exports.SEMATTRS_FAAS_DOCUMENT_NAME = exports.SEMATTRS_FAAS_DOCUMENT_TIME = exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = exports.SEMATTRS_FAAS_EXECUTION = exports.SEMATTRS_FAAS_TRIGGER = exports.SEMATTRS_EXCEPTION_ESCAPED = exports.SEMATTRS_EXCEPTION_STACKTRACE = exports.SEMATTRS_EXCEPTION_MESSAGE = exports.SEMATTRS_EXCEPTION_TYPE = exports.SEMATTRS_DB_SQL_TABLE = exports.SEMATTRS_DB_MONGODB_COLLECTION = exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = exports.SEMATTRS_DB_HBASE_NAMESPACE = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = exports.SEMATTRS_DB_CASSANDRA_TABLE = exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = exports.SEMATTRS_DB_OPERATION = exports.SEMATTRS_DB_STATEMENT = exports.SEMATTRS_DB_NAME = exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = exports.SEMATTRS_DB_USER = exports.SEMATTRS_DB_CONNECTION_STRING = exports.SEMATTRS_DB_SYSTEM = exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = undefined;
  exports.SEMATTRS_MESSAGING_DESTINATION_KIND = exports.SEMATTRS_MESSAGING_DESTINATION = exports.SEMATTRS_MESSAGING_SYSTEM = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = exports.SEMATTRS_AWS_DYNAMODB_COUNT = exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_SELECT = exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = exports.SEMATTRS_AWS_DYNAMODB_LIMIT = exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = exports.SEMATTRS_HTTP_CLIENT_IP = exports.SEMATTRS_HTTP_ROUTE = exports.SEMATTRS_HTTP_SERVER_NAME = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = exports.SEMATTRS_HTTP_USER_AGENT = exports.SEMATTRS_HTTP_FLAVOR = exports.SEMATTRS_HTTP_STATUS_CODE = exports.SEMATTRS_HTTP_SCHEME = exports.SEMATTRS_HTTP_HOST = exports.SEMATTRS_HTTP_TARGET = exports.SEMATTRS_HTTP_URL = exports.SEMATTRS_HTTP_METHOD = exports.SEMATTRS_CODE_LINENO = exports.SEMATTRS_CODE_FILEPATH = exports.SEMATTRS_CODE_NAMESPACE = exports.SEMATTRS_CODE_FUNCTION = exports.SEMATTRS_THREAD_NAME = exports.SEMATTRS_THREAD_ID = exports.SEMATTRS_ENDUSER_SCOPE = exports.SEMATTRS_ENDUSER_ROLE = exports.SEMATTRS_ENDUSER_ID = exports.SEMATTRS_PEER_SERVICE = undefined;
  exports.DBSYSTEMVALUES_FILEMAKER = exports.DBSYSTEMVALUES_DERBY = exports.DBSYSTEMVALUES_FIREBIRD = exports.DBSYSTEMVALUES_ADABAS = exports.DBSYSTEMVALUES_CACHE = exports.DBSYSTEMVALUES_EDB = exports.DBSYSTEMVALUES_FIRSTSQL = exports.DBSYSTEMVALUES_INGRES = exports.DBSYSTEMVALUES_HANADB = exports.DBSYSTEMVALUES_MAXDB = exports.DBSYSTEMVALUES_PROGRESS = exports.DBSYSTEMVALUES_HSQLDB = exports.DBSYSTEMVALUES_CLOUDSCAPE = exports.DBSYSTEMVALUES_HIVE = exports.DBSYSTEMVALUES_REDSHIFT = exports.DBSYSTEMVALUES_POSTGRESQL = exports.DBSYSTEMVALUES_DB2 = exports.DBSYSTEMVALUES_ORACLE = exports.DBSYSTEMVALUES_MYSQL = exports.DBSYSTEMVALUES_MSSQL = exports.DBSYSTEMVALUES_OTHER_SQL = exports.SemanticAttributes = exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_ID = exports.SEMATTRS_MESSAGE_TYPE = exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = exports.SEMATTRS_RPC_JSONRPC_VERSION = exports.SEMATTRS_RPC_GRPC_STATUS_CODE = exports.SEMATTRS_RPC_METHOD = exports.SEMATTRS_RPC_SERVICE = exports.SEMATTRS_RPC_SYSTEM = exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = exports.SEMATTRS_MESSAGING_CONSUMER_ID = exports.SEMATTRS_MESSAGING_OPERATION = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = exports.SEMATTRS_MESSAGING_CONVERSATION_ID = exports.SEMATTRS_MESSAGING_MESSAGE_ID = exports.SEMATTRS_MESSAGING_URL = exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = exports.SEMATTRS_MESSAGING_PROTOCOL = exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = undefined;
  exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = exports.FaasDocumentOperationValues = exports.FAASDOCUMENTOPERATIONVALUES_DELETE = exports.FAASDOCUMENTOPERATIONVALUES_EDIT = exports.FAASDOCUMENTOPERATIONVALUES_INSERT = exports.FaasTriggerValues = exports.FAASTRIGGERVALUES_OTHER = exports.FAASTRIGGERVALUES_TIMER = exports.FAASTRIGGERVALUES_PUBSUB = exports.FAASTRIGGERVALUES_HTTP = exports.FAASTRIGGERVALUES_DATASOURCE = exports.DbCassandraConsistencyLevelValues = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = exports.DbSystemValues = exports.DBSYSTEMVALUES_COCKROACHDB = exports.DBSYSTEMVALUES_MEMCACHED = exports.DBSYSTEMVALUES_ELASTICSEARCH = exports.DBSYSTEMVALUES_GEODE = exports.DBSYSTEMVALUES_NEO4J = exports.DBSYSTEMVALUES_DYNAMODB = exports.DBSYSTEMVALUES_COSMOSDB = exports.DBSYSTEMVALUES_COUCHDB = exports.DBSYSTEMVALUES_COUCHBASE = exports.DBSYSTEMVALUES_REDIS = exports.DBSYSTEMVALUES_MONGODB = exports.DBSYSTEMVALUES_HBASE = exports.DBSYSTEMVALUES_CASSANDRA = exports.DBSYSTEMVALUES_COLDFUSION = exports.DBSYSTEMVALUES_H2 = exports.DBSYSTEMVALUES_VERTICA = exports.DBSYSTEMVALUES_TERADATA = exports.DBSYSTEMVALUES_SYBASE = exports.DBSYSTEMVALUES_SQLITE = exports.DBSYSTEMVALUES_POINTBASE = exports.DBSYSTEMVALUES_PERVASIVE = exports.DBSYSTEMVALUES_NETEZZA = exports.DBSYSTEMVALUES_MARIADB = exports.DBSYSTEMVALUES_INTERBASE = exports.DBSYSTEMVALUES_INSTANTDB = exports.DBSYSTEMVALUES_INFORMIX = undefined;
  exports.MESSAGINGOPERATIONVALUES_RECEIVE = exports.MessagingDestinationKindValues = exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = exports.HttpFlavorValues = exports.HTTPFLAVORVALUES_QUIC = exports.HTTPFLAVORVALUES_SPDY = exports.HTTPFLAVORVALUES_HTTP_2_0 = exports.HTTPFLAVORVALUES_HTTP_1_1 = exports.HTTPFLAVORVALUES_HTTP_1_0 = exports.NetHostConnectionSubtypeValues = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = exports.NetHostConnectionTypeValues = exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = exports.NETHOSTCONNECTIONTYPEVALUES_CELL = exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = exports.NetTransportValues = exports.NETTRANSPORTVALUES_OTHER = exports.NETTRANSPORTVALUES_INPROC = exports.NETTRANSPORTVALUES_PIPE = exports.NETTRANSPORTVALUES_UNIX = exports.NETTRANSPORTVALUES_IP = exports.NETTRANSPORTVALUES_IP_UDP = exports.NETTRANSPORTVALUES_IP_TCP = exports.FaasInvokedProviderValues = exports.FAASINVOKEDPROVIDERVALUES_GCP = exports.FAASINVOKEDPROVIDERVALUES_AZURE = exports.FAASINVOKEDPROVIDERVALUES_AWS = undefined;
  exports.MessageTypeValues = exports.MESSAGETYPEVALUES_RECEIVED = exports.MESSAGETYPEVALUES_SENT = exports.RpcGrpcStatusCodeValues = exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = exports.RPCGRPCSTATUSCODEVALUES_ABORTED = exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = exports.RPCGRPCSTATUSCODEVALUES_OK = exports.MessagingOperationValues = exports.MESSAGINGOPERATIONVALUES_PROCESS = undefined;
  var utils_1 = require_utils10();
  var TMP_AWS_LAMBDA_INVOKED_ARN = "aws.lambda.invoked_arn";
  var TMP_DB_SYSTEM = "db.system";
  var TMP_DB_CONNECTION_STRING = "db.connection_string";
  var TMP_DB_USER = "db.user";
  var TMP_DB_JDBC_DRIVER_CLASSNAME = "db.jdbc.driver_classname";
  var TMP_DB_NAME = "db.name";
  var TMP_DB_STATEMENT = "db.statement";
  var TMP_DB_OPERATION = "db.operation";
  var TMP_DB_MSSQL_INSTANCE_NAME = "db.mssql.instance_name";
  var TMP_DB_CASSANDRA_KEYSPACE = "db.cassandra.keyspace";
  var TMP_DB_CASSANDRA_PAGE_SIZE = "db.cassandra.page_size";
  var TMP_DB_CASSANDRA_CONSISTENCY_LEVEL = "db.cassandra.consistency_level";
  var TMP_DB_CASSANDRA_TABLE = "db.cassandra.table";
  var TMP_DB_CASSANDRA_IDEMPOTENCE = "db.cassandra.idempotence";
  var TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = "db.cassandra.speculative_execution_count";
  var TMP_DB_CASSANDRA_COORDINATOR_ID = "db.cassandra.coordinator.id";
  var TMP_DB_CASSANDRA_COORDINATOR_DC = "db.cassandra.coordinator.dc";
  var TMP_DB_HBASE_NAMESPACE = "db.hbase.namespace";
  var TMP_DB_REDIS_DATABASE_INDEX = "db.redis.database_index";
  var TMP_DB_MONGODB_COLLECTION = "db.mongodb.collection";
  var TMP_DB_SQL_TABLE = "db.sql.table";
  var TMP_EXCEPTION_TYPE = "exception.type";
  var TMP_EXCEPTION_MESSAGE = "exception.message";
  var TMP_EXCEPTION_STACKTRACE = "exception.stacktrace";
  var TMP_EXCEPTION_ESCAPED = "exception.escaped";
  var TMP_FAAS_TRIGGER = "faas.trigger";
  var TMP_FAAS_EXECUTION = "faas.execution";
  var TMP_FAAS_DOCUMENT_COLLECTION = "faas.document.collection";
  var TMP_FAAS_DOCUMENT_OPERATION = "faas.document.operation";
  var TMP_FAAS_DOCUMENT_TIME = "faas.document.time";
  var TMP_FAAS_DOCUMENT_NAME = "faas.document.name";
  var TMP_FAAS_TIME = "faas.time";
  var TMP_FAAS_CRON = "faas.cron";
  var TMP_FAAS_COLDSTART = "faas.coldstart";
  var TMP_FAAS_INVOKED_NAME = "faas.invoked_name";
  var TMP_FAAS_INVOKED_PROVIDER = "faas.invoked_provider";
  var TMP_FAAS_INVOKED_REGION = "faas.invoked_region";
  var TMP_NET_TRANSPORT = "net.transport";
  var TMP_NET_PEER_IP = "net.peer.ip";
  var TMP_NET_PEER_PORT = "net.peer.port";
  var TMP_NET_PEER_NAME = "net.peer.name";
  var TMP_NET_HOST_IP = "net.host.ip";
  var TMP_NET_HOST_PORT = "net.host.port";
  var TMP_NET_HOST_NAME = "net.host.name";
  var TMP_NET_HOST_CONNECTION_TYPE = "net.host.connection.type";
  var TMP_NET_HOST_CONNECTION_SUBTYPE = "net.host.connection.subtype";
  var TMP_NET_HOST_CARRIER_NAME = "net.host.carrier.name";
  var TMP_NET_HOST_CARRIER_MCC = "net.host.carrier.mcc";
  var TMP_NET_HOST_CARRIER_MNC = "net.host.carrier.mnc";
  var TMP_NET_HOST_CARRIER_ICC = "net.host.carrier.icc";
  var TMP_PEER_SERVICE = "peer.service";
  var TMP_ENDUSER_ID = "enduser.id";
  var TMP_ENDUSER_ROLE = "enduser.role";
  var TMP_ENDUSER_SCOPE = "enduser.scope";
  var TMP_THREAD_ID = "thread.id";
  var TMP_THREAD_NAME = "thread.name";
  var TMP_CODE_FUNCTION = "code.function";
  var TMP_CODE_NAMESPACE = "code.namespace";
  var TMP_CODE_FILEPATH = "code.filepath";
  var TMP_CODE_LINENO = "code.lineno";
  var TMP_HTTP_METHOD = "http.method";
  var TMP_HTTP_URL = "http.url";
  var TMP_HTTP_TARGET = "http.target";
  var TMP_HTTP_HOST = "http.host";
  var TMP_HTTP_SCHEME = "http.scheme";
  var TMP_HTTP_STATUS_CODE = "http.status_code";
  var TMP_HTTP_FLAVOR = "http.flavor";
  var TMP_HTTP_USER_AGENT = "http.user_agent";
  var TMP_HTTP_REQUEST_CONTENT_LENGTH = "http.request_content_length";
  var TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = "http.request_content_length_uncompressed";
  var TMP_HTTP_RESPONSE_CONTENT_LENGTH = "http.response_content_length";
  var TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = "http.response_content_length_uncompressed";
  var TMP_HTTP_SERVER_NAME = "http.server_name";
  var TMP_HTTP_ROUTE = "http.route";
  var TMP_HTTP_CLIENT_IP = "http.client_ip";
  var TMP_AWS_DYNAMODB_TABLE_NAMES = "aws.dynamodb.table_names";
  var TMP_AWS_DYNAMODB_CONSUMED_CAPACITY = "aws.dynamodb.consumed_capacity";
  var TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = "aws.dynamodb.item_collection_metrics";
  var TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = "aws.dynamodb.provisioned_read_capacity";
  var TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = "aws.dynamodb.provisioned_write_capacity";
  var TMP_AWS_DYNAMODB_CONSISTENT_READ = "aws.dynamodb.consistent_read";
  var TMP_AWS_DYNAMODB_PROJECTION = "aws.dynamodb.projection";
  var TMP_AWS_DYNAMODB_LIMIT = "aws.dynamodb.limit";
  var TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET = "aws.dynamodb.attributes_to_get";
  var TMP_AWS_DYNAMODB_INDEX_NAME = "aws.dynamodb.index_name";
  var TMP_AWS_DYNAMODB_SELECT = "aws.dynamodb.select";
  var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = "aws.dynamodb.global_secondary_indexes";
  var TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = "aws.dynamodb.local_secondary_indexes";
  var TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = "aws.dynamodb.exclusive_start_table";
  var TMP_AWS_DYNAMODB_TABLE_COUNT = "aws.dynamodb.table_count";
  var TMP_AWS_DYNAMODB_SCAN_FORWARD = "aws.dynamodb.scan_forward";
  var TMP_AWS_DYNAMODB_SEGMENT = "aws.dynamodb.segment";
  var TMP_AWS_DYNAMODB_TOTAL_SEGMENTS = "aws.dynamodb.total_segments";
  var TMP_AWS_DYNAMODB_COUNT = "aws.dynamodb.count";
  var TMP_AWS_DYNAMODB_SCANNED_COUNT = "aws.dynamodb.scanned_count";
  var TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = "aws.dynamodb.attribute_definitions";
  var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = "aws.dynamodb.global_secondary_index_updates";
  var TMP_MESSAGING_SYSTEM = "messaging.system";
  var TMP_MESSAGING_DESTINATION = "messaging.destination";
  var TMP_MESSAGING_DESTINATION_KIND = "messaging.destination_kind";
  var TMP_MESSAGING_TEMP_DESTINATION = "messaging.temp_destination";
  var TMP_MESSAGING_PROTOCOL = "messaging.protocol";
  var TMP_MESSAGING_PROTOCOL_VERSION = "messaging.protocol_version";
  var TMP_MESSAGING_URL = "messaging.url";
  var TMP_MESSAGING_MESSAGE_ID = "messaging.message_id";
  var TMP_MESSAGING_CONVERSATION_ID = "messaging.conversation_id";
  var TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = "messaging.message_payload_size_bytes";
  var TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = "messaging.message_payload_compressed_size_bytes";
  var TMP_MESSAGING_OPERATION = "messaging.operation";
  var TMP_MESSAGING_CONSUMER_ID = "messaging.consumer_id";
  var TMP_MESSAGING_RABBITMQ_ROUTING_KEY = "messaging.rabbitmq.routing_key";
  var TMP_MESSAGING_KAFKA_MESSAGE_KEY = "messaging.kafka.message_key";
  var TMP_MESSAGING_KAFKA_CONSUMER_GROUP = "messaging.kafka.consumer_group";
  var TMP_MESSAGING_KAFKA_CLIENT_ID = "messaging.kafka.client_id";
  var TMP_MESSAGING_KAFKA_PARTITION = "messaging.kafka.partition";
  var TMP_MESSAGING_KAFKA_TOMBSTONE = "messaging.kafka.tombstone";
  var TMP_RPC_SYSTEM = "rpc.system";
  var TMP_RPC_SERVICE = "rpc.service";
  var TMP_RPC_METHOD = "rpc.method";
  var TMP_RPC_GRPC_STATUS_CODE = "rpc.grpc.status_code";
  var TMP_RPC_JSONRPC_VERSION = "rpc.jsonrpc.version";
  var TMP_RPC_JSONRPC_REQUEST_ID = "rpc.jsonrpc.request_id";
  var TMP_RPC_JSONRPC_ERROR_CODE = "rpc.jsonrpc.error_code";
  var TMP_RPC_JSONRPC_ERROR_MESSAGE = "rpc.jsonrpc.error_message";
  var TMP_MESSAGE_TYPE = "message.type";
  var TMP_MESSAGE_ID = "message.id";
  var TMP_MESSAGE_COMPRESSED_SIZE = "message.compressed_size";
  var TMP_MESSAGE_UNCOMPRESSED_SIZE = "message.uncompressed_size";
  exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN;
  exports.SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM;
  exports.SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING;
  exports.SEMATTRS_DB_USER = TMP_DB_USER;
  exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME;
  exports.SEMATTRS_DB_NAME = TMP_DB_NAME;
  exports.SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT;
  exports.SEMATTRS_DB_OPERATION = TMP_DB_OPERATION;
  exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME;
  exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE;
  exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE;
  exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL;
  exports.SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE;
  exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE;
  exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT;
  exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID;
  exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC;
  exports.SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE;
  exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX;
  exports.SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION;
  exports.SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE;
  exports.SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;
  exports.SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;
  exports.SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;
  exports.SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED;
  exports.SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER;
  exports.SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION;
  exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION;
  exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION;
  exports.SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME;
  exports.SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME;
  exports.SEMATTRS_FAAS_TIME = TMP_FAAS_TIME;
  exports.SEMATTRS_FAAS_CRON = TMP_FAAS_CRON;
  exports.SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART;
  exports.SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME;
  exports.SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER;
  exports.SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION;
  exports.SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT;
  exports.SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP;
  exports.SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT;
  exports.SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME;
  exports.SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP;
  exports.SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT;
  exports.SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME;
  exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE;
  exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE;
  exports.SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME;
  exports.SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC;
  exports.SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC;
  exports.SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC;
  exports.SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE;
  exports.SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID;
  exports.SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE;
  exports.SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE;
  exports.SEMATTRS_THREAD_ID = TMP_THREAD_ID;
  exports.SEMATTRS_THREAD_NAME = TMP_THREAD_NAME;
  exports.SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION;
  exports.SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE;
  exports.SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH;
  exports.SEMATTRS_CODE_LINENO = TMP_CODE_LINENO;
  exports.SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD;
  exports.SEMATTRS_HTTP_URL = TMP_HTTP_URL;
  exports.SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET;
  exports.SEMATTRS_HTTP_HOST = TMP_HTTP_HOST;
  exports.SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME;
  exports.SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE;
  exports.SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR;
  exports.SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT;
  exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH;
  exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED;
  exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH;
  exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED;
  exports.SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME;
  exports.SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE;
  exports.SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP;
  exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES;
  exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS;
  exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY;
  exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ;
  exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION;
  exports.SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT;
  exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET;
  exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME;
  exports.SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT;
  exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES;
  exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES;
  exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE;
  exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD;
  exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT;
  exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS;
  exports.SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT;
  exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS;
  exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES;
  exports.SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM;
  exports.SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION;
  exports.SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND;
  exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION;
  exports.SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL;
  exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION;
  exports.SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL;
  exports.SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID;
  exports.SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID;
  exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES;
  exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES;
  exports.SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION;
  exports.SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID;
  exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY;
  exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY;
  exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP;
  exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID;
  exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION;
  exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE;
  exports.SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM;
  exports.SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE;
  exports.SEMATTRS_RPC_METHOD = TMP_RPC_METHOD;
  exports.SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE;
  exports.SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION;
  exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID;
  exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE;
  exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE;
  exports.SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE;
  exports.SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID;
  exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE;
  exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE;
  exports.SemanticAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_AWS_LAMBDA_INVOKED_ARN,
    TMP_DB_SYSTEM,
    TMP_DB_CONNECTION_STRING,
    TMP_DB_USER,
    TMP_DB_JDBC_DRIVER_CLASSNAME,
    TMP_DB_NAME,
    TMP_DB_STATEMENT,
    TMP_DB_OPERATION,
    TMP_DB_MSSQL_INSTANCE_NAME,
    TMP_DB_CASSANDRA_KEYSPACE,
    TMP_DB_CASSANDRA_PAGE_SIZE,
    TMP_DB_CASSANDRA_CONSISTENCY_LEVEL,
    TMP_DB_CASSANDRA_TABLE,
    TMP_DB_CASSANDRA_IDEMPOTENCE,
    TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
    TMP_DB_CASSANDRA_COORDINATOR_ID,
    TMP_DB_CASSANDRA_COORDINATOR_DC,
    TMP_DB_HBASE_NAMESPACE,
    TMP_DB_REDIS_DATABASE_INDEX,
    TMP_DB_MONGODB_COLLECTION,
    TMP_DB_SQL_TABLE,
    TMP_EXCEPTION_TYPE,
    TMP_EXCEPTION_MESSAGE,
    TMP_EXCEPTION_STACKTRACE,
    TMP_EXCEPTION_ESCAPED,
    TMP_FAAS_TRIGGER,
    TMP_FAAS_EXECUTION,
    TMP_FAAS_DOCUMENT_COLLECTION,
    TMP_FAAS_DOCUMENT_OPERATION,
    TMP_FAAS_DOCUMENT_TIME,
    TMP_FAAS_DOCUMENT_NAME,
    TMP_FAAS_TIME,
    TMP_FAAS_CRON,
    TMP_FAAS_COLDSTART,
    TMP_FAAS_INVOKED_NAME,
    TMP_FAAS_INVOKED_PROVIDER,
    TMP_FAAS_INVOKED_REGION,
    TMP_NET_TRANSPORT,
    TMP_NET_PEER_IP,
    TMP_NET_PEER_PORT,
    TMP_NET_PEER_NAME,
    TMP_NET_HOST_IP,
    TMP_NET_HOST_PORT,
    TMP_NET_HOST_NAME,
    TMP_NET_HOST_CONNECTION_TYPE,
    TMP_NET_HOST_CONNECTION_SUBTYPE,
    TMP_NET_HOST_CARRIER_NAME,
    TMP_NET_HOST_CARRIER_MCC,
    TMP_NET_HOST_CARRIER_MNC,
    TMP_NET_HOST_CARRIER_ICC,
    TMP_PEER_SERVICE,
    TMP_ENDUSER_ID,
    TMP_ENDUSER_ROLE,
    TMP_ENDUSER_SCOPE,
    TMP_THREAD_ID,
    TMP_THREAD_NAME,
    TMP_CODE_FUNCTION,
    TMP_CODE_NAMESPACE,
    TMP_CODE_FILEPATH,
    TMP_CODE_LINENO,
    TMP_HTTP_METHOD,
    TMP_HTTP_URL,
    TMP_HTTP_TARGET,
    TMP_HTTP_HOST,
    TMP_HTTP_SCHEME,
    TMP_HTTP_STATUS_CODE,
    TMP_HTTP_FLAVOR,
    TMP_HTTP_USER_AGENT,
    TMP_HTTP_REQUEST_CONTENT_LENGTH,
    TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
    TMP_HTTP_RESPONSE_CONTENT_LENGTH,
    TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
    TMP_HTTP_SERVER_NAME,
    TMP_HTTP_ROUTE,
    TMP_HTTP_CLIENT_IP,
    TMP_AWS_DYNAMODB_TABLE_NAMES,
    TMP_AWS_DYNAMODB_CONSUMED_CAPACITY,
    TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
    TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
    TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
    TMP_AWS_DYNAMODB_CONSISTENT_READ,
    TMP_AWS_DYNAMODB_PROJECTION,
    TMP_AWS_DYNAMODB_LIMIT,
    TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
    TMP_AWS_DYNAMODB_INDEX_NAME,
    TMP_AWS_DYNAMODB_SELECT,
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
    TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
    TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
    TMP_AWS_DYNAMODB_TABLE_COUNT,
    TMP_AWS_DYNAMODB_SCAN_FORWARD,
    TMP_AWS_DYNAMODB_SEGMENT,
    TMP_AWS_DYNAMODB_TOTAL_SEGMENTS,
    TMP_AWS_DYNAMODB_COUNT,
    TMP_AWS_DYNAMODB_SCANNED_COUNT,
    TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
    TMP_MESSAGING_SYSTEM,
    TMP_MESSAGING_DESTINATION,
    TMP_MESSAGING_DESTINATION_KIND,
    TMP_MESSAGING_TEMP_DESTINATION,
    TMP_MESSAGING_PROTOCOL,
    TMP_MESSAGING_PROTOCOL_VERSION,
    TMP_MESSAGING_URL,
    TMP_MESSAGING_MESSAGE_ID,
    TMP_MESSAGING_CONVERSATION_ID,
    TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
    TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
    TMP_MESSAGING_OPERATION,
    TMP_MESSAGING_CONSUMER_ID,
    TMP_MESSAGING_RABBITMQ_ROUTING_KEY,
    TMP_MESSAGING_KAFKA_MESSAGE_KEY,
    TMP_MESSAGING_KAFKA_CONSUMER_GROUP,
    TMP_MESSAGING_KAFKA_CLIENT_ID,
    TMP_MESSAGING_KAFKA_PARTITION,
    TMP_MESSAGING_KAFKA_TOMBSTONE,
    TMP_RPC_SYSTEM,
    TMP_RPC_SERVICE,
    TMP_RPC_METHOD,
    TMP_RPC_GRPC_STATUS_CODE,
    TMP_RPC_JSONRPC_VERSION,
    TMP_RPC_JSONRPC_REQUEST_ID,
    TMP_RPC_JSONRPC_ERROR_CODE,
    TMP_RPC_JSONRPC_ERROR_MESSAGE,
    TMP_MESSAGE_TYPE,
    TMP_MESSAGE_ID,
    TMP_MESSAGE_COMPRESSED_SIZE,
    TMP_MESSAGE_UNCOMPRESSED_SIZE
  ]);
  var TMP_DBSYSTEMVALUES_OTHER_SQL = "other_sql";
  var TMP_DBSYSTEMVALUES_MSSQL = "mssql";
  var TMP_DBSYSTEMVALUES_MYSQL = "mysql";
  var TMP_DBSYSTEMVALUES_ORACLE = "oracle";
  var TMP_DBSYSTEMVALUES_DB2 = "db2";
  var TMP_DBSYSTEMVALUES_POSTGRESQL = "postgresql";
  var TMP_DBSYSTEMVALUES_REDSHIFT = "redshift";
  var TMP_DBSYSTEMVALUES_HIVE = "hive";
  var TMP_DBSYSTEMVALUES_CLOUDSCAPE = "cloudscape";
  var TMP_DBSYSTEMVALUES_HSQLDB = "hsqldb";
  var TMP_DBSYSTEMVALUES_PROGRESS = "progress";
  var TMP_DBSYSTEMVALUES_MAXDB = "maxdb";
  var TMP_DBSYSTEMVALUES_HANADB = "hanadb";
  var TMP_DBSYSTEMVALUES_INGRES = "ingres";
  var TMP_DBSYSTEMVALUES_FIRSTSQL = "firstsql";
  var TMP_DBSYSTEMVALUES_EDB = "edb";
  var TMP_DBSYSTEMVALUES_CACHE = "cache";
  var TMP_DBSYSTEMVALUES_ADABAS = "adabas";
  var TMP_DBSYSTEMVALUES_FIREBIRD = "firebird";
  var TMP_DBSYSTEMVALUES_DERBY = "derby";
  var TMP_DBSYSTEMVALUES_FILEMAKER = "filemaker";
  var TMP_DBSYSTEMVALUES_INFORMIX = "informix";
  var TMP_DBSYSTEMVALUES_INSTANTDB = "instantdb";
  var TMP_DBSYSTEMVALUES_INTERBASE = "interbase";
  var TMP_DBSYSTEMVALUES_MARIADB = "mariadb";
  var TMP_DBSYSTEMVALUES_NETEZZA = "netezza";
  var TMP_DBSYSTEMVALUES_PERVASIVE = "pervasive";
  var TMP_DBSYSTEMVALUES_POINTBASE = "pointbase";
  var TMP_DBSYSTEMVALUES_SQLITE = "sqlite";
  var TMP_DBSYSTEMVALUES_SYBASE = "sybase";
  var TMP_DBSYSTEMVALUES_TERADATA = "teradata";
  var TMP_DBSYSTEMVALUES_VERTICA = "vertica";
  var TMP_DBSYSTEMVALUES_H2 = "h2";
  var TMP_DBSYSTEMVALUES_COLDFUSION = "coldfusion";
  var TMP_DBSYSTEMVALUES_CASSANDRA = "cassandra";
  var TMP_DBSYSTEMVALUES_HBASE = "hbase";
  var TMP_DBSYSTEMVALUES_MONGODB = "mongodb";
  var TMP_DBSYSTEMVALUES_REDIS = "redis";
  var TMP_DBSYSTEMVALUES_COUCHBASE = "couchbase";
  var TMP_DBSYSTEMVALUES_COUCHDB = "couchdb";
  var TMP_DBSYSTEMVALUES_COSMOSDB = "cosmosdb";
  var TMP_DBSYSTEMVALUES_DYNAMODB = "dynamodb";
  var TMP_DBSYSTEMVALUES_NEO4J = "neo4j";
  var TMP_DBSYSTEMVALUES_GEODE = "geode";
  var TMP_DBSYSTEMVALUES_ELASTICSEARCH = "elasticsearch";
  var TMP_DBSYSTEMVALUES_MEMCACHED = "memcached";
  var TMP_DBSYSTEMVALUES_COCKROACHDB = "cockroachdb";
  exports.DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL;
  exports.DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL;
  exports.DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL;
  exports.DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE;
  exports.DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB2;
  exports.DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL;
  exports.DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT;
  exports.DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE;
  exports.DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE;
  exports.DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB;
  exports.DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS;
  exports.DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB;
  exports.DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB;
  exports.DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES;
  exports.DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL;
  exports.DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB;
  exports.DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE;
  exports.DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS;
  exports.DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD;
  exports.DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY;
  exports.DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER;
  exports.DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX;
  exports.DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB;
  exports.DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE;
  exports.DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB;
  exports.DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA;
  exports.DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE;
  exports.DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE;
  exports.DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE;
  exports.DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE;
  exports.DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA;
  exports.DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA;
  exports.DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H2;
  exports.DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION;
  exports.DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA;
  exports.DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE;
  exports.DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB;
  exports.DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS;
  exports.DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE;
  exports.DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB;
  exports.DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB;
  exports.DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB;
  exports.DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J;
  exports.DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE;
  exports.DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH;
  exports.DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED;
  exports.DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB;
  exports.DbSystemValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_DBSYSTEMVALUES_OTHER_SQL,
    TMP_DBSYSTEMVALUES_MSSQL,
    TMP_DBSYSTEMVALUES_MYSQL,
    TMP_DBSYSTEMVALUES_ORACLE,
    TMP_DBSYSTEMVALUES_DB2,
    TMP_DBSYSTEMVALUES_POSTGRESQL,
    TMP_DBSYSTEMVALUES_REDSHIFT,
    TMP_DBSYSTEMVALUES_HIVE,
    TMP_DBSYSTEMVALUES_CLOUDSCAPE,
    TMP_DBSYSTEMVALUES_HSQLDB,
    TMP_DBSYSTEMVALUES_PROGRESS,
    TMP_DBSYSTEMVALUES_MAXDB,
    TMP_DBSYSTEMVALUES_HANADB,
    TMP_DBSYSTEMVALUES_INGRES,
    TMP_DBSYSTEMVALUES_FIRSTSQL,
    TMP_DBSYSTEMVALUES_EDB,
    TMP_DBSYSTEMVALUES_CACHE,
    TMP_DBSYSTEMVALUES_ADABAS,
    TMP_DBSYSTEMVALUES_FIREBIRD,
    TMP_DBSYSTEMVALUES_DERBY,
    TMP_DBSYSTEMVALUES_FILEMAKER,
    TMP_DBSYSTEMVALUES_INFORMIX,
    TMP_DBSYSTEMVALUES_INSTANTDB,
    TMP_DBSYSTEMVALUES_INTERBASE,
    TMP_DBSYSTEMVALUES_MARIADB,
    TMP_DBSYSTEMVALUES_NETEZZA,
    TMP_DBSYSTEMVALUES_PERVASIVE,
    TMP_DBSYSTEMVALUES_POINTBASE,
    TMP_DBSYSTEMVALUES_SQLITE,
    TMP_DBSYSTEMVALUES_SYBASE,
    TMP_DBSYSTEMVALUES_TERADATA,
    TMP_DBSYSTEMVALUES_VERTICA,
    TMP_DBSYSTEMVALUES_H2,
    TMP_DBSYSTEMVALUES_COLDFUSION,
    TMP_DBSYSTEMVALUES_CASSANDRA,
    TMP_DBSYSTEMVALUES_HBASE,
    TMP_DBSYSTEMVALUES_MONGODB,
    TMP_DBSYSTEMVALUES_REDIS,
    TMP_DBSYSTEMVALUES_COUCHBASE,
    TMP_DBSYSTEMVALUES_COUCHDB,
    TMP_DBSYSTEMVALUES_COSMOSDB,
    TMP_DBSYSTEMVALUES_DYNAMODB,
    TMP_DBSYSTEMVALUES_NEO4J,
    TMP_DBSYSTEMVALUES_GEODE,
    TMP_DBSYSTEMVALUES_ELASTICSEARCH,
    TMP_DBSYSTEMVALUES_MEMCACHED,
    TMP_DBSYSTEMVALUES_COCKROACHDB
  ]);
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL = "all";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = "each_quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = "quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = "local_quorum";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE = "one";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO = "two";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE = "three";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = "local_one";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY = "any";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = "serial";
  var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = "local_serial";
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL;
  exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL;
  exports.DbCassandraConsistencyLevelValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL
  ]);
  var TMP_FAASTRIGGERVALUES_DATASOURCE = "datasource";
  var TMP_FAASTRIGGERVALUES_HTTP = "http";
  var TMP_FAASTRIGGERVALUES_PUBSUB = "pubsub";
  var TMP_FAASTRIGGERVALUES_TIMER = "timer";
  var TMP_FAASTRIGGERVALUES_OTHER = "other";
  exports.FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE;
  exports.FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP;
  exports.FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB;
  exports.FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER;
  exports.FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER;
  exports.FaasTriggerValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASTRIGGERVALUES_DATASOURCE,
    TMP_FAASTRIGGERVALUES_HTTP,
    TMP_FAASTRIGGERVALUES_PUBSUB,
    TMP_FAASTRIGGERVALUES_TIMER,
    TMP_FAASTRIGGERVALUES_OTHER
  ]);
  var TMP_FAASDOCUMENTOPERATIONVALUES_INSERT = "insert";
  var TMP_FAASDOCUMENTOPERATIONVALUES_EDIT = "edit";
  var TMP_FAASDOCUMENTOPERATIONVALUES_DELETE = "delete";
  exports.FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT;
  exports.FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT;
  exports.FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE;
  exports.FaasDocumentOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASDOCUMENTOPERATIONVALUES_INSERT,
    TMP_FAASDOCUMENTOPERATIONVALUES_EDIT,
    TMP_FAASDOCUMENTOPERATIONVALUES_DELETE
  ]);
  var TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
  var TMP_FAASINVOKEDPROVIDERVALUES_AWS = "aws";
  var TMP_FAASINVOKEDPROVIDERVALUES_AZURE = "azure";
  var TMP_FAASINVOKEDPROVIDERVALUES_GCP = "gcp";
  exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD;
  exports.FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS;
  exports.FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE;
  exports.FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP;
  exports.FaasInvokedProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
    TMP_FAASINVOKEDPROVIDERVALUES_AWS,
    TMP_FAASINVOKEDPROVIDERVALUES_AZURE,
    TMP_FAASINVOKEDPROVIDERVALUES_GCP
  ]);
  var TMP_NETTRANSPORTVALUES_IP_TCP = "ip_tcp";
  var TMP_NETTRANSPORTVALUES_IP_UDP = "ip_udp";
  var TMP_NETTRANSPORTVALUES_IP = "ip";
  var TMP_NETTRANSPORTVALUES_UNIX = "unix";
  var TMP_NETTRANSPORTVALUES_PIPE = "pipe";
  var TMP_NETTRANSPORTVALUES_INPROC = "inproc";
  var TMP_NETTRANSPORTVALUES_OTHER = "other";
  exports.NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP;
  exports.NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP;
  exports.NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP;
  exports.NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX;
  exports.NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE;
  exports.NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC;
  exports.NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER;
  exports.NetTransportValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETTRANSPORTVALUES_IP_TCP,
    TMP_NETTRANSPORTVALUES_IP_UDP,
    TMP_NETTRANSPORTVALUES_IP,
    TMP_NETTRANSPORTVALUES_UNIX,
    TMP_NETTRANSPORTVALUES_PIPE,
    TMP_NETTRANSPORTVALUES_INPROC,
    TMP_NETTRANSPORTVALUES_OTHER
  ]);
  var TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI = "wifi";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED = "wired";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_CELL = "cell";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = "unavailable";
  var TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = "unknown";
  exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI;
  exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED;
  exports.NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL;
  exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE;
  exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN;
  exports.NetHostConnectionTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI,
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED,
    TMP_NETHOSTCONNECTIONTYPEVALUES_CELL,
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN
  ]);
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = "gprs";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = "edge";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = "umts";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = "cdma";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = "evdo_0";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = "evdo_a";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = "cdma2000_1xrtt";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = "hsdpa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = "hsupa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = "hspa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = "iden";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = "evdo_b";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE = "lte";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = "ehrpd";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = "hspap";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM = "gsm";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = "td_scdma";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = "iwlan";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR = "nr";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = "nrnsa";
  var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = "lte_ca";
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA;
  exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA;
  exports.NetHostConnectionSubtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA
  ]);
  var TMP_HTTPFLAVORVALUES_HTTP_1_0 = "1.0";
  var TMP_HTTPFLAVORVALUES_HTTP_1_1 = "1.1";
  var TMP_HTTPFLAVORVALUES_HTTP_2_0 = "2.0";
  var TMP_HTTPFLAVORVALUES_SPDY = "SPDY";
  var TMP_HTTPFLAVORVALUES_QUIC = "QUIC";
  exports.HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_0;
  exports.HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_1;
  exports.HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_0;
  exports.HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY;
  exports.HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC;
  exports.HttpFlavorValues = {
    HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_0,
    HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_1,
    HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_0,
    SPDY: TMP_HTTPFLAVORVALUES_SPDY,
    QUIC: TMP_HTTPFLAVORVALUES_QUIC
  };
  var TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE = "queue";
  var TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC = "topic";
  exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE;
  exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC;
  exports.MessagingDestinationKindValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE,
    TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC
  ]);
  var TMP_MESSAGINGOPERATIONVALUES_RECEIVE = "receive";
  var TMP_MESSAGINGOPERATIONVALUES_PROCESS = "process";
  exports.MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE;
  exports.MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS;
  exports.MessagingOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGINGOPERATIONVALUES_RECEIVE,
    TMP_MESSAGINGOPERATIONVALUES_PROCESS
  ]);
  var TMP_RPCGRPCSTATUSCODEVALUES_OK = 0;
  var TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED = 1;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN = 2;
  var TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = 3;
  var TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = 4;
  var TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND = 5;
  var TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = 6;
  var TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = 7;
  var TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = 8;
  var TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = 9;
  var TMP_RPCGRPCSTATUSCODEVALUES_ABORTED = 10;
  var TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = 11;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = 12;
  var TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL = 13;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = 14;
  var TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS = 15;
  var TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = 16;
  exports.RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK;
  exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED;
  exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN;
  exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT;
  exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED;
  exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND;
  exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS;
  exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED;
  exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED;
  exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION;
  exports.RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED;
  exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE;
  exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED;
  exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL;
  exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE;
  exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS;
  exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED;
  exports.RpcGrpcStatusCodeValues = {
    OK: TMP_RPCGRPCSTATUSCODEVALUES_OK,
    CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED,
    UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN,
    INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
    DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
    NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
    ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
    PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
    RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
    FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
    ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED,
    OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
    UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
    INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL,
    UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
    DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
    UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED
  };
  var TMP_MESSAGETYPEVALUES_SENT = "SENT";
  var TMP_MESSAGETYPEVALUES_RECEIVED = "RECEIVED";
  exports.MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT;
  exports.MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED;
  exports.MessageTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_MESSAGETYPEVALUES_SENT,
    TMP_MESSAGETYPEVALUES_RECEIVED
  ]);
});

// ../../node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js
var require_trace5 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(require_SemanticAttributes4(), exports);
});

// ../../node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js
var require_SemanticResourceAttributes4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SEMRESATTRS_K8S_STATEFULSET_NAME = exports.SEMRESATTRS_K8S_STATEFULSET_UID = exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = exports.SEMRESATTRS_K8S_REPLICASET_NAME = exports.SEMRESATTRS_K8S_REPLICASET_UID = exports.SEMRESATTRS_K8S_CONTAINER_NAME = exports.SEMRESATTRS_K8S_POD_NAME = exports.SEMRESATTRS_K8S_POD_UID = exports.SEMRESATTRS_K8S_NAMESPACE_NAME = exports.SEMRESATTRS_K8S_NODE_UID = exports.SEMRESATTRS_K8S_NODE_NAME = exports.SEMRESATTRS_K8S_CLUSTER_NAME = exports.SEMRESATTRS_HOST_IMAGE_VERSION = exports.SEMRESATTRS_HOST_IMAGE_ID = exports.SEMRESATTRS_HOST_IMAGE_NAME = exports.SEMRESATTRS_HOST_ARCH = exports.SEMRESATTRS_HOST_TYPE = exports.SEMRESATTRS_HOST_NAME = exports.SEMRESATTRS_HOST_ID = exports.SEMRESATTRS_FAAS_MAX_MEMORY = exports.SEMRESATTRS_FAAS_INSTANCE = exports.SEMRESATTRS_FAAS_VERSION = exports.SEMRESATTRS_FAAS_ID = exports.SEMRESATTRS_FAAS_NAME = exports.SEMRESATTRS_DEVICE_MODEL_NAME = exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = exports.SEMRESATTRS_DEVICE_ID = exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = exports.SEMRESATTRS_CONTAINER_RUNTIME = exports.SEMRESATTRS_CONTAINER_ID = exports.SEMRESATTRS_CONTAINER_NAME = exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = exports.SEMRESATTRS_AWS_ECS_TASK_ARN = exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = exports.SEMRESATTRS_CLOUD_PLATFORM = exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = exports.SEMRESATTRS_CLOUD_REGION = exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = exports.SEMRESATTRS_CLOUD_PROVIDER = undefined;
  exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = exports.CLOUDPLATFORMVALUES_AZURE_AKS = exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = exports.CLOUDPLATFORMVALUES_AZURE_VM = exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = exports.CLOUDPLATFORMVALUES_AWS_EKS = exports.CLOUDPLATFORMVALUES_AWS_ECS = exports.CLOUDPLATFORMVALUES_AWS_EC2 = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = exports.CloudProviderValues = exports.CLOUDPROVIDERVALUES_GCP = exports.CLOUDPROVIDERVALUES_AZURE = exports.CLOUDPROVIDERVALUES_AWS = exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = exports.SemanticResourceAttributes = exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = exports.SEMRESATTRS_WEBENGINE_VERSION = exports.SEMRESATTRS_WEBENGINE_NAME = exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = exports.SEMRESATTRS_TELEMETRY_SDK_NAME = exports.SEMRESATTRS_SERVICE_VERSION = exports.SEMRESATTRS_SERVICE_INSTANCE_ID = exports.SEMRESATTRS_SERVICE_NAMESPACE = exports.SEMRESATTRS_SERVICE_NAME = exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = exports.SEMRESATTRS_PROCESS_OWNER = exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = exports.SEMRESATTRS_PROCESS_COMMAND_LINE = exports.SEMRESATTRS_PROCESS_COMMAND = exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = exports.SEMRESATTRS_PROCESS_PID = exports.SEMRESATTRS_OS_VERSION = exports.SEMRESATTRS_OS_NAME = exports.SEMRESATTRS_OS_DESCRIPTION = exports.SEMRESATTRS_OS_TYPE = exports.SEMRESATTRS_K8S_CRONJOB_NAME = exports.SEMRESATTRS_K8S_CRONJOB_UID = exports.SEMRESATTRS_K8S_JOB_NAME = exports.SEMRESATTRS_K8S_JOB_UID = exports.SEMRESATTRS_K8S_DAEMONSET_NAME = exports.SEMRESATTRS_K8S_DAEMONSET_UID = undefined;
  exports.TelemetrySdkLanguageValues = exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = exports.TELEMETRYSDKLANGUAGEVALUES_PHP = exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = exports.TELEMETRYSDKLANGUAGEVALUES_GO = exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = exports.TELEMETRYSDKLANGUAGEVALUES_CPP = exports.OsTypeValues = exports.OSTYPEVALUES_Z_OS = exports.OSTYPEVALUES_SOLARIS = exports.OSTYPEVALUES_AIX = exports.OSTYPEVALUES_HPUX = exports.OSTYPEVALUES_DRAGONFLYBSD = exports.OSTYPEVALUES_OPENBSD = exports.OSTYPEVALUES_NETBSD = exports.OSTYPEVALUES_FREEBSD = exports.OSTYPEVALUES_DARWIN = exports.OSTYPEVALUES_LINUX = exports.OSTYPEVALUES_WINDOWS = exports.HostArchValues = exports.HOSTARCHVALUES_X86 = exports.HOSTARCHVALUES_PPC64 = exports.HOSTARCHVALUES_PPC32 = exports.HOSTARCHVALUES_IA64 = exports.HOSTARCHVALUES_ARM64 = exports.HOSTARCHVALUES_ARM32 = exports.HOSTARCHVALUES_AMD64 = exports.AwsEcsLaunchtypeValues = exports.AWSECSLAUNCHTYPEVALUES_FARGATE = exports.AWSECSLAUNCHTYPEVALUES_EC2 = exports.CloudPlatformValues = exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = undefined;
  var utils_1 = require_utils10();
  var TMP_CLOUD_PROVIDER = "cloud.provider";
  var TMP_CLOUD_ACCOUNT_ID = "cloud.account.id";
  var TMP_CLOUD_REGION = "cloud.region";
  var TMP_CLOUD_AVAILABILITY_ZONE = "cloud.availability_zone";
  var TMP_CLOUD_PLATFORM = "cloud.platform";
  var TMP_AWS_ECS_CONTAINER_ARN = "aws.ecs.container.arn";
  var TMP_AWS_ECS_CLUSTER_ARN = "aws.ecs.cluster.arn";
  var TMP_AWS_ECS_LAUNCHTYPE = "aws.ecs.launchtype";
  var TMP_AWS_ECS_TASK_ARN = "aws.ecs.task.arn";
  var TMP_AWS_ECS_TASK_FAMILY = "aws.ecs.task.family";
  var TMP_AWS_ECS_TASK_REVISION = "aws.ecs.task.revision";
  var TMP_AWS_EKS_CLUSTER_ARN = "aws.eks.cluster.arn";
  var TMP_AWS_LOG_GROUP_NAMES = "aws.log.group.names";
  var TMP_AWS_LOG_GROUP_ARNS = "aws.log.group.arns";
  var TMP_AWS_LOG_STREAM_NAMES = "aws.log.stream.names";
  var TMP_AWS_LOG_STREAM_ARNS = "aws.log.stream.arns";
  var TMP_CONTAINER_NAME = "container.name";
  var TMP_CONTAINER_ID = "container.id";
  var TMP_CONTAINER_RUNTIME = "container.runtime";
  var TMP_CONTAINER_IMAGE_NAME = "container.image.name";
  var TMP_CONTAINER_IMAGE_TAG = "container.image.tag";
  var TMP_DEPLOYMENT_ENVIRONMENT = "deployment.environment";
  var TMP_DEVICE_ID = "device.id";
  var TMP_DEVICE_MODEL_IDENTIFIER = "device.model.identifier";
  var TMP_DEVICE_MODEL_NAME = "device.model.name";
  var TMP_FAAS_NAME = "faas.name";
  var TMP_FAAS_ID = "faas.id";
  var TMP_FAAS_VERSION = "faas.version";
  var TMP_FAAS_INSTANCE = "faas.instance";
  var TMP_FAAS_MAX_MEMORY = "faas.max_memory";
  var TMP_HOST_ID = "host.id";
  var TMP_HOST_NAME = "host.name";
  var TMP_HOST_TYPE = "host.type";
  var TMP_HOST_ARCH = "host.arch";
  var TMP_HOST_IMAGE_NAME = "host.image.name";
  var TMP_HOST_IMAGE_ID = "host.image.id";
  var TMP_HOST_IMAGE_VERSION = "host.image.version";
  var TMP_K8S_CLUSTER_NAME = "k8s.cluster.name";
  var TMP_K8S_NODE_NAME = "k8s.node.name";
  var TMP_K8S_NODE_UID = "k8s.node.uid";
  var TMP_K8S_NAMESPACE_NAME = "k8s.namespace.name";
  var TMP_K8S_POD_UID = "k8s.pod.uid";
  var TMP_K8S_POD_NAME = "k8s.pod.name";
  var TMP_K8S_CONTAINER_NAME = "k8s.container.name";
  var TMP_K8S_REPLICASET_UID = "k8s.replicaset.uid";
  var TMP_K8S_REPLICASET_NAME = "k8s.replicaset.name";
  var TMP_K8S_DEPLOYMENT_UID = "k8s.deployment.uid";
  var TMP_K8S_DEPLOYMENT_NAME = "k8s.deployment.name";
  var TMP_K8S_STATEFULSET_UID = "k8s.statefulset.uid";
  var TMP_K8S_STATEFULSET_NAME = "k8s.statefulset.name";
  var TMP_K8S_DAEMONSET_UID = "k8s.daemonset.uid";
  var TMP_K8S_DAEMONSET_NAME = "k8s.daemonset.name";
  var TMP_K8S_JOB_UID = "k8s.job.uid";
  var TMP_K8S_JOB_NAME = "k8s.job.name";
  var TMP_K8S_CRONJOB_UID = "k8s.cronjob.uid";
  var TMP_K8S_CRONJOB_NAME = "k8s.cronjob.name";
  var TMP_OS_TYPE = "os.type";
  var TMP_OS_DESCRIPTION = "os.description";
  var TMP_OS_NAME = "os.name";
  var TMP_OS_VERSION = "os.version";
  var TMP_PROCESS_PID = "process.pid";
  var TMP_PROCESS_EXECUTABLE_NAME = "process.executable.name";
  var TMP_PROCESS_EXECUTABLE_PATH = "process.executable.path";
  var TMP_PROCESS_COMMAND = "process.command";
  var TMP_PROCESS_COMMAND_LINE = "process.command_line";
  var TMP_PROCESS_COMMAND_ARGS = "process.command_args";
  var TMP_PROCESS_OWNER = "process.owner";
  var TMP_PROCESS_RUNTIME_NAME = "process.runtime.name";
  var TMP_PROCESS_RUNTIME_VERSION = "process.runtime.version";
  var TMP_PROCESS_RUNTIME_DESCRIPTION = "process.runtime.description";
  var TMP_SERVICE_NAME = "service.name";
  var TMP_SERVICE_NAMESPACE = "service.namespace";
  var TMP_SERVICE_INSTANCE_ID = "service.instance.id";
  var TMP_SERVICE_VERSION = "service.version";
  var TMP_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
  var TMP_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
  var TMP_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
  var TMP_TELEMETRY_AUTO_VERSION = "telemetry.auto.version";
  var TMP_WEBENGINE_NAME = "webengine.name";
  var TMP_WEBENGINE_VERSION = "webengine.version";
  var TMP_WEBENGINE_DESCRIPTION = "webengine.description";
  exports.SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER;
  exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID;
  exports.SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION;
  exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE;
  exports.SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM;
  exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN;
  exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN;
  exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE;
  exports.SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN;
  exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY;
  exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION;
  exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN;
  exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES;
  exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS;
  exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES;
  exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS;
  exports.SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME;
  exports.SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID;
  exports.SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME;
  exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME;
  exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG;
  exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT;
  exports.SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID;
  exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER;
  exports.SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME;
  exports.SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME;
  exports.SEMRESATTRS_FAAS_ID = TMP_FAAS_ID;
  exports.SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION;
  exports.SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE;
  exports.SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY;
  exports.SEMRESATTRS_HOST_ID = TMP_HOST_ID;
  exports.SEMRESATTRS_HOST_NAME = TMP_HOST_NAME;
  exports.SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE;
  exports.SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH;
  exports.SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME;
  exports.SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID;
  exports.SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION;
  exports.SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME;
  exports.SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME;
  exports.SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID;
  exports.SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME;
  exports.SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID;
  exports.SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME;
  exports.SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME;
  exports.SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID;
  exports.SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME;
  exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID;
  exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME;
  exports.SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID;
  exports.SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME;
  exports.SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID;
  exports.SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME;
  exports.SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID;
  exports.SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME;
  exports.SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID;
  exports.SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME;
  exports.SEMRESATTRS_OS_TYPE = TMP_OS_TYPE;
  exports.SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION;
  exports.SEMRESATTRS_OS_NAME = TMP_OS_NAME;
  exports.SEMRESATTRS_OS_VERSION = TMP_OS_VERSION;
  exports.SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID;
  exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME;
  exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH;
  exports.SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND;
  exports.SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE;
  exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS;
  exports.SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER;
  exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME;
  exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION;
  exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION;
  exports.SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME;
  exports.SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE;
  exports.SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID;
  exports.SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION;
  exports.SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME;
  exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE;
  exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION;
  exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION;
  exports.SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME;
  exports.SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION;
  exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION;
  exports.SemanticResourceAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUD_PROVIDER,
    TMP_CLOUD_ACCOUNT_ID,
    TMP_CLOUD_REGION,
    TMP_CLOUD_AVAILABILITY_ZONE,
    TMP_CLOUD_PLATFORM,
    TMP_AWS_ECS_CONTAINER_ARN,
    TMP_AWS_ECS_CLUSTER_ARN,
    TMP_AWS_ECS_LAUNCHTYPE,
    TMP_AWS_ECS_TASK_ARN,
    TMP_AWS_ECS_TASK_FAMILY,
    TMP_AWS_ECS_TASK_REVISION,
    TMP_AWS_EKS_CLUSTER_ARN,
    TMP_AWS_LOG_GROUP_NAMES,
    TMP_AWS_LOG_GROUP_ARNS,
    TMP_AWS_LOG_STREAM_NAMES,
    TMP_AWS_LOG_STREAM_ARNS,
    TMP_CONTAINER_NAME,
    TMP_CONTAINER_ID,
    TMP_CONTAINER_RUNTIME,
    TMP_CONTAINER_IMAGE_NAME,
    TMP_CONTAINER_IMAGE_TAG,
    TMP_DEPLOYMENT_ENVIRONMENT,
    TMP_DEVICE_ID,
    TMP_DEVICE_MODEL_IDENTIFIER,
    TMP_DEVICE_MODEL_NAME,
    TMP_FAAS_NAME,
    TMP_FAAS_ID,
    TMP_FAAS_VERSION,
    TMP_FAAS_INSTANCE,
    TMP_FAAS_MAX_MEMORY,
    TMP_HOST_ID,
    TMP_HOST_NAME,
    TMP_HOST_TYPE,
    TMP_HOST_ARCH,
    TMP_HOST_IMAGE_NAME,
    TMP_HOST_IMAGE_ID,
    TMP_HOST_IMAGE_VERSION,
    TMP_K8S_CLUSTER_NAME,
    TMP_K8S_NODE_NAME,
    TMP_K8S_NODE_UID,
    TMP_K8S_NAMESPACE_NAME,
    TMP_K8S_POD_UID,
    TMP_K8S_POD_NAME,
    TMP_K8S_CONTAINER_NAME,
    TMP_K8S_REPLICASET_UID,
    TMP_K8S_REPLICASET_NAME,
    TMP_K8S_DEPLOYMENT_UID,
    TMP_K8S_DEPLOYMENT_NAME,
    TMP_K8S_STATEFULSET_UID,
    TMP_K8S_STATEFULSET_NAME,
    TMP_K8S_DAEMONSET_UID,
    TMP_K8S_DAEMONSET_NAME,
    TMP_K8S_JOB_UID,
    TMP_K8S_JOB_NAME,
    TMP_K8S_CRONJOB_UID,
    TMP_K8S_CRONJOB_NAME,
    TMP_OS_TYPE,
    TMP_OS_DESCRIPTION,
    TMP_OS_NAME,
    TMP_OS_VERSION,
    TMP_PROCESS_PID,
    TMP_PROCESS_EXECUTABLE_NAME,
    TMP_PROCESS_EXECUTABLE_PATH,
    TMP_PROCESS_COMMAND,
    TMP_PROCESS_COMMAND_LINE,
    TMP_PROCESS_COMMAND_ARGS,
    TMP_PROCESS_OWNER,
    TMP_PROCESS_RUNTIME_NAME,
    TMP_PROCESS_RUNTIME_VERSION,
    TMP_PROCESS_RUNTIME_DESCRIPTION,
    TMP_SERVICE_NAME,
    TMP_SERVICE_NAMESPACE,
    TMP_SERVICE_INSTANCE_ID,
    TMP_SERVICE_VERSION,
    TMP_TELEMETRY_SDK_NAME,
    TMP_TELEMETRY_SDK_LANGUAGE,
    TMP_TELEMETRY_SDK_VERSION,
    TMP_TELEMETRY_AUTO_VERSION,
    TMP_WEBENGINE_NAME,
    TMP_WEBENGINE_VERSION,
    TMP_WEBENGINE_DESCRIPTION
  ]);
  var TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
  var TMP_CLOUDPROVIDERVALUES_AWS = "aws";
  var TMP_CLOUDPROVIDERVALUES_AZURE = "azure";
  var TMP_CLOUDPROVIDERVALUES_GCP = "gcp";
  exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD;
  exports.CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS;
  exports.CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE;
  exports.CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP;
  exports.CloudProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
    TMP_CLOUDPROVIDERVALUES_AWS,
    TMP_CLOUDPROVIDERVALUES_AZURE,
    TMP_CLOUDPROVIDERVALUES_GCP
  ]);
  var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = "alibaba_cloud_ecs";
  var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = "alibaba_cloud_fc";
  var TMP_CLOUDPLATFORMVALUES_AWS_EC2 = "aws_ec2";
  var TMP_CLOUDPLATFORMVALUES_AWS_ECS = "aws_ecs";
  var TMP_CLOUDPLATFORMVALUES_AWS_EKS = "aws_eks";
  var TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA = "aws_lambda";
  var TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = "aws_elastic_beanstalk";
  var TMP_CLOUDPLATFORMVALUES_AZURE_VM = "azure_vm";
  var TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = "azure_container_instances";
  var TMP_CLOUDPLATFORMVALUES_AZURE_AKS = "azure_aks";
  var TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = "azure_functions";
  var TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = "azure_app_service";
  var TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = "gcp_compute_engine";
  var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = "gcp_cloud_run";
  var TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = "gcp_kubernetes_engine";
  var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = "gcp_cloud_functions";
  var TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE = "gcp_app_engine";
  exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS;
  exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC;
  exports.CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC2;
  exports.CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS;
  exports.CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS;
  exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA;
  exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK;
  exports.CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM;
  exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES;
  exports.CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS;
  exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS;
  exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE;
  exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE;
  exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN;
  exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE;
  exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS;
  exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE;
  exports.CloudPlatformValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
    TMP_CLOUDPLATFORMVALUES_AWS_EC2,
    TMP_CLOUDPLATFORMVALUES_AWS_ECS,
    TMP_CLOUDPLATFORMVALUES_AWS_EKS,
    TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA,
    TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
    TMP_CLOUDPLATFORMVALUES_AZURE_VM,
    TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
    TMP_CLOUDPLATFORMVALUES_AZURE_AKS,
    TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
    TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
    TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
    TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
    TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE
  ]);
  var TMP_AWSECSLAUNCHTYPEVALUES_EC2 = "ec2";
  var TMP_AWSECSLAUNCHTYPEVALUES_FARGATE = "fargate";
  exports.AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC2;
  exports.AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE;
  exports.AwsEcsLaunchtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_AWSECSLAUNCHTYPEVALUES_EC2,
    TMP_AWSECSLAUNCHTYPEVALUES_FARGATE
  ]);
  var TMP_HOSTARCHVALUES_AMD64 = "amd64";
  var TMP_HOSTARCHVALUES_ARM32 = "arm32";
  var TMP_HOSTARCHVALUES_ARM64 = "arm64";
  var TMP_HOSTARCHVALUES_IA64 = "ia64";
  var TMP_HOSTARCHVALUES_PPC32 = "ppc32";
  var TMP_HOSTARCHVALUES_PPC64 = "ppc64";
  var TMP_HOSTARCHVALUES_X86 = "x86";
  exports.HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD64;
  exports.HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM32;
  exports.HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM64;
  exports.HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA64;
  exports.HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC32;
  exports.HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC64;
  exports.HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X86;
  exports.HostArchValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_HOSTARCHVALUES_AMD64,
    TMP_HOSTARCHVALUES_ARM32,
    TMP_HOSTARCHVALUES_ARM64,
    TMP_HOSTARCHVALUES_IA64,
    TMP_HOSTARCHVALUES_PPC32,
    TMP_HOSTARCHVALUES_PPC64,
    TMP_HOSTARCHVALUES_X86
  ]);
  var TMP_OSTYPEVALUES_WINDOWS = "windows";
  var TMP_OSTYPEVALUES_LINUX = "linux";
  var TMP_OSTYPEVALUES_DARWIN = "darwin";
  var TMP_OSTYPEVALUES_FREEBSD = "freebsd";
  var TMP_OSTYPEVALUES_NETBSD = "netbsd";
  var TMP_OSTYPEVALUES_OPENBSD = "openbsd";
  var TMP_OSTYPEVALUES_DRAGONFLYBSD = "dragonflybsd";
  var TMP_OSTYPEVALUES_HPUX = "hpux";
  var TMP_OSTYPEVALUES_AIX = "aix";
  var TMP_OSTYPEVALUES_SOLARIS = "solaris";
  var TMP_OSTYPEVALUES_Z_OS = "z_os";
  exports.OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS;
  exports.OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX;
  exports.OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN;
  exports.OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD;
  exports.OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD;
  exports.OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD;
  exports.OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD;
  exports.OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX;
  exports.OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX;
  exports.OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS;
  exports.OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS;
  exports.OsTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_OSTYPEVALUES_WINDOWS,
    TMP_OSTYPEVALUES_LINUX,
    TMP_OSTYPEVALUES_DARWIN,
    TMP_OSTYPEVALUES_FREEBSD,
    TMP_OSTYPEVALUES_NETBSD,
    TMP_OSTYPEVALUES_OPENBSD,
    TMP_OSTYPEVALUES_DRAGONFLYBSD,
    TMP_OSTYPEVALUES_HPUX,
    TMP_OSTYPEVALUES_AIX,
    TMP_OSTYPEVALUES_SOLARIS,
    TMP_OSTYPEVALUES_Z_OS
  ]);
  var TMP_TELEMETRYSDKLANGUAGEVALUES_CPP = "cpp";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET = "dotnet";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG = "erlang";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_GO = "go";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA = "java";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS = "nodejs";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_PHP = "php";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON = "python";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY = "ruby";
  var TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS = "webjs";
  exports.TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP;
  exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET;
  exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG;
  exports.TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO;
  exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA;
  exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS;
  exports.TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP;
  exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON;
  exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY;
  exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS;
  exports.TelemetrySdkLanguageValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
    TMP_TELEMETRYSDKLANGUAGEVALUES_CPP,
    TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET,
    TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG,
    TMP_TELEMETRYSDKLANGUAGEVALUES_GO,
    TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA,
    TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS,
    TMP_TELEMETRYSDKLANGUAGEVALUES_PHP,
    TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON,
    TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY,
    TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS
  ]);
});

// ../../node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js
var require_resource4 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(require_SemanticResourceAttributes4(), exports);
});

// ../../node_modules/@opentelemetry/semantic-conventions/build/src/index.js
var require_src12 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(require_trace5(), exports);
  __exportStar2(require_resource4(), exports);
});

// ../../node_modules/prisma-instrumentation-5-x/dist/chunk-VVAFFO6L.js
var require_chunk_VVAFFO6L = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var chunk_VVAFFO6L_exports = {};
  __export2(chunk_VVAFFO6L_exports, {
    ActiveTracingHelper: () => ActiveTracingHelper
  });
  module.exports = __toCommonJS(chunk_VVAFFO6L_exports);
  var import_api = require_src();
  var import_sdk_trace_base = require_src11();
  var showAllTraces = process.env.PRISMA_SHOW_ALL_TRACES === "true";
  var nonSampledTraceParent = `00-10-10-00`;
  var ActiveTracingHelper = class {
    constructor({ traceMiddleware }) {
      this.traceMiddleware = traceMiddleware;
    }
    isEnabled() {
      return true;
    }
    getTraceParent(context) {
      const span = import_api.trace.getSpanContext(context ?? import_api.context.active());
      if (span) {
        return `00-${span.traceId}-${span.spanId}-0${span.traceFlags}`;
      }
      return nonSampledTraceParent;
    }
    createEngineSpan(engineSpanEvent) {
      const tracer = import_api.trace.getTracer("prisma");
      engineSpanEvent.spans.forEach((engineSpan) => {
        const spanContext = {
          traceId: engineSpan.trace_id,
          spanId: engineSpan.span_id,
          traceFlags: import_api.TraceFlags.SAMPLED
        };
        const links = engineSpan.links?.map((link) => {
          return {
            context: {
              traceId: link.trace_id,
              spanId: link.span_id,
              traceFlags: import_api.TraceFlags.SAMPLED
            }
          };
        });
        const span = new import_sdk_trace_base.Span(tracer, import_api.ROOT_CONTEXT, engineSpan.name, spanContext, import_api.SpanKind.INTERNAL, engineSpan.parent_span_id, links, engineSpan.start_time);
        if (engineSpan.attributes) {
          span.setAttributes(engineSpan.attributes);
        }
        span.end(engineSpan.end_time);
      });
    }
    getActiveContext() {
      return import_api.context.active();
    }
    runInChildSpan(options, callback) {
      if (typeof options === "string") {
        options = { name: options };
      }
      if (options.internal && !showAllTraces) {
        return callback();
      }
      if (options.middleware && !this.traceMiddleware) {
        return callback();
      }
      const tracer = import_api.trace.getTracer("prisma");
      const context = options.context ?? this.getActiveContext();
      const name = `prisma:client:${options.name}`;
      if (options.active === false) {
        const span = tracer.startSpan(name, options, context);
        return endSpan(span, callback(span, context));
      }
      return tracer.startActiveSpan(name, options, (span) => endSpan(span, callback(span, context)));
    }
  };
  function endSpan(span, result) {
    if (isPromiseLike(result)) {
      return result.then((value) => {
        span.end();
        return value;
      }, (reason) => {
        span.end();
        throw reason;
      });
    }
    span.end();
    return result;
  }
  function isPromiseLike(value) {
    return value != null && typeof value["then"] === "function";
  }
});

// ../../node_modules/prisma-instrumentation-5-x/dist/chunk-FTA5RKYX.js
var require_chunk_FTA5RKYX = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var chunk_FTA5RKYX_exports = {};
  __export2(chunk_FTA5RKYX_exports, {
    __commonJS: () => __commonJS2
  });
  module.exports = __toCommonJS(chunk_FTA5RKYX_exports);
  var __getOwnPropNames22 = Object.getOwnPropertyNames;
  var __commonJS2 = (cb2, mod) => function __require() {
    return mod || (0, cb2[__getOwnPropNames22(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
});

// ../../node_modules/prisma-instrumentation-5-x/dist/chunk-O73GN7O4.js
var require_chunk_O73GN7O4 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name2 in all)
      __defProp3(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var chunk_O73GN7O4_exports = {};
  __export2(chunk_O73GN7O4_exports, {
    GLOBAL_KEY: () => GLOBAL_KEY,
    MODULE_NAME: () => MODULE_NAME,
    NAME: () => NAME,
    VERSION: () => VERSION
  });
  module.exports = __toCommonJS(chunk_O73GN7O4_exports);
  var import_chunk_FTA5RKYX = require_chunk_FTA5RKYX();
  var require_package3 = (0, import_chunk_FTA5RKYX.__commonJS)({
    "package.json"(exports2, module2) {
      module2.exports = {
        name: "@prisma/instrumentation",
        version: "5.19.1",
        description: "OpenTelemetry compliant instrumentation for Prisma Client",
        main: "dist/index.js",
        types: "dist/index.d.ts",
        license: "Apache-2.0",
        homepage: "https://www.prisma.io",
        repository: {
          type: "git",
          url: "https://github.com/prisma/prisma.git",
          directory: "packages/instrumentation"
        },
        bugs: "https://github.com/prisma/prisma/issues",
        devDependencies: {
          "@prisma/internals": "workspace:*",
          "@swc/core": "1.6.13",
          "@types/jest": "29.5.12",
          "@types/node": "18.19.31",
          jest: "29.7.0",
          "jest-junit": "16.0.0",
          typescript: "5.4.5"
        },
        dependencies: {
          "@opentelemetry/api": "^1.8",
          "@opentelemetry/instrumentation": "^0.49 || ^0.50 || ^0.51 || ^0.52.0",
          "@opentelemetry/sdk-trace-base": "^1.22"
        },
        files: [
          "dist"
        ],
        keywords: [
          "prisma",
          "instrumentation",
          "opentelemetry",
          "otel"
        ],
        scripts: {
          dev: "DEV=true tsx helpers/build.ts",
          build: "tsx helpers/build.ts",
          prepublishOnly: "pnpm run build",
          test: "jest"
        },
        sideEffects: false
      };
    }
  });
  var { version: version2, name } = require_package3();
  var GLOBAL_KEY = "PRISMA_INSTRUMENTATION";
  var VERSION = version2;
  var NAME = name;
  var MODULE_NAME = "prisma";
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/types/Logger.js
var require_Logger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/types/LoggerProvider.js
var require_LoggerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/types/LogRecord.js
var require_LogRecord2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SeverityNumber = undefined;
  var SeverityNumber;
  (function(SeverityNumber2) {
    SeverityNumber2[SeverityNumber2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    SeverityNumber2[SeverityNumber2["TRACE"] = 1] = "TRACE";
    SeverityNumber2[SeverityNumber2["TRACE2"] = 2] = "TRACE2";
    SeverityNumber2[SeverityNumber2["TRACE3"] = 3] = "TRACE3";
    SeverityNumber2[SeverityNumber2["TRACE4"] = 4] = "TRACE4";
    SeverityNumber2[SeverityNumber2["DEBUG"] = 5] = "DEBUG";
    SeverityNumber2[SeverityNumber2["DEBUG2"] = 6] = "DEBUG2";
    SeverityNumber2[SeverityNumber2["DEBUG3"] = 7] = "DEBUG3";
    SeverityNumber2[SeverityNumber2["DEBUG4"] = 8] = "DEBUG4";
    SeverityNumber2[SeverityNumber2["INFO"] = 9] = "INFO";
    SeverityNumber2[SeverityNumber2["INFO2"] = 10] = "INFO2";
    SeverityNumber2[SeverityNumber2["INFO3"] = 11] = "INFO3";
    SeverityNumber2[SeverityNumber2["INFO4"] = 12] = "INFO4";
    SeverityNumber2[SeverityNumber2["WARN"] = 13] = "WARN";
    SeverityNumber2[SeverityNumber2["WARN2"] = 14] = "WARN2";
    SeverityNumber2[SeverityNumber2["WARN3"] = 15] = "WARN3";
    SeverityNumber2[SeverityNumber2["WARN4"] = 16] = "WARN4";
    SeverityNumber2[SeverityNumber2["ERROR"] = 17] = "ERROR";
    SeverityNumber2[SeverityNumber2["ERROR2"] = 18] = "ERROR2";
    SeverityNumber2[SeverityNumber2["ERROR3"] = 19] = "ERROR3";
    SeverityNumber2[SeverityNumber2["ERROR4"] = 20] = "ERROR4";
    SeverityNumber2[SeverityNumber2["FATAL"] = 21] = "FATAL";
    SeverityNumber2[SeverityNumber2["FATAL2"] = 22] = "FATAL2";
    SeverityNumber2[SeverityNumber2["FATAL3"] = 23] = "FATAL3";
    SeverityNumber2[SeverityNumber2["FATAL4"] = 24] = "FATAL4";
  })(SeverityNumber = exports.SeverityNumber || (exports.SeverityNumber = {}));
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/types/LoggerOptions.js
var require_LoggerOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/types/AnyValue.js
var require_AnyValue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/NoopLogger.js
var require_NoopLogger2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_LOGGER = exports.NoopLogger = undefined;

  class NoopLogger {
    emit(_logRecord) {
    }
  }
  exports.NoopLogger = NoopLogger;
  exports.NOOP_LOGGER = new NoopLogger;
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/NoopLoggerProvider.js
var require_NoopLoggerProvider2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_LOGGER_PROVIDER = exports.NoopLoggerProvider = undefined;
  var NoopLogger_1 = require_NoopLogger2();

  class NoopLoggerProvider {
    getLogger(_name, _version, _options) {
      return new NoopLogger_1.NoopLogger;
    }
  }
  exports.NoopLoggerProvider = NoopLoggerProvider;
  exports.NOOP_LOGGER_PROVIDER = new NoopLoggerProvider;
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/platform/node/globalThis.js
var require_globalThis4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/platform/node/index.js
var require_node9 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(require_globalThis4(), exports);
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/platform/index.js
var require_platform8 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(require_node9(), exports);
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/internal/global-utils.js
var require_global_utils3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.API_BACKWARDS_COMPATIBILITY_VERSION = exports.makeGetter = exports._global = exports.GLOBAL_LOGS_API_KEY = undefined;
  var platform_1 = require_platform8();
  exports.GLOBAL_LOGS_API_KEY = Symbol.for("io.opentelemetry.js.api.logs");
  exports._global = platform_1._globalThis;
  function makeGetter(requiredVersion, instance, fallback) {
    return (version2) => version2 === requiredVersion ? instance : fallback;
  }
  exports.makeGetter = makeGetter;
  exports.API_BACKWARDS_COMPATIBILITY_VERSION = 1;
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/api/logs.js
var require_logs2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LogsAPI = undefined;
  var global_utils_1 = require_global_utils3();
  var NoopLoggerProvider_1 = require_NoopLoggerProvider2();

  class LogsAPI {
    constructor() {
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new LogsAPI;
      }
      return this._instance;
    }
    setGlobalLoggerProvider(provider3) {
      if (global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY]) {
        return this.getLoggerProvider();
      }
      global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY] = (0, global_utils_1.makeGetter)(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, provider3, NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER);
      return provider3;
    }
    getLoggerProvider() {
      var _a2, _b2;
      return (_b2 = (_a2 = global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY]) === null || _a2 === undefined ? undefined : _a2.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b2 !== undefined ? _b2 : NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER;
    }
    getLogger(name, version2, options) {
      return this.getLoggerProvider().getLogger(name, version2, options);
    }
    disable() {
      delete global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY];
    }
  }
  exports.LogsAPI = LogsAPI;
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/node_modules/@opentelemetry/api-logs/build/src/index.js
var require_src13 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logs = undefined;
  __exportStar2(require_Logger(), exports);
  __exportStar2(require_LoggerProvider(), exports);
  __exportStar2(require_LogRecord2(), exports);
  __exportStar2(require_LoggerOptions(), exports);
  __exportStar2(require_AnyValue(), exports);
  __exportStar2(require_NoopLogger2(), exports);
  __exportStar2(require_NoopLoggerProvider2(), exports);
  var logs_1 = require_logs2();
  exports.logs = logs_1.LogsAPI.getInstance();
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/build/src/autoLoaderUtils.js
var require_autoLoaderUtils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.disableInstrumentations = exports.enableInstrumentations = undefined;
  function enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider) {
    for (let i4 = 0, j4 = instrumentations.length;i4 < j4; i4++) {
      const instrumentation = instrumentations[i4];
      if (tracerProvider) {
        instrumentation.setTracerProvider(tracerProvider);
      }
      if (meterProvider) {
        instrumentation.setMeterProvider(meterProvider);
      }
      if (loggerProvider && instrumentation.setLoggerProvider) {
        instrumentation.setLoggerProvider(loggerProvider);
      }
      if (!instrumentation.getConfig().enabled) {
        instrumentation.enable();
      }
    }
  }
  exports.enableInstrumentations = enableInstrumentations;
  function disableInstrumentations(instrumentations) {
    instrumentations.forEach((instrumentation) => instrumentation.disable());
  }
  exports.disableInstrumentations = disableInstrumentations;
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/build/src/autoLoader.js
var require_autoLoader2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.registerInstrumentations = undefined;
  var api_1 = require_src();
  var api_logs_1 = require_src13();
  var autoLoaderUtils_1 = require_autoLoaderUtils2();
  function registerInstrumentations(options) {
    var _a2, _b2;
    const tracerProvider = options.tracerProvider || api_1.trace.getTracerProvider();
    const meterProvider = options.meterProvider || api_1.metrics.getMeterProvider();
    const loggerProvider = options.loggerProvider || api_logs_1.logs.getLoggerProvider();
    const instrumentations = (_b2 = (_a2 = options.instrumentations) === null || _a2 === undefined ? undefined : _a2.flat()) !== null && _b2 !== undefined ? _b2 : [];
    (0, autoLoaderUtils_1.enableInstrumentations)(instrumentations, tracerProvider, meterProvider, loggerProvider);
    return () => {
      (0, autoLoaderUtils_1.disableInstrumentations)(instrumentations);
    };
  }
  exports.registerInstrumentations = registerInstrumentations;
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/build/src/instrumentation.js
var require_instrumentation3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationAbstract = undefined;
  var api_1 = require_src();
  var api_logs_1 = require_src13();
  var shimmer = require_shimmer();

  class InstrumentationAbstract {
    constructor(instrumentationName, instrumentationVersion, config5) {
      this.instrumentationName = instrumentationName;
      this.instrumentationVersion = instrumentationVersion;
      this._wrap = shimmer.wrap;
      this._unwrap = shimmer.unwrap;
      this._massWrap = shimmer.massWrap;
      this._massUnwrap = shimmer.massUnwrap;
      this._config = Object.assign({ enabled: true }, config5);
      this._diag = api_1.diag.createComponentLogger({
        namespace: instrumentationName
      });
      this._tracer = api_1.trace.getTracer(instrumentationName, instrumentationVersion);
      this._meter = api_1.metrics.getMeter(instrumentationName, instrumentationVersion);
      this._logger = api_logs_1.logs.getLogger(instrumentationName, instrumentationVersion);
      this._updateMetricInstruments();
    }
    get meter() {
      return this._meter;
    }
    setMeterProvider(meterProvider) {
      this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
      this._updateMetricInstruments();
    }
    get logger() {
      return this._logger;
    }
    setLoggerProvider(loggerProvider) {
      this._logger = loggerProvider.getLogger(this.instrumentationName, this.instrumentationVersion);
    }
    getModuleDefinitions() {
      var _a2;
      const initResult = (_a2 = this.init()) !== null && _a2 !== undefined ? _a2 : [];
      if (!Array.isArray(initResult)) {
        return [initResult];
      }
      return initResult;
    }
    _updateMetricInstruments() {
      return;
    }
    getConfig() {
      return this._config;
    }
    setConfig(config5) {
      this._config = Object.assign({}, config5);
    }
    setTracerProvider(tracerProvider) {
      this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
    }
    get tracer() {
      return this._tracer;
    }
    _runSpanCustomizationHook(hookHandler, triggerName, span, info) {
      if (!hookHandler) {
        return;
      }
      try {
        hookHandler(span, info);
      } catch (e4) {
        this._diag.error(`Error running span customization hook due to exception in handler`, { triggerName }, e4);
      }
    }
  }
  exports.InstrumentationAbstract = InstrumentationAbstract;
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/build/src/platform/node/ModuleNameTrie.js
var require_ModuleNameTrie2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ModuleNameTrie = exports.ModuleNameSeparator = undefined;
  exports.ModuleNameSeparator = "/";

  class ModuleNameTrieNode {
    constructor() {
      this.hooks = [];
      this.children = new Map;
    }
  }

  class ModuleNameTrie {
    constructor() {
      this._trie = new ModuleNameTrieNode;
      this._counter = 0;
    }
    insert(hook) {
      let trieNode = this._trie;
      for (const moduleNamePart of hook.moduleName.split(exports.ModuleNameSeparator)) {
        let nextNode = trieNode.children.get(moduleNamePart);
        if (!nextNode) {
          nextNode = new ModuleNameTrieNode;
          trieNode.children.set(moduleNamePart, nextNode);
        }
        trieNode = nextNode;
      }
      trieNode.hooks.push({ hook, insertedId: this._counter++ });
    }
    search(moduleName, { maintainInsertionOrder, fullOnly } = {}) {
      let trieNode = this._trie;
      const results = [];
      let foundFull = true;
      for (const moduleNamePart of moduleName.split(exports.ModuleNameSeparator)) {
        const nextNode = trieNode.children.get(moduleNamePart);
        if (!nextNode) {
          foundFull = false;
          break;
        }
        if (!fullOnly) {
          results.push(...nextNode.hooks);
        }
        trieNode = nextNode;
      }
      if (fullOnly && foundFull) {
        results.push(...trieNode.hooks);
      }
      if (results.length === 0) {
        return [];
      }
      if (results.length === 1) {
        return [results[0].hook];
      }
      if (maintainInsertionOrder) {
        results.sort((a5, b3) => a5.insertedId - b3.insertedId);
      }
      return results.map(({ hook }) => hook);
    }
  }
  exports.ModuleNameTrie = ModuleNameTrie;
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/build/src/platform/node/RequireInTheMiddleSingleton.js
var require_RequireInTheMiddleSingleton2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RequireInTheMiddleSingleton = undefined;
  var require_in_the_middle_1 = require_require_in_the_middle();
  var path = __require("path");
  var ModuleNameTrie_1 = require_ModuleNameTrie2();
  var isMocha = [
    "afterEach",
    "after",
    "beforeEach",
    "before",
    "describe",
    "it"
  ].every((fn) => {
    return typeof global[fn] === "function";
  });

  class RequireInTheMiddleSingleton {
    constructor() {
      this._moduleNameTrie = new ModuleNameTrie_1.ModuleNameTrie;
      this._initialize();
    }
    _initialize() {
      new require_in_the_middle_1.Hook(null, { internals: true }, (exports2, name, basedir) => {
        const normalizedModuleName = normalizePathSeparators(name);
        const matches = this._moduleNameTrie.search(normalizedModuleName, {
          maintainInsertionOrder: true,
          fullOnly: basedir === undefined
        });
        for (const { onRequire } of matches) {
          exports2 = onRequire(exports2, name, basedir);
        }
        return exports2;
      });
    }
    register(moduleName, onRequire) {
      const hooked = { moduleName, onRequire };
      this._moduleNameTrie.insert(hooked);
      return hooked;
    }
    static getInstance() {
      var _a2;
      if (isMocha)
        return new RequireInTheMiddleSingleton;
      return this._instance = (_a2 = this._instance) !== null && _a2 !== undefined ? _a2 : new RequireInTheMiddleSingleton;
    }
  }
  exports.RequireInTheMiddleSingleton = RequireInTheMiddleSingleton;
  function normalizePathSeparators(moduleNameOrPath) {
    return path.sep !== ModuleNameTrie_1.ModuleNameSeparator ? moduleNameOrPath.split(path.sep).join(ModuleNameTrie_1.ModuleNameSeparator) : moduleNameOrPath;
  }
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/build/src/utils.js
var require_utils11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isWrapped = exports.safeExecuteInTheMiddleAsync = exports.safeExecuteInTheMiddle = undefined;
  function safeExecuteInTheMiddle(execute, onFinish, preventThrowingError) {
    let error;
    let result;
    try {
      result = execute();
    } catch (e4) {
      error = e4;
    } finally {
      onFinish(error, result);
      if (error && !preventThrowingError) {
        throw error;
      }
      return result;
    }
  }
  exports.safeExecuteInTheMiddle = safeExecuteInTheMiddle;
  async function safeExecuteInTheMiddleAsync(execute, onFinish, preventThrowingError) {
    let error;
    let result;
    try {
      result = await execute();
    } catch (e4) {
      error = e4;
    } finally {
      onFinish(error, result);
      if (error && !preventThrowingError) {
        throw error;
      }
      return result;
    }
  }
  exports.safeExecuteInTheMiddleAsync = safeExecuteInTheMiddleAsync;
  function isWrapped(func) {
    return typeof func === "function" && typeof func.__original === "function" && typeof func.__unwrap === "function" && func.__wrapped === true;
  }
  exports.isWrapped = isWrapped;
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/build/src/platform/node/instrumentation.js
var require_instrumentation4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationBase = undefined;
  var path = __require("path");
  var util_1 = __require("util");
  var semver_1 = require_semver3();
  var shimmer_1 = require_shimmer();
  var instrumentation_1 = require_instrumentation3();
  var RequireInTheMiddleSingleton_1 = require_RequireInTheMiddleSingleton2();
  var import_in_the_middle_1 = require_import_in_the_middle();
  var api_1 = require_src();
  var require_in_the_middle_1 = require_require_in_the_middle();
  var fs_1 = __require("fs");
  var utils_1 = require_utils11();

  class InstrumentationBase extends instrumentation_1.InstrumentationAbstract {
    constructor(instrumentationName, instrumentationVersion, config5) {
      super(instrumentationName, instrumentationVersion, config5);
      this._hooks = [];
      this._requireInTheMiddleSingleton = RequireInTheMiddleSingleton_1.RequireInTheMiddleSingleton.getInstance();
      this._enabled = false;
      this._wrap = (moduleExports, name, wrapper) => {
        if ((0, utils_1.isWrapped)(moduleExports[name])) {
          this._unwrap(moduleExports, name);
        }
        if (!util_1.types.isProxy(moduleExports)) {
          return (0, shimmer_1.wrap)(moduleExports, name, wrapper);
        } else {
          const wrapped = (0, shimmer_1.wrap)(Object.assign({}, moduleExports), name, wrapper);
          return Object.defineProperty(moduleExports, name, {
            value: wrapped
          });
        }
      };
      this._unwrap = (moduleExports, name) => {
        if (!util_1.types.isProxy(moduleExports)) {
          return (0, shimmer_1.unwrap)(moduleExports, name);
        } else {
          return Object.defineProperty(moduleExports, name, {
            value: moduleExports[name]
          });
        }
      };
      this._massWrap = (moduleExportsArray, names, wrapper) => {
        if (!moduleExportsArray) {
          api_1.diag.error("must provide one or more modules to patch");
          return;
        } else if (!Array.isArray(moduleExportsArray)) {
          moduleExportsArray = [moduleExportsArray];
        }
        if (!(names && Array.isArray(names))) {
          api_1.diag.error("must provide one or more functions to wrap on modules");
          return;
        }
        moduleExportsArray.forEach((moduleExports) => {
          names.forEach((name) => {
            this._wrap(moduleExports, name, wrapper);
          });
        });
      };
      this._massUnwrap = (moduleExportsArray, names) => {
        if (!moduleExportsArray) {
          api_1.diag.error("must provide one or more modules to patch");
          return;
        } else if (!Array.isArray(moduleExportsArray)) {
          moduleExportsArray = [moduleExportsArray];
        }
        if (!(names && Array.isArray(names))) {
          api_1.diag.error("must provide one or more functions to wrap on modules");
          return;
        }
        moduleExportsArray.forEach((moduleExports) => {
          names.forEach((name) => {
            this._unwrap(moduleExports, name);
          });
        });
      };
      let modules = this.init();
      if (modules && !Array.isArray(modules)) {
        modules = [modules];
      }
      this._modules = modules || [];
      if (this._modules.length === 0) {
        api_1.diag.debug("No modules instrumentation has been defined for " + `'${this.instrumentationName}@${this.instrumentationVersion}'` + ", nothing will be patched");
      }
      if (this._config.enabled) {
        this.enable();
      }
    }
    _warnOnPreloadedModules() {
      this._modules.forEach((module2) => {
        const { name } = module2;
        try {
          const resolvedModule = __require.resolve(name);
          if (__require.cache[resolvedModule]) {
            this._diag.warn(`Module ${name} has been loaded before ${this.instrumentationName} so it might not work, please initialize it before requiring ${name}`);
          }
        } catch (_a2) {
        }
      });
    }
    _extractPackageVersion(baseDir) {
      try {
        const json = (0, fs_1.readFileSync)(path.join(baseDir, "package.json"), {
          encoding: "utf8"
        });
        const version2 = JSON.parse(json).version;
        return typeof version2 === "string" ? version2 : undefined;
      } catch (error) {
        api_1.diag.warn("Failed extracting version", baseDir);
      }
      return;
    }
    _onRequire(module2, exports2, name, baseDir) {
      var _a2;
      if (!baseDir) {
        if (typeof module2.patch === "function") {
          module2.moduleExports = exports2;
          if (this._enabled) {
            this._diag.debug("Applying instrumentation patch for nodejs core module on require hook", {
              module: module2.name
            });
            return module2.patch(exports2);
          }
        }
        return exports2;
      }
      const version2 = this._extractPackageVersion(baseDir);
      module2.moduleVersion = version2;
      if (module2.name === name) {
        if (isSupported(module2.supportedVersions, version2, module2.includePrerelease)) {
          if (typeof module2.patch === "function") {
            module2.moduleExports = exports2;
            if (this._enabled) {
              this._diag.debug("Applying instrumentation patch for module on require hook", {
                module: module2.name,
                version: module2.moduleVersion,
                baseDir
              });
              return module2.patch(exports2, module2.moduleVersion);
            }
          }
        }
        return exports2;
      }
      const files = (_a2 = module2.files) !== null && _a2 !== undefined ? _a2 : [];
      const normalizedName = path.normalize(name);
      const supportedFileInstrumentations = files.filter((f4) => f4.name === normalizedName).filter((f4) => isSupported(f4.supportedVersions, version2, module2.includePrerelease));
      return supportedFileInstrumentations.reduce((patchedExports, file) => {
        file.moduleExports = patchedExports;
        if (this._enabled) {
          this._diag.debug("Applying instrumentation patch for nodejs module file on require hook", {
            module: module2.name,
            version: module2.moduleVersion,
            fileName: file.name,
            baseDir
          });
          return file.patch(patchedExports, module2.moduleVersion);
        }
        return patchedExports;
      }, exports2);
    }
    enable() {
      if (this._enabled) {
        return;
      }
      this._enabled = true;
      if (this._hooks.length > 0) {
        for (const module2 of this._modules) {
          if (typeof module2.patch === "function" && module2.moduleExports) {
            this._diag.debug("Applying instrumentation patch for nodejs module on instrumentation enabled", {
              module: module2.name,
              version: module2.moduleVersion
            });
            module2.patch(module2.moduleExports, module2.moduleVersion);
          }
          for (const file of module2.files) {
            if (file.moduleExports) {
              this._diag.debug("Applying instrumentation patch for nodejs module file on instrumentation enabled", {
                module: module2.name,
                version: module2.moduleVersion,
                fileName: file.name
              });
              file.patch(file.moduleExports, module2.moduleVersion);
            }
          }
        }
        return;
      }
      this._warnOnPreloadedModules();
      for (const module2 of this._modules) {
        const hookFn = (exports2, name, baseDir) => {
          return this._onRequire(module2, exports2, name, baseDir);
        };
        const onRequire = (exports2, name, baseDir) => {
          return this._onRequire(module2, exports2, name, baseDir);
        };
        const hook = path.isAbsolute(module2.name) ? new require_in_the_middle_1.Hook([module2.name], { internals: true }, onRequire) : this._requireInTheMiddleSingleton.register(module2.name, onRequire);
        this._hooks.push(hook);
        const esmHook = new import_in_the_middle_1.Hook([module2.name], { internals: false }, hookFn);
        this._hooks.push(esmHook);
      }
    }
    disable() {
      if (!this._enabled) {
        return;
      }
      this._enabled = false;
      for (const module2 of this._modules) {
        if (typeof module2.unpatch === "function" && module2.moduleExports) {
          this._diag.debug("Removing instrumentation patch for nodejs module on instrumentation disabled", {
            module: module2.name,
            version: module2.moduleVersion
          });
          module2.unpatch(module2.moduleExports, module2.moduleVersion);
        }
        for (const file of module2.files) {
          if (file.moduleExports) {
            this._diag.debug("Removing instrumentation patch for nodejs module file on instrumentation disabled", {
              module: module2.name,
              version: module2.moduleVersion,
              fileName: file.name
            });
            file.unpatch(file.moduleExports, module2.moduleVersion);
          }
        }
      }
    }
    isEnabled() {
      return this._enabled;
    }
  }
  exports.InstrumentationBase = InstrumentationBase;
  function isSupported(supportedVersions, version2, includePrerelease) {
    if (typeof version2 === "undefined") {
      return supportedVersions.includes("*");
    }
    return supportedVersions.some((supportedVersion) => {
      return (0, semver_1.satisfies)(version2, supportedVersion, { includePrerelease });
    });
  }
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/build/src/platform/node/normalize.js
var require_normalize2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = undefined;
  var path_1 = __require("path");
  Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
    return path_1.normalize;
  } });
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/build/src/platform/node/index.js
var require_node10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = exports.InstrumentationBase = undefined;
  var instrumentation_1 = require_instrumentation4();
  Object.defineProperty(exports, "InstrumentationBase", { enumerable: true, get: function() {
    return instrumentation_1.InstrumentationBase;
  } });
  var normalize_1 = require_normalize2();
  Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
    return normalize_1.normalize;
  } });
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/build/src/platform/index.js
var require_platform9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = exports.InstrumentationBase = undefined;
  var node_1 = require_node10();
  Object.defineProperty(exports, "InstrumentationBase", { enumerable: true, get: function() {
    return node_1.InstrumentationBase;
  } });
  Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
    return node_1.normalize;
  } });
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/build/src/instrumentationNodeModuleDefinition.js
var require_instrumentationNodeModuleDefinition2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationNodeModuleDefinition = undefined;

  class InstrumentationNodeModuleDefinition {
    constructor(name, supportedVersions, patch, unpatch, files) {
      this.name = name;
      this.supportedVersions = supportedVersions;
      this.patch = patch;
      this.unpatch = unpatch;
      this.files = files || [];
    }
  }
  exports.InstrumentationNodeModuleDefinition = InstrumentationNodeModuleDefinition;
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/build/src/instrumentationNodeModuleFile.js
var require_instrumentationNodeModuleFile2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationNodeModuleFile = undefined;
  var index_1 = require_platform9();

  class InstrumentationNodeModuleFile {
    constructor(name, supportedVersions, patch, unpatch) {
      this.supportedVersions = supportedVersions;
      this.patch = patch;
      this.unpatch = unpatch;
      this.name = (0, index_1.normalize)(name);
    }
  }
  exports.InstrumentationNodeModuleFile = InstrumentationNodeModuleFile;
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/build/src/types.js
var require_types2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/build/src/types_internal.js
var require_types_internal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../../node_modules/prisma-instrumentation-5-x/node_modules/@opentelemetry/instrumentation/build/src/index.js
var require_src14 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstrumentationNodeModuleFile = exports.InstrumentationNodeModuleDefinition = exports.InstrumentationBase = exports.registerInstrumentations = undefined;
  var autoLoader_1 = require_autoLoader2();
  Object.defineProperty(exports, "registerInstrumentations", { enumerable: true, get: function() {
    return autoLoader_1.registerInstrumentations;
  } });
  var index_1 = require_platform9();
  Object.defineProperty(exports, "InstrumentationBase", { enumerable: true, get: function() {
    return index_1.InstrumentationBase;
  } });
  var instrumentationNodeModuleDefinition_1 = require_instrumentationNodeModuleDefinition2();
  Object.defineProperty(exports, "InstrumentationNodeModuleDefinition", { enumerable: true, get: function() {
    return instrumentationNodeModuleDefinition_1.InstrumentationNodeModuleDefinition;
  } });
  var instrumentationNodeModuleFile_1 = require_instrumentationNodeModuleFile2();
  Object.defineProperty(exports, "InstrumentationNodeModuleFile", { enumerable: true, get: function() {
    return instrumentationNodeModuleFile_1.InstrumentationNodeModuleFile;
  } });
  __exportStar2(require_types2(), exports);
  __exportStar2(require_types_internal(), exports);
  __exportStar2(require_utils11(), exports);
});

// ../../node_modules/prisma-instrumentation-5-x/dist/chunk-6MQXHI6Y.js
var require_chunk_6MQXHI6Y = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var chunk_6MQXHI6Y_exports = {};
  __export2(chunk_6MQXHI6Y_exports, {
    PrismaInstrumentation: () => PrismaInstrumentation
  });
  module.exports = __toCommonJS(chunk_6MQXHI6Y_exports);
  var import_chunk_VVAFFO6L = require_chunk_VVAFFO6L();
  var import_chunk_O73GN7O4 = require_chunk_O73GN7O4();
  var import_instrumentation = require_src14();
  var PrismaInstrumentation = class extends import_instrumentation.InstrumentationBase {
    constructor(config5 = {}) {
      super(import_chunk_O73GN7O4.NAME, import_chunk_O73GN7O4.VERSION, config5);
    }
    init() {
      const module2 = new import_instrumentation.InstrumentationNodeModuleDefinition(import_chunk_O73GN7O4.MODULE_NAME, [import_chunk_O73GN7O4.VERSION]);
      return [module2];
    }
    enable() {
      const config5 = this._config;
      const globalValue = {
        helper: new import_chunk_VVAFFO6L.ActiveTracingHelper({ traceMiddleware: config5.middleware ?? false })
      };
      global[import_chunk_O73GN7O4.GLOBAL_KEY] = globalValue;
    }
    disable() {
      delete global[import_chunk_O73GN7O4.GLOBAL_KEY];
    }
    isEnabled() {
      return Boolean(global[import_chunk_O73GN7O4.GLOBAL_KEY]);
    }
  };
});

// ../../node_modules/prisma-instrumentation-5-x/dist/index.js
var require_dist2 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var dist_exports = {};
  __export2(dist_exports, {
    PrismaInstrumentation: () => import_chunk_6MQXHI6Y.PrismaInstrumentation
  });
  module.exports = __toCommonJS(dist_exports);
  var import_chunk_6MQXHI6Y = require_chunk_6MQXHI6Y();
  var import_chunk_VVAFFO6L = require_chunk_VVAFFO6L();
  var import_chunk_O73GN7O4 = require_chunk_O73GN7O4();
  var import_chunk_FTA5RKYX = require_chunk_FTA5RKYX();
});

// ../../node_modules/prisma-instrumentation-6-x/dist/chunk-TUF6OX4N.js
var require_chunk_TUF6OX4N = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var chunk_TUF6OX4N_exports = {};
  __export2(chunk_TUF6OX4N_exports, {
    ActiveTracingHelper: () => ActiveTracingHelper
  });
  module.exports = __toCommonJS(chunk_TUF6OX4N_exports);
  var import_api = require_src();
  var showAllTraces = process.env.PRISMA_SHOW_ALL_TRACES === "true";
  var nonSampledTraceParent = `00-10-10-00`;
  function engineSpanKindToOtelSpanKind(engineSpanKind) {
    switch (engineSpanKind) {
      case "client":
        return import_api.SpanKind.CLIENT;
      case "internal":
      default:
        return import_api.SpanKind.INTERNAL;
    }
  }
  var ActiveTracingHelper = class {
    constructor({ traceMiddleware, tracerProvider }) {
      this.traceMiddleware = traceMiddleware;
      this.tracerProvider = tracerProvider;
    }
    isEnabled() {
      return true;
    }
    getTraceParent(context) {
      const span = import_api.trace.getSpanContext(context ?? import_api.context.active());
      if (span) {
        return `00-${span.traceId}-${span.spanId}-0${span.traceFlags}`;
      }
      return nonSampledTraceParent;
    }
    dispatchEngineSpans(spans) {
      const tracer = this.tracerProvider.getTracer("prisma");
      const linkIds = /* @__PURE__ */ new Map;
      const roots = spans.filter((span) => span.parentId === null);
      for (const root of roots) {
        dispatchEngineSpan(tracer, root, spans, linkIds);
      }
    }
    getActiveContext() {
      return import_api.context.active();
    }
    runInChildSpan(options, callback) {
      if (typeof options === "string") {
        options = { name: options };
      }
      if (options.internal && !showAllTraces) {
        return callback();
      }
      if (options.middleware && !this.traceMiddleware) {
        return callback();
      }
      const tracer = this.tracerProvider.getTracer("prisma");
      const context = options.context ?? this.getActiveContext();
      const name = `prisma:client:${options.name}`;
      if (options.active === false) {
        const span = tracer.startSpan(name, options, context);
        return endSpan(span, callback(span, context));
      }
      return tracer.startActiveSpan(name, options, (span) => endSpan(span, callback(span, context)));
    }
  };
  function dispatchEngineSpan(tracer, engineSpan, allSpans, linkIds) {
    const spanOptions = {
      attributes: engineSpan.attributes,
      kind: engineSpanKindToOtelSpanKind(engineSpan.kind),
      startTime: engineSpan.startTime
    };
    tracer.startActiveSpan(engineSpan.name, spanOptions, (span) => {
      linkIds.set(engineSpan.id, span.spanContext().spanId);
      if (engineSpan.links) {
        span.addLinks(engineSpan.links.flatMap((link) => {
          const linkedId = linkIds.get(link);
          if (!linkedId) {
            return [];
          }
          return {
            context: {
              spanId: linkedId,
              traceId: span.spanContext().traceId,
              traceFlags: span.spanContext().traceFlags
            }
          };
        }));
      }
      const children = allSpans.filter((s5) => s5.parentId === engineSpan.id);
      for (const child of children) {
        dispatchEngineSpan(tracer, child, allSpans, linkIds);
      }
      span.end(engineSpan.endTime);
    });
  }
  function endSpan(span, result) {
    if (isPromiseLike(result)) {
      return result.then((value) => {
        span.end();
        return value;
      }, (reason) => {
        span.end();
        throw reason;
      });
    }
    span.end();
    return result;
  }
  function isPromiseLike(value) {
    return value != null && typeof value["then"] === "function";
  }
});

// ../../node_modules/prisma-instrumentation-6-x/dist/chunk-FTA5RKYX.js
var require_chunk_FTA5RKYX2 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var chunk_FTA5RKYX_exports = {};
  __export2(chunk_FTA5RKYX_exports, {
    __commonJS: () => __commonJS2
  });
  module.exports = __toCommonJS(chunk_FTA5RKYX_exports);
  var __getOwnPropNames22 = Object.getOwnPropertyNames;
  var __commonJS2 = (cb2, mod) => function __require() {
    return mod || (0, cb2[__getOwnPropNames22(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
});

// ../../node_modules/prisma-instrumentation-6-x/dist/chunk-DBFKZZHY.js
var require_chunk_DBFKZZHY = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name2 in all)
      __defProp3(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var chunk_DBFKZZHY_exports = {};
  __export2(chunk_DBFKZZHY_exports, {
    GLOBAL_KEY: () => GLOBAL_KEY,
    MODULE_NAME: () => MODULE_NAME,
    NAME: () => NAME,
    VERSION: () => VERSION
  });
  module.exports = __toCommonJS(chunk_DBFKZZHY_exports);
  var import_chunk_FTA5RKYX = require_chunk_FTA5RKYX2();
  var require_package3 = (0, import_chunk_FTA5RKYX.__commonJS)({
    "package.json"(exports2, module2) {
      module2.exports = {
        name: "@prisma/instrumentation",
        version: "6.1.0",
        description: "OpenTelemetry compliant instrumentation for Prisma Client",
        main: "dist/index.js",
        types: "dist/index.d.ts",
        license: "Apache-2.0",
        homepage: "https://www.prisma.io",
        repository: {
          type: "git",
          url: "https://github.com/prisma/prisma.git",
          directory: "packages/instrumentation"
        },
        bugs: "https://github.com/prisma/prisma/issues",
        devDependencies: {
          "@prisma/internals": "workspace:*",
          "@swc/core": "1.10.1",
          "@types/jest": "29.5.14",
          "@types/node": "18.19.31",
          "@opentelemetry/api": "1.9.0",
          jest: "29.7.0",
          "jest-junit": "16.0.0",
          typescript: "5.4.5"
        },
        dependencies: {
          "@opentelemetry/instrumentation": "^0.52.0 || ^0.53.0 || ^0.54.0 || ^0.55.0 || ^0.56.0"
        },
        peerDependencies: {
          "@opentelemetry/api": "^1.8"
        },
        files: [
          "dist"
        ],
        keywords: [
          "prisma",
          "instrumentation",
          "opentelemetry",
          "otel"
        ],
        scripts: {
          dev: "DEV=true tsx helpers/build.ts",
          build: "tsx helpers/build.ts",
          prepublishOnly: "pnpm run build",
          test: "jest"
        },
        sideEffects: false
      };
    }
  });
  var { version: version2, name } = require_package3();
  var GLOBAL_KEY = "PRISMA_INSTRUMENTATION";
  var VERSION = version2;
  var NAME = name;
  var MODULE_NAME = "@prisma/client";
});

// ../../node_modules/prisma-instrumentation-6-x/dist/chunk-5YZY52UW.js
var require_chunk_5YZY52UW = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var chunk_5YZY52UW_exports = {};
  __export2(chunk_5YZY52UW_exports, {
    PrismaInstrumentation: () => PrismaInstrumentation
  });
  module.exports = __toCommonJS(chunk_5YZY52UW_exports);
  var import_chunk_TUF6OX4N = require_chunk_TUF6OX4N();
  var import_chunk_DBFKZZHY = require_chunk_DBFKZZHY();
  var import_api = require_src();
  var import_instrumentation = require_src5();
  var PrismaInstrumentation = class extends import_instrumentation.InstrumentationBase {
    constructor(config5 = {}) {
      super(import_chunk_DBFKZZHY.NAME, import_chunk_DBFKZZHY.VERSION, config5);
    }
    setTracerProvider(tracerProvider) {
      this.tracerProvider = tracerProvider;
    }
    init() {
      const module2 = new import_instrumentation.InstrumentationNodeModuleDefinition(import_chunk_DBFKZZHY.MODULE_NAME, [import_chunk_DBFKZZHY.VERSION]);
      return [module2];
    }
    enable() {
      const config5 = this._config;
      const globalValue = {
        helper: new import_chunk_TUF6OX4N.ActiveTracingHelper({
          traceMiddleware: config5.middleware ?? false,
          tracerProvider: this.tracerProvider ?? import_api.trace.getTracerProvider()
        })
      };
      global[import_chunk_DBFKZZHY.GLOBAL_KEY] = globalValue;
    }
    disable() {
      delete global[import_chunk_DBFKZZHY.GLOBAL_KEY];
    }
    isEnabled() {
      return Boolean(global[import_chunk_DBFKZZHY.GLOBAL_KEY]);
    }
  };
});

// ../../node_modules/prisma-instrumentation-6-x/dist/index.js
var require_dist3 = __commonJS((exports, module) => {
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp3(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod);
  var dist_exports = {};
  __export2(dist_exports, {
    PrismaInstrumentation: () => import_chunk_5YZY52UW.PrismaInstrumentation,
    registerInstrumentations: () => import_instrumentation.registerInstrumentations
  });
  module.exports = __toCommonJS(dist_exports);
  var import_chunk_5YZY52UW = require_chunk_5YZY52UW();
  var import_chunk_TUF6OX4N = require_chunk_TUF6OX4N();
  var import_chunk_DBFKZZHY = require_chunk_DBFKZZHY();
  var import_chunk_FTA5RKYX = require_chunk_FTA5RKYX2();
  var import_instrumentation = require_src5();
});

// ../../node_modules/@prisma/extension-optimize/node_modules/zod/lib/helpers/util.js
var require_util2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = undefined;
  var util;
  (function(util2) {
    util2.assertEqual = (val2) => val2;
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error;
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k4) => typeof obj[obj[k4]] !== "number");
      const filtered = {};
      for (const k4 of validKeys) {
        filtered[k4] = obj[k4];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e4) {
        return obj[e4];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val2) => Number.isInteger(val2) : (val2) => typeof val2 === "number" && isFinite(val2) && Math.floor(val2) === val2;
    function joinValues(array, separator = " | ") {
      return array.map((val2) => typeof val2 === "string" ? `'${val2}'` : val2).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_3, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util = exports.util || (exports.util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
      };
    };
  })(objectUtil = exports.objectUtil || (exports.objectUtil = {}));
  exports.ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  var getParsedType = (data) => {
    const t4 = typeof data;
    switch (t4) {
      case "undefined":
        return exports.ZodParsedType.undefined;
      case "string":
        return exports.ZodParsedType.string;
      case "number":
        return isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
      case "boolean":
        return exports.ZodParsedType.boolean;
      case "function":
        return exports.ZodParsedType.function;
      case "bigint":
        return exports.ZodParsedType.bigint;
      case "symbol":
        return exports.ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return exports.ZodParsedType.array;
        }
        if (data === null) {
          return exports.ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return exports.ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return exports.ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return exports.ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return exports.ZodParsedType.date;
        }
        return exports.ZodParsedType.object;
      default:
        return exports.ZodParsedType.unknown;
    }
  };
  exports.getParsedType = getParsedType;
});

// ../../node_modules/@prisma/extension-optimize/node_modules/zod/lib/ZodError.js
var require_ZodError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ZodError = exports.quotelessJson = exports.ZodIssueCode = undefined;
  var util_1 = require_util2();
  exports.ZodIssueCode = util_1.util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  var quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  exports.quotelessJson = quotelessJson;

  class ZodError extends Error {
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    get errors() {
      return this.issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i4 = 0;
            while (i4 < issue.path.length) {
              const el = issue.path[i4];
              const terminal = i4 === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i4++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  }
  exports.ZodError = ZodError;
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
});

// ../../node_modules/@prisma/extension-optimize/node_modules/zod/lib/locales/en.js
var require_en = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util2();
  var ZodError_1 = require_ZodError();
  var errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodError_1.ZodIssueCode.invalid_type:
        if (issue.received === util_1.ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodError_1.ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;
        break;
      case ZodError_1.ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodError_1.ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodError_1.ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;
        break;
      case ZodError_1.ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodError_1.ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodError_1.ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodError_1.ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodError_1.ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util_1.util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodError_1.ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodError_1.ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodError_1.ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodError_1.ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodError_1.ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodError_1.ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util_1.util.assertNever(issue);
    }
    return { message };
  };
  exports.default = errorMap;
});

// ../../node_modules/@prisma/extension-optimize/node_modules/zod/lib/errors.js
var require_errors = __commonJS((exports) => {
  var __importDefault2 = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getErrorMap = exports.setErrorMap = exports.defaultErrorMap = undefined;
  var en_1 = __importDefault2(require_en());
  exports.defaultErrorMap = en_1.default;
  var overrideErrorMap = en_1.default;
  function setErrorMap(map2) {
    overrideErrorMap = map2;
  }
  exports.setErrorMap = setErrorMap;
  function getErrorMap() {
    return overrideErrorMap;
  }
  exports.getErrorMap = getErrorMap;
});

// ../../node_modules/@prisma/extension-optimize/node_modules/zod/lib/helpers/parseUtil.js
var require_parseUtil = __commonJS((exports) => {
  var __importDefault2 = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = undefined;
  var errors_1 = require_errors();
  var en_1 = __importDefault2(require_en());
  var makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    if (issueData.message !== undefined) {
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message
      };
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m4) => !!m4).slice().reverse();
    for (const map2 of maps) {
      errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: errorMessage
    };
  };
  exports.makeIssue = makeIssue;
  exports.EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const overrideMap = (0, errors_1.getErrorMap)();
    const issue = (0, exports.makeIssue)({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        ctx.schemaErrorMap,
        overrideMap,
        overrideMap === en_1.default ? undefined : en_1.default
      ].filter((x4) => !!x4)
    });
    ctx.common.issues.push(issue);
  }
  exports.addIssueToContext = addIssueToContext;

  class ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s5 of results) {
        if (s5.status === "aborted")
          return exports.INVALID;
        if (s5.status === "dirty")
          status.dirty();
        arrayValue.push(s5.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        const key = await pair.key;
        const value = await pair.value;
        syncPairs.push({
          key,
          value
        });
      }
      return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return exports.INVALID;
        if (value.status === "aborted")
          return exports.INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  }
  exports.ParseStatus = ParseStatus;
  exports.INVALID = Object.freeze({
    status: "aborted"
  });
  var DIRTY = (value) => ({ status: "dirty", value });
  exports.DIRTY = DIRTY;
  var OK = (value) => ({ status: "valid", value });
  exports.OK = OK;
  var isAborted = (x4) => x4.status === "aborted";
  exports.isAborted = isAborted;
  var isDirty = (x4) => x4.status === "dirty";
  exports.isDirty = isDirty;
  var isValid = (x4) => x4.status === "valid";
  exports.isValid = isValid;
  var isAsync = (x4) => typeof Promise !== "undefined" && x4 instanceof Promise;
  exports.isAsync = isAsync;
});

// ../../node_modules/@prisma/extension-optimize/node_modules/zod/lib/helpers/typeAliases.js
var require_typeAliases = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// ../../node_modules/@prisma/extension-optimize/node_modules/zod/lib/helpers/errorUtil.js
var require_errorUtil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.errorUtil = undefined;
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
  })(errorUtil = exports.errorUtil || (exports.errorUtil = {}));
});

// ../../node_modules/@prisma/extension-optimize/node_modules/zod/lib/types.js
var require_types3 = __commonJS((exports) => {
  var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f4) {
    if (kind === "a" && !f4)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f4 : kind === "a" ? f4.call(receiver) : f4 ? f4.value : state.get(receiver);
  };
  var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f4) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f4)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f4.call(receiver, value) : f4 ? f4.value = value : state.set(receiver, value), value;
  };
  var _ZodEnum_cache;
  var _ZodNativeEnum_cache;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.boolean = exports.bigint = exports.array = exports.any = exports.coerce = exports.ZodFirstPartyTypeKind = exports.late = exports.ZodSchema = exports.Schema = exports.custom = exports.ZodReadonly = exports.ZodPipeline = exports.ZodBranded = exports.BRAND = exports.ZodNaN = exports.ZodCatch = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = exports.ZodTransformer = exports.ZodEffects = exports.ZodPromise = exports.ZodNativeEnum = exports.ZodEnum = exports.ZodLiteral = exports.ZodLazy = exports.ZodFunction = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.ZodArray = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodDate = exports.ZodBoolean = exports.ZodBigInt = exports.ZodNumber = exports.ZodString = exports.datetimeRegex = exports.ZodType = undefined;
  exports.NEVER = exports.void = exports.unknown = exports.union = exports.undefined = exports.tuple = exports.transformer = exports.symbol = exports.string = exports.strictObject = exports.set = exports.record = exports.promise = exports.preprocess = exports.pipeline = exports.ostring = exports.optional = exports.onumber = exports.oboolean = exports.object = exports.number = exports.nullable = exports.null = exports.never = exports.nativeEnum = exports.nan = exports.map = exports.literal = exports.lazy = exports.intersection = exports.instanceof = exports.function = exports.enum = exports.effect = exports.discriminatedUnion = exports.date = undefined;
  var errors_1 = require_errors();
  var errorUtil_1 = require_errorUtil();
  var parseUtil_1 = require_parseUtil();
  var util_1 = require_util2();
  var ZodError_1 = require_ZodError();

  class ParseInputLazyPath {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (this._key instanceof Array) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  }
  var handleResult = (ctx, result) => {
    if ((0, parseUtil_1.isValid)(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError_1.ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
      return { errorMap, description };
    const customMap = (iss, ctx) => {
      var _a2, _b2;
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message !== null && message !== undefined ? message : ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: (_a2 = message !== null && message !== undefined ? message : required_error) !== null && _a2 !== undefined ? _a2 : ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: (_b2 = message !== null && message !== undefined ? message : invalid_type_error) !== null && _b2 !== undefined ? _b2 : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }

  class ZodType {
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return (0, util_1.getParsedType)(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: (0, util_1.getParsedType)(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new parseUtil_1.ParseStatus,
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: (0, util_1.getParsedType)(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if ((0, parseUtil_1.isAsync)(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      var _a2;
      const ctx = {
        common: {
          issues: [],
          async: (_a2 = params === null || params === undefined ? undefined : params.async) !== null && _a2 !== undefined ? _a2 : false,
          contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
        },
        path: (params === null || params === undefined ? undefined : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: (0, util_1.getParsedType)(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
          async: true
        },
        path: (params === null || params === undefined ? undefined : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: (0, util_1.getParsedType)(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val2) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val2);
        } else {
          return message;
        }
      };
      return this._refinement((val2, ctx) => {
        const result = check(val2);
        const setError = () => ctx.addIssue({
          code: ZodError_1.ZodIssueCode.custom,
          ...getIssueProperties(val2)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val2, ctx) => {
        if (!check(val2)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val2, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this, this._def);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(undefined).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  exports.ZodType = ZodType;
  exports.Schema = ZodType;
  exports.ZodSchema = ZodType;
  var cuidRegex = /^c[^\s-]{8,}$/i;
  var cuid2Regex = /^[0-9a-z]+$/;
  var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
  var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  var nanoidRegex = /^[a-z0-9_-]{21}$/i;
  var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  var emojiRegex2;
  var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
  var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  var dateRegex = new RegExp(`^${dateRegexSource}$`);
  function timeRegexSource(args) {
    let regex2 = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
    if (args.precision) {
      regex2 = `${regex2}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      regex2 = `${regex2}(\\.\\d+)?`;
    }
    return regex2;
  }
  function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
  }
  function datetimeRegex(args) {
    let regex2 = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex2 = `${regex2}(${opts.join("|")})`;
    return new RegExp(`^${regex2}$`);
  }
  exports.datetimeRegex = datetimeRegex;
  function isValidIP(ip, version2) {
    if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }

  class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx2, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.string,
          received: ctx2.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const status = new parseUtil_1.ParseStatus;
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "email",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex2) {
            emojiRegex2 = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "emoji",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "uuid",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "nanoid",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "cuid",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "cuid2",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "ulid",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a2) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "url",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "regex",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex2 = datetimeRegex(check);
          if (!regex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex2 = dateRegex;
          if (!regex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex2 = timeRegex(check);
          if (!regex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "duration",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "ip",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "base64",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util_1.util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex2, validation, message) {
      return this.refinement((data) => regex2.test(data), {
        validation,
        code: ZodError_1.ZodIssueCode.invalid_string,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil_1.errorUtil.errToObj(options) });
    }
    datetime(options) {
      var _a2, _b2;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
        offset: (_a2 = options === null || options === undefined ? undefined : options.offset) !== null && _a2 !== undefined ? _a2 : false,
        local: (_b2 = options === null || options === undefined ? undefined : options.local) !== null && _b2 !== undefined ? _b2 : false,
        ...errorUtil_1.errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
        ...errorUtil_1.errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    regex(regex2, message) {
      return this._addCheck({
        kind: "regex",
        regex: regex2,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options === null || options === undefined ? undefined : options.position,
        ...errorUtil_1.errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil_1.errorUtil.errToObj(message)
      });
    }
    nonempty(message) {
      return this.min(1, errorUtil_1.errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch2) => ch2.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch2) => ch2.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch2) => ch2.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch2) => ch2.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch2) => ch2.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch2) => ch2.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch2) => ch2.kind === "ip");
    }
    get isBase64() {
      return !!this._def.checks.find((ch2) => ch2.kind === "base64");
    }
    get minLength() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max === null || ch2.value < max)
            max = ch2.value;
        }
      }
      return max;
    }
  }
  exports.ZodString = ZodString;
  ZodString.create = (params) => {
    var _a2;
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: (_a2 = params === null || params === undefined ? undefined : params.coerce) !== null && _a2 !== undefined ? _a2 : false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val2, step) {
    const valDecCount = (val2.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val2.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  }

  class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx2, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.number,
          received: ctx2.parsedType
        });
        return parseUtil_1.INVALID;
      }
      let ctx = undefined;
      const status = new parseUtil_1.ParseStatus;
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util_1.util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util_1.util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil_1.errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil_1.errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max === null || ch2.value < max)
            max = ch2.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util_1.util.isInteger(ch2.value));
    }
    get isFinite() {
      let max = null, min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
          return true;
        } else if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        } else if (ch2.kind === "max") {
          if (max === null || ch2.value < max)
            max = ch2.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  }
  exports.ZodNumber = ZodNumber;
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
      ...processCreateParams(params)
    });
  };

  class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = BigInt(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.bigint) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx2, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.bigint,
          received: ctx2.parsedType
        });
        return parseUtil_1.INVALID;
      }
      let ctx = undefined;
      const status = new parseUtil_1.ParseStatus;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util_1.util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil_1.errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max === null || ch2.value < max)
            max = ch2.value;
        }
      }
      return max;
    }
  }
  exports.ZodBigInt = ZodBigInt;
  ZodBigInt.create = (params) => {
    var _a2;
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: (_a2 = params === null || params === undefined ? undefined : params.coerce) !== null && _a2 !== undefined ? _a2 : false,
      ...processCreateParams(params)
    });
  };

  class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodBoolean = ZodBoolean;
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
      ...processCreateParams(params)
    });
  };

  class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx2, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.date,
          received: ctx2.parsedType
        });
        return parseUtil_1.INVALID;
      }
      if (isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx2, {
          code: ZodError_1.ZodIssueCode.invalid_date
        });
        return parseUtil_1.INVALID;
      }
      const status = new parseUtil_1.ParseStatus;
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util_1.util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil_1.errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max === null || ch2.value < max)
            max = ch2.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  }
  exports.ZodDate = ZodDate;
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };

  class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodSymbol = ZodSymbol;
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };

  class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodUndefined = ZodUndefined;
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };

  class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.null,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodNull = ZodNull;
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };

  class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodAny = ZodAny;
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };

  class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodUnknown = ZodUnknown;
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };

  class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      (0, parseUtil_1.addIssueToContext)(ctx, {
        code: ZodError_1.ZodIssueCode.invalid_type,
        expected: util_1.ZodParsedType.never,
        received: ctx.parsedType
      });
      return parseUtil_1.INVALID;
    }
  }
  exports.ZodNever = ZodNever;
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };

  class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.void,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
  }
  exports.ZodVoid = ZodVoid;
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };

  class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== util_1.ZodParsedType.array) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.array,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : undefined,
            maximum: tooBig ? def.exactLength.value : undefined,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i4) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i4));
        })).then((result2) => {
          return parseUtil_1.ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i4) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i4));
      });
      return parseUtil_1.ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  exports.ZodArray = ZodArray;
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }

  class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util_1.util.objectKeys(shape);
      return this._cached = { shape, keys };
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx2, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.object,
          received: ctx2.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") {
        } else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil_1.errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== undefined ? {
          errorMap: (issue, ctx) => {
            var _a2, _b2, _c2, _d2;
            const defaultError = (_c2 = (_b2 = (_a2 = this._def).errorMap) === null || _b2 === undefined ? undefined : _b2.call(_a2, issue, ctx).message) !== null && _c2 !== undefined ? _c2 : ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: (_d2 = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d2 !== undefined ? _d2 : defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    catchall(index) {
      return new ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      util_1.util.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      util_1.util.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      util_1.util.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      util_1.util.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util_1.util.objectKeys(this.shape));
    }
  }
  exports.ZodObject = ZodObject;
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };

  class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_union,
          unionErrors
        });
        return parseUtil_1.INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = undefined;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError_1.ZodError(issues2));
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_union,
          unionErrors
        });
        return parseUtil_1.INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  exports.ZodUnion = ZodUnion;
  ZodUnion.create = (types10, params) => {
    return new ZodUnion({
      options: types10,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  var getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return util_1.util.objectValues(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [undefined];
    } else if (type instanceof ZodNull) {
      return [null];
    } else if (type instanceof ZodOptional) {
      return [undefined, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodNullable) {
      return [null, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodBranded) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodReadonly) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodCatch) {
      return getDiscriminator(type._def.innerType);
    } else {
      return [];
    }
  };

  class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.object) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.object,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return parseUtil_1.INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(discriminator, options, params) {
      const optionsMap = new Map;
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  }
  exports.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
  function mergeValues(a5, b3) {
    const aType = (0, util_1.getParsedType)(a5);
    const bType = (0, util_1.getParsedType)(b3);
    if (a5 === b3) {
      return { valid: true, data: a5 };
    } else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {
      const bKeys = util_1.util.objectKeys(b3);
      const sharedKeys = util_1.util.objectKeys(a5).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a5, ...b3 };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a5[key], b3[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {
      if (a5.length !== b3.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0;index < a5.length; index++) {
        const itemA = a5[index];
        const itemB = b3[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === util_1.ZodParsedType.date && bType === util_1.ZodParsedType.date && +a5 === +b3) {
      return { valid: true, data: a5 };
    } else {
      return { valid: false };
    }
  }

  class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {
          return parseUtil_1.INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_intersection_types
          });
          return parseUtil_1.INVALID;
        }
        if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  }
  exports.ZodIntersection = ZodIntersection;
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };

  class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.array) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.array,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return parseUtil_1.INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x4) => !!x4);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return parseUtil_1.ParseStatus.mergeArray(status, results);
        });
      } else {
        return parseUtil_1.ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  }
  exports.ZodTuple = ZodTuple;
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };

  class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.object) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.object,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  }
  exports.ZodRecord = ZodRecord;

  class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.map) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.map,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = new Map;
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return parseUtil_1.INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = new Map;
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return parseUtil_1.INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  }
  exports.ZodMap = ZodMap;
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };

  class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.set) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.set,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = new Set;
        for (const element of elements2) {
          if (element.status === "aborted")
            return parseUtil_1.INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i4) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i4)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  exports.ZodSet = ZodSet;
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };

  class ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.function) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.function,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      function makeArgsIssue(args, error) {
        return (0, parseUtil_1.makeIssue)({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            (0, errors_1.getErrorMap)(),
            errors_1.defaultErrorMap
          ].filter((x4) => !!x4),
          issueData: {
            code: ZodError_1.ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return (0, parseUtil_1.makeIssue)({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            (0, errors_1.getErrorMap)(),
            errors_1.defaultErrorMap
          ].filter((x4) => !!x4),
          issueData: {
            code: ZodError_1.ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me2 = this;
        return (0, parseUtil_1.OK)(async function(...args) {
          const error = new ZodError_1.ZodError([]);
          const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e4) => {
            error.addIssue(makeArgsIssue(args, e4));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e4) => {
            error.addIssue(makeReturnsIssue(result, e4));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me2 = this;
        return (0, parseUtil_1.OK)(function(...args) {
          const parsedArgs = me2._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me2._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  }
  exports.ZodFunction = ZodFunction;

  class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  }
  exports.ZodLazy = ZodLazy;
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };

  class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          received: ctx.data,
          code: ZodError_1.ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return parseUtil_1.INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  }
  exports.ZodLiteral = ZodLiteral;
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }

  class ZodEnum extends ZodType {
    constructor() {
      super(...arguments);
      _ZodEnum_cache.set(this, undefined);
    }
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        (0, parseUtil_1.addIssueToContext)(ctx, {
          expected: util_1.util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodError_1.ZodIssueCode.invalid_type
        });
        return parseUtil_1.INVALID;
      }
      if (!__classPrivateFieldGet2(this, _ZodEnum_cache, "f")) {
        __classPrivateFieldSet2(this, _ZodEnum_cache, new Set(this._def.values), "f");
      }
      if (!__classPrivateFieldGet2(this, _ZodEnum_cache, "f").has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        (0, parseUtil_1.addIssueToContext)(ctx, {
          received: ctx.data,
          code: ZodError_1.ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val2 of this._def.values) {
        enumValues[val2] = val2;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val2 of this._def.values) {
        enumValues[val2] = val2;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val2 of this._def.values) {
        enumValues[val2] = val2;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  }
  exports.ZodEnum = ZodEnum;
  _ZodEnum_cache = new WeakMap;
  ZodEnum.create = createZodEnum;

  class ZodNativeEnum extends ZodType {
    constructor() {
      super(...arguments);
      _ZodNativeEnum_cache.set(this, undefined);
    }
    _parse(input) {
      const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== util_1.ZodParsedType.string && ctx.parsedType !== util_1.ZodParsedType.number) {
        const expectedValues = util_1.util.objectValues(nativeEnumValues);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          expected: util_1.util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodError_1.ZodIssueCode.invalid_type
        });
        return parseUtil_1.INVALID;
      }
      if (!__classPrivateFieldGet2(this, _ZodNativeEnum_cache, "f")) {
        __classPrivateFieldSet2(this, _ZodNativeEnum_cache, new Set(util_1.util.getValidEnumValues(this._def.values)), "f");
      }
      if (!__classPrivateFieldGet2(this, _ZodNativeEnum_cache, "f").has(input.data)) {
        const expectedValues = util_1.util.objectValues(nativeEnumValues);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          received: ctx.data,
          code: ZodError_1.ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return parseUtil_1.INVALID;
      }
      return (0, parseUtil_1.OK)(input.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  exports.ZodNativeEnum = ZodNativeEnum;
  _ZodNativeEnum_cache = new WeakMap;
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };

  class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_1.ZodParsedType.promise && ctx.common.async === false) {
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.promise,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      const promisified = ctx.parsedType === util_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return (0, parseUtil_1.OK)(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  }
  exports.ZodPromise = ZodPromise;
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };

  class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          (0, parseUtil_1.addIssueToContext)(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return parseUtil_1.INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return parseUtil_1.INVALID;
            if (result.status === "dirty")
              return (0, parseUtil_1.DIRTY)(result.value);
            if (status.value === "dirty")
              return (0, parseUtil_1.DIRTY)(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return parseUtil_1.INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return parseUtil_1.INVALID;
          if (result.status === "dirty")
            return (0, parseUtil_1.DIRTY)(result.value);
          if (status.value === "dirty")
            return (0, parseUtil_1.DIRTY)(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return parseUtil_1.INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return parseUtil_1.INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!(0, parseUtil_1.isValid)(base))
            return base;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!(0, parseUtil_1.isValid)(base))
              return base;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
          });
        }
      }
      util_1.util.assertNever(effect);
    }
  }
  exports.ZodEffects = ZodEffects;
  exports.ZodTransformer = ZodEffects;
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };

  class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === util_1.ZodParsedType.undefined) {
        return (0, parseUtil_1.OK)(undefined);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  exports.ZodOptional = ZodOptional;
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };

  class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === util_1.ZodParsedType.null) {
        return (0, parseUtil_1.OK)(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  exports.ZodNullable = ZodNullable;
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };

  class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === util_1.ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  exports.ZodDefault = ZodDefault;
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };

  class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if ((0, parseUtil_1.isAsync)(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError_1.ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError_1.ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  exports.ZodCatch = ZodCatch;
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };

  class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_1.ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.nan,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      return { status: "valid", value: input.data };
    }
  }
  exports.ZodNaN = ZodNaN;
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  exports.BRAND = Symbol("zod_brand");

  class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  exports.ZodBranded = ZodBranded;

  class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return parseUtil_1.INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return (0, parseUtil_1.DIRTY)(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return parseUtil_1.INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a5, b3) {
      return new ZodPipeline({
        in: a5,
        out: b3,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  }
  exports.ZodPipeline = ZodPipeline;

  class ZodReadonly extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if ((0, parseUtil_1.isValid)(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return (0, parseUtil_1.isAsync)(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  exports.ZodReadonly = ZodReadonly;
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  function custom(check, params = {}, fatal) {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        var _a2, _b2;
        if (!check(data)) {
          const p5 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
          const _fatal = (_b2 = (_a2 = p5.fatal) !== null && _a2 !== undefined ? _a2 : fatal) !== null && _b2 !== undefined ? _b2 : true;
          const p22 = typeof p5 === "string" ? { message: p5 } : p5;
          ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
        }
      });
    return ZodAny.create();
  }
  exports.custom = custom;
  exports.late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind = exports.ZodFirstPartyTypeKind || (exports.ZodFirstPartyTypeKind = {}));
  var instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data) => data instanceof cls, params);
  exports.instanceof = instanceOfType;
  var stringType = ZodString.create;
  exports.string = stringType;
  var numberType = ZodNumber.create;
  exports.number = numberType;
  var nanType = ZodNaN.create;
  exports.nan = nanType;
  var bigIntType = ZodBigInt.create;
  exports.bigint = bigIntType;
  var booleanType = ZodBoolean.create;
  exports.boolean = booleanType;
  var dateType = ZodDate.create;
  exports.date = dateType;
  var symbolType = ZodSymbol.create;
  exports.symbol = symbolType;
  var undefinedType = ZodUndefined.create;
  exports.undefined = undefinedType;
  var nullType = ZodNull.create;
  exports.null = nullType;
  var anyType = ZodAny.create;
  exports.any = anyType;
  var unknownType = ZodUnknown.create;
  exports.unknown = unknownType;
  var neverType = ZodNever.create;
  exports.never = neverType;
  var voidType = ZodVoid.create;
  exports.void = voidType;
  var arrayType = ZodArray.create;
  exports.array = arrayType;
  var objectType = ZodObject.create;
  exports.object = objectType;
  var strictObjectType = ZodObject.strictCreate;
  exports.strictObject = strictObjectType;
  var unionType = ZodUnion.create;
  exports.union = unionType;
  var discriminatedUnionType = ZodDiscriminatedUnion.create;
  exports.discriminatedUnion = discriminatedUnionType;
  var intersectionType = ZodIntersection.create;
  exports.intersection = intersectionType;
  var tupleType = ZodTuple.create;
  exports.tuple = tupleType;
  var recordType = ZodRecord.create;
  exports.record = recordType;
  var mapType = ZodMap.create;
  exports.map = mapType;
  var setType = ZodSet.create;
  exports.set = setType;
  var functionType = ZodFunction.create;
  exports.function = functionType;
  var lazyType = ZodLazy.create;
  exports.lazy = lazyType;
  var literalType = ZodLiteral.create;
  exports.literal = literalType;
  var enumType = ZodEnum.create;
  exports.enum = enumType;
  var nativeEnumType = ZodNativeEnum.create;
  exports.nativeEnum = nativeEnumType;
  var promiseType = ZodPromise.create;
  exports.promise = promiseType;
  var effectsType = ZodEffects.create;
  exports.effect = effectsType;
  exports.transformer = effectsType;
  var optionalType = ZodOptional.create;
  exports.optional = optionalType;
  var nullableType = ZodNullable.create;
  exports.nullable = nullableType;
  var preprocessType = ZodEffects.createWithPreprocess;
  exports.preprocess = preprocessType;
  var pipelineType = ZodPipeline.create;
  exports.pipeline = pipelineType;
  var ostring = () => stringType().optional();
  exports.ostring = ostring;
  var onumber = () => numberType().optional();
  exports.onumber = onumber;
  var oboolean = () => booleanType().optional();
  exports.oboolean = oboolean;
  exports.coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  exports.NEVER = parseUtil_1.INVALID;
});

// ../../node_modules/@prisma/extension-optimize/node_modules/zod/lib/external.js
var require_external = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(require_errors(), exports);
  __exportStar2(require_parseUtil(), exports);
  __exportStar2(require_typeAliases(), exports);
  __exportStar2(require_util2(), exports);
  __exportStar2(require_types3(), exports);
  __exportStar2(require_ZodError(), exports);
});

// ../../node_modules/@prisma/extension-optimize/node_modules/zod/lib/index.js
var require_lib = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    Object.defineProperty(o3, k22, { enumerable: true, get: function() {
      return m4[k4];
    } });
  } : function(o3, m4, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o3[k22] = m4[k4];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o3, v7) {
    Object.defineProperty(o3, "default", { enumerable: true, value: v7 });
  } : function(o3, v7) {
    o3["default"] = v7;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k4 in mod)
        if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod, k4))
          __createBinding2(result, mod, k4);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __exportStar2 = exports && exports.__exportStar || function(m4, exports2) {
    for (var p5 in m4)
      if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
        __createBinding2(exports2, m4, p5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.z = undefined;
  var z3 = __importStar2(require_external());
  exports.z = z3;
  __exportStar2(require_external(), exports);
  exports.default = z3;
});

// ../../node_modules/@prisma/extension-optimize/dist/index.js
var require_dist4 = __commonJS((exports, module) => {
  var yt = Object.create;
  var z3 = Object.defineProperty;
  var xt = Object.getOwnPropertyDescriptor;
  var bt2 = Object.getOwnPropertyNames;
  var It = Object.getPrototypeOf;
  var Tt = Object.prototype.hasOwnProperty;
  var Rt = (e4, t4) => {
    for (var n4 in t4)
      z3(e4, n4, { get: t4[n4], enumerable: true });
  };
  var ye = (e4, t4, n4, r5) => {
    if (t4 && typeof t4 == "object" || typeof t4 == "function")
      for (let s5 of bt2(t4))
        !Tt.call(e4, s5) && s5 !== n4 && z3(e4, s5, { get: () => t4[s5], enumerable: !(r5 = xt(t4, s5)) || r5.enumerable });
    return e4;
  };
  var wt = (e4, t4, n4) => (n4 = e4 != null ? yt(It(e4)) : {}, ye(t4 || !e4 || !e4.__esModule ? z3(n4, "default", { value: e4, enumerable: true }) : n4, e4));
  var vt = (e4) => ye(z3({}, "__esModule", { value: true }), e4);
  var rn = {};
  Rt(rn, { PROD_DASHBOARD_URL: () => gt, PROD_INGESTION_URL: () => dt, withOptimize: () => nn });
  module.exports = vt(rn);
  var ft = require_src();
  var mt = require_extension();
  var B4 = class {
    constructor() {
      this.keyToValue = new Map, this.valueToKey = new Map;
    }
    set(t4, n4) {
      this.keyToValue.set(t4, n4), this.valueToKey.set(n4, t4);
    }
    getByKey(t4) {
      return this.keyToValue.get(t4);
    }
    getByValue(t4) {
      return this.valueToKey.get(t4);
    }
    clear() {
      this.keyToValue.clear(), this.valueToKey.clear();
    }
  };
  var E3 = class {
    constructor(t4) {
      this.generateIdentifier = t4, this.kv = new B4;
    }
    register(t4, n4) {
      this.kv.getByValue(t4) || (n4 || (n4 = this.generateIdentifier(t4)), this.kv.set(n4, t4));
    }
    clear() {
      this.kv.clear();
    }
    getIdentifier(t4) {
      return this.kv.getByValue(t4);
    }
    getValue(t4) {
      return this.kv.getByKey(t4);
    }
  };
  var N4 = class extends E3 {
    constructor() {
      super((t4) => t4.name), this.classToAllowedProps = new Map;
    }
    register(t4, n4) {
      typeof n4 == "object" ? (n4.allowProps && this.classToAllowedProps.set(t4, n4.allowProps), super.register(t4, n4.identifier)) : super.register(t4, n4);
    }
    getAllowedProps(t4) {
      return this.classToAllowedProps.get(t4);
    }
  };
  function Et(e4) {
    if ("values" in Object)
      return Object.values(e4);
    let t4 = [];
    for (let n4 in e4)
      e4.hasOwnProperty(n4) && t4.push(e4[n4]);
    return t4;
  }
  function xe(e4, t4) {
    let n4 = Et(e4);
    if ("find" in n4)
      return n4.find(t4);
    let r5 = n4;
    for (let s5 = 0;s5 < r5.length; s5++) {
      let i4 = r5[s5];
      if (t4(i4))
        return i4;
    }
  }
  function R4(e4, t4) {
    Object.entries(e4).forEach(([n4, r5]) => t4(r5, n4));
  }
  function O4(e4, t4) {
    return e4.indexOf(t4) !== -1;
  }
  function Y3(e4, t4) {
    for (let n4 = 0;n4 < e4.length; n4++) {
      let r5 = e4[n4];
      if (t4(r5))
        return r5;
    }
  }
  var _3 = class {
    constructor() {
      this.transfomers = {};
    }
    register(t4) {
      this.transfomers[t4.name] = t4;
    }
    findApplicable(t4) {
      return xe(this.transfomers, (n4) => n4.isApplicable(t4));
    }
    findByName(t4) {
      return this.transfomers[t4];
    }
  };
  var Ot = (e4) => Object.prototype.toString.call(e4).slice(8, -1);
  var J3 = (e4) => typeof e4 > "u";
  var Pt = (e4) => e4 === null;
  var w4 = (e4) => typeof e4 != "object" || e4 === null || e4 === Object.prototype ? false : Object.getPrototypeOf(e4) === null ? true : Object.getPrototypeOf(e4) === Object.prototype;
  var V3 = (e4) => w4(e4) && Object.keys(e4).length === 0;
  var m4 = (e4) => Array.isArray(e4);
  var At = (e4) => typeof e4 == "string";
  var qt = (e4) => typeof e4 == "number" && !isNaN(e4);
  var Ct = (e4) => typeof e4 == "boolean";
  var be2 = (e4) => e4 instanceof RegExp;
  var b3 = (e4) => e4 instanceof Map;
  var I4 = (e4) => e4 instanceof Set;
  var ee2 = (e4) => Ot(e4) === "Symbol";
  var Ie = (e4) => e4 instanceof Date && !isNaN(e4.valueOf());
  var Te = (e4) => e4 instanceof Error;
  var te = (e4) => typeof e4 == "number" && isNaN(e4);
  var Re = (e4) => Ct(e4) || Pt(e4) || J3(e4) || qt(e4) || At(e4) || ee2(e4);
  var we = (e4) => typeof e4 == "bigint";
  var ve = (e4) => e4 === 1 / 0 || e4 === -1 / 0;
  var Ee = (e4) => ArrayBuffer.isView(e4) && !(e4 instanceof DataView);
  var Oe = (e4) => e4 instanceof URL;
  var ne = (e4) => e4.replace(/\./g, "\\.");
  var M3 = (e4) => e4.map(String).map(ne).join(".");
  var P4 = (e4) => {
    let t4 = [], n4 = "";
    for (let s5 = 0;s5 < e4.length; s5++) {
      let i4 = e4.charAt(s5);
      if (i4 === "\\" && e4.charAt(s5 + 1) === ".") {
        n4 += ".", s5++;
        continue;
      }
      if (i4 === ".") {
        t4.push(n4), n4 = "";
        continue;
      }
      n4 += i4;
    }
    let r5 = n4;
    return t4.push(r5), t4;
  };
  function h4(e4, t4, n4, r5) {
    return { isApplicable: e4, annotation: t4, transform: n4, untransform: r5 };
  }
  var Pe = [h4(J3, "undefined", () => null, () => {
  }), h4(we, "bigint", (e4) => e4.toString(), (e4) => typeof BigInt < "u" ? BigInt(e4) : (console.error("Please add a BigInt polyfill."), e4)), h4(Ie, "Date", (e4) => e4.toISOString(), (e4) => new Date(e4)), h4(Te, "Error", (e4, t4) => {
    let n4 = { name: e4.name, message: e4.message };
    return t4.allowedErrorProps.forEach((r5) => {
      n4[r5] = e4[r5];
    }), n4;
  }, (e4, t4) => {
    let n4 = new Error(e4.message);
    return n4.name = e4.name, n4.stack = e4.stack, t4.allowedErrorProps.forEach((r5) => {
      n4[r5] = e4[r5];
    }), n4;
  }), h4(be2, "regexp", (e4) => "" + e4, (e4) => {
    let t4 = e4.slice(1, e4.lastIndexOf("/")), n4 = e4.slice(e4.lastIndexOf("/") + 1);
    return new RegExp(t4, n4);
  }), h4(I4, "set", (e4) => [...e4.values()], (e4) => new Set(e4)), h4(b3, "map", (e4) => [...e4.entries()], (e4) => new Map(e4)), h4((e4) => te(e4) || ve(e4), "number", (e4) => te(e4) ? "NaN" : e4 > 0 ? "Infinity" : "-Infinity", Number), h4((e4) => e4 === 0 && 1 / e4 === -1 / 0, "number", () => "-0", Number), h4(Oe, "URL", (e4) => e4.toString(), (e4) => new URL(e4))];
  function F3(e4, t4, n4, r5) {
    return { isApplicable: e4, annotation: t4, transform: n4, untransform: r5 };
  }
  var Ae = F3((e4, t4) => ee2(e4) ? !!t4.symbolRegistry.getIdentifier(e4) : false, (e4, t4) => ["symbol", t4.symbolRegistry.getIdentifier(e4)], (e4) => e4.description, (e4, t4, n4) => {
    let r5 = n4.symbolRegistry.getValue(t4[1]);
    if (!r5)
      throw new Error("Trying to deserialize unknown symbol");
    return r5;
  });
  var kt = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array, Uint8ClampedArray].reduce((e4, t4) => (e4[t4.name] = t4, e4), {});
  var qe = F3(Ee, (e4) => ["typed-array", e4.constructor.name], (e4) => [...e4], (e4, t4) => {
    let n4 = kt[t4[1]];
    if (!n4)
      throw new Error("Trying to deserialize unknown typed array");
    return new n4(e4);
  });
  function re(e4, t4) {
    return e4?.constructor ? !!t4.classRegistry.getIdentifier(e4.constructor) : false;
  }
  var Ce = F3(re, (e4, t4) => ["class", t4.classRegistry.getIdentifier(e4.constructor)], (e4, t4) => {
    let n4 = t4.classRegistry.getAllowedProps(e4.constructor);
    if (!n4)
      return { ...e4 };
    let r5 = {};
    return n4.forEach((s5) => {
      r5[s5] = e4[s5];
    }), r5;
  }, (e4, t4, n4) => {
    let r5 = n4.classRegistry.getValue(t4[1]);
    if (!r5)
      throw new Error(`Trying to deserialize unknown class '${t4[1]}' - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564`);
    return Object.assign(Object.create(r5.prototype), e4);
  });
  var ke = F3((e4, t4) => !!t4.customTransformerRegistry.findApplicable(e4), (e4, t4) => ["custom", t4.customTransformerRegistry.findApplicable(e4).name], (e4, t4) => t4.customTransformerRegistry.findApplicable(e4).serialize(e4), (e4, t4, n4) => {
    let r5 = n4.customTransformerRegistry.findByName(t4[1]);
    if (!r5)
      throw new Error("Trying to deserialize unknown custom value");
    return r5.deserialize(e4);
  });
  var jt = [Ce, Ae, ke, qe];
  var se = (e4, t4) => {
    let n4 = Y3(jt, (s5) => s5.isApplicable(e4, t4));
    if (n4)
      return { value: n4.transform(e4, t4), type: n4.annotation(e4, t4) };
    let r5 = Y3(Pe, (s5) => s5.isApplicable(e4, t4));
    if (r5)
      return { value: r5.transform(e4, t4), type: r5.annotation };
  };
  var je = {};
  Pe.forEach((e4) => {
    je[e4.annotation] = e4;
  });
  var ze = (e4, t4, n4) => {
    if (m4(t4))
      switch (t4[0]) {
        case "symbol":
          return Ae.untransform(e4, t4, n4);
        case "class":
          return Ce.untransform(e4, t4, n4);
        case "custom":
          return ke.untransform(e4, t4, n4);
        case "typed-array":
          return qe.untransform(e4, t4, n4);
        default:
          throw new Error("Unknown transformation: " + t4);
      }
    else {
      let r5 = je[t4];
      if (!r5)
        throw new Error("Unknown transformation: " + t4);
      return r5.untransform(e4, n4);
    }
  };
  var A4 = (e4, t4) => {
    if (t4 > e4.size)
      throw new Error("index out of bounds");
    let n4 = e4.keys();
    for (;t4 > 0; )
      n4.next(), t4--;
    return n4.next().value;
  };
  function Be(e4) {
    if (O4(e4, "__proto__"))
      throw new Error("__proto__ is not allowed as a property");
    if (O4(e4, "prototype"))
      throw new Error("prototype is not allowed as a property");
    if (O4(e4, "constructor"))
      throw new Error("constructor is not allowed as a property");
  }
  var Ne = (e4, t4) => {
    Be(t4);
    for (let n4 = 0;n4 < t4.length; n4++) {
      let r5 = t4[n4];
      if (I4(e4))
        e4 = A4(e4, +r5);
      else if (b3(e4)) {
        let s5 = +r5, i4 = +t4[++n4] == 0 ? "key" : "value", a5 = A4(e4, s5);
        switch (i4) {
          case "key":
            e4 = a5;
            break;
          case "value":
            e4 = e4.get(a5);
            break;
        }
      } else
        e4 = e4[r5];
    }
    return e4;
  };
  var U3 = (e4, t4, n4) => {
    if (Be(t4), t4.length === 0)
      return n4(e4);
    let r5 = e4;
    for (let i4 = 0;i4 < t4.length - 1; i4++) {
      let a5 = t4[i4];
      if (m4(r5)) {
        let u5 = +a5;
        r5 = r5[u5];
      } else if (w4(r5))
        r5 = r5[a5];
      else if (I4(r5)) {
        let u5 = +a5;
        r5 = A4(r5, u5);
      } else if (b3(r5)) {
        if (i4 === t4.length - 2)
          break;
        let p5 = +a5, S4 = +t4[++i4] == 0 ? "key" : "value", d4 = A4(r5, p5);
        switch (S4) {
          case "key":
            r5 = d4;
            break;
          case "value":
            r5 = r5.get(d4);
            break;
        }
      }
    }
    let s5 = t4[t4.length - 1];
    if (m4(r5) ? r5[+s5] = n4(r5[+s5]) : w4(r5) && (r5[s5] = n4(r5[s5])), I4(r5)) {
      let i4 = A4(r5, +s5), a5 = n4(i4);
      i4 !== a5 && (r5.delete(i4), r5.add(a5));
    }
    if (b3(r5)) {
      let i4 = +t4[t4.length - 2], a5 = A4(r5, i4);
      switch (+s5 == 0 ? "key" : "value") {
        case "key": {
          let p5 = n4(a5);
          r5.set(p5, r5.get(a5)), p5 !== a5 && r5.delete(a5);
          break;
        }
        case "value": {
          r5.set(a5, n4(r5.get(a5)));
          break;
        }
      }
    }
    return e4;
  };
  function ie(e4, t4, n4 = []) {
    if (!e4)
      return;
    if (!m4(e4)) {
      R4(e4, (i4, a5) => ie(i4, t4, [...n4, ...P4(a5)]));
      return;
    }
    let [r5, s5] = e4;
    s5 && R4(s5, (i4, a5) => {
      ie(i4, t4, [...n4, ...P4(a5)]);
    }), t4(r5, n4);
  }
  function _e2(e4, t4, n4) {
    return ie(t4, (r5, s5) => {
      e4 = U3(e4, s5, (i4) => ze(i4, r5, n4));
    }), e4;
  }
  function Ve(e4, t4) {
    function n4(r5, s5) {
      let i4 = Ne(e4, P4(s5));
      r5.map(P4).forEach((a5) => {
        e4 = U3(e4, a5, () => i4);
      });
    }
    if (m4(t4)) {
      let [r5, s5] = t4;
      r5.forEach((i4) => {
        e4 = U3(e4, P4(i4), () => e4);
      }), s5 && R4(s5, n4);
    } else
      R4(t4, n4);
    return e4;
  }
  var zt = (e4, t4) => w4(e4) || m4(e4) || b3(e4) || I4(e4) || re(e4, t4);
  function Bt(e4, t4, n4) {
    let r5 = n4.get(e4);
    r5 ? r5.push(t4) : n4.set(e4, [t4]);
  }
  function Me(e4, t4) {
    let n4 = {}, r5;
    return e4.forEach((s5) => {
      if (s5.length <= 1)
        return;
      t4 || (s5 = s5.map((u5) => u5.map(String)).sort((u5, p5) => u5.length - p5.length));
      let [i4, ...a5] = s5;
      i4.length === 0 ? r5 = a5.map(M3) : n4[M3(i4)] = a5.map(M3);
    }), r5 ? V3(n4) ? [r5] : [r5, n4] : V3(n4) ? undefined : n4;
  }
  var oe = (e4, t4, n4, r5, s5 = [], i4 = [], a5 = new Map) => {
    let u5 = Re(e4);
    if (!u5) {
      Bt(e4, s5, t4);
      let g3 = a5.get(e4);
      if (g3)
        return r5 ? { transformedValue: null } : g3;
    }
    if (!zt(e4, n4)) {
      let g3 = se(e4, n4), l4 = g3 ? { transformedValue: g3.value, annotations: [g3.type] } : { transformedValue: e4 };
      return u5 || a5.set(e4, l4), l4;
    }
    if (O4(i4, e4))
      return { transformedValue: null };
    let p5 = se(e4, n4), S4 = p5?.value ?? e4, d4 = m4(S4) ? [] : {}, y4 = {};
    R4(S4, (g3, l4) => {
      if (l4 === "__proto__" || l4 === "constructor" || l4 === "prototype")
        throw new Error(`Detected property ${l4}. This is a prototype pollution risk, please remove it from your object.`);
      let x4 = oe(g3, t4, n4, r5, [...s5, l4], [...i4, e4], a5);
      d4[l4] = x4.transformedValue, m4(x4.annotations) ? y4[l4] = x4.annotations : w4(x4.annotations) && R4(x4.annotations, (G4, Z2) => {
        y4[ne(l4) + "." + Z2] = G4;
      });
    });
    let j4 = V3(y4) ? { transformedValue: d4, annotations: p5 ? [p5.type] : undefined } : { transformedValue: d4, annotations: p5 ? [p5.type, y4] : y4 };
    return u5 || a5.set(e4, j4), j4;
  };
  function D3(e4) {
    return Object.prototype.toString.call(e4).slice(8, -1);
  }
  function ae2(e4) {
    return D3(e4) === "Array";
  }
  function Fe(e4) {
    if (D3(e4) !== "Object")
      return false;
    let t4 = Object.getPrototypeOf(e4);
    return !!t4 && t4.constructor === Object && t4 === Object.prototype;
  }
  function Nt(e4) {
    return D3(e4) === "Null";
  }
  function _t(e4, t4, n4, r5, s5) {
    return (i4) => e4(i4) || t4(i4) || !!n4 && n4(i4) || !!r5 && r5(i4) || !!s5 && s5(i4);
  }
  function Vt(e4) {
    return D3(e4) === "Undefined";
  }
  var An = _t(Nt, Vt);
  function Mt(e4, t4, n4, r5, s5) {
    let i4 = {}.propertyIsEnumerable.call(r5, t4) ? "enumerable" : "nonenumerable";
    i4 === "enumerable" && (e4[t4] = n4), s5 && i4 === "nonenumerable" && Object.defineProperty(e4, t4, { value: n4, enumerable: false, writable: true, configurable: true });
  }
  function L4(e4, t4 = {}) {
    if (ae2(e4))
      return e4.map((s5) => L4(s5, t4));
    if (!Fe(e4))
      return e4;
    let n4 = Object.getOwnPropertyNames(e4), r5 = Object.getOwnPropertySymbols(e4);
    return [...n4, ...r5].reduce((s5, i4) => {
      if (ae2(t4.props) && !t4.props.includes(i4))
        return s5;
      let a5 = e4[i4], u5 = L4(a5, t4);
      return Mt(s5, i4, u5, e4, t4.nonenumerable), s5;
    }, {});
  }
  var c5 = class {
    constructor({ dedupe: t4 = false } = {}) {
      this.classRegistry = new N4, this.symbolRegistry = new E3((n4) => n4.description ?? ""), this.customTransformerRegistry = new _3, this.allowedErrorProps = [], this.dedupe = t4;
    }
    serialize(t4) {
      let n4 = new Map, r5 = oe(t4, n4, this, this.dedupe), s5 = { json: r5.transformedValue };
      r5.annotations && (s5.meta = { ...s5.meta, values: r5.annotations });
      let i4 = Me(n4, this.dedupe);
      return i4 && (s5.meta = { ...s5.meta, referentialEqualities: i4 }), s5;
    }
    deserialize(t4) {
      let { json: n4, meta: r5 } = t4, s5 = L4(n4);
      return r5?.values && (s5 = _e2(s5, r5.values, this)), r5?.referentialEqualities && (s5 = Ve(s5, r5.referentialEqualities)), s5;
    }
    stringify(t4) {
      return JSON.stringify(this.serialize(t4));
    }
    parse(t4) {
      return this.deserialize(JSON.parse(t4));
    }
    registerClass(t4, n4) {
      this.classRegistry.register(t4, n4);
    }
    registerSymbol(t4, n4) {
      this.symbolRegistry.register(t4, n4);
    }
    registerCustom(t4, n4) {
      this.customTransformerRegistry.register({ name: n4, ...t4 });
    }
    allowErrorProps(...t4) {
      this.allowedErrorProps.push(...t4);
    }
  };
  c5.defaultInstance = new c5;
  c5.serialize = c5.defaultInstance.serialize.bind(c5.defaultInstance);
  c5.deserialize = c5.defaultInstance.deserialize.bind(c5.defaultInstance);
  c5.stringify = c5.defaultInstance.stringify.bind(c5.defaultInstance);
  c5.parse = c5.defaultInstance.parse.bind(c5.defaultInstance);
  c5.registerClass = c5.defaultInstance.registerClass.bind(c5.defaultInstance);
  c5.registerSymbol = c5.defaultInstance.registerSymbol.bind(c5.defaultInstance);
  c5.registerCustom = c5.defaultInstance.registerCustom.bind(c5.defaultInstance);
  c5.allowErrorProps = c5.defaultInstance.allowErrorProps.bind(c5.defaultInstance);
  var Vn = c5.serialize;
  var Ft = c5.deserialize;
  var Ue = c5.stringify;
  var Mn = c5.parse;
  var Fn = c5.registerClass;
  var De = c5.registerCustom;
  var Un = c5.registerSymbol;
  var Dn = c5.allowErrorProps;
  var $e = false;
  function Ut(e4) {
    De({ isApplicable: (t4) => (e4?.isBuffer?.(t4) ?? (typeof Buffer < "u" && Buffer.isBuffer(t4))) || Le(t4), serialize: (t4) => Le(t4) ? t4.data : [...t4], deserialize: (t4) => e4?.from?.(t4) ?? (typeof Buffer < "u" ? Buffer.from(t4) : { type: "Buffer", data: t4 }) }, "buffer"), $e = true;
  }
  function Le(e4) {
    return typeof e4 == "object" && e4 !== null && Reflect.get(e4, "type") === "Buffer" && Array.isArray(Reflect.get(e4, "data"));
  }
  var He = (e4) => typeof e4 == "string" ? e4 : ($e || Ut(), Ue(e4));
  function Dt(e4, t4) {
    let n4;
    return async function(r5, s5, i4) {
      let a5 = new URL(r5, e4), u5 = new Headers({ "Content-Type": "application/json", Authorization: `Bearer ${t4}` });
      n4 && u5.set("prisma-optimize-jwt", n4);
      let p5 = await fetch(a5, { method: s5, headers: u5, body: He(i4) });
      if (!p5.ok) {
        let d4 = await p5.clone().text().catch(() => "<unreadable>");
        console.error(`[optimize] HTTP ${p5.status} ${p5.statusText}: ${d4}`);
      }
      let S4 = p5.headers.get("prisma-optimize-jwt");
      return S4 && (n4 = S4), p5;
    };
  }
  function Ke(e4, t4) {
    let n4 = Dt(e4, t4);
    return { request: n4, post: (r5, s5) => n4(r5, "POST", s5) };
  }
  var Qe = wt(require_kleur());
  var { bold: Lt, underline: $t } = Qe.default;
  function We(e4) {
    let t4 = "See your Optimize dashboard at:", n4 = t4.length, r5 = `${$t(Lt(e4))}`, s5 = e4.length, i4 = Math.max(n4, s5) + 2;
    console.log("\u250C" + "\u2500".repeat(i4) + "\u2510"), console.log("\u2502 " + t4 + " ".repeat(i4 - n4 - 2) + " \u2502"), console.log("\u2502 " + r5 + " ".repeat(i4 - s5 - 2) + " \u2502"), console.log("\u2514" + "\u2500".repeat(i4) + "\u2518");
  }
  var et = require_src();
  var tt = require_src2();
  var nt = require_src5();
  var rt = require_src9();
  var st = require_src11();
  var W3 = require_src12();
  var ge = require_dist2();
  var it = require_dist3();
  async function Ge(e4, t4) {
    t4.length > 0 && await e4.post("/ingest", t4);
  }
  async function Ze(e4, t4) {
    return await (await e4.post("/schema", t4)).text();
  }
  function T4(e4) {
    return e4[0] * 1000 + e4[1] / 1e6;
  }
  var o3 = require_lib();
  var v7 = require_lib();
  var $ = class {
    spans = {};
    rootSpans = {};
    waitSpans = {};
    treeShape;
    collectedSpans;
    collectedRootSpans;
    sendTimeout;
    sendInterval;
    pendingSend;
    constructor(t4) {
      this.treeShape = t4.treeShape, this.sendTimeout = t4.sendTimeout, this.sendInterval = t4.sendInterval, this.collectedSpans = t4.collectedSpans, this.collectedRootSpans = t4.collectedRootSpans, this.onEnd = Ht(() => void this.forceFlush(), this.sendInterval);
    }
    onStart(t4) {
      let { parentSpanId: n4, name: r5 } = t4, { spanId: s5 } = t4.spanContext();
      if (!this.collectedSpans.includes(r5))
        return this.cleanSpan(this.spans[s5]);
      this.spans[s5] && this.spans[s5].kind === "future" ? Object.assign(this.spans[s5], { kind: "present", value: t4 }) : this.spans[s5] = { spanId: s5, kind: "present", children: [], value: t4, retries: 0 }, this.collectedRootSpans.includes(r5) && (this.rootSpans[s5] = { ...this.spans[s5], done: false }, this.waitSpans[s5] = this.spans[s5]), n4 !== undefined && (this.spans[n4] ? this.spans[n4].children.push(this.spans[s5]) : (this.spans[n4] = { spanId: n4, kind: "future", children: [this.spans[s5]], retries: 0 }, this.waitSpans[n4] = this.spans[n4]));
    }
    cleanSpan(t4) {
      if (t4 === undefined)
        return;
      let n4 = t4.spanId;
      for (let r5 of t4.children)
        this.cleanSpan(r5);
      delete this.spans[n4], delete this.rootSpans[n4], delete this.waitSpans[n4], this.onClean(t4);
    }
    async forceFlush() {
      await this.pendingSend;
      let t4 = Object.values(this.rootSpans).flatMap((n4) => {
        if (n4.done)
          return [];
        let r5 = this.treeShape.safeParse(n4);
        return r5.data ? (n4.done = true, [{ original: n4, pruned: r5.data }]) : [];
      });
      t4.length > 0 && (this.pendingSend = this.onFlush(t4).finally(() => {
        t4.forEach(({ original: n4 }) => this.cleanSpan(n4));
      }));
      for (let n4 of Object.values(this.waitSpans))
        ++n4.retries * this.sendInterval > this.sendTimeout && this.cleanSpan(n4);
    }
    async shutdown() {
      await this.forceFlush(), this.spans = {}, this.rootSpans = {}, this.waitSpans = {};
    }
    onEnd() {
    }
  };
  function Ht(e4, t4) {
    let n4 = false;
    return () => {
      n4 === false && (n4 = true, setTimeout(() => (n4 = false) || e4(), t4));
    };
  }
  var f4 = { ended: v7.z.literal(true), _spanContext: v7.z.custom(), spanContext: v7.z.custom(), startTime: v7.z.custom(), endTime: v7.z.custom(), attributes: v7.z.custom() };
  var Xe = o3.z.object({ value: o3.z.object({ name: o3.z.literal("prisma:engine:db_query"), ...f4 }) });
  var Kt = o3.z.object({ value: o3.z.object({ name: o3.z.literal("prisma:engine:itx_execute_single"), ...f4 }), children: q4([Xe]) });
  var H2 = o3.z.object({ value: o3.z.object({ name: o3.z.union([o3.z.literal("prisma:engine"), o3.z.literal("prisma:engine:query")]), ...f4 }), children: q4([Xe]) });
  var Qt = o3.z.object({ value: o3.z.object({ name: o3.z.union([o3.z.literal("prisma:engine"), o3.z.literal("prisma:engine:query")]), ...f4 }), children: q4([Kt]) });
  var K2 = o3.z.object({ value: o3.z.object({ name: o3.z.literal("prisma:client:connect"), ...f4 }) });
  var ce2 = o3.z.object({ value: o3.z.object({ name: o3.z.literal("prisma:client:operation"), ...f4 }), children: o3.z.union([o3.z.tuple([H2]), o3.z.tuple([K2, H2]), o3.z.tuple([H2, K2])]) });
  var ue2 = o3.z.object({ value: o3.z.object({ name: o3.z.literal("prisma:client:operation"), ...f4 }), children: q4([Qt]) });
  var Wt = o3.z.object({ value: o3.z.object({ name: o3.z.union([o3.z.literal("prisma:engine:start_transaction"), o3.z.literal("prisma:engine:commit_transaction")]), ...f4 }) });
  var pe2 = o3.z.object({ value: o3.z.object({ name: o3.z.literal("prisma:client:operation"), ...f4 }), children: o3.z.array(K2) });
  var le = o3.z.object({ value: o3.z.object({ name: o3.z.literal("prisma:client:transaction"), ...f4 }), children: q4([Wt, ue2, K2]) });
  var fe = o3.z.object({ value: o3.z.object({ name: o3.z.literal("prisma:client:transaction"), ...f4 }), children: q4([pe2, H2]) });
  var Ye = o3.z.union([ce2, le, fe]);
  function q4(e4) {
    return o3.z.array(o3.z.any()).nonempty().superRefine((t4, n4) => {
      e4.every((s5) => t4.some((i4) => s5.safeParse(i4).success)) || n4.addIssue({ code: "custom", message: "Array does not contain all the required items" });
    });
  }
  var Q3 = class extends $ {
    requests = {};
    errors = {};
    schemaHash;
    resolvedSchemaHash;
    apiClient;
    schemaRequest;
    constructor(t4) {
      super({ treeShape: Ye, sendTimeout: t4.sendTimeout, sendInterval: t4.sendInterval, collectedSpans: ["prisma:client:transaction", "prisma:client:operation", "prisma:client:connect", "prisma:engine", "prisma:engine:query", "prisma:engine:db_query", "prisma:engine:itx_execute_single", "prisma:engine:start_transaction", "prisma:engine:commit_transaction"], collectedRootSpans: ["prisma:client:operation", "prisma:client:transaction"] }), this.apiClient = t4.apiClient, this.schemaRequest = t4.schemaRequest;
    }
    setRequest(t4) {
      this.requests[t4.spanId] = t4;
    }
    setError(t4) {
      this.errors[t4.spanId] = t4;
    }
    onClean({ spanId: t4 }) {
      delete this.requests[t4], delete this.errors[t4];
    }
    async onFlush(t4) {
      this.schemaHash ??= Ze(this.apiClient, this.schemaRequest), this.resolvedSchemaHash ??= await this.schemaHash;
      let n4 = t4.flatMap(({ pruned: r5 }) => Gt(r5, this));
      await Ge(this.apiClient, n4);
    }
  };
  function Gt(e4, t4) {
    return le.safeParse(e4).success ? Zt(e4, t4) : fe.safeParse(e4).success ? Xt(e4, t4) : ce2.safeParse(e4).success ? Yt(e4, t4) : [];
  }
  function Zt(e4, t4) {
    let n4 = [], r5 = e4.children.filter((s5) => ue2.safeParse(s5).success);
    for (let s5 of r5) {
      if (de2({ span: s5, ip: t4 }) === false)
        continue;
      let i4 = en(s5);
      n4.push(C3({ ip: t4, span: s5, sql: i4, connect: false }));
    }
    if (n4.length) {
      let s5 = me2(e4);
      n4.unshift(C3({ ip: t4, span: e4, sql: null, connect: s5 }));
    }
    return n4;
  }
  function Xt(e4, t4) {
    let n4 = [], r5 = e4.children.filter((i4) => pe2.safeParse(i4).success), s5 = false;
    for (let i4 of r5)
      de2({ span: i4, ip: t4 }) !== false && (s5 ||= me2(i4), n4.push(C3({ ip: t4, span: i4, sql: null, connect: false })));
    return n4.length && n4.unshift(C3({ ip: t4, span: e4, sql: null, connect: s5 })), n4;
  }
  function Yt(e4, t4) {
    let n4 = me2(e4), r5 = Jt(e4);
    return de2({ span: e4, ip: t4 }) === false ? [] : [C3({ ip: t4, span: e4, sql: r5, connect: n4 })];
  }
  function C3(e4) {
    let { span: t4, sql: n4, connect: r5, ip: s5 } = e4, i4 = t4.value.spanContext().spanId, { value: a5 } = t4;
    return { hash: s5.resolvedSchemaHash, sql: n4 ?? null, connect: r5 ?? false, error: s5.errors[i4]?.error ?? null, ts: T4(a5.startTime), model: s5.requests[i4]?.model ?? a5.attributes.model ?? null, operation: s5.requests[i4]?.operation ?? a5.attributes.method, args: s5.requests[i4]?.args ?? {}, latency: T4(a5.endTime) - T4(a5.startTime) };
  }
  function Je(e4) {
    return e4.sort((n4, r5) => T4(n4.value.startTime) - T4(r5.value.startTime)).reduce((n4, r5) => {
      let s5 = r5.value.attributes["db.statement"];
      return s5 ??= r5.value.attributes["db.query.text"], typeof s5 == "string" ? `${n4}${s5}
` : n4;
    }, "");
  }
  function Jt(e4) {
    let { children: t4 } = e4.children.find(({ value: r5 }) => r5.name === "prisma:engine" || r5.name === "prisma:engine:query"), n4 = t4.filter(({ value: r5 }) => r5.name === "prisma:engine:db_query");
    return Je(n4);
  }
  function en(e4) {
    let { children: t4 } = e4.children.find(({ value: s5 }) => s5.name === "prisma:engine" || s5.name === "prisma:engine:query"), r5 = t4.filter(({ value: s5 }) => s5.name === "prisma:engine:itx_execute_single").flatMap(({ children: s5 }) => s5.filter(({ value: i4 }) => i4.name === "prisma:engine:db_query"));
    return Je(r5);
  }
  function me2(e4) {
    let { value: t4 } = e4.children.find(({ value: n4 }) => n4.name === "prisma:client:connect") ?? {};
    return t4 ? T4(t4.endTime) - T4(t4.startTime) : false;
  }
  function de2(e4) {
    let { span: t4, ip: n4 } = e4;
    return !!n4.requests[t4.value.spanContext().spanId];
  }
  var k4;
  var tn = { "5-x": ge.PrismaInstrumentation, "6-x": it.PrismaInstrumentation };
  function ot(e4) {
    if (k4)
      return k4;
    let t4 = new tt.AsyncHooksContextManager().enable();
    et.context.setGlobalContextManager(t4);
    let n4 = new st.BasicTracerProvider({ resource: new rt.Resource({ [W3.SEMRESATTRS_SERVICE_NAME]: "extension-optimize", [W3.SEMRESATTRS_SERVICE_VERSION]: "0.0.0" }) });
    k4 = new Q3(e4), n4.addSpanProcessor(k4);
    let [r5 = "5", s5 = "0"] = e4.clientVersion.split("."), i4 = tn[`${r5}-x`];
    return (r5 === "6" && s5 === "0" || i4 === undefined) && (i4 = ge.PrismaInstrumentation), (0, nt.registerInstrumentations)({ tracerProvider: n4, instrumentations: [new i4] }), n4.register(), k4;
  }
  function at2(e4) {
    let t4 = Reflect.get(e4, "_clientVersion");
    return Number(t4.split(".")[0] ?? "5") < 6 ? e4._previewFeatures?.includes("tracing") : true;
  }
  function ct2(e4) {
    return e4._engineConfig.inlineSchema;
  }
  function ut(e4) {
    if (e4 instanceof Error)
      return e4.stack ?? e4.message;
    switch (typeof e4) {
      case "undefined":
        return "undefined";
      case "object": {
        let t4;
        return e4 !== null && typeof e4.toString == "function" && (t4 = e4.toString()), typeof t4 == "string" && t4 !== "[object Object]" ? t4 : JSON.stringify(e4);
      }
      default:
        return String(e4);
    }
  }
  var pt = require_extension();
  var lt = pt.Prisma.defineExtension((e4) => e4.$extends({}));
  var dt = "https://optimize-ingestion.datacdn.workers.dev/";
  var gt = "https://optimize.prisma.io";
  function nn({ enable: e4 = true, ingestionUrl: t4 = dt, dashboardUrl: n4 = gt, sendInterval: r5 = 500, sendTimeout: s5 = 1e4, showNotification: i4 = true, apiKey: a5 }) {
    return e4 ? (i4 && We(n4), mt.Prisma.defineExtension((u5) => {
      let p5 = ct2(u5), S4 = Reflect.get(u5, "_clientVersion"), d4 = Reflect.get(u5, "_activeProvider"), y4 = Reflect.get(u5, "_accelerateEngineConfig"), { protocol: j4 } = new URL(y4.accelerateUtils.resolveDatasourceUrl(y4)), g3 = { schema: p5, provider: d4, protocol: j4 }, l4 = Ke(t4, a5), x4 = ot({ schemaRequest: g3, apiClient: l4, sendInterval: r5, sendTimeout: s5, clientVersion: S4 });
      if (!at2(u5))
        throw new Error('Please enable the "tracing" preview feature and regenerate the client.');
      return u5.$extends({ query: { async $allOperations({ query: G4, model: Z2, operation: ht, args: he }) {
        let X3 = ft.trace.getActiveSpan()?.spanContext().spanId;
        if (!X3)
          throw new Error("prisma:client:operation span is expected to be entered in the client extension when tracing is enabled");
        x4.setRequest({ spanId: X3, model: Z2, operation: ht, args: he });
        try {
          return await G4(he);
        } catch (Se) {
          let St = ut(Se);
          throw x4.setError({ spanId: X3, error: St }), Se;
        }
      } } });
    })) : lt;
  }
});
// ../huginn-shared/src/constants.ts
var constants = {
  USERNAME_MIN_LENGTH: 4,
  USERNAME_MAX_LENGTH: 20,
  DISPLAY_NAME_MIN_LENGTH: 1,
  DISPLAY_NAME_MAX_LENGTH: 32,
  PASSWORD_MIN_LENGTH: 4,
  IDENTITY_TOKEN_EXPIRE_TIME: "5mins",
  ACCESS_TOKEN_EXPIRE_TIME: "1d",
  REFRESH_TOKEN_EXPIRE_TIME: "7d",
  EMAIL_REGEX: /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|.(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
  USERNAME_REGEX: /^[a-zA-Z0-9_.]*$/,
  HEARTBEAT_INTERVAL: 20000,
  ALLOWED_IMAGE_SIZES: [16, 32, 64, 128, 256, 512, 1024, 2048, 4096],
  ALLOWED_IMAGE_FORMATS: ["webp", "png", "jpg", "jpeg", "gif"],
  CHANNEL_NAME_MAX_LENGTH: 100
};
// ../../node_modules/@sapphire/snowflake/dist/esm/index.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var IncrementSymbol = Symbol("@sapphire/snowflake.increment");
var EpochSymbol = Symbol("@sapphire/snowflake.epoch");
var EpochNumberSymbol = Symbol("@sapphire/snowflake.epoch.number");
var ProcessIdSymbol = Symbol("@sapphire/snowflake.processId");
var WorkerIdSymbol = Symbol("@sapphire/snowflake.workerId");
var MaximumWorkerId = 0b11111n;
var MaximumProcessId = 0b11111n;
var MaximumIncrement = 0b111111111111n;
var TimestampFieldDivisor = 2 ** 22;
var _a;
var _b;
var _c;
var _d;
var _e;
_e = EpochSymbol, _d = EpochNumberSymbol, _c = IncrementSymbol, _b = ProcessIdSymbol, _a = WorkerIdSymbol;
var _Snowflake = class _Snowflake2 {
  constructor(epoch) {
    __publicField(this, "decode", this.deconstruct);
    __publicField(this, _e);
    __publicField(this, _d);
    __publicField(this, _c, 0n);
    __publicField(this, _b, 1n);
    __publicField(this, _a, 0n);
    this[EpochSymbol] = BigInt(epoch instanceof Date ? epoch.getTime() : epoch);
    this[EpochNumberSymbol] = Number(this[EpochSymbol]);
  }
  get epoch() {
    return this[EpochSymbol];
  }
  get epochNumber() {
    return this[EpochNumberSymbol];
  }
  get processId() {
    return this[ProcessIdSymbol];
  }
  set processId(value) {
    this[ProcessIdSymbol] = BigInt(value) & MaximumProcessId;
  }
  get workerId() {
    return this[WorkerIdSymbol];
  }
  set workerId(value) {
    this[WorkerIdSymbol] = BigInt(value) & MaximumWorkerId;
  }
  generate({
    increment,
    timestamp = Date.now(),
    workerId = this[WorkerIdSymbol],
    processId = this[ProcessIdSymbol]
  } = {}) {
    if (timestamp instanceof Date)
      timestamp = BigInt(timestamp.getTime());
    else if (typeof timestamp === "number")
      timestamp = BigInt(timestamp);
    else if (typeof timestamp !== "bigint") {
      throw new TypeError(`"timestamp" argument must be a number, bigint, or Date (received ${typeof timestamp})`);
    }
    if (typeof increment !== "bigint") {
      increment = this[IncrementSymbol];
      this[IncrementSymbol] = increment + 1n & MaximumIncrement;
    }
    return timestamp - this[EpochSymbol] << 22n | (workerId & MaximumWorkerId) << 17n | (processId & MaximumProcessId) << 12n | increment & MaximumIncrement;
  }
  deconstruct(id) {
    const bigIntId = BigInt(id);
    const epoch = this[EpochSymbol];
    return {
      id: bigIntId,
      timestamp: (bigIntId >> 22n) + epoch,
      workerId: bigIntId >> 17n & MaximumWorkerId,
      processId: bigIntId >> 12n & MaximumProcessId,
      increment: bigIntId & MaximumIncrement,
      epoch
    };
  }
  timestampFrom(id) {
    return Math.floor(Number(id) / TimestampFieldDivisor) + this[EpochNumberSymbol];
  }
  static compare(a, b) {
    const typeA = typeof a;
    return typeA === typeof b ? typeA === "string" ? cmpString(a, b) : cmpBigInt(a, b) : cmpBigInt(BigInt(a), BigInt(b));
  }
};
__name(_Snowflake, "Snowflake");
var Snowflake = _Snowflake;
function cmpBigInt(a, b) {
  return a === b ? 0 : a < b ? -1 : 1;
}
__name(cmpBigInt, "cmpBigInt");
function cmpString(a, b) {
  return a === b ? 0 : a.length < b.length ? -1 : a.length > b.length ? 1 : a < b ? -1 : 1;
}
__name(cmpString, "cmpString");
var DiscordSnowflake = new Snowflake(1420070400000n);
var TwitterSnowflake = new Snowflake(1288834974657n);

// ../huginn-shared/src/snowflake.ts
var epoch = new Date("2023-01-01T00:00:00.000Z");
var globalSnowflake = new Snowflake(epoch);
var snowflake = {
  generateString(workerId) {
    const value = globalSnowflake.generate({ workerId: BigInt(workerId) });
    return value.toString();
  },
  generate(workerId) {
    const value = globalSnowflake.generate({ workerId: BigInt(workerId) });
    return value;
  },
  getTimestamp(id) {
    return globalSnowflake.timestampFrom(id);
  }
};
// ../huginn-shared/src/utils.ts
function pick(data, keys) {
  const result = {};
  for (const key of keys) {
    result[key] = data[key];
  }
  return result;
}
function isObject(item) {
  return item !== null && typeof item === "object" && !Array.isArray(item);
}
function deepMerge(target, source) {
  const output = { ...target };
  if (isObject(target) && isObject(source)) {
    for (const key of Object.keys(source)) {
      const sourceKey = key;
      const targetKey = key;
      if (isObject(source[sourceKey])) {
        if (!(key in target)) {
          output[key] = source[sourceKey];
        } else {
          output[key] = deepMerge(target[targetKey], source[sourceKey]);
        }
      } else {
        output[key] = source[sourceKey];
      }
    }
  }
  return output;
}
function merge(...objects) {
  return objects.reduce((acc, obj) => deepMerge(acc, obj), {});
}
function idFix(obj) {
  if (Array.isArray(obj)) {
    return obj.map((item) => idFix(item));
  }
  if (obj instanceof Date) {
    return obj;
  }
  if (typeof obj === "object" && obj !== null) {
    const newObj = {};
    for (const key in obj) {
      if (typeof obj[key] === "bigint") {
        newObj[key] = obj[key].toString();
      } else if (typeof obj[key] === "object") {
        newObj[key] = idFix(obj[key]);
      } else {
        newObj[key] = obj[key];
      }
    }
    return newObj;
  }
  return obj;
}
function isOpcode(data, opcode) {
  if (data && typeof data === "object") {
    return "op" in data && data.op === opcode;
  }
  return false;
}
function generateRandomString(n) {
  if (n % 2 === 1) {
    throw new Error("Only even sizes are supported");
  }
  const buf = new Uint8Array(n / 2);
  crypto.getRandomValues(buf);
  let ret = "";
  for (let i = 0;i < buf.length; ++i) {
    ret += `0${buf[i].toString(16)}`.slice(-2);
  }
  return ret;
}
// ../huginn-shared/src/errors.ts
var Errors = {
  unauthorized() {
    return ["Unauthorized", 0 /* NONE */];
  },
  forbidden() {
    return ["Forbidden", 0 /* NONE */];
  },
  serverError() {
    return ["Server Error", 0 /* NONE */];
  },
  fileNotFound() {
    return ["File Not Found", 0 /* NONE */];
  },
  invalidFileFormat() {
    return ["Invalid File Format", 0 /* NONE */];
  },
  malformedBody() {
    return ["Malformed Body", 0 /* NONE */];
  },
  websocketFail() {
    return ["Websocket Upgrade Failed", 0 /* NONE */];
  },
  invalidFormBody() {
    return ["Invalid Form Body", 2001 /* INVALID_FORM_BODY */];
  },
  unknownUser(userId) {
    return [`Unknown User (${userId})`, 1004 /* UNKNOWN_USER */];
  },
  unknownChannel(channelId) {
    return [`Unknown Channel (${channelId})`, 1005 /* UNKNOWN_CHANNEL */];
  },
  unknownMessage(messageId) {
    return [`Unknown Message (${messageId})`, 1002 /* UNKNOWN_MESSAGE */];
  },
  unknownRelationship(relationshipId) {
    return [`Unknown Relationship (${relationshipId})`, 1006 /* UNKNOWN_RELATIONSHIP */];
  },
  noUserWithUsername() {
    return ["No user with specified username was found", 3001 /* USERNAME_NOT_FOUND */];
  },
  relationshipSelfRequest() {
    return ["Cannot send friend request to self", 3002 /* RELATION_SELF_REQUEST */];
  },
  relationshipExists() {
    return ["You are already friends with this user", 3003 /* RELATION_EXISTS */];
  },
  missingPermission() {
    return ["Missing Permissions", 2003 /* MISSING_PERMISSION */];
  },
  missingAccess() {
    return ["Missing Access", 2002 /* MISSING_ACCESS */];
  },
  invalidChannelType() {
    return ["Invalid Channel Type", 2004 /* INVALID_CHANNEL_TYPE */];
  },
  invalidRecipient(recipientId) {
    return [`Invalid Recipient (${recipientId})`, 2005 /* INVALID_RECIPIENT */];
  },
  invalidId(id) {
    return [`"${id}" is not a valid Snowflake`, 2006 /* INVALID_ID */];
  }
};
// ../huginn-shared/src/http-error.ts
class HTTPError extends Error {
  status;
  method;
  url;
  requestBody;
  name = HTTPError.name;
  constructor(status, statusText, method, url, bodyData) {
    super(`${statusText}:${status}`);
    this.status = status;
    this.method = method;
    this.url = url;
    this.requestBody = { files: bodyData.files, json: bodyData.body };
  }
}
// ../../node_modules/@std/encoding/_validate_binary_like.js
var encoder = new TextEncoder;
// ../../node_modules/@std/encoding/base32.js
var lookup = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split("");
var revLookup = [];
lookup.forEach((c, i) => revLookup[c.charCodeAt(0)] = i);
// ../../node_modules/@std/encoding/base58.js
var base58alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz".split("");
// ../../node_modules/@std/encoding/hex.js
var hexTable = new TextEncoder().encode("0123456789abcdef");
var textEncoder = new TextEncoder;
var textDecoder = new TextDecoder;
// ../../node_modules/@std/encoding/varint.js
var AB = new ArrayBuffer(8);
var U32_VIEW = new Uint32Array(AB);
var U64_VIEW = new BigUint64Array(AB);
// ../huginn-backend-shared/src/error-factory.ts
class ErrorFactory {
  message;
  code;
  errors = {};
  constructor(message, code) {
    this.message = message;
    this.code = code;
  }
  addError(path, field) {
    this.setValueByPath(this.errors, path, { code: field[1], message: field[0] });
    return this;
  }
  getValueByPath(obj, path) {
    const paths = path.split(".");
    let current = obj;
    for (let i = 0;i < paths.length; ++i) {
      if (current[paths[i]] === undefined) {
        return;
      }
      current = current[paths[i]];
    }
    return current;
  }
  setValueByPath(obj, path, value) {
    const [current, ...rest] = path.split(".");
    if (rest.length > 0) {
      if (!obj[current]) {
        obj[current] = {};
      }
      if (typeof obj[current] !== "object") {
        obj[current] = this.setValueByPath({}, rest.join("."), value);
      } else {
        obj[current] = this.setValueByPath(obj[current], rest.join("."), value);
      }
    } else {
      if (!obj[current]?._errors) {
        obj[current] = { _errors: [] };
      }
      obj[current]._errors.push(value);
    }
    return obj;
  }
  toObject() {
    return {
      message: this.message,
      code: this.code,
      errors: this.hasErrors() ? this.errors : undefined
    };
  }
  hasErrors() {
    return Object.keys(this.errors).length !== 0;
  }
}
function createErrorRaw(message, code) {
  const factory = new ErrorFactory(message, code);
  return factory;
}
function createErrorFactory(error) {
  return createErrorRaw(error[0], error[1]);
}

// ../huginn-backend-shared/src/errors.ts
class DBError extends Error {
  callerName;
  type;
  cause;
  constructor(callerName, type, cause) {
    super(`Unhandeled Database Error => ${callerName} => ${type}: ${cause ? `(${cause})` : ""}`, {
      cause
    });
    this.callerName = callerName;
    this.type = type;
    this.cause = cause;
  }
  isErrorType(type) {
    return this.type === type;
  }
}
function isDBError(object) {
  if (object !== null && typeof object === "object" && object instanceof DBError) {
    return true;
  }
  return false;
}
function createHuginnError(c, errorFactory, status = 400 /* BAD_REQUEST */) {
  return c.json(errorFactory.toObject(), status);
}
function notFound(c) {
  return c.text("Not Found", 404 /* NOT_FOUND */);
}
// ../../node_modules/consola/dist/core.mjs
var LogLevels = {
  silent: Number.NEGATIVE_INFINITY,
  fatal: 0,
  error: 0,
  warn: 1,
  log: 2,
  info: 3,
  success: 3,
  fail: 3,
  ready: 3,
  start: 3,
  box: 3,
  debug: 4,
  trace: 5,
  verbose: Number.POSITIVE_INFINITY
};
var LogTypes = {
  silent: {
    level: -1
  },
  fatal: {
    level: LogLevels.fatal
  },
  error: {
    level: LogLevels.error
  },
  warn: {
    level: LogLevels.warn
  },
  log: {
    level: LogLevels.log
  },
  info: {
    level: LogLevels.info
  },
  success: {
    level: LogLevels.success
  },
  fail: {
    level: LogLevels.fail
  },
  ready: {
    level: LogLevels.info
  },
  start: {
    level: LogLevels.info
  },
  box: {
    level: LogLevels.info
  },
  debug: {
    level: LogLevels.debug
  },
  trace: {
    level: LogLevels.trace
  },
  verbose: {
    level: LogLevels.verbose
  }
};
function isPlainObject$1(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}
function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isPlainObject$1(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === undefined) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject$1(value) && isPlainObject$1(object[key])) {
      object[key] = _defu(value, object[key], (namespace ? `${namespace}.` : "") + key.toString(), merger);
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => arguments_.reduce((p, c) => _defu(p, c, "", merger), {});
}
var defu = createDefu();
function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
function isLogObj(arg) {
  if (!isPlainObject(arg)) {
    return false;
  }
  if (!arg.message && !arg.args) {
    return false;
  }
  if (arg.stack) {
    return false;
  }
  return true;
}
var paused = false;
var queue = [];

class Consola {
  options;
  _lastLog;
  _mockFn;
  constructor(options = {}) {
    const types = options.types || LogTypes;
    this.options = defu({
      ...options,
      defaults: { ...options.defaults },
      level: _normalizeLogLevel(options.level, types),
      reporters: [...options.reporters || []]
    }, {
      types: LogTypes,
      throttle: 1000,
      throttleMin: 5,
      formatOptions: {
        date: true,
        colors: false,
        compact: true
      }
    });
    for (const type in types) {
      const defaults = {
        type,
        ...this.options.defaults,
        ...types[type]
      };
      this[type] = this._wrapLogFn(defaults);
      this[type].raw = this._wrapLogFn(defaults, true);
    }
    if (this.options.mockFn) {
      this.mockTypes();
    }
    this._lastLog = {};
  }
  get level() {
    return this.options.level;
  }
  set level(level) {
    this.options.level = _normalizeLogLevel(level, this.options.types, this.options.level);
  }
  prompt(message, opts) {
    if (!this.options.prompt) {
      throw new Error("prompt is not supported!");
    }
    return this.options.prompt(message, opts);
  }
  create(options) {
    const instance = new Consola({
      ...this.options,
      ...options
    });
    if (this._mockFn) {
      instance.mockTypes(this._mockFn);
    }
    return instance;
  }
  withDefaults(defaults) {
    return this.create({
      ...this.options,
      defaults: {
        ...this.options.defaults,
        ...defaults
      }
    });
  }
  withTag(tag) {
    return this.withDefaults({
      tag: this.options.defaults.tag ? this.options.defaults.tag + ":" + tag : tag
    });
  }
  addReporter(reporter) {
    this.options.reporters.push(reporter);
    return this;
  }
  removeReporter(reporter) {
    if (reporter) {
      const i = this.options.reporters.indexOf(reporter);
      if (i !== -1) {
        return this.options.reporters.splice(i, 1);
      }
    } else {
      this.options.reporters.splice(0);
    }
    return this;
  }
  setReporters(reporters) {
    this.options.reporters = Array.isArray(reporters) ? reporters : [reporters];
    return this;
  }
  wrapAll() {
    this.wrapConsole();
    this.wrapStd();
  }
  restoreAll() {
    this.restoreConsole();
    this.restoreStd();
  }
  wrapConsole() {
    for (const type in this.options.types) {
      if (!console["__" + type]) {
        console["__" + type] = console[type];
      }
      console[type] = this[type].raw;
    }
  }
  restoreConsole() {
    for (const type in this.options.types) {
      if (console["__" + type]) {
        console[type] = console["__" + type];
        delete console["__" + type];
      }
    }
  }
  wrapStd() {
    this._wrapStream(this.options.stdout, "log");
    this._wrapStream(this.options.stderr, "log");
  }
  _wrapStream(stream, type) {
    if (!stream) {
      return;
    }
    if (!stream.__write) {
      stream.__write = stream.write;
    }
    stream.write = (data) => {
      this[type].raw(String(data).trim());
    };
  }
  restoreStd() {
    this._restoreStream(this.options.stdout);
    this._restoreStream(this.options.stderr);
  }
  _restoreStream(stream) {
    if (!stream) {
      return;
    }
    if (stream.__write) {
      stream.write = stream.__write;
      delete stream.__write;
    }
  }
  pauseLogs() {
    paused = true;
  }
  resumeLogs() {
    paused = false;
    const _queue = queue.splice(0);
    for (const item of _queue) {
      item[0]._logFn(item[1], item[2]);
    }
  }
  mockTypes(mockFn) {
    const _mockFn = mockFn || this.options.mockFn;
    this._mockFn = _mockFn;
    if (typeof _mockFn !== "function") {
      return;
    }
    for (const type in this.options.types) {
      this[type] = _mockFn(type, this.options.types[type]) || this[type];
      this[type].raw = this[type];
    }
  }
  _wrapLogFn(defaults, isRaw) {
    return (...args) => {
      if (paused) {
        queue.push([this, defaults, args, isRaw]);
        return;
      }
      return this._logFn(defaults, args, isRaw);
    };
  }
  _logFn(defaults, args, isRaw) {
    if ((defaults.level || 0) > this.level) {
      return false;
    }
    const logObj = {
      date: /* @__PURE__ */ new Date,
      args: [],
      ...defaults,
      level: _normalizeLogLevel(defaults.level, this.options.types)
    };
    if (!isRaw && args.length === 1 && isLogObj(args[0])) {
      Object.assign(logObj, args[0]);
    } else {
      logObj.args = [...args];
    }
    if (logObj.message) {
      logObj.args.unshift(logObj.message);
      delete logObj.message;
    }
    if (logObj.additional) {
      if (!Array.isArray(logObj.additional)) {
        logObj.additional = logObj.additional.split(`
`);
      }
      logObj.args.push(`
` + logObj.additional.join(`
`));
      delete logObj.additional;
    }
    logObj.type = typeof logObj.type === "string" ? logObj.type.toLowerCase() : "log";
    logObj.tag = typeof logObj.tag === "string" ? logObj.tag : "";
    const resolveLog = (newLog = false) => {
      const repeated = (this._lastLog.count || 0) - this.options.throttleMin;
      if (this._lastLog.object && repeated > 0) {
        const args2 = [...this._lastLog.object.args];
        if (repeated > 1) {
          args2.push(`(repeated ${repeated} times)`);
        }
        this._log({ ...this._lastLog.object, args: args2 });
        this._lastLog.count = 1;
      }
      if (newLog) {
        this._lastLog.object = logObj;
        this._log(logObj);
      }
    };
    clearTimeout(this._lastLog.timeout);
    const diffTime = this._lastLog.time && logObj.date ? logObj.date.getTime() - this._lastLog.time.getTime() : 0;
    this._lastLog.time = logObj.date;
    if (diffTime < this.options.throttle) {
      try {
        const serializedLog = JSON.stringify([
          logObj.type,
          logObj.tag,
          logObj.args
        ]);
        const isSameLog = this._lastLog.serialized === serializedLog;
        this._lastLog.serialized = serializedLog;
        if (isSameLog) {
          this._lastLog.count = (this._lastLog.count || 0) + 1;
          if (this._lastLog.count > this.options.throttleMin) {
            this._lastLog.timeout = setTimeout(resolveLog, this.options.throttle);
            return;
          }
        }
      } catch {
      }
    }
    resolveLog(true);
  }
  _log(logObj) {
    for (const reporter of this.options.reporters) {
      reporter.log(logObj, {
        options: this.options
      });
    }
  }
}
function _normalizeLogLevel(input, types = {}, defaultLevel = 3) {
  if (input === undefined) {
    return defaultLevel;
  }
  if (typeof input === "number") {
    return input;
  }
  if (types[input] && types[input].level !== undefined) {
    return types[input].level;
  }
  return defaultLevel;
}
Consola.prototype.add = Consola.prototype.addReporter;
Consola.prototype.remove = Consola.prototype.removeReporter;
Consola.prototype.clear = Consola.prototype.removeReporter;
Consola.prototype.withScope = Consola.prototype.withTag;
Consola.prototype.mock = Consola.prototype.mockTypes;
Consola.prototype.pause = Consola.prototype.pauseLogs;
Consola.prototype.resume = Consola.prototype.resumeLogs;
function createConsola(options = {}) {
  return new Consola(options);
}
// ../../node_modules/consola/dist/shared/consola.Cs5FdtHD.mjs
import { formatWithOptions } from "util";
import { sep } from "path";
function parseStack(stack) {
  const cwd = process.cwd() + sep;
  const lines = stack.split(`
`).splice(1).map((l) => l.trim().replace("file://", "").replace(cwd, ""));
  return lines;
}
function writeStream(data, stream) {
  const write = stream.__write || stream.write;
  return write.call(stream, data);
}
var bracket = (x) => x ? `[${x}]` : "";

class BasicReporter {
  formatStack(stack, opts) {
    const indent = "  ".repeat((opts?.errorLevel || 0) + 1);
    return indent + parseStack(stack).join(`
${indent}`);
  }
  formatError(err, opts) {
    const message = err.message ?? formatWithOptions(opts, err);
    const stack = err.stack ? this.formatStack(err.stack, opts) : "";
    const level = opts?.errorLevel || 0;
    const causedPrefix = level > 0 ? `${"  ".repeat(level)}[cause]: ` : "";
    const causedError = err.cause ? `

` + this.formatError(err.cause, { ...opts, errorLevel: level + 1 }) : "";
    return causedPrefix + message + `
` + stack + causedError;
  }
  formatArgs(args, opts) {
    const _args = args.map((arg) => {
      if (arg && typeof arg.stack === "string") {
        return this.formatError(arg, opts);
      }
      return arg;
    });
    return formatWithOptions(opts, ..._args);
  }
  formatDate(date, opts) {
    return opts.date ? date.toLocaleTimeString() : "";
  }
  filterAndJoin(arr) {
    return arr.filter(Boolean).join(" ");
  }
  formatLogObj(logObj, opts) {
    const message = this.formatArgs(logObj.args, opts);
    if (logObj.type === "box") {
      return `
` + [
        bracket(logObj.tag),
        logObj.title && logObj.title,
        ...message.split(`
`)
      ].filter(Boolean).map((l) => " > " + l).join(`
`) + `
`;
    }
    return this.filterAndJoin([
      bracket(logObj.type),
      bracket(logObj.tag),
      message
    ]);
  }
  log(logObj, ctx) {
    const line = this.formatLogObj(logObj, {
      columns: ctx.options.stdout.columns || 0,
      ...ctx.options.formatOptions
    });
    return writeStream(line + `
`, logObj.level < 2 ? ctx.options.stderr || process.stderr : ctx.options.stdout || process.stdout);
  }
}

// ../../node_modules/consola/dist/index.mjs
import p$1 from "process";

// ../../node_modules/consola/dist/shared/consola.lX6kr4n8.mjs
import * as tty from "tty";
var {
  env = {},
  argv = [],
  platform = ""
} = typeof process === "undefined" ? {} : process;
var isDisabled = "NO_COLOR" in env || argv.includes("--no-color");
var isForced = "FORCE_COLOR" in env || argv.includes("--color");
var isWindows = platform === "win32";
var isDumbTerminal = env.TERM === "dumb";
var isCompatibleTerminal = tty && tty.isatty && tty.isatty(1) && env.TERM && !isDumbTerminal;
var isCI = "CI" in env && (("GITHUB_ACTIONS" in env) || ("GITLAB_CI" in env) || ("CIRCLECI" in env));
var isColorSupported = !isDisabled && (isForced || isWindows && !isDumbTerminal || isCompatibleTerminal || isCI);
function replaceClose(index, string, close, replace, head = string.slice(0, Math.max(0, index)) + replace, tail = string.slice(Math.max(0, index + close.length)), next = tail.indexOf(close)) {
  return head + (next < 0 ? tail : replaceClose(next, tail, close, replace));
}
function clearBleed(index, string, open, close, replace) {
  return index < 0 ? open + string + close : open + replaceClose(index, string, close, replace) + close;
}
function filterEmpty(open, close, replace = open, at = open.length + 1) {
  return (string) => string || !(string === "" || string === undefined) ? clearBleed(("" + string).indexOf(close, at), string, open, close, replace) : "";
}
function init(open, close, replace) {
  return filterEmpty(`\x1B[${open}m`, `\x1B[${close}m`, replace);
}
var colorDefs = {
  reset: init(0, 0),
  bold: init(1, 22, "\x1B[22m\x1B[1m"),
  dim: init(2, 22, "\x1B[22m\x1B[2m"),
  italic: init(3, 23),
  underline: init(4, 24),
  inverse: init(7, 27),
  hidden: init(8, 28),
  strikethrough: init(9, 29),
  black: init(30, 39),
  red: init(31, 39),
  green: init(32, 39),
  yellow: init(33, 39),
  blue: init(34, 39),
  magenta: init(35, 39),
  cyan: init(36, 39),
  white: init(37, 39),
  gray: init(90, 39),
  bgBlack: init(40, 49),
  bgRed: init(41, 49),
  bgGreen: init(42, 49),
  bgYellow: init(43, 49),
  bgBlue: init(44, 49),
  bgMagenta: init(45, 49),
  bgCyan: init(46, 49),
  bgWhite: init(47, 49),
  blackBright: init(90, 39),
  redBright: init(91, 39),
  greenBright: init(92, 39),
  yellowBright: init(93, 39),
  blueBright: init(94, 39),
  magentaBright: init(95, 39),
  cyanBright: init(96, 39),
  whiteBright: init(97, 39),
  bgBlackBright: init(100, 49),
  bgRedBright: init(101, 49),
  bgGreenBright: init(102, 49),
  bgYellowBright: init(103, 49),
  bgBlueBright: init(104, 49),
  bgMagentaBright: init(105, 49),
  bgCyanBright: init(106, 49),
  bgWhiteBright: init(107, 49)
};
function createColors(useColor = isColorSupported) {
  return useColor ? colorDefs : Object.fromEntries(Object.keys(colorDefs).map((key) => [key, String]));
}
var colors = createColors();
function getColor(color, fallback = "reset") {
  return colors[color] || colors[fallback];
}
var ansiRegex = [
  String.raw`[\u001B\u009B][[\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\d\/#&.:=?%@~_]+)*|[a-zA-Z\d]+(?:;[-a-zA-Z\d\/#&.:=?%@~_]*)*)?\u0007)`,
  String.raw`(?:(?:\d{1,4}(?:;\d{0,4})*)?[\dA-PR-TZcf-nq-uy=><~]))`
].join("|");
function stripAnsi(text) {
  return text.replace(new RegExp(ansiRegex, "g"), "");
}
var boxStylePresets = {
  solid: {
    tl: "\u250C",
    tr: "\u2510",
    bl: "\u2514",
    br: "\u2518",
    h: "\u2500",
    v: "\u2502"
  },
  double: {
    tl: "\u2554",
    tr: "\u2557",
    bl: "\u255A",
    br: "\u255D",
    h: "\u2550",
    v: "\u2551"
  },
  doubleSingle: {
    tl: "\u2553",
    tr: "\u2556",
    bl: "\u2559",
    br: "\u255C",
    h: "\u2500",
    v: "\u2551"
  },
  doubleSingleRounded: {
    tl: "\u256D",
    tr: "\u256E",
    bl: "\u2570",
    br: "\u256F",
    h: "\u2500",
    v: "\u2551"
  },
  singleThick: {
    tl: "\u250F",
    tr: "\u2513",
    bl: "\u2517",
    br: "\u251B",
    h: "\u2501",
    v: "\u2503"
  },
  singleDouble: {
    tl: "\u2552",
    tr: "\u2555",
    bl: "\u2558",
    br: "\u255B",
    h: "\u2550",
    v: "\u2502"
  },
  singleDoubleRounded: {
    tl: "\u256D",
    tr: "\u256E",
    bl: "\u2570",
    br: "\u256F",
    h: "\u2550",
    v: "\u2502"
  },
  rounded: {
    tl: "\u256D",
    tr: "\u256E",
    bl: "\u2570",
    br: "\u256F",
    h: "\u2500",
    v: "\u2502"
  }
};
var defaultStyle = {
  borderColor: "white",
  borderStyle: "rounded",
  valign: "center",
  padding: 2,
  marginLeft: 1,
  marginTop: 1,
  marginBottom: 1
};
function box(text, _opts = {}) {
  const opts = {
    ..._opts,
    style: {
      ...defaultStyle,
      ..._opts.style
    }
  };
  const textLines = text.split(`
`);
  const boxLines = [];
  const _color = getColor(opts.style.borderColor);
  const borderStyle = {
    ...typeof opts.style.borderStyle === "string" ? boxStylePresets[opts.style.borderStyle] || boxStylePresets.solid : opts.style.borderStyle
  };
  if (_color) {
    for (const key in borderStyle) {
      borderStyle[key] = _color(borderStyle[key]);
    }
  }
  const paddingOffset = opts.style.padding % 2 === 0 ? opts.style.padding : opts.style.padding + 1;
  const height = textLines.length + paddingOffset;
  const width = Math.max(...textLines.map((line) => stripAnsi(line).length)) + paddingOffset;
  const widthOffset = width + paddingOffset;
  const leftSpace = opts.style.marginLeft > 0 ? " ".repeat(opts.style.marginLeft) : "";
  if (opts.style.marginTop > 0) {
    boxLines.push("".repeat(opts.style.marginTop));
  }
  if (opts.title) {
    const title = _color ? _color(opts.title) : opts.title;
    const left = borderStyle.h.repeat(Math.floor((width - stripAnsi(opts.title).length) / 2));
    const right = borderStyle.h.repeat(width - stripAnsi(opts.title).length - stripAnsi(left).length + paddingOffset);
    boxLines.push(`${leftSpace}${borderStyle.tl}${left}${title}${right}${borderStyle.tr}`);
  } else {
    boxLines.push(`${leftSpace}${borderStyle.tl}${borderStyle.h.repeat(widthOffset)}${borderStyle.tr}`);
  }
  const valignOffset = opts.style.valign === "center" ? Math.floor((height - textLines.length) / 2) : opts.style.valign === "top" ? height - textLines.length - paddingOffset : height - textLines.length;
  for (let i = 0;i < height; i++) {
    if (i < valignOffset || i >= valignOffset + textLines.length) {
      boxLines.push(`${leftSpace}${borderStyle.v}${" ".repeat(widthOffset)}${borderStyle.v}`);
    } else {
      const line = textLines[i - valignOffset];
      const left = " ".repeat(paddingOffset);
      const right = " ".repeat(width - stripAnsi(line).length);
      boxLines.push(`${leftSpace}${borderStyle.v}${left}${line}${right}${borderStyle.v}`);
    }
  }
  boxLines.push(`${leftSpace}${borderStyle.bl}${borderStyle.h.repeat(widthOffset)}${borderStyle.br}`);
  if (opts.style.marginBottom > 0) {
    boxLines.push("".repeat(opts.style.marginBottom));
  }
  return boxLines.join(`
`);
}

// ../../node_modules/consola/dist/index.mjs
var r2 = Object.create(null);
var i = (e2) => globalThis.process?.env || import.meta.env || globalThis.Deno?.env.toObject() || globalThis.__env__ || (e2 ? r2 : globalThis);
var s$1 = new Proxy(r2, { get(e2, o) {
  return i()[o] ?? r2[o];
}, has(e2, o) {
  const E2 = i();
  return o in E2 || o in r2;
}, set(e2, o, E2) {
  const b = i(true);
  return b[o] = E2, true;
}, deleteProperty(e2, o) {
  if (!o)
    return false;
  const E2 = i(true);
  return delete E2[o], true;
}, ownKeys() {
  const e2 = i(true);
  return Object.keys(e2);
} });
var t = typeof process < "u" && process.env && "development" || "";
var B2 = [["APPVEYOR"], ["AWS_AMPLIFY", "AWS_APP_ID", { ci: true }], ["AZURE_PIPELINES", "SYSTEM_TEAMFOUNDATIONCOLLECTIONURI"], ["AZURE_STATIC", "INPUT_AZURE_STATIC_WEB_APPS_API_TOKEN"], ["APPCIRCLE", "AC_APPCIRCLE"], ["BAMBOO", "bamboo_planKey"], ["BITBUCKET", "BITBUCKET_COMMIT"], ["BITRISE", "BITRISE_IO"], ["BUDDY", "BUDDY_WORKSPACE_ID"], ["BUILDKITE"], ["CIRCLE", "CIRCLECI"], ["CIRRUS", "CIRRUS_CI"], ["CLOUDFLARE_PAGES", "CF_PAGES", { ci: true }], ["CODEBUILD", "CODEBUILD_BUILD_ARN"], ["CODEFRESH", "CF_BUILD_ID"], ["DRONE"], ["DRONE", "DRONE_BUILD_EVENT"], ["DSARI"], ["GITHUB_ACTIONS"], ["GITLAB", "GITLAB_CI"], ["GITLAB", "CI_MERGE_REQUEST_ID"], ["GOCD", "GO_PIPELINE_LABEL"], ["LAYERCI"], ["HUDSON", "HUDSON_URL"], ["JENKINS", "JENKINS_URL"], ["MAGNUM"], ["NETLIFY"], ["NETLIFY", "NETLIFY_LOCAL", { ci: false }], ["NEVERCODE"], ["RENDER"], ["SAIL", "SAILCI"], ["SEMAPHORE"], ["SCREWDRIVER"], ["SHIPPABLE"], ["SOLANO", "TDDIUM"], ["STRIDER"], ["TEAMCITY", "TEAMCITY_VERSION"], ["TRAVIS"], ["VERCEL", "NOW_BUILDER"], ["VERCEL", "VERCEL", { ci: false }], ["VERCEL", "VERCEL_ENV", { ci: false }], ["APPCENTER", "APPCENTER_BUILD_ID"], ["CODESANDBOX", "CODESANDBOX_SSE", { ci: false }], ["STACKBLITZ"], ["STORMKIT"], ["CLEAVR"], ["ZEABUR"], ["CODESPHERE", "CODESPHERE_APP_ID", { ci: true }], ["RAILWAY", "RAILWAY_PROJECT_ID"], ["RAILWAY", "RAILWAY_SERVICE_ID"], ["DENO-DEPLOY", "DENO_DEPLOYMENT_ID"], ["FIREBASE_APP_HOSTING", "FIREBASE_APP_HOSTING", { ci: true }]];
function p2() {
  if (globalThis.process?.env)
    for (const e2 of B2) {
      const o = e2[1] || e2[0];
      if (globalThis.process?.env[o])
        return { name: e2[0].toLowerCase(), ...e2[2] };
    }
  return globalThis.process?.env?.SHELL === "/bin/jsh" && globalThis.process?.versions?.webcontainer ? { name: "stackblitz", ci: false } : { name: "", ci: false };
}
var l = p2();
l.name;
function n(e2) {
  return e2 ? e2 !== "false" : false;
}
var I2 = globalThis.process?.platform || "";
var T2 = n(s$1.CI) || l.ci !== false;
var R2 = n(globalThis.process?.stdout && globalThis.process?.stdout.isTTY);
var U = n(s$1.DEBUG);
var A2 = t === "test" || n(s$1.TEST);
n(s$1.MINIMAL);
var _2 = /^win/i.test(I2);
!n(s$1.NO_COLOR) && (n(s$1.FORCE_COLOR) || (R2 || _2) && s$1.TERM);
var C = (globalThis.process?.versions?.node || "").replace(/^v/, "") || null;
Number(C?.split(".")[0]);
var y2 = globalThis.process || Object.create(null);
var c2 = { versions: {} };
new Proxy(y2, { get(e2, o) {
  if (o === "env")
    return s$1;
  if (o in e2)
    return e2[o];
  if (o in c2)
    return c2[o];
} });
var L2 = globalThis.process?.release?.name === "node";
var a2 = !!globalThis.Bun || !!globalThis.process?.versions?.bun;
var D = !!globalThis.Deno;
var O2 = !!globalThis.fastly;
var S2 = !!globalThis.Netlify;
var N2 = !!globalThis.EdgeRuntime;
var P2 = globalThis.navigator?.userAgent === "Cloudflare-Workers";
var F = [[S2, "netlify"], [N2, "edge-light"], [P2, "workerd"], [O2, "fastly"], [D, "deno"], [a2, "bun"], [L2, "node"]];
function G2() {
  const e2 = F.find((o) => o[0]);
  if (e2)
    return { name: e2[1] };
}
var u2 = G2();
u2?.name;
function ansiRegex2({ onlyFirst = false } = {}) {
  const ST = "(?:\\u0007|\\u001B\\u005C|\\u009C)";
  const pattern = [
    `[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?${ST})`,
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
  ].join("|");
  return new RegExp(pattern, onlyFirst ? undefined : "g");
}
var regex = ansiRegex2();
function stripAnsi2(string) {
  if (typeof string !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
  }
  return string.replace(regex, "");
}
function isAmbiguous(x2) {
  return x2 === 161 || x2 === 164 || x2 === 167 || x2 === 168 || x2 === 170 || x2 === 173 || x2 === 174 || x2 >= 176 && x2 <= 180 || x2 >= 182 && x2 <= 186 || x2 >= 188 && x2 <= 191 || x2 === 198 || x2 === 208 || x2 === 215 || x2 === 216 || x2 >= 222 && x2 <= 225 || x2 === 230 || x2 >= 232 && x2 <= 234 || x2 === 236 || x2 === 237 || x2 === 240 || x2 === 242 || x2 === 243 || x2 >= 247 && x2 <= 250 || x2 === 252 || x2 === 254 || x2 === 257 || x2 === 273 || x2 === 275 || x2 === 283 || x2 === 294 || x2 === 295 || x2 === 299 || x2 >= 305 && x2 <= 307 || x2 === 312 || x2 >= 319 && x2 <= 322 || x2 === 324 || x2 >= 328 && x2 <= 331 || x2 === 333 || x2 === 338 || x2 === 339 || x2 === 358 || x2 === 359 || x2 === 363 || x2 === 462 || x2 === 464 || x2 === 466 || x2 === 468 || x2 === 470 || x2 === 472 || x2 === 474 || x2 === 476 || x2 === 593 || x2 === 609 || x2 === 708 || x2 === 711 || x2 >= 713 && x2 <= 715 || x2 === 717 || x2 === 720 || x2 >= 728 && x2 <= 731 || x2 === 733 || x2 === 735 || x2 >= 768 && x2 <= 879 || x2 >= 913 && x2 <= 929 || x2 >= 931 && x2 <= 937 || x2 >= 945 && x2 <= 961 || x2 >= 963 && x2 <= 969 || x2 === 1025 || x2 >= 1040 && x2 <= 1103 || x2 === 1105 || x2 === 8208 || x2 >= 8211 && x2 <= 8214 || x2 === 8216 || x2 === 8217 || x2 === 8220 || x2 === 8221 || x2 >= 8224 && x2 <= 8226 || x2 >= 8228 && x2 <= 8231 || x2 === 8240 || x2 === 8242 || x2 === 8243 || x2 === 8245 || x2 === 8251 || x2 === 8254 || x2 === 8308 || x2 === 8319 || x2 >= 8321 && x2 <= 8324 || x2 === 8364 || x2 === 8451 || x2 === 8453 || x2 === 8457 || x2 === 8467 || x2 === 8470 || x2 === 8481 || x2 === 8482 || x2 === 8486 || x2 === 8491 || x2 === 8531 || x2 === 8532 || x2 >= 8539 && x2 <= 8542 || x2 >= 8544 && x2 <= 8555 || x2 >= 8560 && x2 <= 8569 || x2 === 8585 || x2 >= 8592 && x2 <= 8601 || x2 === 8632 || x2 === 8633 || x2 === 8658 || x2 === 8660 || x2 === 8679 || x2 === 8704 || x2 === 8706 || x2 === 8707 || x2 === 8711 || x2 === 8712 || x2 === 8715 || x2 === 8719 || x2 === 8721 || x2 === 8725 || x2 === 8730 || x2 >= 8733 && x2 <= 8736 || x2 === 8739 || x2 === 8741 || x2 >= 8743 && x2 <= 8748 || x2 === 8750 || x2 >= 8756 && x2 <= 8759 || x2 === 8764 || x2 === 8765 || x2 === 8776 || x2 === 8780 || x2 === 8786 || x2 === 8800 || x2 === 8801 || x2 >= 8804 && x2 <= 8807 || x2 === 8810 || x2 === 8811 || x2 === 8814 || x2 === 8815 || x2 === 8834 || x2 === 8835 || x2 === 8838 || x2 === 8839 || x2 === 8853 || x2 === 8857 || x2 === 8869 || x2 === 8895 || x2 === 8978 || x2 >= 9312 && x2 <= 9449 || x2 >= 9451 && x2 <= 9547 || x2 >= 9552 && x2 <= 9587 || x2 >= 9600 && x2 <= 9615 || x2 >= 9618 && x2 <= 9621 || x2 === 9632 || x2 === 9633 || x2 >= 9635 && x2 <= 9641 || x2 === 9650 || x2 === 9651 || x2 === 9654 || x2 === 9655 || x2 === 9660 || x2 === 9661 || x2 === 9664 || x2 === 9665 || x2 >= 9670 && x2 <= 9672 || x2 === 9675 || x2 >= 9678 && x2 <= 9681 || x2 >= 9698 && x2 <= 9701 || x2 === 9711 || x2 === 9733 || x2 === 9734 || x2 === 9737 || x2 === 9742 || x2 === 9743 || x2 === 9756 || x2 === 9758 || x2 === 9792 || x2 === 9794 || x2 === 9824 || x2 === 9825 || x2 >= 9827 && x2 <= 9829 || x2 >= 9831 && x2 <= 9834 || x2 === 9836 || x2 === 9837 || x2 === 9839 || x2 === 9886 || x2 === 9887 || x2 === 9919 || x2 >= 9926 && x2 <= 9933 || x2 >= 9935 && x2 <= 9939 || x2 >= 9941 && x2 <= 9953 || x2 === 9955 || x2 === 9960 || x2 === 9961 || x2 >= 9963 && x2 <= 9969 || x2 === 9972 || x2 >= 9974 && x2 <= 9977 || x2 === 9979 || x2 === 9980 || x2 === 9982 || x2 === 9983 || x2 === 10045 || x2 >= 10102 && x2 <= 10111 || x2 >= 11094 && x2 <= 11097 || x2 >= 12872 && x2 <= 12879 || x2 >= 57344 && x2 <= 63743 || x2 >= 65024 && x2 <= 65039 || x2 === 65533 || x2 >= 127232 && x2 <= 127242 || x2 >= 127248 && x2 <= 127277 || x2 >= 127280 && x2 <= 127337 || x2 >= 127344 && x2 <= 127373 || x2 === 127375 || x2 === 127376 || x2 >= 127387 && x2 <= 127404 || x2 >= 917760 && x2 <= 917999 || x2 >= 983040 && x2 <= 1048573 || x2 >= 1048576 && x2 <= 1114109;
}
function isFullWidth(x2) {
  return x2 === 12288 || x2 >= 65281 && x2 <= 65376 || x2 >= 65504 && x2 <= 65510;
}
function isWide(x2) {
  return x2 >= 4352 && x2 <= 4447 || x2 === 8986 || x2 === 8987 || x2 === 9001 || x2 === 9002 || x2 >= 9193 && x2 <= 9196 || x2 === 9200 || x2 === 9203 || x2 === 9725 || x2 === 9726 || x2 === 9748 || x2 === 9749 || x2 >= 9776 && x2 <= 9783 || x2 >= 9800 && x2 <= 9811 || x2 === 9855 || x2 >= 9866 && x2 <= 9871 || x2 === 9875 || x2 === 9889 || x2 === 9898 || x2 === 9899 || x2 === 9917 || x2 === 9918 || x2 === 9924 || x2 === 9925 || x2 === 9934 || x2 === 9940 || x2 === 9962 || x2 === 9970 || x2 === 9971 || x2 === 9973 || x2 === 9978 || x2 === 9981 || x2 === 9989 || x2 === 9994 || x2 === 9995 || x2 === 10024 || x2 === 10060 || x2 === 10062 || x2 >= 10067 && x2 <= 10069 || x2 === 10071 || x2 >= 10133 && x2 <= 10135 || x2 === 10160 || x2 === 10175 || x2 === 11035 || x2 === 11036 || x2 === 11088 || x2 === 11093 || x2 >= 11904 && x2 <= 11929 || x2 >= 11931 && x2 <= 12019 || x2 >= 12032 && x2 <= 12245 || x2 >= 12272 && x2 <= 12287 || x2 >= 12289 && x2 <= 12350 || x2 >= 12353 && x2 <= 12438 || x2 >= 12441 && x2 <= 12543 || x2 >= 12549 && x2 <= 12591 || x2 >= 12593 && x2 <= 12686 || x2 >= 12688 && x2 <= 12773 || x2 >= 12783 && x2 <= 12830 || x2 >= 12832 && x2 <= 12871 || x2 >= 12880 && x2 <= 42124 || x2 >= 42128 && x2 <= 42182 || x2 >= 43360 && x2 <= 43388 || x2 >= 44032 && x2 <= 55203 || x2 >= 63744 && x2 <= 64255 || x2 >= 65040 && x2 <= 65049 || x2 >= 65072 && x2 <= 65106 || x2 >= 65108 && x2 <= 65126 || x2 >= 65128 && x2 <= 65131 || x2 >= 94176 && x2 <= 94180 || x2 === 94192 || x2 === 94193 || x2 >= 94208 && x2 <= 100343 || x2 >= 100352 && x2 <= 101589 || x2 >= 101631 && x2 <= 101640 || x2 >= 110576 && x2 <= 110579 || x2 >= 110581 && x2 <= 110587 || x2 === 110589 || x2 === 110590 || x2 >= 110592 && x2 <= 110882 || x2 === 110898 || x2 >= 110928 && x2 <= 110930 || x2 === 110933 || x2 >= 110948 && x2 <= 110951 || x2 >= 110960 && x2 <= 111355 || x2 >= 119552 && x2 <= 119638 || x2 >= 119648 && x2 <= 119670 || x2 === 126980 || x2 === 127183 || x2 === 127374 || x2 >= 127377 && x2 <= 127386 || x2 >= 127488 && x2 <= 127490 || x2 >= 127504 && x2 <= 127547 || x2 >= 127552 && x2 <= 127560 || x2 === 127568 || x2 === 127569 || x2 >= 127584 && x2 <= 127589 || x2 >= 127744 && x2 <= 127776 || x2 >= 127789 && x2 <= 127797 || x2 >= 127799 && x2 <= 127868 || x2 >= 127870 && x2 <= 127891 || x2 >= 127904 && x2 <= 127946 || x2 >= 127951 && x2 <= 127955 || x2 >= 127968 && x2 <= 127984 || x2 === 127988 || x2 >= 127992 && x2 <= 128062 || x2 === 128064 || x2 >= 128066 && x2 <= 128252 || x2 >= 128255 && x2 <= 128317 || x2 >= 128331 && x2 <= 128334 || x2 >= 128336 && x2 <= 128359 || x2 === 128378 || x2 === 128405 || x2 === 128406 || x2 === 128420 || x2 >= 128507 && x2 <= 128591 || x2 >= 128640 && x2 <= 128709 || x2 === 128716 || x2 >= 128720 && x2 <= 128722 || x2 >= 128725 && x2 <= 128727 || x2 >= 128732 && x2 <= 128735 || x2 === 128747 || x2 === 128748 || x2 >= 128756 && x2 <= 128764 || x2 >= 128992 && x2 <= 129003 || x2 === 129008 || x2 >= 129292 && x2 <= 129338 || x2 >= 129340 && x2 <= 129349 || x2 >= 129351 && x2 <= 129535 || x2 >= 129648 && x2 <= 129660 || x2 >= 129664 && x2 <= 129673 || x2 >= 129679 && x2 <= 129734 || x2 >= 129742 && x2 <= 129756 || x2 >= 129759 && x2 <= 129769 || x2 >= 129776 && x2 <= 129784 || x2 >= 131072 && x2 <= 196605 || x2 >= 196608 && x2 <= 262141;
}
function validate(codePoint) {
  if (!Number.isSafeInteger(codePoint)) {
    throw new TypeError(`Expected a code point, got \`${typeof codePoint}\`.`);
  }
}
function eastAsianWidth(codePoint, { ambiguousAsWide = false } = {}) {
  validate(codePoint);
  if (isFullWidth(codePoint) || isWide(codePoint) || ambiguousAsWide && isAmbiguous(codePoint)) {
    return 2;
  }
  return 1;
}
var emojiRegex = () => {
  return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
};
var segmenter = globalThis.Intl?.Segmenter ? new Intl.Segmenter : { segment: (str) => str.split("") };
var defaultIgnorableCodePointRegex = /^\p{Default_Ignorable_Code_Point}$/u;
function stringWidth$1(string, options = {}) {
  if (typeof string !== "string" || string.length === 0) {
    return 0;
  }
  const {
    ambiguousIsNarrow = true,
    countAnsiEscapeCodes = false
  } = options;
  if (!countAnsiEscapeCodes) {
    string = stripAnsi2(string);
  }
  if (string.length === 0) {
    return 0;
  }
  let width = 0;
  const eastAsianWidthOptions = { ambiguousAsWide: !ambiguousIsNarrow };
  for (const { segment: character } of segmenter.segment(string)) {
    const codePoint = character.codePointAt(0);
    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {
      continue;
    }
    if (codePoint >= 8203 && codePoint <= 8207 || codePoint === 65279) {
      continue;
    }
    if (codePoint >= 768 && codePoint <= 879 || codePoint >= 6832 && codePoint <= 6911 || codePoint >= 7616 && codePoint <= 7679 || codePoint >= 8400 && codePoint <= 8447 || codePoint >= 65056 && codePoint <= 65071) {
      continue;
    }
    if (codePoint >= 55296 && codePoint <= 57343) {
      continue;
    }
    if (codePoint >= 65024 && codePoint <= 65039) {
      continue;
    }
    if (defaultIgnorableCodePointRegex.test(character)) {
      continue;
    }
    if (emojiRegex().test(character)) {
      width += 2;
      continue;
    }
    width += eastAsianWidth(codePoint, eastAsianWidthOptions);
  }
  return width;
}
function isUnicodeSupported() {
  const { env: env2 } = p$1;
  const { TERM, TERM_PROGRAM } = env2;
  if (p$1.platform !== "win32") {
    return TERM !== "linux";
  }
  return Boolean(env2.WT_SESSION) || Boolean(env2.TERMINUS_SUBLIME) || env2.ConEmuTask === "{cmd::Cmder}" || TERM_PROGRAM === "Terminus-Sublime" || TERM_PROGRAM === "vscode" || TERM === "xterm-256color" || TERM === "alacritty" || TERM === "rxvt-unicode" || TERM === "rxvt-unicode-256color" || env2.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}
var TYPE_COLOR_MAP = {
  info: "cyan",
  fail: "red",
  success: "green",
  ready: "green",
  start: "magenta"
};
var LEVEL_COLOR_MAP = {
  0: "red",
  1: "yellow"
};
var unicode = isUnicodeSupported();
var s = (c3, fallback) => unicode ? c3 : fallback;
var TYPE_ICONS = {
  error: s("\u2716", "\xD7"),
  fatal: s("\u2716", "\xD7"),
  ready: s("\u2714", "\u221A"),
  warn: s("\u26A0", "\u203C"),
  info: s("\u2139", "i"),
  success: s("\u2714", "\u221A"),
  debug: s("\u2699", "D"),
  trace: s("\u2192", "\u2192"),
  fail: s("\u2716", "\xD7"),
  start: s("\u25D0", "o"),
  log: ""
};
function stringWidth(str) {
  const hasICU = typeof Intl === "object";
  if (!hasICU || !Intl.Segmenter) {
    return stripAnsi(str).length;
  }
  return stringWidth$1(str);
}

class FancyReporter extends BasicReporter {
  formatStack(stack, opts) {
    const indent = "  ".repeat((opts?.errorLevel || 0) + 1);
    return `
${indent}` + parseStack(stack).map((line) => "  " + line.replace(/^at +/, (m2) => colors.gray(m2)).replace(/\((.+)\)/, (_3, m2) => `(${colors.cyan(m2)})`)).join(`
${indent}`);
  }
  formatType(logObj, isBadge, opts) {
    const typeColor = TYPE_COLOR_MAP[logObj.type] || LEVEL_COLOR_MAP[logObj.level] || "gray";
    if (isBadge) {
      return getBgColor(typeColor)(colors.black(` ${logObj.type.toUpperCase()} `));
    }
    const _type = typeof TYPE_ICONS[logObj.type] === "string" ? TYPE_ICONS[logObj.type] : logObj.icon || logObj.type;
    return _type ? getColor2(typeColor)(_type) : "";
  }
  formatLogObj(logObj, opts) {
    const [message, ...additional] = this.formatArgs(logObj.args, opts).split(`
`);
    if (logObj.type === "box") {
      return box(characterFormat(message + (additional.length > 0 ? `
` + additional.join(`
`) : "")), {
        title: logObj.title ? characterFormat(logObj.title) : undefined,
        style: logObj.style
      });
    }
    const date = this.formatDate(logObj.date, opts);
    const coloredDate = date && colors.gray(date);
    const isBadge = logObj.badge ?? logObj.level < 2;
    const type = this.formatType(logObj, isBadge, opts);
    const tag = logObj.tag ? colors.gray(logObj.tag) : "";
    let line;
    const left = this.filterAndJoin([type, characterFormat(message)]);
    const right = this.filterAndJoin(opts.columns ? [tag, coloredDate] : [tag]);
    const space = (opts.columns || 0) - stringWidth(left) - stringWidth(right) - 2;
    line = space > 0 && (opts.columns || 0) >= 80 ? left + " ".repeat(space) + right : (right ? `${colors.gray(`[${right}]`)} ` : "") + left;
    line += characterFormat(additional.length > 0 ? `
` + additional.join(`
`) : "");
    if (logObj.type === "trace") {
      const _err = new Error("Trace: " + logObj.message);
      line += this.formatStack(_err.stack || "");
    }
    return isBadge ? `
` + line + `
` : line;
  }
}
function characterFormat(str) {
  return str.replace(/`([^`]+)`/gm, (_3, m2) => colors.cyan(m2)).replace(/\s+_([^_]+)_\s+/gm, (_3, m2) => ` ${colors.underline(m2)} `);
}
function getColor2(color = "white") {
  return colors[color] || colors.white;
}
function getBgColor(color = "bgWhite") {
  return colors[`bg${color[0].toUpperCase()}${color.slice(1)}`] || colors.bgWhite;
}
function createConsola2(options = {}) {
  let level = _getDefaultLogLevel();
  if (process.env.CONSOLA_LEVEL) {
    level = Number.parseInt(process.env.CONSOLA_LEVEL) ?? level;
  }
  const consola2 = createConsola({
    level,
    defaults: { level },
    stdout: process.stdout,
    stderr: process.stderr,
    prompt: (...args) => Promise.resolve().then(() => (init_prompt(), exports_prompt)).then((m2) => m2.prompt(...args)),
    reporters: options.reporters || [
      options.fancy ?? !(T2 || A2) ? new FancyReporter : new BasicReporter
    ],
    ...options
  });
  return consola2;
}
function _getDefaultLogLevel() {
  if (U) {
    return LogLevels.debug;
  }
  if (A2) {
    return LogLevels.warn;
  }
  return LogLevels.info;
}
var consola = createConsola2();
// ../huginn-backend-shared/src/log-utils.ts
var divider = colors.gray(">");
var startText = colors.bold(colors.gray("START"));
var endText = colors.bold(colors.gray("END"));
var requestDataText = colors.bold(colors.gray("REQUEST DATA"));
var responseDataText = colors.bold(colors.gray("RESPONSE DATA"));
var gatewayOpen = colors.bold(colors.cyan("GATEWAY OPEN"));
var gatewayClose = colors.bold(colors.red("GATEWAY CLOSE"));
var gatewayRecieve = colors.bold(colors.gray("GATEWAY RECIEVE"));
var gatewaySend = colors.bold(colors.gray("GATEWAY SEND"));
var getFile = colors.bold(colors.green("GET FILE"));
var writeFile = colors.bold(colors.magenta("WRITE FILE"));
var notFoundFile = colors.bold(colors.red("FILE NOT FOUND"));
var cdn = colors.bold(colors.gray("CDN REQUEST"));
function logServerError(path, e2) {
  consola.box(`${colors.bold(colors.red("Server Error:"))} ${colors.green(path.length > 100 ? `${path.slice(0, 100)}...` : path)}
`, e2?.cause ?? e2?.stack ?? e2?.message ?? e2);
}
function logReject(path, method, time, id, error, status) {
  const rejectText = colors.bold(colors.red("Rejected"));
  const methodText = colors.bold(colors.red(method));
  const pathText = colors.green(path);
  const statusText = status ? colors.bold(colors.red(` ${status} `)) : " ";
  const idText = colors.yellow(id ?? "unknown");
  const timeText = colors.gray(`${time}ms`);
  let errorText = colors.red("Unknown Error");
  if (typeof error === "string") {
    errorText = colors.red(error);
  } else if (typeof error === "object") {
    errorText = colors.red(`${error?.message ?? "Unknown Error"} (${colors.bold(error?.code)})`);
  }
  consola.fail(`${idText} ${divider} ${endText} ${divider} ${rejectText} (${methodText}) ${divider} ${pathText} ${divider}${statusText}${errorText} ${timeText}
`);
}
function logResponse(path, status, time, id, data) {
  logData(path, responseDataText, id, data);
  const responseText = colors.bold(colors.magenta("Response"));
  const statusText = colors.bold(colors.magenta(status));
  const pathText = colors.green(path);
  const idText = colors.yellow(id ?? "unknown");
  const timeText = colors.gray(`${time}ms`);
  consola.success(`${idText} ${divider} ${endText} ${divider} ${responseText} (${statusText}) ${divider} ${pathText} ${timeText}
`);
}
function logRequest(path, method, id, data) {
  const pathText = colors.green(path);
  const methodText = colors.bold(colors.cyan(method));
  const requestText = colors.bold(colors.cyan("Request"));
  const idText = colors.yellow(id ?? "unknown");
  consola.info(`${idText} ${divider} ${startText} ${divider} ${requestText} (${methodText}) ${divider} ${pathText}`);
  logData(path, requestDataText, id, data);
}
function logData(path, text, id, data) {
  if (!data) {
    return;
  }
  const dataString = JSON.stringify(data);
  if (!dataString) {
    return;
  }
  const pathText = colors.green(path);
  const idText = colors.yellow(id ?? "unknown");
  let dataText = colors.gray(data instanceof ReadableStream ? "File Data" : dataString);
  if (data !== null && typeof data === "object" && "content" in data) {
    const content = data.content.replaceAll(`
`, " \\n ");
    dataText = colors.gray(`${colors.underline("Formatted")} > ${content}`);
  } else if (dataString.length > 100) {
    dataText = colors.gray("Data Too Long");
  }
  consola.info(`${idText} ${divider} ${text} ${divider} ${pathText} ${divider} ${dataText}`);
}
function logGatewayOpen() {
  consola.info(`${gatewayOpen}
`);
}
function logGatewayClose(code, reason) {
  const codeText = colors.red(code);
  const reasonText = colors.gray(reason === "" ? "No reason" : reason);
  consola.info(`${gatewayClose} (${codeText}) ${divider} ${reasonText}
`);
}
function logGatewayRecieve(id, data, logHeartbeat) {
  if (data.op === 1 /* HEARTBEAT */ && !logHeartbeat) {
    return;
  }
  const idText = colors.yellow(id);
  const opcodeText = colors.yellow(opcodeToText(data.op));
  const opcodeNumberText = colors.yellow(data.op);
  let dataText = colors.gray(JSON.stringify(data.d));
  if (dataText.length > 100) {
    dataText = colors.gray("Data Too Long");
  }
  consola.info(`${gatewayRecieve} ${divider} ${idText} ${divider} ${opcodeText} (${opcodeNumberText}) ${divider} ${dataText}`);
}
function logGatewaySend(topics, data, logHeartbeat) {
  if (data.op === 11 /* HEARTBEAT_ACK */ && !logHeartbeat) {
    return;
  }
  const topicText = colors.green(Array.isArray(topics) ? topics.join(", ") : topics);
  const opcodeText = colors.blue(data.t ? `${data.t} ${divider} ${opcodeToText(data.op)}` : opcodeToText(data.op));
  const opcodeNumberText = colors.blue(data.op);
  let dataText = colors.gray(JSON.stringify(data.d) || "null");
  if (dataText.length > 100) {
    dataText = colors.gray("Data Too Long");
  }
  consola.info(`${gatewaySend} ${divider} ${topicText} ${divider} ${opcodeText} (${opcodeNumberText}) ${divider} ${dataText}`);
}
function opcodeToText(opcode) {
  switch (opcode) {
    case 0 /* DISPATCH */:
      return "Dispatch";
    case 1 /* HEARTBEAT */:
      return "Heartbeat";
    case 11 /* HEARTBEAT_ACK */:
      return "HeartbeatAck";
    case 10 /* HELLO */:
      return "Hello";
    case 2 /* IDENTIFY */:
      return "Identify";
    case 6 /* RESUME */:
      return "Resume";
    default:
      return "Unknown";
  }
}
// ../../node_modules/hono/dist/utils/url.js
var splitPath = (path) => {
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
};
var splitRoutingPath = (routePath) => {
  const { groups, path } = extractGroupsFromPath(routePath);
  const paths = splitPath(path);
  return replaceGroupMarks(paths, groups);
};
var extractGroupsFromPath = (path) => {
  const groups = [];
  path = path.replace(/\{[^}]+\}/g, (match, index) => {
    const mark = `@${index}`;
    groups.push([mark, match]);
    return mark;
  });
  return { groups, path };
};
var replaceGroupMarks = (paths, groups) => {
  for (let i2 = groups.length - 1;i2 >= 0; i2--) {
    const [mark] = groups[i2];
    for (let j2 = paths.length - 1;j2 >= 0; j2--) {
      if (paths[j2].includes(mark)) {
        paths[j2] = paths[j2].replace(mark, groups[i2][1]);
        break;
      }
    }
  }
  return paths;
};
var patternCache = {};
var getPattern = (label) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    if (!patternCache[label]) {
      if (match[2]) {
        patternCache[label] = [label, match[1], new RegExp("^" + match[2] + "$")];
      } else {
        patternCache[label] = [label, match[1], true];
      }
    }
    return patternCache[label];
  }
  return null;
};
var tryDecode = (str, decoder) => {
  try {
    return decoder(str);
  } catch {
    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {
      try {
        return decoder(match);
      } catch {
        return match;
      }
    });
  }
};
var tryDecodeURI = (str) => tryDecode(str, decodeURI);
var getPath = (request) => {
  const url = request.url;
  const start = url.indexOf("/", 8);
  let i2 = start;
  for (;i2 < url.length; i2++) {
    const charCode = url.charCodeAt(i2);
    if (charCode === 37) {
      const queryIndex = url.indexOf("?", i2);
      const path = url.slice(start, queryIndex === -1 ? undefined : queryIndex);
      return tryDecodeURI(path.includes("%25") ? path.replace(/%25/g, "%2525") : path);
    } else if (charCode === 63) {
      break;
    }
  }
  return url.slice(start, i2);
};
var getPathNoStrict = (request) => {
  const result = getPath(request);
  return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
};
var mergePath = (...paths) => {
  let p3 = "";
  let endsWithSlash = false;
  for (let path of paths) {
    if (p3.at(-1) === "/") {
      p3 = p3.slice(0, -1);
      endsWithSlash = true;
    }
    if (path[0] !== "/") {
      path = `/${path}`;
    }
    if (path === "/" && endsWithSlash) {
      p3 = `${p3}/`;
    } else if (path !== "/") {
      p3 = `${p3}${path}`;
    }
    if (path === "/" && p3 === "") {
      p3 = "/";
    }
  }
  return p3;
};
var checkOptionalParameter = (path) => {
  if (!path.match(/\:.+\?$/)) {
    return null;
  }
  const segments = path.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v2, i2, a3) => a3.indexOf(v2) === i2);
};
var _decodeURI = (value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return value.indexOf("%") !== -1 ? decodeURIComponent_(value) : value;
};
var _getQueryParam = (url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf(`?${key}`, 8);
    if (keyIndex2 === -1) {
      keyIndex2 = url.indexOf(`&${key}`, 8);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? undefined : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return;
    }
  }
  const results = {};
  encoded ??= /[%+]/.test(url);
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(keyIndex + 1, valueIndex === -1 ? nextKeyIndex === -1 ? undefined : nextKeyIndex : valueIndex);
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? undefined : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = [];
      }
      results[name].push(value);
    } else {
      results[name] ??= value;
    }
  }
  return key ? results[key] : results;
};
var getQueryParam = _getQueryParam;
var getQueryParams = (url, key) => {
  return _getQueryParam(url, key, true);
};
var decodeURIComponent_ = decodeURIComponent;

// ../../node_modules/hono/dist/utils/cookie.js
var validCookieNameRegEx = /^[\w!#$%&'*.^`|~+-]+$/;
var validCookieValueRegEx = /^[ !#-:<-[\]-~]*$/;
var parse = (cookie, name) => {
  if (name && cookie.indexOf(name) === -1) {
    return {};
  }
  const pairs = cookie.trim().split(";");
  const parsedCookie = {};
  for (let pairStr of pairs) {
    pairStr = pairStr.trim();
    const valueStartPos = pairStr.indexOf("=");
    if (valueStartPos === -1) {
      continue;
    }
    const cookieName = pairStr.substring(0, valueStartPos).trim();
    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {
      continue;
    }
    let cookieValue = pairStr.substring(valueStartPos + 1).trim();
    if (cookieValue.startsWith('"') && cookieValue.endsWith('"')) {
      cookieValue = cookieValue.slice(1, -1);
    }
    if (validCookieValueRegEx.test(cookieValue)) {
      parsedCookie[cookieName] = decodeURIComponent_(cookieValue);
      if (name) {
        break;
      }
    }
  }
  return parsedCookie;
};
var _serialize = (name, value, opt = {}) => {
  let cookie = `${name}=${value}`;
  if (name.startsWith("__Secure-") && !opt.secure) {
    throw new Error("__Secure- Cookie must have Secure attributes");
  }
  if (name.startsWith("__Host-")) {
    if (!opt.secure) {
      throw new Error("__Host- Cookie must have Secure attributes");
    }
    if (opt.path !== "/") {
      throw new Error('__Host- Cookie must have Path attributes with "/"');
    }
    if (opt.domain) {
      throw new Error("__Host- Cookie must not have Domain attributes");
    }
  }
  if (opt && typeof opt.maxAge === "number" && opt.maxAge >= 0) {
    if (opt.maxAge > 34560000) {
      throw new Error("Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.");
    }
    cookie += `; Max-Age=${opt.maxAge | 0}`;
  }
  if (opt.domain && opt.prefix !== "host") {
    cookie += `; Domain=${opt.domain}`;
  }
  if (opt.path) {
    cookie += `; Path=${opt.path}`;
  }
  if (opt.expires) {
    if (opt.expires.getTime() - Date.now() > 34560000000) {
      throw new Error("Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.");
    }
    cookie += `; Expires=${opt.expires.toUTCString()}`;
  }
  if (opt.httpOnly) {
    cookie += "; HttpOnly";
  }
  if (opt.secure) {
    cookie += "; Secure";
  }
  if (opt.sameSite) {
    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;
  }
  if (opt.priority) {
    cookie += `; Priority=${opt.priority}`;
  }
  if (opt.partitioned) {
    if (!opt.secure) {
      throw new Error("Partitioned Cookie must have Secure attributes");
    }
    cookie += "; Partitioned";
  }
  return cookie;
};
var serialize = (name, value, opt) => {
  value = encodeURIComponent(value);
  return _serialize(name, value, opt);
};

// ../../node_modules/hono/dist/helper/cookie/index.js
var getCookie = (c3, key, prefix) => {
  const cookie = c3.req.raw.headers.get("Cookie");
  if (typeof key === "string") {
    if (!cookie) {
      return;
    }
    let finalKey = key;
    if (prefix === "secure") {
      finalKey = "__Secure-" + key;
    } else if (prefix === "host") {
      finalKey = "__Host-" + key;
    }
    const obj2 = parse(cookie, finalKey);
    return obj2[finalKey];
  }
  if (!cookie) {
    return {};
  }
  const obj = parse(cookie);
  return obj;
};
var setCookie = (c3, name, value, opt) => {
  let cookie;
  if (opt?.prefix === "secure") {
    cookie = serialize("__Secure-" + name, value, { path: "/", ...opt, secure: true });
  } else if (opt?.prefix === "host") {
    cookie = serialize("__Host-" + name, value, {
      ...opt,
      path: "/",
      secure: true,
      domain: undefined
    });
  } else {
    cookie = serialize(name, value, { path: "/", ...opt });
  }
  c3.header("Set-Cookie", cookie, { append: true });
};

// ../../node_modules/hono/dist/utils/body.js
var parseBody = async (request, options = /* @__PURE__ */ Object.create(null)) => {
  const { all = false, dot = false } = options;
  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
  const contentType = headers.get("Content-Type");
  if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
    return parseFormData(request, { all, dot });
  }
  return {};
};
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key, value]) => {
      const shouldParseDotValues = key.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value);
        delete form[key];
      }
    });
  }
  return form;
}
var handleParsingAllValues = (form, key, value) => {
  if (form[key] !== undefined) {
    if (Array.isArray(form[key])) {
      form[key].push(value);
    } else {
      form[key] = [form[key], value];
    }
  } else {
    form[key] = value;
  }
};
var handleParsingNestedValues = (form, key, value) => {
  let nestedForm = form;
  const keys = key.split(".");
  keys.forEach((key2, index) => {
    if (index === keys.length - 1) {
      nestedForm[key2] = value;
    } else {
      if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
        nestedForm[key2] = /* @__PURE__ */ Object.create(null);
      }
      nestedForm = nestedForm[key2];
    }
  });
};

// ../../node_modules/hono/dist/request.js
var tryDecodeURIComponent = (str) => tryDecode(str, decodeURIComponent_);
var HonoRequest = class {
  raw;
  #validatedData;
  #matchResult;
  routeIndex = 0;
  path;
  bodyCache = {};
  constructor(request, path = "/", matchResult = [[]]) {
    this.raw = request;
    this.path = path;
    this.#matchResult = matchResult;
    this.#validatedData = {};
  }
  param(key) {
    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();
  }
  #getDecodedParam(key) {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key];
    const param = this.#getParamValue(paramKey);
    return param ? /\%/.test(param) ? tryDecodeURIComponent(param) : param : undefined;
  }
  #getAllDecodedParams() {
    const decoded = {};
    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
    for (const key of keys) {
      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
      if (value && typeof value === "string") {
        decoded[key] = /\%/.test(value) ? tryDecodeURIComponent(value) : value;
      }
    }
    return decoded;
  }
  #getParamValue(paramKey) {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name) {
      return this.raw.headers.get(name.toLowerCase()) ?? undefined;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    return this.bodyCache.parsedBody ??= await parseBody(this, options);
  }
  #cachedBody = (key) => {
    const { bodyCache, raw: raw2 } = this;
    const cachedBody = bodyCache[key];
    if (cachedBody) {
      return cachedBody;
    }
    const anyCachedKey = Object.keys(bodyCache)[0];
    if (anyCachedKey) {
      return bodyCache[anyCachedKey].then((body) => {
        if (anyCachedKey === "json") {
          body = JSON.stringify(body);
        }
        return new Response(body)[key]();
      });
    }
    return bodyCache[key] = raw2[key]();
  };
  json() {
    return this.#cachedBody("json");
  }
  text() {
    return this.#cachedBody("text");
  }
  arrayBuffer() {
    return this.#cachedBody("arrayBuffer");
  }
  blob() {
    return this.#cachedBody("blob");
  }
  formData() {
    return this.#cachedBody("formData");
  }
  addValidatedData(target, data) {
    this.#validatedData[target] = data;
  }
  valid(target) {
    return this.#validatedData[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get matchedRoutes() {
    return this.#matchResult[0].map(([[, route]]) => route);
  }
  get routePath() {
    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
};

// ../../node_modules/hono/dist/utils/html.js
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw2 = (value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
};
var resolveCallback = async (str, phase, preserveCallbacks, context, buffer) => {
  if (typeof str === "object" && !(str instanceof String)) {
    if (!(str instanceof Promise)) {
      str = str.toString();
    }
    if (str instanceof Promise) {
      str = await str;
    }
  }
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c3) => c3({ phase, buffer, context }))).then((res) => Promise.all(res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))).then(() => buffer[0]));
  if (preserveCallbacks) {
    return raw2(await resStr, callbacks);
  } else {
    return resStr;
  }
};

// ../../node_modules/hono/dist/context.js
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setHeaders = (headers, map = {}) => {
  for (const key of Object.keys(map)) {
    headers.set(key, map[key]);
  }
  return headers;
};
var Context = class {
  #rawRequest;
  #req;
  env = {};
  #var;
  finalized = false;
  error;
  #status = 200;
  #executionCtx;
  #headers;
  #preparedHeaders;
  #res;
  #isFresh = true;
  #layout;
  #renderer;
  #notFoundHandler;
  #matchResult;
  #path;
  constructor(req, options) {
    this.#rawRequest = req;
    if (options) {
      this.#executionCtx = options.executionCtx;
      this.env = options.env;
      this.#notFoundHandler = options.notFoundHandler;
      this.#path = options.path;
      this.#matchResult = options.matchResult;
    }
  }
  get req() {
    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
    return this.#req;
  }
  get event() {
    if (this.#executionCtx && "respondWith" in this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    this.#isFresh = false;
    return this.#res ||= new Response("404 Not Found", { status: 404 });
  }
  set res(_res) {
    this.#isFresh = false;
    if (this.#res && _res) {
      try {
        for (const [k2, v2] of this.#res.headers.entries()) {
          if (k2 === "content-type") {
            continue;
          }
          if (k2 === "set-cookie") {
            const cookies = this.#res.headers.getSetCookie();
            _res.headers.delete("set-cookie");
            for (const cookie of cookies) {
              _res.headers.append("set-cookie", cookie);
            }
          } else {
            _res.headers.set(k2, v2);
          }
        }
      } catch (e2) {
        if (e2 instanceof TypeError && e2.message.includes("immutable")) {
          this.res = new Response(_res.body, {
            headers: _res.headers,
            status: _res.status
          });
          return;
        } else {
          throw e2;
        }
      }
    }
    this.#res = _res;
    this.finalized = true;
  }
  render = (...args) => {
    this.#renderer ??= (content) => this.html(content);
    return this.#renderer(...args);
  };
  setLayout = (layout) => this.#layout = layout;
  getLayout = () => this.#layout;
  setRenderer = (renderer) => {
    this.#renderer = renderer;
  };
  header = (name, value, options) => {
    if (value === undefined) {
      if (this.#headers) {
        this.#headers.delete(name);
      } else if (this.#preparedHeaders) {
        delete this.#preparedHeaders[name.toLocaleLowerCase()];
      }
      if (this.finalized) {
        this.res.headers.delete(name);
      }
      return;
    }
    if (options?.append) {
      if (!this.#headers) {
        this.#isFresh = false;
        this.#headers = new Headers(this.#preparedHeaders);
        this.#preparedHeaders = {};
      }
      this.#headers.append(name, value);
    } else {
      if (this.#headers) {
        this.#headers.set(name, value);
      } else {
        this.#preparedHeaders ??= {};
        this.#preparedHeaders[name.toLowerCase()] = value;
      }
    }
    if (this.finalized) {
      if (options?.append) {
        this.res.headers.append(name, value);
      } else {
        this.res.headers.set(name, value);
      }
    }
  };
  status = (status) => {
    this.#isFresh = false;
    this.#status = status;
  };
  set = (key, value) => {
    this.#var ??= /* @__PURE__ */ new Map;
    this.#var.set(key, value);
  };
  get = (key) => {
    return this.#var ? this.#var.get(key) : undefined;
  };
  get var() {
    if (!this.#var) {
      return {};
    }
    return Object.fromEntries(this.#var);
  }
  #newResponse(data, arg, headers) {
    if (this.#isFresh && !headers && !arg && this.#status === 200) {
      return new Response(data, {
        headers: this.#preparedHeaders
      });
    }
    if (arg && typeof arg !== "number") {
      const header = new Headers(arg.headers);
      if (this.#headers) {
        this.#headers.forEach((v2, k2) => {
          if (k2 === "set-cookie") {
            header.append(k2, v2);
          } else {
            header.set(k2, v2);
          }
        });
      }
      const headers2 = setHeaders(header, this.#preparedHeaders);
      return new Response(data, {
        headers: headers2,
        status: arg.status ?? this.#status
      });
    }
    const status = typeof arg === "number" ? arg : this.#status;
    this.#preparedHeaders ??= {};
    this.#headers ??= new Headers;
    setHeaders(this.#headers, this.#preparedHeaders);
    if (this.#res) {
      this.#res.headers.forEach((v2, k2) => {
        if (k2 === "set-cookie") {
          this.#headers?.append(k2, v2);
        } else {
          this.#headers?.set(k2, v2);
        }
      });
      setHeaders(this.#headers, this.#preparedHeaders);
    }
    headers ??= {};
    for (const [k2, v2] of Object.entries(headers)) {
      if (typeof v2 === "string") {
        this.#headers.set(k2, v2);
      } else {
        this.#headers.delete(k2);
        for (const v22 of v2) {
          this.#headers.append(k2, v22);
        }
      }
    }
    return new Response(data, {
      status,
      headers: this.#headers
    });
  }
  newResponse = (...args) => this.#newResponse(...args);
  body = (data, arg, headers) => {
    return typeof arg === "number" ? this.#newResponse(data, arg, headers) : this.#newResponse(data, arg);
  };
  text = (text, arg, headers) => {
    if (!this.#preparedHeaders) {
      if (this.#isFresh && !headers && !arg) {
        return new Response(text);
      }
      this.#preparedHeaders = {};
    }
    this.#preparedHeaders["content-type"] = TEXT_PLAIN;
    if (typeof arg === "number") {
      return this.#newResponse(text, arg, headers);
    }
    return this.#newResponse(text, arg);
  };
  json = (object, arg, headers) => {
    const body = JSON.stringify(object);
    this.#preparedHeaders ??= {};
    this.#preparedHeaders["content-type"] = "application/json";
    return typeof arg === "number" ? this.#newResponse(body, arg, headers) : this.#newResponse(body, arg);
  };
  html = (html, arg, headers) => {
    this.#preparedHeaders ??= {};
    this.#preparedHeaders["content-type"] = "text/html; charset=UTF-8";
    if (typeof html === "object") {
      return resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then((html2) => {
        return typeof arg === "number" ? this.#newResponse(html2, arg, headers) : this.#newResponse(html2, arg);
      });
    }
    return typeof arg === "number" ? this.#newResponse(html, arg, headers) : this.#newResponse(html, arg);
  };
  redirect = (location, status) => {
    this.#headers ??= new Headers;
    this.#headers.set("Location", String(location));
    return this.newResponse(null, status ?? 302);
  };
  notFound = () => {
    this.#notFoundHandler ??= () => new Response;
    return this.#notFoundHandler(this);
  };
};

// ../../node_modules/hono/dist/compose.js
var compose = (middleware, onError, onNotFound) => {
  return (context, next) => {
    let index = -1;
    const isContext = context instanceof Context;
    return dispatch(0);
    async function dispatch(i2) {
      if (i2 <= index) {
        throw new Error("next() called multiple times");
      }
      index = i2;
      let res;
      let isError = false;
      let handler;
      if (middleware[i2]) {
        handler = middleware[i2][0][0];
        if (isContext) {
          context.req.routeIndex = i2;
        }
      } else {
        handler = i2 === middleware.length && next || undefined;
      }
      if (!handler) {
        if (isContext && context.finalized === false && onNotFound) {
          res = await onNotFound(context);
        }
      } else {
        try {
          res = await handler(context, () => {
            return dispatch(i2 + 1);
          });
        } catch (err) {
          if (err instanceof Error && isContext && onError) {
            context.error = err;
            res = await onError(err, context);
            isError = true;
          } else {
            throw err;
          }
        }
      }
      if (res && (context.finalized === false || isError)) {
        context.res = res;
      }
      return context;
    }
  };
};

// ../../node_modules/hono/dist/router.js
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
};

// ../../node_modules/hono/dist/utils/constants.js
var COMPOSED_HANDLER = "__COMPOSED_HANDLER";

// ../../node_modules/hono/dist/hono-base.js
var notFoundHandler = (c3) => {
  return c3.text("404 Not Found", 404);
};
var errorHandler = (err, c3) => {
  if ("getResponse" in err) {
    return err.getResponse();
  }
  console.error(err);
  return c3.text("Internal Server Error", 500);
};
var Hono = class {
  get;
  post;
  put;
  delete;
  options;
  patch;
  all;
  on;
  use;
  router;
  getPath;
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.#addRoute(method, this.#path, args1);
        }
        args.forEach((handler) => {
          this.#addRoute(method, this.#path, handler);
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      for (const p3 of [path].flat()) {
        this.#path = p3;
        for (const m2 of [method].flat()) {
          handlers.map((handler) => {
            this.#addRoute(m2.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers.unshift(arg1);
      }
      handlers.forEach((handler) => {
        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const strict = options.strict ?? true;
    delete options.strict;
    Object.assign(this, options);
    this.getPath = strict ? options.getPath ?? getPath : getPathNoStrict;
  }
  #clone() {
    const clone = new Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone.routes = this.routes;
    return clone;
  }
  #notFoundHandler = notFoundHandler;
  errorHandler = errorHandler;
  route(path, app) {
    const subApp = this.basePath(path);
    app.routes.map((r3) => {
      let handler;
      if (app.errorHandler === errorHandler) {
        handler = r3.handler;
      } else {
        handler = async (c3, next) => (await compose([], app.errorHandler)(c3, () => r3.handler(c3, next))).res;
        handler[COMPOSED_HANDLER] = r3.handler;
      }
      subApp.#addRoute(r3.method, r3.path, handler);
    });
    return this;
  }
  basePath(path) {
    const subApp = this.#clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  onError = (handler) => {
    this.errorHandler = handler;
    return this;
  };
  notFound = (handler) => {
    this.#notFoundHandler = handler;
    return this;
  };
  mount(path, applicationHandler, options) {
    let replaceRequest;
    let optionHandler;
    if (options) {
      if (typeof options === "function") {
        optionHandler = options;
      } else {
        optionHandler = options.optionHandler;
        replaceRequest = options.replaceRequest;
      }
    }
    const getOptions = optionHandler ? (c3) => {
      const options2 = optionHandler(c3);
      return Array.isArray(options2) ? options2 : [options2];
    } : (c3) => {
      let executionContext = undefined;
      try {
        executionContext = c3.executionCtx;
      } catch {
      }
      return [c3.env, executionContext];
    };
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path);
      const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
      return (request) => {
        const url = new URL(request.url);
        url.pathname = url.pathname.slice(pathPrefixLength) || "/";
        return new Request(url, request);
      };
    })();
    const handler = async (c3, next) => {
      const res = await applicationHandler(replaceRequest(c3.req.raw), ...getOptions(c3));
      if (res) {
        return res;
      }
      await next();
    };
    this.#addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  #addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    const r3 = { path, method, handler };
    this.router.add(method, path, [handler, r3]);
    this.routes.push(r3);
  }
  #handleError(err, c3) {
    if (err instanceof Error) {
      return this.errorHandler(err, c3);
    }
    throw err;
  }
  #dispatch(request, executionCtx, env2, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env2, "GET")))();
    }
    const path = this.getPath(request, { env: env2 });
    const matchResult = this.router.match(method, path);
    const c3 = new Context(request, {
      path,
      matchResult,
      env: env2,
      executionCtx,
      notFoundHandler: this.#notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c3, async () => {
          c3.res = await this.#notFoundHandler(c3);
        });
      } catch (err) {
        return this.#handleError(err, c3);
      }
      return res instanceof Promise ? res.then((resolved) => resolved || (c3.finalized ? c3.res : this.#notFoundHandler(c3))).catch((err) => this.#handleError(err, c3)) : res ?? this.#notFoundHandler(c3);
    }
    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);
    return (async () => {
      try {
        const context = await composed(c3);
        if (!context.finalized) {
          throw new Error("Context is not finalized. Did you forget to return a Response object or `await next()`?");
        }
        return context.res;
      } catch (err) {
        return this.#handleError(err, c3);
      }
    })();
  }
  fetch = (request, ...rest) => {
    return this.#dispatch(request, rest[1], rest[0], request.method);
  };
  request = (input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);
    }
    input = input.toString();
    return this.fetch(new Request(/^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`, requestInit), Env, executionCtx);
  };
  fire = () => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.#dispatch(event.request, event, undefined, event.request.method));
    });
  };
};

// ../../node_modules/hono/dist/router/reg-exp-router/node.js
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a3, b) {
  if (a3.length === 1) {
    return b.length === 1 ? a3 < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a3 === ONLY_WILDCARD_REG_EXP_STR || a3 === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a3 === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a3.length === b.length ? a3 < b ? -1 : 1 : b.length - a3.length;
}
var Node = class {
  #index;
  #varIndex;
  #children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.#index !== undefined) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.#index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.#children[regexpStr];
      if (!node) {
        if (Object.keys(this.#children).some((k2) => k2 !== ONLY_WILDCARD_REG_EXP_STR && k2 !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[regexpStr] = new Node;
        if (name !== "") {
          node.#varIndex = context.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.#varIndex]);
      }
    } else {
      node = this.#children[token];
      if (!node) {
        if (Object.keys(this.#children).some((k2) => k2.length > 1 && k2 !== ONLY_WILDCARD_REG_EXP_STR && k2 !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[token] = new Node;
      }
    }
    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.#children).sort(compareKey);
    const strList = childKeys.map((k2) => {
      const c3 = this.#children[k2];
      return (typeof c3.#varIndex === "number" ? `(${k2})@${c3.#varIndex}` : regExpMetaChars.has(k2) ? `\\${k2}` : k2) + c3.buildRegExpStr();
    });
    if (typeof this.#index === "number") {
      strList.unshift(`#${this.#index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// ../../node_modules/hono/dist/router/reg-exp-router/trie.js
var Trie = class {
  #context = { varIndex: 0 };
  #root = new Node;
  insert(path, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i2 = 0;; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m2) => {
        const mark = `@\\${i2}`;
        groups[i2] = [mark, m2];
        i2++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i2 = groups.length - 1;i2 >= 0; i2--) {
      const [mark] = groups[i2];
      for (let j2 = tokens.length - 1;j2 >= 0; j2--) {
        if (tokens[j2].indexOf(mark) !== -1) {
          tokens[j2] = tokens[j2].replace(mark, groups[i2][1]);
          break;
        }
      }
    }
    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.#root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_3, handlerIndex, paramIndex) => {
      if (handlerIndex !== undefined) {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (paramIndex !== undefined) {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// ../../node_modules/hono/dist/router/reg-exp-router/router.js
var emptyParam = [];
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ??= new RegExp(path === "*" ? "" : `^${path.replace(/\/\*$|([.\\+*[^\]$()])/g, (_3, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)")}$`);
}
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
function buildMatcherFromPreprocessedRoutes(routes2) {
  const trie = new Trie;
  const handlerData = [];
  if (routes2.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes2.map((route) => [!/\*|\/:/.test(route[0]), ...route]).sort(([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length);
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i2 = 0, j2 = -1, len = routesWithStaticPathFlag.length;i2 < len; i2++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i2];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h2]) => [h2, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j2++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j2, pathErrorCheckOnly);
    } catch (e2) {
      throw e2 === PATH_ERROR ? new UnsupportedPathError(path) : e2;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j2] = handlers.map(([h2, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (;paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h2, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i2 = 0, len = handlerData.length;i2 < len; i2++) {
    for (let j2 = 0, len2 = handlerData[i2].length;j2 < len2; j2++) {
      const map = handlerData[i2][j2]?.[1];
      if (!map) {
        continue;
      }
      const keys = Object.keys(map);
      for (let k2 = 0, len3 = keys.length;k2 < len3; k2++) {
        map[keys[k2]] = paramReplacementMap[map[keys[k2]]];
      }
    }
  }
  const handlerMap = [];
  for (const i2 in indexReplacementMap) {
    handlerMap[i2] = handlerData[indexReplacementMap[i2]];
  }
  return [regexp, handlerMap, staticMap];
}
function findMiddleware(middleware, path) {
  if (!middleware) {
    return;
  }
  for (const k2 of Object.keys(middleware).sort((a3, b) => b.length - a3.length)) {
    if (buildWildcardRegExp(k2).test(path)) {
      return [...middleware[k2]];
    }
  }
  return;
}
var RegExpRouter = class {
  name = "RegExpRouter";
  #middleware;
  #routes;
  constructor() {
    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path, handler) {
    const middleware = this.#middleware;
    const routes2 = this.#routes;
    if (!middleware || !routes2) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      [middleware, routes2].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p3) => {
          handlerMap[method][p3] = [...handlerMap[METHOD_NAME_ALL][p3]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m2) => {
          middleware[m2][path] ||= findMiddleware(middleware[m2], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
        });
      } else {
        middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
      }
      Object.keys(middleware).forEach((m2) => {
        if (method === METHOD_NAME_ALL || method === m2) {
          Object.keys(middleware[m2]).forEach((p3) => {
            re.test(p3) && middleware[m2][p3].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes2).forEach((m2) => {
        if (method === METHOD_NAME_ALL || method === m2) {
          Object.keys(routes2[m2]).forEach((p3) => re.test(p3) && routes2[m2][p3].push([handler, paramCount]));
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path) || [path];
    for (let i2 = 0, len = paths.length;i2 < len; i2++) {
      const path2 = paths[i2];
      Object.keys(routes2).forEach((m2) => {
        if (method === METHOD_NAME_ALL || method === m2) {
          routes2[m2][path2] ||= [
            ...findMiddleware(middleware[m2], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
          ];
          routes2[m2][path2].push([handler, paramCount - len + i2 + 1]);
        }
      });
    }
  }
  match(method, path) {
    clearWildcardRegExpCache();
    const matchers = this.#buildAllMatchers();
    this.match = (method2, path2) => {
      const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
      const staticMatch = matcher[2][path2];
      if (staticMatch) {
        return staticMatch;
      }
      const match = path2.match(matcher[0]);
      if (!match) {
        return [[], emptyParam];
      }
      const index = match.indexOf("", 1);
      return [matcher[1][index], match];
    };
    return this.match(method, path);
  }
  #buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {
      matchers[method] ||= this.#buildMatcher(method);
    });
    this.#middleware = this.#routes = undefined;
    return matchers;
  }
  #buildMatcher(method) {
    const routes2 = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.#middleware, this.#routes].forEach((r3) => {
      const ownRoute = r3[method] ? Object.keys(r3[method]).map((path) => [path, r3[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes2.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes2.push(...Object.keys(r3[METHOD_NAME_ALL]).map((path) => [path, r3[METHOD_NAME_ALL][path]]));
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes2);
    }
  }
};

// ../../node_modules/hono/dist/router/smart-router/router.js
var SmartRouter = class {
  name = "SmartRouter";
  #routers = [];
  #routes = [];
  constructor(init2) {
    this.#routers = init2.routers;
  }
  add(method, path, handler) {
    if (!this.#routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.#routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.#routes) {
      throw new Error("Fatal error");
    }
    const routers = this.#routers;
    const routes2 = this.#routes;
    const len = routers.length;
    let i2 = 0;
    let res;
    for (;i2 < len; i2++) {
      const router = routers[i2];
      try {
        for (let i22 = 0, len2 = routes2.length;i22 < len2; i22++) {
          router.add(...routes2[i22]);
        }
        res = router.match(method, path);
      } catch (e2) {
        if (e2 instanceof UnsupportedPathError) {
          continue;
        }
        throw e2;
      }
      this.match = router.match.bind(router);
      this.#routers = [router];
      this.#routes = undefined;
      break;
    }
    if (i2 === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.#routes || this.#routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.#routers[0];
  }
};

// ../../node_modules/hono/dist/router/trie-router/node.js
var emptyParams = /* @__PURE__ */ Object.create(null);
var Node2 = class {
  #methods;
  #children;
  #patterns;
  #order = 0;
  #params = emptyParams;
  constructor(method, handler, children) {
    this.#children = children || /* @__PURE__ */ Object.create(null);
    this.#methods = [];
    if (method && handler) {
      const m2 = /* @__PURE__ */ Object.create(null);
      m2[method] = { handler, possibleKeys: [], score: 0 };
      this.#methods = [m2];
    }
    this.#patterns = [];
  }
  insert(method, path, handler) {
    this.#order = ++this.#order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const possibleKeys = [];
    for (let i2 = 0, len = parts.length;i2 < len; i2++) {
      const p3 = parts[i2];
      if (Object.keys(curNode.#children).includes(p3)) {
        curNode = curNode.#children[p3];
        const pattern2 = getPattern(p3);
        if (pattern2) {
          possibleKeys.push(pattern2[1]);
        }
        continue;
      }
      curNode.#children[p3] = new Node2;
      const pattern = getPattern(p3);
      if (pattern) {
        curNode.#patterns.push(pattern);
        possibleKeys.push(pattern[1]);
      }
      curNode = curNode.#children[p3];
    }
    const m2 = /* @__PURE__ */ Object.create(null);
    const handlerSet = {
      handler,
      possibleKeys: possibleKeys.filter((v2, i2, a3) => a3.indexOf(v2) === i2),
      score: this.#order
    };
    m2[method] = handlerSet;
    curNode.#methods.push(m2);
    return curNode;
  }
  #getHandlerSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i2 = 0, len = node.#methods.length;i2 < len; i2++) {
      const m2 = node.#methods[i2];
      const handlerSet = m2[method] || m2[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== undefined) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSets.push(handlerSet);
        if (nodeParams !== emptyParams || params && params !== emptyParams) {
          for (let i22 = 0, len2 = handlerSet.possibleKeys.length;i22 < len2; i22++) {
            const key = handlerSet.possibleKeys[i22];
            const processed = processedSet[handlerSet.score];
            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];
            processedSet[handlerSet.score] = true;
          }
        }
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    this.#params = emptyParams;
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path);
    for (let i2 = 0, len = parts.length;i2 < len; i2++) {
      const part = parts[i2];
      const isLast = i2 === len - 1;
      const tempNodes = [];
      for (let j2 = 0, len2 = curNodes.length;j2 < len2; j2++) {
        const node = curNodes[j2];
        const nextNode = node.#children[part];
        if (nextNode) {
          nextNode.#params = node.#params;
          if (isLast) {
            if (nextNode.#children["*"]) {
              handlerSets.push(...this.#getHandlerSets(nextNode.#children["*"], method, node.#params));
            }
            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k2 = 0, len3 = node.#patterns.length;k2 < len3; k2++) {
          const pattern = node.#patterns[k2];
          const params = node.#params === emptyParams ? {} : { ...node.#params };
          if (pattern === "*") {
            const astNode = node.#children["*"];
            if (astNode) {
              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
              tempNodes.push(astNode);
            }
            continue;
          }
          if (part === "") {
            continue;
          }
          const [key, name, matcher] = pattern;
          const child = node.#children[key];
          const restPathString = parts.slice(i2).join("/");
          if (matcher instanceof RegExp && matcher.test(restPathString)) {
            params[name] = restPathString;
            handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
            continue;
          }
          if (matcher === true || matcher.test(part)) {
            params[name] = part;
            if (isLast) {
              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
              if (child.#children["*"]) {
                handlerSets.push(...this.#getHandlerSets(child.#children["*"], method, params, node.#params));
              }
            } else {
              child.#params = params;
              tempNodes.push(child);
            }
          }
        }
      }
      curNodes = tempNodes;
    }
    if (handlerSets.length > 1) {
      handlerSets.sort((a3, b) => {
        return a3.score - b.score;
      });
    }
    return [handlerSets.map(({ handler, params }) => [handler, params])];
  }
};

// ../../node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  name = "TrieRouter";
  #node;
  constructor() {
    this.#node = new Node2;
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (let i2 = 0, len = results.length;i2 < len; i2++) {
        this.#node.insert(method, results[i2], handler);
      }
      return;
    }
    this.#node.insert(method, path, handler);
  }
  match(method, path) {
    return this.#node.search(method, path);
  }
};

// ../../node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter, new TrieRouter]
    });
  }
};

// ../huginn-backend-shared/src/route-utils.ts
var appInstance = new Hono2;
// ../huginn-backend-shared/src/env-reader.ts
function readEnv(envs) {
  const result = {};
  for (const env2 of envs) {
    if (typeof env2 === "string") {
      result[env2] = process.env[env2];
    } else {
      result[env2.key] = process.env[env2.key] ?? env2.default;
    }
  }
  return result;
}
// ../huginn-backend-shared/src/shared-handlers.ts
function serverOnError(error, c3) {
  if (!isDBError(error))
    return;
  if (error.isErrorType("INVALID_ID" /* INVALID_ID */)) {
    return createHuginnError(c3, createErrorFactory(Errors.invalidId(error.cause)), 400 /* BAD_REQUEST */);
  }
  if (error.isErrorType("NULL_USER" /* NULL_USER */)) {
    return createHuginnError(c3, createErrorFactory(Errors.unknownUser(error.cause)), 404 /* NOT_FOUND */);
  }
  if (error.isErrorType("NULL_RELATIONSHIP" /* NULL_RELATIONSHIP */)) {
    return createHuginnError(c3, createErrorFactory(Errors.unknownRelationship(error.cause)), 404 /* NOT_FOUND */);
  }
  if (error.isErrorType("NULL_CHANNEL" /* NULL_CHANNEL */)) {
    return createHuginnError(c3, createErrorFactory(Errors.unknownChannel(error.cause)), 404 /* NOT_FOUND */);
  }
  if (error.isErrorType("NULL_MESSAGE" /* NULL_MESSAGE */)) {
    return createHuginnError(c3, createErrorFactory(Errors.unknownMessage(error.cause)), 404 /* NOT_FOUND */);
  }
  return;
}
function handleServerError(error, c3) {
  const id = c3.get("id");
  const time = performance.now() - c3.get("startTime");
  logServerError(c3.req.path, error);
  logReject(c3.req.path, c3.req.method, time.toFixed(2), id, "Server Error", 500 /* SERVER_ERROR */);
  return c3.json(createErrorFactory(Errors.serverError()).toObject(), 500 /* SERVER_ERROR */);
}
async function sharedOnAfterResponse(c3) {
  if (c3.req.method === "OPTIONS") {
    return;
  }
  const clone = c3.res.clone();
  const contentType = c3.res.headers.get("Content-Type");
  const body = contentType?.includes("application/json") ? await clone.json() : contentType?.includes("text/plain") ? await clone.text() : undefined;
  const id = c3.get("id");
  const time = performance.now() - c3.get("startTime");
  const status = c3.res.status;
  if (status >= 200 && status < 400) {
    logResponse(c3.req.path, status, time.toFixed(2), id, body);
  } else {
    logReject(c3.req.path, c3.req.method, time.toFixed(2), id, body ? body : body, status);
  }
  Promise.allSettled(c3.get("waitUntilPromises")?.map((x2) => x2()) ?? []);
}
async function sharedOnRequest(c3) {
  const id = generateRandomString(6);
  c3.set("startTime", performance.now());
  c3.set("id", id);
  const clone = c3.req.raw.clone();
  const contentType = clone.headers.get("Content-Type");
  const body = contentType?.includes("application/json") ? await clone.json() : contentType?.includes("multipart/form-data") ? await clone.formData() : contentType?.includes("text/plain") ? await clone.text() : undefined;
  logRequest(c3.req.path, c3.req.method, id, body);
}
// ../huginn-backend-shared/node_modules/pathe/dist/shared/pathe.UZ-hd4nF.mjs
var _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input = "") {
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r3) => r3.toUpperCase());
}
var _UNC_REGEX = /^[/\\]{2}/;
var _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
var _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
var normalize = function(path) {
  if (path.length === 0) {
    return ".";
  }
  path = normalizeWindowsPath(path);
  const isUNCPath = path.match(_UNC_REGEX);
  const isPathAbsolute = isAbsolute(path);
  const trailingSeparator = path[path.length - 1] === "/";
  path = normalizeString(path, !isPathAbsolute);
  if (path.length === 0) {
    if (isPathAbsolute) {
      return "/";
    }
    return trailingSeparator ? "./" : ".";
  }
  if (trailingSeparator) {
    path += "/";
  }
  if (_DRIVE_LETTER_RE.test(path)) {
    path += "/";
  }
  if (isUNCPath) {
    if (!isPathAbsolute) {
      return `//./${path}`;
    }
    return `//${path}`;
  }
  return isPathAbsolute && !isAbsolute(path) ? `/${path}` : path;
};
var join2 = function(...segments) {
  let path = "";
  for (const seg of segments) {
    if (!seg) {
      continue;
    }
    if (path.length > 0) {
      const pathTrailing = path[path.length - 1] === "/";
      const segLeading = seg[0] === "/";
      const both = pathTrailing && segLeading;
      if (both) {
        path += seg.slice(1);
      } else {
        path += pathTrailing || segLeading ? seg : `/${seg}`;
      }
    } else {
      path += seg;
    }
  }
  return normalize(path);
};
function normalizeString(path, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = null;
  for (let index = 0;index <= path.length; ++index) {
    if (index < path.length) {
      char = path[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1)
        ;
      else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path.slice(lastSlash + 1, index)}`;
        } else {
          res = path.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var isAbsolute = function(p3) {
  return _IS_ABSOLUTE_RE.test(p3);
};
// ../huginn-backend-shared/src/route-importer.ts
import fs from "fs/promises";
async function importRoutes(log) {
  const routes2 = (await fs.readdir(join2(process.cwd(), "src/routes"), { recursive: true })).filter((file) => file.endsWith(".ts"));
  for (const route of routes2) {
    const fixedRoute = `./src/routes/${route.replace(".ts", "")}`;
    const importPath = normalize(join2(process.cwd(), fixedRoute));
    await import(importPath);
  }
}
// ../../node_modules/hono/dist/helper/factory/index.js
var createMiddleware = (middleware) => middleware;
// ../../node_modules/iron-webcrypto/dist/index.js
var exports_dist = {};
__export(exports_dist, {
  unseal: () => unseal,
  stringToBuffer: () => stringToBuffer,
  seal: () => seal,
  randomBits: () => randomBits,
  macPrefix: () => macPrefix,
  macFormatVersion: () => macFormatVersion,
  hmacWithPassword: () => hmacWithPassword,
  generateKey: () => generateKey,
  encrypt: () => encrypt,
  defaults: () => defaults,
  decrypt: () => decrypt,
  clone: () => clone,
  bufferToString: () => bufferToString,
  base64urlEncode: () => base64urlEncode,
  base64urlDecode: () => base64urlDecode,
  algorithms: () => algorithms
});
var alphabetByEncoding = {};
var alphabetByValue = new Array(64);
for (let i2 = 0, start = 65, limit = 90;i2 + start <= limit; i2++) {
  const char = String.fromCharCode(i2 + start);
  alphabetByEncoding[char] = i2;
  alphabetByValue[i2] = char;
}
for (let i2 = 0, start = 97, limit = 122;i2 + start <= limit; i2++) {
  const char = String.fromCharCode(i2 + start);
  const index = i2 + 26;
  alphabetByEncoding[char] = index;
  alphabetByValue[index] = char;
}
for (let i2 = 0;i2 < 10; i2++) {
  alphabetByEncoding[i2.toString(10)] = i2 + 52;
  const char = i2.toString(10);
  const index = i2 + 52;
  alphabetByEncoding[char] = index;
  alphabetByValue[index] = char;
}
alphabetByEncoding["+"] = 62;
alphabetByValue[62] = "+";
alphabetByEncoding["/"] = 63;
alphabetByValue[63] = "/";
var bitsPerLetter = 6;
var bitsPerByte = 8;
var maxLetterValue = 63;
var fromBase642 = (input) => {
  let totalByteLength = input.length / 4 * 3;
  if (input.slice(-2) === "==") {
    totalByteLength -= 2;
  } else if (input.slice(-1) === "=") {
    totalByteLength--;
  }
  const out = new ArrayBuffer(totalByteLength);
  const dataView = new DataView(out);
  for (let i2 = 0;i2 < input.length; i2 += 4) {
    let bits = 0;
    let bitLength = 0;
    for (let j2 = i2, limit = i2 + 3;j2 <= limit; j2++) {
      if (input[j2] !== "=") {
        if (!(input[j2] in alphabetByEncoding)) {
          throw new TypeError(`Invalid character ${input[j2]} in base64 string.`);
        }
        bits |= alphabetByEncoding[input[j2]] << (limit - j2) * bitsPerLetter;
        bitLength += bitsPerLetter;
      } else {
        bits >>= bitsPerLetter;
      }
    }
    const chunkOffset = i2 / 4 * 3;
    bits >>= bitLength % bitsPerByte;
    const byteLength = Math.floor(bitLength / bitsPerByte);
    for (let k2 = 0;k2 < byteLength; k2++) {
      const offset = (byteLength - k2 - 1) * bitsPerByte;
      dataView.setUint8(chunkOffset + k2, (bits & 255 << offset) >> offset);
    }
  }
  return new Uint8Array(out);
};
function toBase642(input) {
  let str = "";
  for (let i2 = 0;i2 < input.length; i2 += 3) {
    let bits = 0;
    let bitLength = 0;
    for (let j2 = i2, limit = Math.min(i2 + 3, input.length);j2 < limit; j2++) {
      bits |= input[j2] << (limit - j2 - 1) * bitsPerByte;
      bitLength += bitsPerByte;
    }
    const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);
    bits <<= bitClusterCount * bitsPerLetter - bitLength;
    for (let k2 = 1;k2 <= bitClusterCount; k2++) {
      const offset = (bitClusterCount - k2) * bitsPerLetter;
      str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];
    }
    str += "==".slice(0, 4 - bitClusterCount);
  }
  return str;
}
var stringToBuffer = (value) => {
  return new TextEncoder().encode(value);
};
var bufferToString = (value) => {
  return new TextDecoder().decode(value);
};
var base64urlEncode = (value) => toBase642(typeof value === "string" ? stringToBuffer(value) : value).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
var base64urlDecode = (value) => fromBase642(value.replace(/-/g, "+").replace(/_/g, "/") + Array((4 - value.length % 4) % 4 + 1).join("="));
var defaults = {
  encryption: { saltBits: 256, algorithm: "aes-256-cbc", iterations: 1, minPasswordlength: 32 },
  integrity: { saltBits: 256, algorithm: "sha256", iterations: 1, minPasswordlength: 32 },
  ttl: 0,
  timestampSkewSec: 60,
  localtimeOffsetMsec: 0
};
var clone = (options) => ({
  ...options,
  encryption: { ...options.encryption },
  integrity: { ...options.integrity }
});
var algorithms = {
  "aes-128-ctr": { keyBits: 128, ivBits: 128, name: "AES-CTR" },
  "aes-256-cbc": { keyBits: 256, ivBits: 128, name: "AES-CBC" },
  sha256: { keyBits: 256, name: "SHA-256" }
};
var macFormatVersion = "2";
var macPrefix = `Fe26.${macFormatVersion}`;
var randomBytes = (_crypto, size) => {
  const bytes = new Uint8Array(size);
  _crypto.getRandomValues(bytes);
  return bytes;
};
var randomBits = (_crypto, bits) => {
  if (bits < 1)
    throw Error("Invalid random bits count");
  const bytes = Math.ceil(bits / 8);
  return randomBytes(_crypto, bytes);
};
var pbkdf2 = async (_crypto, password, salt, iterations, keyLength, hash) => {
  const passwordBuffer = stringToBuffer(password);
  const importedKey = await _crypto.subtle.importKey("raw", passwordBuffer, "PBKDF2", false, [
    "deriveBits"
  ]);
  const saltBuffer = stringToBuffer(salt);
  const params = { name: "PBKDF2", hash, salt: saltBuffer, iterations };
  const derivation = await _crypto.subtle.deriveBits(params, importedKey, keyLength * 8);
  return derivation;
};
var generateKey = async (_crypto, password, options) => {
  if (!password?.length)
    throw new Error("Empty password");
  if (options == null || typeof options !== "object")
    throw new Error("Bad options");
  if (!(options.algorithm in algorithms))
    throw new Error(`Unknown algorithm: ${options.algorithm}`);
  const algorithm = algorithms[options.algorithm];
  const result = {};
  const hmac = options.hmac ?? false;
  const id = hmac ? { name: "HMAC", hash: algorithm.name } : { name: algorithm.name };
  const usage = hmac ? ["sign", "verify"] : ["encrypt", "decrypt"];
  if (typeof password === "string") {
    if (password.length < options.minPasswordlength)
      throw new Error(`Password string too short (min ${options.minPasswordlength} characters required)`);
    let { salt = "" } = options;
    if (!salt) {
      const { saltBits = 0 } = options;
      if (!saltBits)
        throw new Error("Missing salt and saltBits options");
      const randomSalt = randomBits(_crypto, saltBits);
      salt = [...new Uint8Array(randomSalt)].map((x2) => x2.toString(16).padStart(2, "0")).join("");
    }
    const derivedKey = await pbkdf2(_crypto, password, salt, options.iterations, algorithm.keyBits / 8, "SHA-1");
    const importedEncryptionKey = await _crypto.subtle.importKey("raw", derivedKey, id, false, usage);
    result.key = importedEncryptionKey;
    result.salt = salt;
  } else {
    if (password.length < algorithm.keyBits / 8)
      throw new Error("Key buffer (password) too small");
    result.key = await _crypto.subtle.importKey("raw", password, id, false, usage);
    result.salt = "";
  }
  if (options.iv)
    result.iv = options.iv;
  else if ("ivBits" in algorithm)
    result.iv = randomBits(_crypto, algorithm.ivBits);
  return result;
};
var encrypt = async (_crypto, password, options, data) => {
  const key = await generateKey(_crypto, password, options);
  const textBuffer = stringToBuffer(data);
  const encrypted = await _crypto.subtle.encrypt({ name: algorithms[options.algorithm].name, iv: key.iv }, key.key, textBuffer);
  return { encrypted: new Uint8Array(encrypted), key };
};
var decrypt = async (_crypto, password, options, data) => {
  const key = await generateKey(_crypto, password, options);
  const decrypted = await _crypto.subtle.decrypt({ name: algorithms[options.algorithm].name, iv: key.iv }, key.key, typeof data === "string" ? stringToBuffer(data) : data);
  return bufferToString(new Uint8Array(decrypted));
};
var hmacWithPassword = async (_crypto, password, options, data) => {
  const key = await generateKey(_crypto, password, { ...options, hmac: true });
  const textBuffer = stringToBuffer(data);
  const signed = await _crypto.subtle.sign({ name: "HMAC" }, key.key, textBuffer);
  const digest = base64urlEncode(new Uint8Array(signed));
  return { digest, salt: key.salt };
};
var normalizePassword = (password) => {
  if (typeof password === "string" || password instanceof Uint8Array)
    return { encryption: password, integrity: password };
  if ("secret" in password)
    return { id: password.id, encryption: password.secret, integrity: password.secret };
  return { id: password.id, encryption: password.encryption, integrity: password.integrity };
};
var seal = async (_crypto, object, password, options) => {
  if (!password)
    throw Error("Empty password");
  const opts = clone(options);
  const now = Date.now() + (opts.localtimeOffsetMsec || 0);
  const objectString = JSON.stringify(object);
  const pass = normalizePassword(password);
  const { id = "" } = pass;
  if (id && !/^\w+$/.test(id))
    throw new Error("Invalid password id");
  const { encrypted, key } = await encrypt(_crypto, pass.encryption, opts.encryption, objectString);
  const encryptedB64 = base64urlEncode(new Uint8Array(encrypted));
  const iv = base64urlEncode(key.iv);
  const expiration = opts.ttl ? now + opts.ttl : "";
  const macBaseString = `${macPrefix}*${id}*${key.salt}*${iv}*${encryptedB64}*${expiration}`;
  const mac = await hmacWithPassword(_crypto, pass.integrity, opts.integrity, macBaseString);
  const sealed = `${macBaseString}*${mac.salt}*${mac.digest}`;
  return sealed;
};
var fixedTimeComparison = (a3, b) => {
  let mismatch = a3.length === b.length ? 0 : 1;
  if (mismatch)
    b = a3;
  for (let i2 = 0;i2 < a3.length; i2 += 1)
    mismatch |= a3.charCodeAt(i2) ^ b.charCodeAt(i2);
  return mismatch === 0;
};
var unseal = async (_crypto, sealed, password, options) => {
  if (!password)
    throw Error("Empty password");
  const opts = clone(options);
  const now = Date.now() + (opts.localtimeOffsetMsec || 0);
  const parts = sealed.split("*");
  if (parts.length !== 8)
    throw new Error("Incorrect number of sealed components");
  const prefix = parts[0];
  let passwordId = parts[1];
  const encryptionSalt = parts[2];
  const encryptionIv = parts[3];
  const encryptedB64 = parts[4];
  const expiration = parts[5];
  const hmacSalt = parts[6];
  const hmac = parts[7];
  const macBaseString = `${prefix}*${passwordId}*${encryptionSalt}*${encryptionIv}*${encryptedB64}*${expiration}`;
  if (macPrefix !== prefix)
    throw new Error("Wrong mac prefix");
  if (expiration) {
    if (!/^\d+$/.exec(expiration))
      throw new Error("Invalid expiration");
    const exp = parseInt(expiration, 10);
    if (exp <= now - opts.timestampSkewSec * 1000)
      throw new Error("Expired seal");
  }
  if (typeof password === "undefined" || typeof password === "string" && password.length === 0)
    throw new Error("Empty password");
  let pass = "";
  passwordId = passwordId || "default";
  if (typeof password === "string" || password instanceof Uint8Array)
    pass = password;
  else if (!(passwordId in password))
    throw new Error(`Cannot find password: ${passwordId}`);
  else
    pass = password[passwordId];
  pass = normalizePassword(pass);
  const macOptions = opts.integrity;
  macOptions.salt = hmacSalt;
  const mac = await hmacWithPassword(_crypto, pass.integrity, macOptions, macBaseString);
  if (!fixedTimeComparison(mac.digest, hmac))
    throw new Error("Bad hmac value");
  const encrypted = base64urlDecode(encryptedB64);
  const decryptOptions = opts.encryption;
  decryptOptions.salt = encryptionSalt;
  decryptOptions.iv = base64urlDecode(encryptionIv);
  const decrypted = await decrypt(_crypto, pass.encryption, decryptOptions, encrypted);
  if (decrypted)
    return JSON.parse(decrypted);
  return null;
};
// ../../node_modules/hono-sessions/esm/src/store/CookieStore.js
class CookieStore {
  constructor(options) {
    Object.defineProperty(this, "encryptionKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "cookieOptions", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "sessionCookieName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.encryptionKey = options?.encryptionKey;
    this.cookieOptions = options?.cookieOptions;
    this.sessionCookieName = options?.sessionCookieName || "session";
  }
  async getSession(c3) {
    let session_data_raw;
    const sessionCookie = getCookie(c3, this.sessionCookieName);
    if (this.encryptionKey && sessionCookie) {
      try {
        session_data_raw = await decrypt2(this.encryptionKey, sessionCookie);
      } catch {
        return null;
      }
      try {
        const session_data = JSON.parse(session_data_raw);
        return session_data;
      } catch {
        return null;
      }
    } else {
      return null;
    }
  }
  async createSession(c3, initial_data) {
    const stringified_data = JSON.stringify(initial_data);
    setCookie(c3, this.sessionCookieName, this.encryptionKey ? await encrypt2(this.encryptionKey, stringified_data) : stringified_data, this.cookieOptions);
  }
  async deleteSession(c3) {
    setCookie(c3, this.sessionCookieName, this.encryptionKey ? await encrypt2(this.encryptionKey, "") : "", this.cookieOptions);
  }
  async persistSessionData(c3, session_data) {
    const stringified_data = JSON.stringify(session_data);
    setCookie(c3, this.sessionCookieName, this.encryptionKey ? await encrypt2(this.encryptionKey, stringified_data) : stringified_data, this.cookieOptions);
  }
}
var CookieStore_default = CookieStore;

// ../../node_modules/hono-sessions/esm/src/Crypto.js
async function encrypt2(password, payload) {
  return await exports_dist.seal(globalThis.crypto, payload, password, exports_dist.defaults);
}
async function decrypt2(password, encrypted) {
  return await exports_dist.unseal(globalThis.crypto, encrypted, { default: password }, exports_dist.defaults);
}

// ../../node_modules/hono-sessions/esm/src/Middleware.js
function sessionMiddleware(options) {
  const store = options.store;
  const encryptionKey = options.encryptionKey;
  const expireAfterSeconds = options.expireAfterSeconds;
  const cookieOptions = options.cookieOptions;
  const sessionCookieName = options.sessionCookieName || "session";
  if (store instanceof CookieStore_default) {
    store.sessionCookieName = sessionCookieName;
    if (encryptionKey) {
      store.encryptionKey = encryptionKey;
    } else {
      throw new Error("encryptionKey is required while using CookieStore. encryptionKey must be at least 32 characters long.");
    }
    if (cookieOptions) {
      store.cookieOptions = cookieOptions;
    }
  }
  const middleware = createMiddleware(async (c3, next) => {
    const session = new Session;
    let sid = "";
    let session_data;
    let createNewSession = false;
    const sessionCookie = getCookie(c3, sessionCookieName);
    if (sessionCookie) {
      if (store instanceof CookieStore_default) {
        session_data = await store.getSession(c3);
      } else {
        try {
          sid = encryptionKey ? await decrypt2(encryptionKey, sessionCookie) : sessionCookie;
          session_data = await store.getSessionById(sid);
        } catch {
          createNewSession = true;
        }
      }
      if (session_data) {
        session.setCache(session_data);
        if (session.sessionValid()) {
          session.reupSession(expireAfterSeconds);
        } else {
          store instanceof CookieStore_default ? await store.deleteSession(c3) : await store.deleteSession(sid);
          createNewSession = true;
        }
      } else {
        createNewSession = true;
      }
    } else {
      createNewSession = true;
    }
    if (createNewSession) {
      const defaultData = {
        _data: {},
        _expire: null,
        _delete: false,
        _accessed: null
      };
      if (store instanceof CookieStore_default) {
        await store.createSession(c3, defaultData);
      } else {
        sid = globalThis.crypto.randomUUID();
        await store.createSession(sid, defaultData);
      }
      session.setCache(defaultData);
    }
    if (!(store instanceof CookieStore_default)) {
      setCookie(c3, sessionCookieName, encryptionKey ? await encrypt2(encryptionKey, sid) : sid, cookieOptions);
    }
    session.updateAccess();
    c3.set("session", session);
    await next();
    const shouldDelete = session.getCache()._delete;
    const shouldRotateSessionKey = c3.get("session_key_rotation") === true;
    const storeIsCookieStore = store instanceof CookieStore_default;
    if (shouldDelete) {
      store instanceof CookieStore_default ? await store.deleteSession(c3) : await store.deleteSession(sid);
    }
    const shouldRecreateSessionForNonCookieStore = !shouldDelete && !storeIsCookieStore && shouldRotateSessionKey;
    if (shouldRecreateSessionForNonCookieStore) {
      await store.deleteSession(sid);
      sid = globalThis.crypto.randomUUID();
      await store.createSession(sid, session.getCache());
      setCookie(c3, sessionCookieName, encryptionKey ? await encrypt2(encryptionKey, sid) : sid, cookieOptions);
    }
    const shouldPersistSession = !shouldDelete && (!shouldRotateSessionKey || storeIsCookieStore);
    if (shouldPersistSession) {
      store instanceof CookieStore_default ? await store.persistSessionData(c3, session.getCache()) : await store.persistSessionData(sid, session.getCache());
    }
  });
  return middleware;
}

// ../../node_modules/hono-sessions/esm/src/Session.js
class Session {
  constructor() {
    Object.defineProperty(this, "cache", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.cache = {
      _data: {},
      _expire: null,
      _delete: false,
      _accessed: null
    };
  }
  setCache(cache_data) {
    this.cache = cache_data;
  }
  getCache() {
    return this.cache;
  }
  setExpiration(expiration) {
    this.cache._expire = expiration;
  }
  reupSession(expiration) {
    if (expiration) {
      this.setExpiration(new Date(Date.now() + expiration * 1000).toISOString());
    }
  }
  deleteSession() {
    this.cache._delete = true;
  }
  sessionValid() {
    return this.cache._expire == null || Date.now() < new Date(this.cache._expire).getTime();
  }
  updateAccess() {
    this.cache._accessed = new Date().toISOString();
  }
  get(key) {
    const entry = this.cache._data[key];
    if (entry) {
      const value = entry.value;
      if (entry.flash) {
        delete this.cache._data[key];
      }
      return value;
    } else {
      return null;
    }
  }
  set(key, value) {
    const entry = {
      value,
      flash: false
    };
    this.cache._data[key] = entry;
  }
  forget(key) {
    const entry = this.cache._data[key];
    if (!entry)
      return;
    delete this.cache._data[key];
  }
  flash(key, value) {
    const entry = {
      value,
      flash: true
    };
    this.cache._data[key] = entry;
  }
}

// ../../node_modules/hono/dist/adapter/bun/serve-static.js
import { stat } from "fs/promises";

// ../../node_modules/hono/dist/utils/compress.js
var COMPRESSIBLE_CONTENT_TYPE_REGEX = /^\s*(?:text\/(?!event-stream(?:[;\s]|$))[^;\s]+|application\/(?:javascript|json|xml|xml-dtd|ecmascript|dart|postscript|rtf|tar|toml|vnd\.dart|vnd\.ms-fontobject|vnd\.ms-opentype|wasm|x-httpd-php|x-javascript|x-ns-proxy-autoconfig|x-sh|x-tar|x-virtualbox-hdd|x-virtualbox-ova|x-virtualbox-ovf|x-virtualbox-vbox|x-virtualbox-vdi|x-virtualbox-vhd|x-virtualbox-vmdk|x-www-form-urlencoded)|font\/(?:otf|ttf)|image\/(?:bmp|vnd\.adobe\.photoshop|vnd\.microsoft\.icon|vnd\.ms-dds|x-icon|x-ms-bmp)|message\/rfc822|model\/gltf-binary|x-shader\/x-fragment|x-shader\/x-vertex|[^;\s]+?\+(?:json|text|xml|yaml))(?:[;\s]|$)/i;

// ../../node_modules/hono/dist/utils/filepath.js
var getFilePath = (options) => {
  let filename = options.filename;
  const defaultDocument = options.defaultDocument || "index.html";
  if (filename.endsWith("/")) {
    filename = filename.concat(defaultDocument);
  } else if (!filename.match(/\.[a-zA-Z0-9_-]+$/)) {
    filename = filename.concat("/" + defaultDocument);
  }
  const path = getFilePathWithoutDefaultDocument({
    root: options.root,
    filename
  });
  return path;
};
var getFilePathWithoutDefaultDocument = (options) => {
  let root = options.root || "";
  let filename = options.filename;
  if (/(?:^|[\/\\])\.\.(?:$|[\/\\])/.test(filename)) {
    return;
  }
  filename = filename.replace(/^\.?[\/\\]/, "");
  filename = filename.replace(/\\/, "/");
  root = root.replace(/\/$/, "");
  let path = root ? root + "/" + filename : filename;
  path = path.replace(/^\.?\//, "");
  if (root[0] !== "/" && path[0] === "/") {
    return;
  }
  return path;
};

// ../../node_modules/hono/dist/utils/mime.js
var getMimeType = (filename, mimes = baseMimes) => {
  const regexp = /\.([a-zA-Z0-9]+?)$/;
  const match = filename.match(regexp);
  if (!match) {
    return;
  }
  let mimeType = mimes[match[1]];
  if (mimeType && mimeType.startsWith("text")) {
    mimeType += "; charset=utf-8";
  }
  return mimeType;
};
var _baseMimes = {
  aac: "audio/aac",
  avi: "video/x-msvideo",
  avif: "image/avif",
  av1: "video/av1",
  bin: "application/octet-stream",
  bmp: "image/bmp",
  css: "text/css",
  csv: "text/csv",
  eot: "application/vnd.ms-fontobject",
  epub: "application/epub+zip",
  gif: "image/gif",
  gz: "application/gzip",
  htm: "text/html",
  html: "text/html",
  ico: "image/x-icon",
  ics: "text/calendar",
  jpeg: "image/jpeg",
  jpg: "image/jpeg",
  js: "text/javascript",
  json: "application/json",
  jsonld: "application/ld+json",
  map: "application/json",
  mid: "audio/x-midi",
  midi: "audio/x-midi",
  mjs: "text/javascript",
  mp3: "audio/mpeg",
  mp4: "video/mp4",
  mpeg: "video/mpeg",
  oga: "audio/ogg",
  ogv: "video/ogg",
  ogx: "application/ogg",
  opus: "audio/opus",
  otf: "font/otf",
  pdf: "application/pdf",
  png: "image/png",
  rtf: "application/rtf",
  svg: "image/svg+xml",
  tif: "image/tiff",
  tiff: "image/tiff",
  ts: "video/mp2t",
  ttf: "font/ttf",
  txt: "text/plain",
  wasm: "application/wasm",
  webm: "video/webm",
  weba: "audio/webm",
  webp: "image/webp",
  woff: "font/woff",
  woff2: "font/woff2",
  xhtml: "application/xhtml+xml",
  xml: "application/xml",
  zip: "application/zip",
  "3gp": "video/3gpp",
  "3g2": "video/3gpp2",
  gltf: "model/gltf+json",
  glb: "model/gltf-binary"
};
var baseMimes = _baseMimes;

// ../../node_modules/hono/dist/middleware/serve-static/index.js
var ENCODINGS = {
  br: ".br",
  zstd: ".zst",
  gzip: ".gz"
};
var ENCODINGS_ORDERED_KEYS = Object.keys(ENCODINGS);
var DEFAULT_DOCUMENT = "index.html";
var defaultPathResolve = (path) => path;
var serveStatic = (options) => {
  let isAbsoluteRoot = false;
  let root;
  if (options.root) {
    if (options.root.startsWith("/")) {
      isAbsoluteRoot = true;
      root = new URL(`file://${options.root}`).pathname;
    } else {
      root = options.root;
    }
  }
  return async (c3, next) => {
    if (c3.finalized) {
      await next();
      return;
    }
    let filename = options.path ?? decodeURI(c3.req.path);
    filename = options.rewriteRequestPath ? options.rewriteRequestPath(filename) : filename;
    if (!filename.endsWith("/") && options.isDir) {
      const path2 = getFilePathWithoutDefaultDocument({
        filename,
        root
      });
      if (path2 && await options.isDir(path2)) {
        filename += "/";
      }
    }
    let path = getFilePath({
      filename,
      root,
      defaultDocument: DEFAULT_DOCUMENT
    });
    if (!path) {
      return await next();
    }
    if (isAbsoluteRoot) {
      path = "/" + path;
    }
    const getContent = options.getContent;
    const pathResolve = options.pathResolve ?? defaultPathResolve;
    path = pathResolve(path);
    let content = await getContent(path, c3);
    if (!content) {
      let pathWithoutDefaultDocument = getFilePathWithoutDefaultDocument({
        filename,
        root
      });
      if (!pathWithoutDefaultDocument) {
        return await next();
      }
      pathWithoutDefaultDocument = pathResolve(pathWithoutDefaultDocument);
      if (pathWithoutDefaultDocument !== path) {
        content = await getContent(pathWithoutDefaultDocument, c3);
        if (content) {
          path = pathWithoutDefaultDocument;
        }
      }
    }
    if (content instanceof Response) {
      return c3.newResponse(content.body, content);
    }
    if (content) {
      const mimeType = options.mimes && getMimeType(path, options.mimes) || getMimeType(path);
      c3.header("Content-Type", mimeType || "application/octet-stream");
      if (options.precompressed && (!mimeType || COMPRESSIBLE_CONTENT_TYPE_REGEX.test(mimeType))) {
        const acceptEncodingSet = new Set(c3.req.header("Accept-Encoding")?.split(",").map((encoding) => encoding.trim()));
        for (const encoding of ENCODINGS_ORDERED_KEYS) {
          if (!acceptEncodingSet.has(encoding)) {
            continue;
          }
          const compressedContent = await getContent(path + ENCODINGS[encoding], c3);
          if (compressedContent) {
            content = compressedContent;
            c3.header("Content-Encoding", encoding);
            c3.header("Vary", "Accept-Encoding", { append: true });
            break;
          }
        }
      }
      await options.onFound?.(path, c3);
      return c3.body(content);
    }
    await options.onNotFound?.(path, c3);
    await next();
    return;
  };
};

// ../../node_modules/hono/dist/adapter/bun/serve-static.js
var serveStatic2 = (options) => {
  return async function serveStatic2(c3, next) {
    const getContent = async (path) => {
      path = path.startsWith("/") ? path : `./${path}`;
      const file = Bun.file(path);
      return await file.exists() ? file : null;
    };
    const pathResolve = (path) => {
      return path.startsWith("/") ? path : `./${path}`;
    };
    const isDir = async (path) => {
      let isDir2;
      try {
        const stats = await stat(path);
        isDir2 = stats.isDirectory();
      } catch {
      }
      return isDir2;
    };
    return serveStatic({
      ...options,
      getContent,
      pathResolve,
      isDir
    })(c3, next);
  };
};

// ../../node_modules/hono/dist/helper/ssg/middleware.js
var X_HONO_DISABLE_SSG_HEADER_KEY = "x-hono-disable-ssg";
var SSG_DISABLED_RESPONSE = (() => {
  try {
    return new Response("SSG is disabled", {
      status: 404,
      headers: { [X_HONO_DISABLE_SSG_HEADER_KEY]: "true" }
    });
  } catch {
    return null;
  }
})();

// ../../node_modules/hono/dist/utils/handler.js
var isMiddleware = (handler) => handler.length > 1;
var findTargetHandler = (handler) => {
  return handler[COMPOSED_HANDLER] ? findTargetHandler(handler[COMPOSED_HANDLER]) : handler;
};
// ../../node_modules/hono/dist/adapter/bun/ssg.js
var { write } = Bun;

// ../../node_modules/hono/dist/helper/websocket/index.js
var WSContext = class {
  #init;
  constructor(init2) {
    this.#init = init2;
    this.raw = init2.raw;
    this.url = init2.url ? new URL(init2.url) : null;
    this.protocol = init2.protocol ?? null;
  }
  send(source, options) {
    this.#init.send(source, options ?? {});
  }
  raw;
  binaryType = "arraybuffer";
  get readyState() {
    return this.#init.readyState;
  }
  url;
  protocol;
  close(code, reason) {
    this.#init.close(code, reason);
  }
};

// ../../node_modules/hono/dist/utils/color.js
function getColorEnabled() {
  const { process: process2, Deno } = globalThis;
  const isNoColor = typeof Deno?.noColor === "boolean" ? Deno.noColor : process2 !== undefined ? "NO_COLOR" in process2?.env : false;
  return !isNoColor;
}

// ../../node_modules/hono/dist/helper/dev/index.js
var handlerName = (handler) => {
  return handler.name || (isMiddleware(handler) ? "[middleware]" : "[handler]");
};
var inspectRoutes = (hono) => {
  return hono.routes.map(({ path, method, handler }) => {
    const targetHandler = findTargetHandler(handler);
    return {
      path,
      method,
      name: handlerName(targetHandler),
      isMiddleware: isMiddleware(targetHandler)
    };
  });
};
var showRoutes = (hono, opts) => {
  const colorEnabled = opts?.colorize ?? getColorEnabled();
  const routeData = {};
  let maxMethodLength = 0;
  let maxPathLength = 0;
  inspectRoutes(hono).filter(({ isMiddleware: isMiddleware2 }) => opts?.verbose || !isMiddleware2).map((route) => {
    const key = `${route.method}-${route.path}`;
    (routeData[key] ||= []).push(route);
    if (routeData[key].length > 1) {
      return;
    }
    maxMethodLength = Math.max(maxMethodLength, route.method.length);
    maxPathLength = Math.max(maxPathLength, route.path.length);
    return { method: route.method, path: route.path, routes: routeData[key] };
  }).forEach((data) => {
    if (!data) {
      return;
    }
    const { method, path, routes: routes2 } = data;
    const methodStr = colorEnabled ? `\x1B[32m${method}\x1B[0m` : method;
    console.log(`${methodStr} ${" ".repeat(maxMethodLength - method.length)} ${path}`);
    if (!opts?.verbose) {
      return;
    }
    routes2.forEach(({ name }) => {
      console.log(`${" ".repeat(maxMethodLength + 3)} ${name}`);
    });
  });
};

// ../../node_modules/uncrypto/dist/crypto.web.mjs
var webCrypto = globalThis.crypto;
var subtle = webCrypto.subtle;
var randomUUID = () => {
  return webCrypto.randomUUID();
};

// ../../node_modules/crossws/dist/shared/crossws.DLRVRjZs.mjs
function toBufferLike(val2) {
  if (val2 === undefined || val2 === null) {
    return "";
  }
  const type = typeof val2;
  if (type === "string") {
    return val2;
  }
  if (type === "number" || type === "boolean" || type === "bigint") {
    return val2.toString();
  }
  if (type === "function" || type === "symbol") {
    return "{}";
  }
  if (val2 instanceof Uint8Array || val2 instanceof ArrayBuffer) {
    return val2;
  }
  if (isPlainObject2(val2)) {
    return JSON.stringify(val2);
  }
  return val2;
}
function isPlainObject2(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}

class Message {
  event;
  peer;
  rawData;
  #id;
  #uint8Array;
  #arrayBuffer;
  #blob;
  #text;
  #json;
  constructor(rawData, peer, event) {
    this.rawData = rawData || "";
    this.peer = peer;
    this.event = event;
  }
  get id() {
    if (!this.#id) {
      this.#id = randomUUID();
    }
    return this.#id;
  }
  uint8Array() {
    const _uint8Array = this.#uint8Array;
    if (_uint8Array) {
      return _uint8Array;
    }
    const rawData = this.rawData;
    if (rawData instanceof Uint8Array) {
      return this.#uint8Array = rawData;
    }
    if (rawData instanceof ArrayBuffer || rawData instanceof SharedArrayBuffer) {
      this.#arrayBuffer = rawData;
      return this.#uint8Array = new Uint8Array(rawData);
    }
    if (typeof rawData === "string") {
      this.#text = rawData;
      return this.#uint8Array = new TextEncoder().encode(this.#text);
    }
    if (Symbol.iterator in rawData) {
      return this.#uint8Array = new Uint8Array(rawData);
    }
    if (typeof rawData?.length === "number") {
      return this.#uint8Array = new Uint8Array(rawData);
    }
    if (rawData instanceof DataView) {
      return this.#uint8Array = new Uint8Array(rawData.buffer, rawData.byteOffset, rawData.byteLength);
    }
    throw new TypeError(`Unsupported message type: ${Object.prototype.toString.call(rawData)}`);
  }
  arrayBuffer() {
    const _arrayBuffer = this.#arrayBuffer;
    if (_arrayBuffer) {
      return _arrayBuffer;
    }
    const rawData = this.rawData;
    if (rawData instanceof ArrayBuffer || rawData instanceof SharedArrayBuffer) {
      return this.#arrayBuffer = rawData;
    }
    return this.#arrayBuffer = this.uint8Array().buffer;
  }
  blob() {
    const _blob = this.#blob;
    if (_blob) {
      return _blob;
    }
    const rawData = this.rawData;
    if (rawData instanceof Blob) {
      return this.#blob = rawData;
    }
    return this.#blob = new Blob([this.uint8Array()]);
  }
  text() {
    const _text = this.#text;
    if (_text) {
      return _text;
    }
    const rawData = this.rawData;
    if (typeof rawData === "string") {
      return this.#text = rawData;
    }
    return this.#text = new TextDecoder().decode(this.uint8Array());
  }
  json() {
    const _json = this.#json;
    if (_json) {
      return _json;
    }
    return this.#json = JSON.parse(this.text());
  }
  get data() {
    switch (this.peer?.websocket?.binaryType) {
      case "arraybuffer": {
        return this.arrayBuffer();
      }
      case "blob": {
        return this.blob();
      }
      case "nodebuffer": {
        return globalThis.Buffer ? Buffer.from(this.uint8Array()) : this.uint8Array();
      }
      case "uint8array": {
        return this.uint8Array();
      }
      case "text": {
        return this.text();
      }
      default: {
        return this.rawData;
      }
    }
  }
  toString() {
    return this.text();
  }
  [Symbol.toPrimitive]() {
    return this.text();
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return { data: this.rawData };
  }
}

class Peer {
  _internal;
  _topics;
  _id;
  #ws;
  constructor(internal) {
    this._topics = /* @__PURE__ */ new Set;
    this._internal = internal;
  }
  get context() {
    return this._internal.context ??= {};
  }
  get id() {
    if (!this._id) {
      this._id = randomUUID();
    }
    return this._id;
  }
  get remoteAddress() {
    return;
  }
  get request() {
    return this._internal.request;
  }
  get websocket() {
    if (!this.#ws) {
      const _ws = this._internal.ws;
      const _request = this._internal.request;
      this.#ws = _request ? createWsProxy(_ws, _request) : _ws;
    }
    return this.#ws;
  }
  get peers() {
    return this._internal.peers || /* @__PURE__ */ new Set;
  }
  terminate() {
    this.close();
  }
  subscribe(topic) {
    this._topics.add(topic);
  }
  unsubscribe(topic) {
    this._topics.delete(topic);
  }
  toString() {
    return this.id;
  }
  [Symbol.toPrimitive]() {
    return this.id;
  }
  [Symbol.toStringTag]() {
    return "WebSocket";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return Object.fromEntries([
      ["id", this.id],
      ["remoteAddress", this.remoteAddress],
      ["peers", this.peers],
      ["webSocket", this.websocket]
    ].filter((p3) => p3[1]));
  }
}
function createWsProxy(ws, request) {
  return new Proxy(ws, {
    get: (target, prop) => {
      const value = Reflect.get(target, prop);
      if (!value) {
        switch (prop) {
          case "protocol": {
            return request?.headers?.get("sec-websocket-protocol") || "";
          }
          case "extensions": {
            return request?.headers?.get("sec-websocket-extensions") || "";
          }
          case "url": {
            return request?.url?.replace(/^http/, "ws") || undefined;
          }
        }
      }
      return value;
    }
  });
}

// ../../node_modules/crossws/dist/shared/crossws.CB4awDDj.mjs
class AdapterHookable {
  options;
  constructor(options) {
    this.options = options || {};
  }
  callHook(name, arg1, arg2) {
    const globalHook = this.options.hooks?.[name];
    const globalPromise = globalHook?.(arg1, arg2);
    const resolveHooksPromise = this.options.resolve?.(arg1);
    if (!resolveHooksPromise) {
      return globalPromise;
    }
    const resolvePromise = resolveHooksPromise instanceof Promise ? resolveHooksPromise.then((hooks) => hooks?.[name]) : resolveHooksPromise?.[name];
    return Promise.all([globalPromise, resolvePromise]).then(([globalRes, hook]) => {
      const hookResPromise = hook?.(arg1, arg2);
      return hookResPromise instanceof Promise ? hookResPromise.then((hookRes) => hookRes || globalRes) : hookResPromise || globalRes;
    });
  }
  async upgrade(request) {
    const context = request.context ??= {};
    try {
      const res = await this.callHook("upgrade", request);
      if (!res) {
        return { context };
      }
      if (res.ok === false) {
        return { context, endResponse: res };
      }
      if (res.headers) {
        return {
          context,
          upgradeHeaders: res.headers
        };
      }
    } catch (error) {
      const errResponse = error.response || error;
      if (errResponse instanceof Response) {
        return {
          context,
          endResponse: errResponse
        };
      }
      throw error;
    }
    return { context };
  }
}
function adapterUtils(peers) {
  return {
    peers,
    publish(topic, message, options) {
      const firstPeer = peers.values().next().value;
      if (firstPeer) {
        firstPeer.send(message, options);
        firstPeer.publish(topic, message, options);
      }
    }
  };
}
function defineWebSocketAdapter(factory) {
  return factory;
}

// ../../node_modules/crossws/dist/adapters/bun.mjs
var bun = defineWebSocketAdapter((options = {}) => {
  const hooks = new AdapterHookable(options);
  const peers = /* @__PURE__ */ new Set;
  return {
    ...adapterUtils(peers),
    async handleUpgrade(request, server) {
      const { upgradeHeaders, endResponse, context } = await hooks.upgrade(request);
      if (endResponse) {
        return endResponse;
      }
      const upgradeOK = server.upgrade(request, {
        data: {
          server,
          request,
          context
        },
        headers: upgradeHeaders
      });
      if (!upgradeOK) {
        return new Response("Upgrade failed", { status: 500 });
      }
    },
    websocket: {
      message: (ws, message) => {
        const peer = getPeer(ws, peers);
        hooks.callHook("message", peer, new Message(message, peer));
      },
      open: (ws) => {
        const peer = getPeer(ws, peers);
        peers.add(peer);
        hooks.callHook("open", peer);
      },
      close: (ws) => {
        const peer = getPeer(ws, peers);
        peers.delete(peer);
        hooks.callHook("close", peer, {});
      }
    }
  };
});
function getPeer(ws, peers) {
  if (ws.data?.peer) {
    return ws.data.peer;
  }
  const peer = new BunPeer({ ws, request: ws.data.request, peers });
  ws.data = {
    ...ws.data,
    peer
  };
  return peer;
}

class BunPeer extends Peer {
  get remoteAddress() {
    return this._internal.ws.remoteAddress;
  }
  get context() {
    return this._internal.ws.data.context;
  }
  send(data, options) {
    return this._internal.ws.send(toBufferLike(data), options?.compress);
  }
  publish(topic, data, options) {
    return this._internal.ws.publish(topic, toBufferLike(data), options?.compress);
  }
  subscribe(topic) {
    this._internal.ws.subscribe(topic);
  }
  unsubscribe(topic) {
    this._internal.ws.unsubscribe(topic);
  }
  close(code, reason) {
    this._internal.ws.close(code, reason);
  }
  terminate() {
    this._internal.ws.terminate();
  }
}

// ../../node_modules/@aws-sdk/middleware-expect-continue/dist-es/index.js
init_dist_es();
function addExpectContinueMiddleware(options) {
  return (next) => async (args) => {
    const { request } = args;
    if (HttpRequest.isInstance(request) && request.body && options.runtime === "node") {
      if (options.requestHandler?.constructor?.name !== "FetchHttpHandler") {
        request.headers = {
          ...request.headers,
          Expect: "100-continue"
        };
      }
    }
    return next({
      ...args,
      request
    });
  };
}
var addExpectContinueMiddlewareOptions = {
  step: "build",
  tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
  name: "addExpectContinueMiddleware",
  override: true
};
var getAddExpectContinuePlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(addExpectContinueMiddleware(options), addExpectContinueMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/constants.js
var RequestChecksumCalculation = {
  WHEN_SUPPORTED: "WHEN_SUPPORTED",
  WHEN_REQUIRED: "WHEN_REQUIRED"
};
var DEFAULT_REQUEST_CHECKSUM_CALCULATION = RequestChecksumCalculation.WHEN_SUPPORTED;
var ResponseChecksumValidation = {
  WHEN_SUPPORTED: "WHEN_SUPPORTED",
  WHEN_REQUIRED: "WHEN_REQUIRED"
};
var DEFAULT_RESPONSE_CHECKSUM_VALIDATION = RequestChecksumCalculation.WHEN_SUPPORTED;
var ChecksumAlgorithm;
(function(ChecksumAlgorithm2) {
  ChecksumAlgorithm2["MD5"] = "MD5";
  ChecksumAlgorithm2["CRC32"] = "CRC32";
  ChecksumAlgorithm2["CRC32C"] = "CRC32C";
  ChecksumAlgorithm2["CRC64NVME"] = "CRC64NVME";
  ChecksumAlgorithm2["SHA1"] = "SHA1";
  ChecksumAlgorithm2["SHA256"] = "SHA256";
})(ChecksumAlgorithm || (ChecksumAlgorithm = {}));
var ChecksumLocation;
(function(ChecksumLocation2) {
  ChecksumLocation2["HEADER"] = "header";
  ChecksumLocation2["TRAILER"] = "trailer";
})(ChecksumLocation || (ChecksumLocation = {}));
var DEFAULT_CHECKSUM_ALGORITHM = ChecksumAlgorithm.CRC32;

// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/stringUnionSelector.js
var SelectorType;
(function(SelectorType2) {
  SelectorType2["ENV"] = "env";
  SelectorType2["CONFIG"] = "shared config entry";
})(SelectorType || (SelectorType = {}));
var stringUnionSelector = (obj, key, union, type) => {
  if (!(key in obj))
    return;
  const value = obj[key].toUpperCase();
  if (!Object.values(union).includes(value)) {
    throw new TypeError(`Cannot load ${type} '${key}'. Expected one of ${Object.values(union)}, got '${obj[key]}'.`);
  }
  return value;
};

// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS.js
var ENV_REQUEST_CHECKSUM_CALCULATION = "AWS_REQUEST_CHECKSUM_CALCULATION";
var CONFIG_REQUEST_CHECKSUM_CALCULATION = "request_checksum_calculation";
var NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS = {
  environmentVariableSelector: (env2) => stringUnionSelector(env2, ENV_REQUEST_CHECKSUM_CALCULATION, RequestChecksumCalculation, SelectorType.ENV),
  configFileSelector: (profile) => stringUnionSelector(profile, CONFIG_REQUEST_CHECKSUM_CALCULATION, RequestChecksumCalculation, SelectorType.CONFIG),
  default: DEFAULT_REQUEST_CHECKSUM_CALCULATION
};
// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS.js
var ENV_RESPONSE_CHECKSUM_VALIDATION = "AWS_RESPONSE_CHECKSUM_VALIDATION";
var CONFIG_RESPONSE_CHECKSUM_VALIDATION = "response_checksum_validation";
var NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS = {
  environmentVariableSelector: (env2) => stringUnionSelector(env2, ENV_RESPONSE_CHECKSUM_VALIDATION, ResponseChecksumValidation, SelectorType.ENV),
  configFileSelector: (profile) => stringUnionSelector(profile, CONFIG_RESPONSE_CHECKSUM_VALIDATION, ResponseChecksumValidation, SelectorType.CONFIG),
  default: DEFAULT_RESPONSE_CHECKSUM_VALIDATION
};
// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsMiddleware.js
init_dist_es();

// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/types.js
var CLIENT_SUPPORTED_ALGORITHMS = [
  ChecksumAlgorithm.CRC32,
  ChecksumAlgorithm.CRC32C,
  ChecksumAlgorithm.CRC64NVME,
  ChecksumAlgorithm.SHA1,
  ChecksumAlgorithm.SHA256
];
var PRIORITY_ORDER_ALGORITHMS = [
  ChecksumAlgorithm.SHA256,
  ChecksumAlgorithm.SHA1,
  ChecksumAlgorithm.CRC32,
  ChecksumAlgorithm.CRC32C,
  ChecksumAlgorithm.CRC64NVME
];
// ../../node_modules/tslib/modules/index.js
var import_tslib = __toESM(require_tslib(), 1);
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension
} = import_tslib.default;

// ../../node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/node_modules/@smithy/util-buffer-from/dist-es/index.js
import { Buffer as Buffer2 } from "buffer";
var fromString = (input, encoding) => {
  if (typeof input !== "string") {
    throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
  }
  return encoding ? Buffer2.from(input, encoding) : Buffer2.from(input);
};

// ../../node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/fromUtf8.js
var fromUtf8 = (input) => {
  const buf = fromString(input, "utf8");
  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};
// ../../node_modules/@aws-crypto/util/build/module/convertToBuffer.js
var fromUtf83 = typeof Buffer !== "undefined" && Buffer.from ? function(input) {
  return Buffer.from(input, "utf8");
} : fromUtf8;
function convertToBuffer(data) {
  if (data instanceof Uint8Array)
    return data;
  if (typeof data === "string") {
    return fromUtf83(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
}
// ../../node_modules/@aws-crypto/util/build/module/isEmptyData.js
function isEmptyData(data) {
  if (typeof data === "string") {
    return data.length === 0;
  }
  return data.byteLength === 0;
}
// ../../node_modules/@aws-crypto/util/build/module/numToUint8.js
function numToUint8(num) {
  return new Uint8Array([
    (num & 4278190080) >> 24,
    (num & 16711680) >> 16,
    (num & 65280) >> 8,
    num & 255
  ]);
}
// ../../node_modules/@aws-crypto/util/build/module/uint32ArrayFrom.js
function uint32ArrayFrom(a_lookUpTable) {
  if (!Uint32Array.from) {
    var return_array = new Uint32Array(a_lookUpTable.length);
    var a_index = 0;
    while (a_index < a_lookUpTable.length) {
      return_array[a_index] = a_lookUpTable[a_index];
      a_index += 1;
    }
    return return_array;
  }
  return Uint32Array.from(a_lookUpTable);
}
// ../../node_modules/@aws-crypto/crc32c/build/module/aws_crc32c.js
var AwsCrc32c = function() {
  function AwsCrc32c2() {
    this.crc32c = new Crc32c;
  }
  AwsCrc32c2.prototype.update = function(toHash) {
    if (isEmptyData(toHash))
      return;
    this.crc32c.update(convertToBuffer(toHash));
  };
  AwsCrc32c2.prototype.digest = function() {
    return __awaiter(this, undefined, undefined, function() {
      return __generator(this, function(_a2) {
        return [2, numToUint8(this.crc32c.digest())];
      });
    });
  };
  AwsCrc32c2.prototype.reset = function() {
    this.crc32c = new Crc32c;
  };
  return AwsCrc32c2;
}();
// ../../node_modules/@aws-crypto/crc32c/build/module/index.js
var Crc32c = function() {
  function Crc32c2() {
    this.checksum = 4294967295;
  }
  Crc32c2.prototype.update = function(data) {
    var e_1, _a2;
    try {
      for (var data_1 = __values(data), data_1_1 = data_1.next();!data_1_1.done; data_1_1 = data_1.next()) {
        var byte = data_1_1.value;
        this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (data_1_1 && !data_1_1.done && (_a2 = data_1.return))
          _a2.call(data_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return this;
  };
  Crc32c2.prototype.digest = function() {
    return (this.checksum ^ 4294967295) >>> 0;
  };
  return Crc32c2;
}();
var a_lookupTable = [
  0,
  4067132163,
  3778769143,
  324072436,
  3348797215,
  904991772,
  648144872,
  3570033899,
  2329499855,
  2024987596,
  1809983544,
  2575936315,
  1296289744,
  3207089363,
  2893594407,
  1578318884,
  274646895,
  3795141740,
  4049975192,
  51262619,
  3619967088,
  632279923,
  922689671,
  3298075524,
  2592579488,
  1760304291,
  2075979607,
  2312596564,
  1562183871,
  2943781820,
  3156637768,
  1313733451,
  549293790,
  3537243613,
  3246849577,
  871202090,
  3878099393,
  357341890,
  102525238,
  4101499445,
  2858735121,
  1477399826,
  1264559846,
  3107202533,
  1845379342,
  2677391885,
  2361733625,
  2125378298,
  820201905,
  3263744690,
  3520608582,
  598981189,
  4151959214,
  85089709,
  373468761,
  3827903834,
  3124367742,
  1213305469,
  1526817161,
  2842354314,
  2107672161,
  2412447074,
  2627466902,
  1861252501,
  1098587580,
  3004210879,
  2688576843,
  1378610760,
  2262928035,
  1955203488,
  1742404180,
  2511436119,
  3416409459,
  969524848,
  714683780,
  3639785095,
  205050476,
  4266873199,
  3976438427,
  526918040,
  1361435347,
  2739821008,
  2954799652,
  1114974503,
  2529119692,
  1691668175,
  2005155131,
  2247081528,
  3690758684,
  697762079,
  986182379,
  3366744552,
  476452099,
  3993867776,
  4250756596,
  255256311,
  1640403810,
  2477592673,
  2164122517,
  1922457750,
  2791048317,
  1412925310,
  1197962378,
  3037525897,
  3944729517,
  427051182,
  170179418,
  4165941337,
  746937522,
  3740196785,
  3451792453,
  1070968646,
  1905808397,
  2213795598,
  2426610938,
  1657317369,
  3053634322,
  1147748369,
  1463399397,
  2773627110,
  4215344322,
  153784257,
  444234805,
  3893493558,
  1021025245,
  3467647198,
  3722505002,
  797665321,
  2197175160,
  1889384571,
  1674398607,
  2443626636,
  1164749927,
  3070701412,
  2757221520,
  1446797203,
  137323447,
  4198817972,
  3910406976,
  461344835,
  3484808360,
  1037989803,
  781091935,
  3705997148,
  2460548119,
  1623424788,
  1939049696,
  2180517859,
  1429367560,
  2807687179,
  3020495871,
  1180866812,
  410100952,
  3927582683,
  4182430767,
  186734380,
  3756733383,
  763408580,
  1053836080,
  3434856499,
  2722870694,
  1344288421,
  1131464017,
  2971354706,
  1708204729,
  2545590714,
  2229949006,
  1988219213,
  680717673,
  3673779818,
  3383336350,
  1002577565,
  4010310262,
  493091189,
  238226049,
  4233660802,
  2987750089,
  1082061258,
  1395524158,
  2705686845,
  1972364758,
  2279892693,
  2494862625,
  1725896226,
  952904198,
  3399985413,
  3656866545,
  731699698,
  4283874585,
  222117402,
  510512622,
  3959836397,
  3280807620,
  837199303,
  582374963,
  3504198960,
  68661723,
  4135334616,
  3844915500,
  390545967,
  1230274059,
  3141532936,
  2825850620,
  1510247935,
  2395924756,
  2091215383,
  1878366691,
  2644384480,
  3553878443,
  565732008,
  854102364,
  3229815391,
  340358836,
  3861050807,
  4117890627,
  119113024,
  1493875044,
  2875275879,
  3090270611,
  1247431312,
  2660249211,
  1828433272,
  2141937292,
  2378227087,
  3811616794,
  291187481,
  34330861,
  4032846830,
  615137029,
  3603020806,
  3314634738,
  939183345,
  1776939221,
  2609017814,
  2295496738,
  2058945313,
  2926798794,
  1545135305,
  1330124605,
  3173225534,
  4084100981,
  17165430,
  307568514,
  3762199681,
  888469610,
  3332340585,
  3587147933,
  665062302,
  2042050490,
  2346497209,
  2559330125,
  1793573966,
  3190661285,
  1279665062,
  1595330642,
  2910671697
];
var lookupTable = uint32ArrayFrom(a_lookupTable);

// ../../node_modules/@aws-crypto/crc32/build/module/aws_crc32.js
var AwsCrc32 = function() {
  function AwsCrc322() {
    this.crc32 = new Crc32;
  }
  AwsCrc322.prototype.update = function(toHash) {
    if (isEmptyData(toHash))
      return;
    this.crc32.update(convertToBuffer(toHash));
  };
  AwsCrc322.prototype.digest = function() {
    return __awaiter(this, undefined, undefined, function() {
      return __generator(this, function(_a2) {
        return [2, numToUint8(this.crc32.digest())];
      });
    });
  };
  AwsCrc322.prototype.reset = function() {
    this.crc32 = new Crc32;
  };
  return AwsCrc322;
}();
// ../../node_modules/@aws-crypto/crc32/build/module/index.js
var Crc32 = function() {
  function Crc322() {
    this.checksum = 4294967295;
  }
  Crc322.prototype.update = function(data) {
    var e_1, _a2;
    try {
      for (var data_1 = __values(data), data_1_1 = data_1.next();!data_1_1.done; data_1_1 = data_1.next()) {
        var byte = data_1_1.value;
        this.checksum = this.checksum >>> 8 ^ lookupTable2[(this.checksum ^ byte) & 255];
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (data_1_1 && !data_1_1.done && (_a2 = data_1.return))
          _a2.call(data_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return this;
  };
  Crc322.prototype.digest = function() {
    return (this.checksum ^ 4294967295) >>> 0;
  };
  return Crc322;
}();
var a_lookUpTable = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918000,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
var lookupTable2 = uint32ArrayFrom(a_lookUpTable);

// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/stringHasher.js
init_dist_es3();
// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsResponseMiddleware.js
init_dist_es();

// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/validateChecksumFromResponse.js
init_dist_es8();
// ../../node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/resolveFlexibleChecksumsConfig.js
init_dist_es9();
var resolveFlexibleChecksumsConfig = (input) => ({
  ...input,
  requestChecksumCalculation: normalizeProvider(input.requestChecksumCalculation ?? DEFAULT_REQUEST_CHECKSUM_CALCULATION),
  responseChecksumValidation: normalizeProvider(input.responseChecksumValidation ?? DEFAULT_RESPONSE_CHECKSUM_VALIDATION)
});
// ../../node_modules/@aws-sdk/client-s3/dist-es/S3Client.js
init_dist_es10();
init_dist_es11();
init_dist_es12();

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/check-content-length-header.js
init_dist_es();
init_dist_es14();
// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-endpoint-middleware.js
var regionRedirectEndpointMiddleware = (config2) => {
  return (next, context) => async (args) => {
    const originalRegion = await config2.region();
    const regionProviderRef = config2.region;
    let unlock = () => {
    };
    if (context.__s3RegionRedirect) {
      Object.defineProperty(config2, "region", {
        writable: false,
        value: async () => {
          return context.__s3RegionRedirect;
        }
      });
      unlock = () => Object.defineProperty(config2, "region", {
        writable: true,
        value: regionProviderRef
      });
    }
    try {
      const result = await next(args);
      if (context.__s3RegionRedirect) {
        unlock();
        const region = await config2.region();
        if (originalRegion !== region) {
          throw new Error("Region was not restored following S3 region redirect.");
        }
      }
      return result;
    } catch (e2) {
      unlock();
      throw e2;
    }
  };
};
var regionRedirectEndpointMiddlewareOptions = {
  tags: ["REGION_REDIRECT", "S3"],
  name: "regionRedirectEndpointMiddleware",
  override: true,
  relation: "before",
  toMiddleware: "endpointV2Middleware"
};
// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-middleware.js
function regionRedirectMiddleware(clientConfig) {
  return (next, context) => async (args) => {
    try {
      return await next(args);
    } catch (err) {
      if (clientConfig.followRegionRedirects) {
        if (err?.$metadata?.httpStatusCode === 301 || err?.$metadata?.httpStatusCode === 400 && err?.name === "IllegalLocationConstraintException") {
          try {
            const actualRegion = err.$response.headers["x-amz-bucket-region"];
            context.logger?.debug(`Redirecting from ${await clientConfig.region()} to ${actualRegion}`);
            context.__s3RegionRedirect = actualRegion;
          } catch (e2) {
            throw new Error("Region redirect failed: " + e2);
          }
          return next(args);
        }
      }
      throw err;
    }
  };
}
var regionRedirectMiddlewareOptions = {
  step: "initialize",
  tags: ["REGION_REDIRECT", "S3"],
  name: "regionRedirectMiddleware",
  override: true
};
var getRegionRedirectMiddlewarePlugin = (clientConfig) => ({
  applyToStack: (clientStack) => {
    clientStack.add(regionRedirectMiddleware(clientConfig), regionRedirectMiddlewareOptions);
    clientStack.addRelativeTo(regionRedirectEndpointMiddleware(clientConfig), regionRedirectEndpointMiddlewareOptions);
  }
});
// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-expires-middleware.js
init_dist_es();
init_dist_es14();
// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCache.js
class S3ExpressIdentityCache {
  data;
  lastPurgeTime = Date.now();
  static EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 30000;
  constructor(data = {}) {
    this.data = data;
  }
  get(key) {
    const entry = this.data[key];
    if (!entry) {
      return;
    }
    return entry;
  }
  set(key, entry) {
    this.data[key] = entry;
    return entry;
  }
  delete(key) {
    delete this.data[key];
  }
  async purgeExpired() {
    const now = Date.now();
    if (this.lastPurgeTime + S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > now) {
      return;
    }
    for (const key in this.data) {
      const entry = this.data[key];
      if (!entry.isRefreshing) {
        const credential = await entry.identity;
        if (credential.expiration) {
          if (credential.expiration.getTime() < now) {
            delete this.data[key];
          }
        }
      }
    }
  }
}
// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCacheEntry.js
class S3ExpressIdentityCacheEntry {
  _identity;
  isRefreshing;
  accessed;
  constructor(_identity, isRefreshing = false, accessed = Date.now()) {
    this._identity = _identity;
    this.isRefreshing = isRefreshing;
    this.accessed = accessed;
  }
  get identity() {
    this.accessed = Date.now();
    return this._identity;
  }
}
// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityProviderImpl.js
class S3ExpressIdentityProviderImpl {
  createSessionFn;
  cache;
  static REFRESH_WINDOW_MS = 60000;
  constructor(createSessionFn, cache = new S3ExpressIdentityCache) {
    this.createSessionFn = createSessionFn;
    this.cache = cache;
  }
  async getS3ExpressIdentity(awsIdentity, identityProperties) {
    const key = identityProperties.Bucket;
    const { cache } = this;
    const entry = cache.get(key);
    if (entry) {
      return entry.identity.then((identity) => {
        const isExpired = (identity.expiration?.getTime() ?? 0) < Date.now();
        if (isExpired) {
          return cache.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
        }
        const isExpiringSoon = (identity.expiration?.getTime() ?? 0) < Date.now() + S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS;
        if (isExpiringSoon && !entry.isRefreshing) {
          entry.isRefreshing = true;
          this.getIdentity(key).then((id) => {
            cache.set(key, new S3ExpressIdentityCacheEntry(Promise.resolve(id)));
          });
        }
        return identity;
      });
    }
    return cache.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
  }
  async getIdentity(key) {
    await this.cache.purgeExpired().catch((error) => {
      console.warn(`Error while clearing expired entries in S3ExpressIdentityCache: 
` + error);
    });
    const session = await this.createSessionFn(key);
    if (!session.Credentials?.AccessKeyId || !session.Credentials?.SecretAccessKey) {
      throw new Error("s3#createSession response credential missing AccessKeyId or SecretAccessKey.");
    }
    const identity = {
      accessKeyId: session.Credentials.AccessKeyId,
      secretAccessKey: session.Credentials.SecretAccessKey,
      sessionToken: session.Credentials.SessionToken,
      expiration: session.Credentials.Expiration ? new Date(session.Credentials.Expiration) : undefined
    };
    return identity;
  }
}
// ../../node_modules/@smithy/signature-v4/dist-es/SignatureV4.js
var import_util_hex_encoding5 = __toESM(require_dist_cjs13(), 1);
init_dist_es9();
var import_util_uri_escape3 = __toESM(require_dist_cjs9(), 1);
init_dist_es3();

// ../../node_modules/@smithy/signature-v4/dist-es/constants.js
var ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
var CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
var AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
var SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
var EXPIRES_QUERY_PARAM = "X-Amz-Expires";
var SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
var TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
var AUTH_HEADER = "authorization";
var AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
var DATE_HEADER = "date";
var GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
var SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
var SHA256_HEADER = "x-amz-content-sha256";
var TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
var ALWAYS_UNSIGNABLE_HEADERS = {
  authorization: true,
  "cache-control": true,
  connection: true,
  expect: true,
  from: true,
  "keep-alive": true,
  "max-forwards": true,
  pragma: true,
  referer: true,
  te: true,
  trailer: true,
  "transfer-encoding": true,
  upgrade: true,
  "user-agent": true,
  "x-amzn-trace-id": true
};
var PROXY_HEADER_PATTERN = /^proxy-/;
var SEC_HEADER_PATTERN = /^sec-/;
var ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
var EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
var UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
var MAX_CACHE_SIZE = 50;
var KEY_TYPE_IDENTIFIER = "aws4_request";
var MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;

// ../../node_modules/@smithy/signature-v4/dist-es/credentialDerivation.js
var import_util_hex_encoding2 = __toESM(require_dist_cjs13(), 1);
init_dist_es3();
var signingKeyCache = {};
var cacheQueue = [];
var createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;
var getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
  const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
  const cacheKey = `${shortDate}:${region}:${service}:${import_util_hex_encoding2.toHex(credsHash)}:${credentials.sessionToken}`;
  if (cacheKey in signingKeyCache) {
    return signingKeyCache[cacheKey];
  }
  cacheQueue.push(cacheKey);
  while (cacheQueue.length > MAX_CACHE_SIZE) {
    delete signingKeyCache[cacheQueue.shift()];
  }
  let key = `AWS4${credentials.secretAccessKey}`;
  for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
    key = await hmac(sha256Constructor, key, signable);
  }
  return signingKeyCache[cacheKey] = key;
};
var hmac = (ctor, secret, data) => {
  const hash = new ctor(secret);
  hash.update(toUint8Array2(data));
  return hash.digest();
};

// ../../node_modules/@smithy/signature-v4/dist-es/getCanonicalHeaders.js
var getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
  const canonical = {};
  for (const headerName of Object.keys(headers).sort()) {
    if (headers[headerName] == undefined) {
      continue;
    }
    const canonicalHeaderName = headerName.toLowerCase();
    if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || unsignableHeaders?.has(canonicalHeaderName) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
      if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
        continue;
      }
    }
    canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
  }
  return canonical;
};

// ../../node_modules/@smithy/signature-v4/dist-es/getCanonicalQuery.js
var import_util_uri_escape2 = __toESM(require_dist_cjs9(), 1);
var getCanonicalQuery = ({ query = {} }) => {
  const keys = [];
  const serialized = {};
  for (const key of Object.keys(query)) {
    if (key.toLowerCase() === SIGNATURE_HEADER) {
      continue;
    }
    const encodedKey = import_util_uri_escape2.escapeUri(key);
    keys.push(encodedKey);
    const value = query[key];
    if (typeof value === "string") {
      serialized[encodedKey] = `${encodedKey}=${import_util_uri_escape2.escapeUri(value)}`;
    } else if (Array.isArray(value)) {
      serialized[encodedKey] = value.slice(0).reduce((encoded, value2) => encoded.concat([`${encodedKey}=${import_util_uri_escape2.escapeUri(value2)}`]), []).sort().join("&");
    }
  }
  return keys.sort().map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
};

// ../../node_modules/@smithy/signature-v4/dist-es/getPayloadHash.js
var import_util_hex_encoding3 = __toESM(require_dist_cjs13(), 1);
init_dist_es3();
var getPayloadHash = async ({ headers, body }, hashConstructor) => {
  for (const headerName of Object.keys(headers)) {
    if (headerName.toLowerCase() === SHA256_HEADER) {
      return headers[headerName];
    }
  }
  if (body == undefined) {
    return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  } else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer(body)) {
    const hashCtor = new hashConstructor;
    hashCtor.update(toUint8Array2(body));
    return import_util_hex_encoding3.toHex(await hashCtor.digest());
  }
  return UNSIGNED_PAYLOAD;
};

// ../../node_modules/@smithy/signature-v4/dist-es/HeaderFormatter.js
var import_util_hex_encoding4 = __toESM(require_dist_cjs13(), 1);
init_dist_es3();

class HeaderFormatter {
  format(headers) {
    const chunks = [];
    for (const headerName of Object.keys(headers)) {
      const bytes = fromUtf84(headerName);
      chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
    }
    const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
    let position = 0;
    for (const chunk of chunks) {
      out.set(chunk, position);
      position += chunk.byteLength;
    }
    return out;
  }
  formatHeaderValue(header) {
    switch (header.type) {
      case "boolean":
        return Uint8Array.from([header.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, header.value]);
      case "short":
        const shortView = new DataView(new ArrayBuffer(3));
        shortView.setUint8(0, 3);
        shortView.setInt16(1, header.value, false);
        return new Uint8Array(shortView.buffer);
      case "integer":
        const intView = new DataView(new ArrayBuffer(5));
        intView.setUint8(0, 4);
        intView.setInt32(1, header.value, false);
        return new Uint8Array(intView.buffer);
      case "long":
        const longBytes = new Uint8Array(9);
        longBytes[0] = 5;
        longBytes.set(header.value.bytes, 1);
        return longBytes;
      case "binary":
        const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
        binView.setUint8(0, 6);
        binView.setUint16(1, header.value.byteLength, false);
        const binBytes = new Uint8Array(binView.buffer);
        binBytes.set(header.value, 3);
        return binBytes;
      case "string":
        const utf8Bytes = fromUtf84(header.value);
        const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
        strView.setUint8(0, 7);
        strView.setUint16(1, utf8Bytes.byteLength, false);
        const strBytes = new Uint8Array(strView.buffer);
        strBytes.set(utf8Bytes, 3);
        return strBytes;
      case "timestamp":
        const tsBytes = new Uint8Array(9);
        tsBytes[0] = 8;
        tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
        return tsBytes;
      case "uuid":
        if (!UUID_PATTERN.test(header.value)) {
          throw new Error(`Invalid UUID received: ${header.value}`);
        }
        const uuidBytes = new Uint8Array(17);
        uuidBytes[0] = 9;
        uuidBytes.set(import_util_hex_encoding4.fromHex(header.value.replace(/\-/g, "")), 1);
        return uuidBytes;
    }
  }
}
var HEADER_VALUE_TYPE;
(function(HEADER_VALUE_TYPE2) {
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolTrue"] = 0] = "boolTrue";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolFalse"] = 1] = "boolFalse";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byte"] = 2] = "byte";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["short"] = 3] = "short";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["integer"] = 4] = "integer";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["long"] = 5] = "long";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byteArray"] = 6] = "byteArray";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["string"] = 7] = "string";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["timestamp"] = 8] = "timestamp";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
var UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;

class Int64 {
  constructor(bytes) {
    this.bytes = bytes;
    if (bytes.byteLength !== 8) {
      throw new Error("Int64 buffers must be exactly 8 bytes");
    }
  }
  static fromNumber(number) {
    if (number > 9223372036854776000 || number < -9223372036854776000) {
      throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
    }
    const bytes = new Uint8Array(8);
    for (let i2 = 7, remaining = Math.abs(Math.round(number));i2 > -1 && remaining > 0; i2--, remaining /= 256) {
      bytes[i2] = remaining;
    }
    if (number < 0) {
      negate(bytes);
    }
    return new Int64(bytes);
  }
  valueOf() {
    const bytes = this.bytes.slice(0);
    const negative = bytes[0] & 128;
    if (negative) {
      negate(bytes);
    }
    return parseInt(import_util_hex_encoding4.toHex(bytes), 16) * (negative ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
}
function negate(bytes) {
  for (let i2 = 0;i2 < 8; i2++) {
    bytes[i2] ^= 255;
  }
  for (let i2 = 7;i2 > -1; i2--) {
    bytes[i2]++;
    if (bytes[i2] !== 0)
      break;
  }
}

// ../../node_modules/@smithy/signature-v4/dist-es/headerUtil.js
var hasHeader2 = (soughtHeader, headers) => {
  soughtHeader = soughtHeader.toLowerCase();
  for (const headerName of Object.keys(headers)) {
    if (soughtHeader === headerName.toLowerCase()) {
      return true;
    }
  }
  return false;
};

// ../../node_modules/@smithy/signature-v4/dist-es/moveHeadersToQuery.js
init_dist_es();
var moveHeadersToQuery = (request, options = {}) => {
  const { headers, query = {} } = HttpRequest.clone(request);
  for (const name of Object.keys(headers)) {
    const lname = name.toLowerCase();
    if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname) || options.hoistableHeaders?.has(lname)) {
      query[name] = headers[name];
      delete headers[name];
    }
  }
  return {
    ...request,
    headers,
    query
  };
};

// ../../node_modules/@smithy/signature-v4/dist-es/prepareRequest.js
init_dist_es();
var prepareRequest = (request) => {
  request = HttpRequest.clone(request);
  for (const headerName of Object.keys(request.headers)) {
    if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
      delete request.headers[headerName];
    }
  }
  return request;
};

// ../../node_modules/@smithy/signature-v4/dist-es/utilDate.js
var iso8601 = (time) => toDate(time).toISOString().replace(/\.\d{3}Z$/, "Z");
var toDate = (time) => {
  if (typeof time === "number") {
    return new Date(time * 1000);
  }
  if (typeof time === "string") {
    if (Number(time)) {
      return new Date(Number(time) * 1000);
    }
    return new Date(time);
  }
  return time;
};

// ../../node_modules/@smithy/signature-v4/dist-es/SignatureV4.js
class SignatureV4 {
  constructor({ applyChecksum, credentials, region, service, sha256: sha2562, uriEscapePath = true }) {
    this.headerFormatter = new HeaderFormatter;
    this.service = service;
    this.sha256 = sha2562;
    this.uriEscapePath = uriEscapePath;
    this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
    this.regionProvider = normalizeProvider(region);
    this.credentialProvider = normalizeProvider(credentials);
  }
  async presign(originalRequest, options = {}) {
    const { signingDate = new Date, expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, hoistableHeaders, signingRegion, signingService } = options;
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion ?? await this.regionProvider();
    const { longDate, shortDate } = formatDate(signingDate);
    if (expiresIn > MAX_PRESIGNED_TTL) {
      return Promise.reject("Signature version 4 presigned URLs" + " must have an expiration date less than one week in" + " the future");
    }
    const scope = createScope(shortDate, region, signingService ?? this.service);
    const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders, hoistableHeaders });
    if (credentials.sessionToken) {
      request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
    }
    request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
    request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
    request.query[AMZ_DATE_QUERY_PARAM] = longDate;
    request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
    request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
    request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
    return request;
  }
  async sign(toSign, options) {
    if (typeof toSign === "string") {
      return this.signString(toSign, options);
    } else if (toSign.headers && toSign.payload) {
      return this.signEvent(toSign, options);
    } else if (toSign.message) {
      return this.signMessage(toSign, options);
    } else {
      return this.signRequest(toSign, options);
    }
  }
  async signEvent({ headers, payload }, { signingDate = new Date, priorSignature, signingRegion, signingService }) {
    const region = signingRegion ?? await this.regionProvider();
    const { shortDate, longDate } = formatDate(signingDate);
    const scope = createScope(shortDate, region, signingService ?? this.service);
    const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
    const hash = new this.sha256;
    hash.update(headers);
    const hashedHeaders = import_util_hex_encoding5.toHex(await hash.digest());
    const stringToSign = [
      EVENT_ALGORITHM_IDENTIFIER,
      longDate,
      scope,
      priorSignature,
      hashedHeaders,
      hashedPayload
    ].join(`
`);
    return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
  }
  async signMessage(signableMessage, { signingDate = new Date, signingRegion, signingService }) {
    const promise = this.signEvent({
      headers: this.headerFormatter.format(signableMessage.message.headers),
      payload: signableMessage.message.body
    }, {
      signingDate,
      signingRegion,
      signingService,
      priorSignature: signableMessage.priorSignature
    });
    return promise.then((signature) => {
      return { message: signableMessage.message, signature };
    });
  }
  async signString(stringToSign, { signingDate = new Date, signingRegion, signingService } = {}) {
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion ?? await this.regionProvider();
    const { shortDate } = formatDate(signingDate);
    const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
    hash.update(toUint8Array2(stringToSign));
    return import_util_hex_encoding5.toHex(await hash.digest());
  }
  async signRequest(requestToSign, { signingDate = new Date, signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion ?? await this.regionProvider();
    const request = prepareRequest(requestToSign);
    const { longDate, shortDate } = formatDate(signingDate);
    const scope = createScope(shortDate, region, signingService ?? this.service);
    request.headers[AMZ_DATE_HEADER] = longDate;
    if (credentials.sessionToken) {
      request.headers[TOKEN_HEADER] = credentials.sessionToken;
    }
    const payloadHash = await getPayloadHash(request, this.sha256);
    if (!hasHeader2(SHA256_HEADER, request.headers) && this.applyChecksum) {
      request.headers[SHA256_HEADER] = payloadHash;
    }
    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
    const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
    request.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} ` + `Credential=${credentials.accessKeyId}/${scope}, ` + `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` + `Signature=${signature}`;
    return request;
  }
  createCanonicalRequest(request, canonicalHeaders, payloadHash) {
    const sortedHeaders = Object.keys(canonicalHeaders).sort();
    return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join(`
`)}

${sortedHeaders.join(";")}
${payloadHash}`;
  }
  async createStringToSign(longDate, credentialScope, canonicalRequest) {
    const hash = new this.sha256;
    hash.update(toUint8Array2(canonicalRequest));
    const hashedRequest = await hash.digest();
    return `${ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${import_util_hex_encoding5.toHex(hashedRequest)}`;
  }
  getCanonicalPath({ path }) {
    if (this.uriEscapePath) {
      const normalizedPathSegments = [];
      for (const pathSegment of path.split("/")) {
        if (pathSegment?.length === 0)
          continue;
        if (pathSegment === ".")
          continue;
        if (pathSegment === "..") {
          normalizedPathSegments.pop();
        } else {
          normalizedPathSegments.push(pathSegment);
        }
      }
      const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
      const doubleEncoded = import_util_uri_escape3.escapeUri(normalizedPath);
      return doubleEncoded.replace(/%2F/g, "/");
    }
    return path;
  }
  async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
    const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
    const hash = new this.sha256(await keyPromise);
    hash.update(toUint8Array2(stringToSign));
    return import_util_hex_encoding5.toHex(await hash.digest());
  }
  getSigningKey(credentials, region, shortDate, service) {
    return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
  }
  validateResolvedCredentials(credentials) {
    if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
      throw new Error("Resolved credential object is not valid");
    }
  }
}
var formatDate = (now) => {
  const longDate = iso8601(now).replace(/[\-:]/g, "");
  return {
    longDate,
    shortDate: longDate.slice(0, 8)
  };
};
var getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(";");
// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/constants.js
init_dist_es15();
var S3_EXPRESS_BUCKET_TYPE = "Directory";
var S3_EXPRESS_BACKEND = "S3Express";
var S3_EXPRESS_AUTH_SCHEME = "sigv4-s3express";
var SESSION_TOKEN_QUERY_PARAM = "X-Amz-S3session-Token";
var SESSION_TOKEN_HEADER = SESSION_TOKEN_QUERY_PARAM.toLowerCase();
var NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_ENV_NAME = "AWS_S3_DISABLE_EXPRESS_SESSION_AUTH";
var NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_INI_NAME = "s3_disable_express_session_auth";
var NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS = {
  environmentVariableSelector: (env2) => booleanSelector(env2, NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_ENV_NAME, SelectorType2.ENV),
  configFileSelector: (profile) => booleanSelector(profile, NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_INI_NAME, SelectorType2.CONFIG),
  default: false
};

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/SignatureV4S3Express.js
class SignatureV4S3Express extends SignatureV4 {
  async signWithCredentials(requestToSign, credentials, options) {
    const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
    requestToSign.headers[SESSION_TOKEN_HEADER] = credentials.sessionToken;
    const privateAccess = this;
    setSingleOverride(privateAccess, credentialsWithoutSessionToken);
    return privateAccess.signRequest(requestToSign, options ?? {});
  }
  async presignWithCredentials(requestToSign, credentials, options) {
    const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
    delete requestToSign.headers[SESSION_TOKEN_HEADER];
    requestToSign.headers[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
    requestToSign.query = requestToSign.query ?? {};
    requestToSign.query[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
    const privateAccess = this;
    setSingleOverride(privateAccess, credentialsWithoutSessionToken);
    return this.presign(requestToSign, options);
  }
}
function getCredentialsWithoutSessionToken(credentials) {
  const credentialsWithoutSessionToken = {
    accessKeyId: credentials.accessKeyId,
    secretAccessKey: credentials.secretAccessKey,
    expiration: credentials.expiration
  };
  return credentialsWithoutSessionToken;
}
function setSingleOverride(privateAccess, credentialsWithoutSessionToken) {
  const id = setTimeout(() => {
    throw new Error("SignatureV4S3Express credential override was created but not called.");
  }, 10);
  const currentCredentialProvider = privateAccess.credentialProvider;
  const overrideCredentialsProviderOnce = () => {
    clearTimeout(id);
    privateAccess.credentialProvider = currentCredentialProvider;
    return Promise.resolve(credentialsWithoutSessionToken);
  };
  privateAccess.credentialProvider = overrideCredentialsProviderOnce;
}
// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressMiddleware.js
var import_core3 = __toESM(require_dist_cjs20(), 1);
init_dist_es();
var s3ExpressMiddleware = (options) => {
  return (next, context) => async (args) => {
    if (context.endpointV2) {
      const endpoint = context.endpointV2;
      const isS3ExpressAuth = endpoint.properties?.authSchemes?.[0]?.name === S3_EXPRESS_AUTH_SCHEME;
      const isS3ExpressBucket = endpoint.properties?.backend === S3_EXPRESS_BACKEND || endpoint.properties?.bucketType === S3_EXPRESS_BUCKET_TYPE;
      if (isS3ExpressBucket) {
        import_core3.setFeature(context, "S3_EXPRESS_BUCKET", "J");
        context.isS3ExpressBucket = true;
      }
      if (isS3ExpressAuth) {
        const requestBucket = args.input.Bucket;
        if (requestBucket) {
          const s3ExpressIdentity = await options.s3ExpressIdentityProvider.getS3ExpressIdentity(await options.credentials(), {
            Bucket: requestBucket
          });
          context.s3ExpressIdentity = s3ExpressIdentity;
          if (HttpRequest.isInstance(args.request) && s3ExpressIdentity.sessionToken) {
            args.request.headers[SESSION_TOKEN_HEADER] = s3ExpressIdentity.sessionToken;
          }
        }
      }
    }
    return next(args);
  };
};
var s3ExpressMiddlewareOptions = {
  name: "s3ExpressMiddleware",
  step: "build",
  tags: ["S3", "S3_EXPRESS"],
  override: true
};
var getS3ExpressPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(s3ExpressMiddleware(options), s3ExpressMiddlewareOptions);
  }
});
// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressHttpSigningMiddleware.js
var import_core4 = __toESM(require_dist_cjs15(), 1);
init_dist_es();
var import_types8 = __toESM(require_dist_cjs(), 1);
init_dist_es9();

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/signS3Express.js
var signS3Express = async (s3ExpressIdentity, signingOptions, request, sigV4MultiRegionSigner) => {
  const signedRequest = await sigV4MultiRegionSigner.signWithCredentials(request, s3ExpressIdentity, {});
  if (signedRequest.headers["X-Amz-Security-Token"] || signedRequest.headers["x-amz-security-token"]) {
    throw new Error("X-Amz-Security-Token must not be set for s3-express requests.");
  }
  return signedRequest;
};

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressHttpSigningMiddleware.js
var defaultErrorHandler = (signingProperties) => (error) => {
  throw error;
};
var defaultSuccessHandler = (httpResponse2, signingProperties) => {
};
var s3ExpressHttpSigningMiddleware = (config2) => (next, context) => async (args) => {
  if (!HttpRequest.isInstance(args.request)) {
    return next(args);
  }
  const smithyContext = getSmithyContext(context);
  const scheme = smithyContext.selectedHttpAuthScheme;
  if (!scheme) {
    throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
  }
  const { httpAuthOption: { signingProperties = {} }, identity, signer } = scheme;
  let request;
  if (context.s3ExpressIdentity) {
    request = await signS3Express(context.s3ExpressIdentity, signingProperties, args.request, await config2.signer());
  } else {
    request = await signer.sign(args.request, identity, signingProperties);
  }
  const output = await next({
    ...args,
    request
  }).catch((signer.errorHandler || defaultErrorHandler)(signingProperties));
  (signer.successHandler || defaultSuccessHandler)(output.response, signingProperties);
  return output;
};
var getS3ExpressHttpSigningPlugin = (config2) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(s3ExpressHttpSigningMiddleware(config2), import_core4.httpSigningMiddlewareOptions);
  }
});
// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3Configuration.js
var resolveS3Config = (input, { session }) => {
  const [s3ClientProvider, CreateSessionCommandCtor] = session;
  return {
    ...input,
    forcePathStyle: input.forcePathStyle ?? false,
    useAccelerateEndpoint: input.useAccelerateEndpoint ?? false,
    disableMultiregionAccessPoints: input.disableMultiregionAccessPoints ?? false,
    followRegionRedirects: input.followRegionRedirects ?? false,
    s3ExpressIdentityProvider: input.s3ExpressIdentityProvider ?? new S3ExpressIdentityProviderImpl(async (key) => s3ClientProvider().send(new CreateSessionCommandCtor({
      Bucket: key,
      SessionMode: "ReadWrite"
    }))),
    bucketEndpoint: input.bucketEndpoint ?? false
  };
};
// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/throw-200-exceptions.js
init_dist_es();
init_dist_es8();
var THROW_IF_EMPTY_BODY = {
  CopyObjectCommand: true,
  UploadPartCopyCommand: true,
  CompleteMultipartUploadCommand: true
};
var MAX_BYTES_TO_INSPECT = 3000;
var throw200ExceptionsMiddleware = (config2) => (next, context) => async (args) => {
  const result = await next(args);
  const { response } = result;
  if (!HttpResponse.isInstance(response)) {
    return result;
  }
  const { statusCode, body: sourceBody } = response;
  if (statusCode < 200 || statusCode >= 300) {
    return result;
  }
  const isSplittableStream = typeof sourceBody?.stream === "function" || typeof sourceBody?.pipe === "function" || typeof sourceBody?.tee === "function";
  if (!isSplittableStream) {
    return result;
  }
  let bodyCopy = sourceBody;
  let body = sourceBody;
  if (sourceBody && typeof sourceBody === "object" && !(sourceBody instanceof Uint8Array)) {
    [bodyCopy, body] = await splitStream3(sourceBody);
  }
  response.body = body;
  const bodyBytes = await collectBody3(bodyCopy, {
    streamCollector: async (stream) => {
      return headStream3(stream, MAX_BYTES_TO_INSPECT);
    }
  });
  if (typeof bodyCopy?.destroy === "function") {
    bodyCopy.destroy();
  }
  const bodyStringTail = config2.utf8Encoder(bodyBytes.subarray(bodyBytes.length - 16));
  if (bodyBytes.length === 0 && THROW_IF_EMPTY_BODY[context.commandName]) {
    const err = new Error("S3 aborted request");
    err.name = "InternalError";
    throw err;
  }
  if (bodyStringTail && bodyStringTail.endsWith("</Error>")) {
    response.statusCode = 400;
  }
  return result;
};
var collectBody3 = (streamBody = new Uint8Array, context) => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array);
};
var throw200ExceptionsMiddlewareOptions = {
  relation: "after",
  toMiddleware: "deserializerMiddleware",
  tags: ["THROW_200_EXCEPTIONS", "S3"],
  name: "throw200ExceptionsMiddleware",
  override: true
};
var getThrow200ExceptionsPlugin = (config2) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(throw200ExceptionsMiddleware(config2), throw200ExceptionsMiddlewareOptions);
  }
});
// ../../node_modules/@aws-sdk/util-arn-parser/dist-es/index.js
var validate2 = (str) => typeof str === "string" && str.indexOf("arn:") === 0 && str.split(":").length >= 6;

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/bucket-endpoint-middleware.js
function bucketEndpointMiddleware(options) {
  return (next, context) => async (args) => {
    if (options.bucketEndpoint) {
      const endpoint = context.endpointV2;
      if (endpoint) {
        const bucket = args.input.Bucket;
        if (typeof bucket === "string") {
          try {
            const bucketEndpointUrl = new URL(bucket);
            context.endpointV2 = {
              ...endpoint,
              url: bucketEndpointUrl
            };
          } catch (e2) {
            const warning = `@aws-sdk/middleware-sdk-s3: bucketEndpoint=true was set but Bucket=${bucket} could not be parsed as URL.`;
            if (context.logger?.constructor?.name === "NoOpLogger") {
              console.warn(warning);
            } else {
              context.logger?.warn?.(warning);
            }
            throw e2;
          }
        }
      }
    }
    return next(args);
  };
}
var bucketEndpointMiddlewareOptions = {
  name: "bucketEndpointMiddleware",
  override: true,
  relation: "after",
  toMiddleware: "endpointV2Middleware"
};

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/validate-bucket-name.js
function validateBucketNameMiddleware({ bucketEndpoint }) {
  return (next) => async (args) => {
    const { input: { Bucket } } = args;
    if (!bucketEndpoint && typeof Bucket === "string" && !validate2(Bucket) && Bucket.indexOf("/") >= 0) {
      const err = new Error(`Bucket name shouldn't contain '/', received '${Bucket}'`);
      err.name = "InvalidBucketName";
      throw err;
    }
    return next({ ...args });
  };
}
var validateBucketNameMiddlewareOptions = {
  step: "initialize",
  tags: ["VALIDATE_BUCKET_NAME"],
  name: "validateBucketNameMiddleware",
  override: true
};
var getValidateBucketNamePlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(validateBucketNameMiddleware(options), validateBucketNameMiddlewareOptions);
    clientStack.addRelativeTo(bucketEndpointMiddleware(options), bucketEndpointMiddlewareOptions);
  }
});
// ../../node_modules/@aws-sdk/client-s3/dist-es/S3Client.js
init_dist_es18();
init_dist_es19();
var import_core22 = __toESM(require_dist_cjs15(), 1);

// ../../node_modules/@smithy/eventstream-serde-config-resolver/dist-es/EventStreamSerdeConfig.js
var resolveEventStreamSerdeConfig = (input) => ({
  ...input,
  eventStreamMarshaller: input.eventStreamSerdeProvider(input)
});
// ../../node_modules/@aws-sdk/client-s3/dist-es/S3Client.js
init_dist_es20();
init_dist_es25();
init_dist_es28();
init_dist_es14();

// ../../node_modules/@aws-sdk/client-s3/dist-es/auth/httpAuthSchemeProvider.js
var import_core8 = __toESM(require_dist_cjs20(), 1);

// ../../node_modules/@aws-sdk/signature-v4-multi-region/dist-es/signature-v4-crt-container.js
var signatureV4CrtContainer = {
  CrtSignerV4: null
};

// ../../node_modules/@aws-sdk/signature-v4-multi-region/dist-es/SignatureV4MultiRegion.js
class SignatureV4MultiRegion {
  sigv4aSigner;
  sigv4Signer;
  signerOptions;
  constructor(options) {
    this.sigv4Signer = new SignatureV4S3Express(options);
    this.signerOptions = options;
  }
  async sign(requestToSign, options = {}) {
    if (options.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().sign(requestToSign, options);
    }
    return this.sigv4Signer.sign(requestToSign, options);
  }
  async signWithCredentials(requestToSign, credentials, options = {}) {
    if (options.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().signWithCredentials(requestToSign, credentials, options);
    }
    return this.sigv4Signer.signWithCredentials(requestToSign, credentials, options);
  }
  async presign(originalRequest, options = {}) {
    if (options.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().presign(originalRequest, options);
    }
    return this.sigv4Signer.presign(originalRequest, options);
  }
  async presignWithCredentials(originalRequest, credentials, options = {}) {
    if (options.signingRegion === "*") {
      throw new Error("Method presignWithCredentials is not supported for [signingRegion=*].");
    }
    return this.sigv4Signer.presignWithCredentials(originalRequest, credentials, options);
  }
  getSigv4aSigner() {
    if (!this.sigv4aSigner) {
      let CrtSignerV4 = null;
      try {
        CrtSignerV4 = signatureV4CrtContainer.CrtSignerV4;
        if (typeof CrtSignerV4 !== "function")
          throw new Error;
      } catch (e2) {
        e2.message = `${e2.message}
` + `Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. 
` + `You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] ` + `or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. 
` + "For more information please go to " + "https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt";
        throw e2;
      }
      this.sigv4aSigner = new CrtSignerV4({
        ...this.signerOptions,
        signingAlgorithm: 1
      });
    }
    return this.sigv4aSigner;
  }
}
// ../../node_modules/@aws-sdk/client-s3/dist-es/auth/httpAuthSchemeProvider.js
init_dist_es25();
init_dist_es9();

// ../../node_modules/@aws-sdk/client-s3/dist-es/endpoint/endpointResolver.js
init_dist_es17();
init_dist_es16();

// ../../node_modules/@aws-sdk/client-s3/dist-es/endpoint/ruleset.js
var ci = "required";
var cj = "type";
var ck = "conditions";
var cl = "fn";
var cm = "argv";
var cn = "ref";
var co = "assign";
var cp = "url";
var cq = "properties";
var cr = "backend";
var cs = "authSchemes";
var ct = "disableDoubleEncoding";
var cu = "signingName";
var cv = "signingRegion";
var cw = "headers";
var cx = "signingRegionSet";
var a3 = 6;
var b = false;
var c3 = true;
var d2 = "isSet";
var e2 = "booleanEquals";
var f2 = "error";
var g = "aws.partition";
var h2 = "stringEquals";
var i2 = "getAttr";
var j2 = "name";
var k2 = "substring";
var l2 = "bucketSuffix";
var m2 = "parseURL";
var n2 = "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}";
var o = "endpoint";
var p3 = "tree";
var q2 = "aws.isVirtualHostableS3Bucket";
var r3 = "{url#scheme}://{Bucket}.{url#authority}{url#path}";
var s2 = "not";
var t2 = "{url#scheme}://{url#authority}{url#path}";
var u3 = "hardwareType";
var v2 = "regionPrefix";
var w2 = "bucketAliasSuffix";
var x2 = "outpostId";
var y3 = "isValidHostLabel";
var z2 = "sigv4a";
var A3 = "s3-outposts";
var B3 = "s3";
var C2 = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}";
var D2 = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}";
var E2 = "https://{Bucket}.s3.{partitionResult#dnsSuffix}";
var F2 = "aws.parseArn";
var G3 = "bucketArn";
var H = "arnType";
var I3 = "";
var J2 = "s3-object-lambda";
var K = "accesspoint";
var L3 = "accessPointName";
var M2 = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}";
var N3 = "mrapPartition";
var O3 = "outpostType";
var P3 = "arnPrefix";
var Q2 = "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}";
var R3 = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}";
var S3 = "https://s3.{partitionResult#dnsSuffix}";
var T3 = { [ci]: false, [cj]: "String" };
var U2 = { [ci]: true, default: false, [cj]: "Boolean" };
var V2 = { [ci]: false, [cj]: "Boolean" };
var W2 = { [cl]: e2, [cm]: [{ [cn]: "Accelerate" }, true] };
var X2 = { [cl]: e2, [cm]: [{ [cn]: "UseFIPS" }, true] };
var Y2 = { [cl]: e2, [cm]: [{ [cn]: "UseDualStack" }, true] };
var Z = { [cl]: d2, [cm]: [{ [cn]: "Endpoint" }] };
var aa = { [cl]: g, [cm]: [{ [cn]: "Region" }], [co]: "partitionResult" };
var ab = { [cl]: h2, [cm]: [{ [cl]: i2, [cm]: [{ [cn]: "partitionResult" }, j2] }, "aws-cn"] };
var ac = { [cl]: d2, [cm]: [{ [cn]: "Bucket" }] };
var ad = { [cn]: "Bucket" };
var ae = { [cl]: m2, [cm]: [{ [cn]: "Endpoint" }], [co]: "url" };
var af = { [cl]: e2, [cm]: [{ [cl]: i2, [cm]: [{ [cn]: "url" }, "isIp"] }, true] };
var ag = { [cn]: "url" };
var ah = { [cl]: "uriEncode", [cm]: [ad], [co]: "uri_encoded_bucket" };
var ai = { [cr]: "S3Express", [cs]: [{ [ct]: true, [j2]: "sigv4", [cu]: "s3express", [cv]: "{Region}" }] };
var aj = {};
var ak = { [cl]: q2, [cm]: [ad, false] };
var al = { [f2]: "S3Express bucket name is not a valid virtual hostable name.", [cj]: f2 };
var am = { [cr]: "S3Express", [cs]: [{ [ct]: true, [j2]: "sigv4-s3express", [cu]: "s3express", [cv]: "{Region}" }] };
var an = { [cl]: d2, [cm]: [{ [cn]: "UseS3ExpressControlEndpoint" }] };
var ao = { [cl]: e2, [cm]: [{ [cn]: "UseS3ExpressControlEndpoint" }, true] };
var ap = { [cl]: s2, [cm]: [Z] };
var aq = { [f2]: "Unrecognized S3Express bucket name format.", [cj]: f2 };
var ar = { [cl]: s2, [cm]: [ac] };
var as = { [cn]: u3 };
var at = { [ck]: [ap], [f2]: "Expected a endpoint to be specified but no endpoint was found", [cj]: f2 };
var au = { [cs]: [{ [ct]: true, [j2]: z2, [cu]: A3, [cx]: ["*"] }, { [ct]: true, [j2]: "sigv4", [cu]: A3, [cv]: "{Region}" }] };
var av = { [cl]: e2, [cm]: [{ [cn]: "ForcePathStyle" }, false] };
var aw = { [cn]: "ForcePathStyle" };
var ax = { [cl]: e2, [cm]: [{ [cn]: "Accelerate" }, false] };
var ay = { [cl]: h2, [cm]: [{ [cn]: "Region" }, "aws-global"] };
var az = { [cs]: [{ [ct]: true, [j2]: "sigv4", [cu]: B3, [cv]: "us-east-1" }] };
var aA = { [cl]: s2, [cm]: [ay] };
var aB = { [cl]: e2, [cm]: [{ [cn]: "UseGlobalEndpoint" }, true] };
var aC = { [cp]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cq]: { [cs]: [{ [ct]: true, [j2]: "sigv4", [cu]: B3, [cv]: "{Region}" }] }, [cw]: {} };
var aD2 = { [cs]: [{ [ct]: true, [j2]: "sigv4", [cu]: B3, [cv]: "{Region}" }] };
var aE = { [cl]: e2, [cm]: [{ [cn]: "UseGlobalEndpoint" }, false] };
var aF = { [cl]: e2, [cm]: [{ [cn]: "UseDualStack" }, false] };
var aG = { [cp]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}", [cq]: aD2, [cw]: {} };
var aH = { [cl]: e2, [cm]: [{ [cn]: "UseFIPS" }, false] };
var aI = { [cp]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}", [cq]: aD2, [cw]: {} };
var aJ = { [cp]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cq]: aD2, [cw]: {} };
var aK = { [cl]: e2, [cm]: [{ [cl]: i2, [cm]: [ag, "isIp"] }, false] };
var aL = { [cp]: C2, [cq]: aD2, [cw]: {} };
var aM = { [cp]: r3, [cq]: aD2, [cw]: {} };
var aN = { [o]: aM, [cj]: o };
var aO = { [cp]: D2, [cq]: aD2, [cw]: {} };
var aP = { [cp]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}", [cq]: aD2, [cw]: {} };
var aQ = { [f2]: "Invalid region: region was not a valid DNS name.", [cj]: f2 };
var aR = { [cn]: G3 };
var aS = { [cn]: H };
var aT = { [cl]: i2, [cm]: [aR, "service"] };
var aU = { [cn]: L3 };
var aV = { [ck]: [Y2], [f2]: "S3 Object Lambda does not support Dual-stack", [cj]: f2 };
var aW = { [ck]: [W2], [f2]: "S3 Object Lambda does not support S3 Accelerate", [cj]: f2 };
var aX = { [ck]: [{ [cl]: d2, [cm]: [{ [cn]: "DisableAccessPoints" }] }, { [cl]: e2, [cm]: [{ [cn]: "DisableAccessPoints" }, true] }], [f2]: "Access points are not supported for this operation", [cj]: f2 };
var aY = { [ck]: [{ [cl]: d2, [cm]: [{ [cn]: "UseArnRegion" }] }, { [cl]: e2, [cm]: [{ [cn]: "UseArnRegion" }, false] }, { [cl]: s2, [cm]: [{ [cl]: h2, [cm]: [{ [cl]: i2, [cm]: [aR, "region"] }, "{Region}"] }] }], [f2]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`", [cj]: f2 };
var aZ = { [cl]: i2, [cm]: [{ [cn]: "bucketPartition" }, j2] };
var ba = { [cl]: i2, [cm]: [aR, "accountId"] };
var bb = { [cs]: [{ [ct]: true, [j2]: "sigv4", [cu]: J2, [cv]: "{bucketArn#region}" }] };
var bc = { [f2]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`", [cj]: f2 };
var bd = { [f2]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`", [cj]: f2 };
var be = { [f2]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)", [cj]: f2 };
var bf = { [f2]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`", [cj]: f2 };
var bg = { [f2]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.", [cj]: f2 };
var bh = { [f2]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided", [cj]: f2 };
var bi = { [cs]: [{ [ct]: true, [j2]: "sigv4", [cu]: B3, [cv]: "{bucketArn#region}" }] };
var bj = { [cs]: [{ [ct]: true, [j2]: z2, [cu]: A3, [cx]: ["*"] }, { [ct]: true, [j2]: "sigv4", [cu]: A3, [cv]: "{bucketArn#region}" }] };
var bk = { [cl]: F2, [cm]: [ad] };
var bl = { [cp]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: aD2, [cw]: {} };
var bm = { [cp]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: aD2, [cw]: {} };
var bn = { [cp]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: aD2, [cw]: {} };
var bo = { [cp]: Q2, [cq]: aD2, [cw]: {} };
var bp = { [cp]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: aD2, [cw]: {} };
var bq = { [cn]: "UseObjectLambdaEndpoint" };
var br = { [cs]: [{ [ct]: true, [j2]: "sigv4", [cu]: J2, [cv]: "{Region}" }] };
var bs = { [cp]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cq]: aD2, [cw]: {} };
var bt = { [cp]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}", [cq]: aD2, [cw]: {} };
var bu = { [cp]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cq]: aD2, [cw]: {} };
var bv = { [cp]: t2, [cq]: aD2, [cw]: {} };
var bw = { [cp]: "https://s3.{Region}.{partitionResult#dnsSuffix}", [cq]: aD2, [cw]: {} };
var bx = [{ [cn]: "Region" }];
var by = [{ [cn]: "Endpoint" }];
var bz = [ad];
var bA = [Y2];
var bB = [W2];
var bC = [Z, ae];
var bD2 = [{ [cl]: d2, [cm]: [{ [cn]: "DisableS3ExpressSessionAuth" }] }, { [cl]: e2, [cm]: [{ [cn]: "DisableS3ExpressSessionAuth" }, true] }];
var bE = [af];
var bF = [ah];
var bG = [ak];
var bH = [X2];
var bI = [{ [cl]: k2, [cm]: [ad, 6, 14, true], [co]: "s3expressAvailabilityZoneId" }, { [cl]: k2, [cm]: [ad, 14, 16, true], [co]: "s3expressAvailabilityZoneDelim" }, { [cl]: h2, [cm]: [{ [cn]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var bJ = [{ [ck]: [X2], [o]: { [cp]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cq]: ai, [cw]: {} }, [cj]: o }, { [o]: { [cp]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cq]: ai, [cw]: {} }, [cj]: o }];
var bK = [{ [cl]: k2, [cm]: [ad, 6, 15, true], [co]: "s3expressAvailabilityZoneId" }, { [cl]: k2, [cm]: [ad, 15, 17, true], [co]: "s3expressAvailabilityZoneDelim" }, { [cl]: h2, [cm]: [{ [cn]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var bL = [{ [cl]: k2, [cm]: [ad, 6, 19, true], [co]: "s3expressAvailabilityZoneId" }, { [cl]: k2, [cm]: [ad, 19, 21, true], [co]: "s3expressAvailabilityZoneDelim" }, { [cl]: h2, [cm]: [{ [cn]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var bM = [{ [cl]: k2, [cm]: [ad, 6, 20, true], [co]: "s3expressAvailabilityZoneId" }, { [cl]: k2, [cm]: [ad, 20, 22, true], [co]: "s3expressAvailabilityZoneDelim" }, { [cl]: h2, [cm]: [{ [cn]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var bN = [{ [cl]: k2, [cm]: [ad, 6, 26, true], [co]: "s3expressAvailabilityZoneId" }, { [cl]: k2, [cm]: [ad, 26, 28, true], [co]: "s3expressAvailabilityZoneDelim" }, { [cl]: h2, [cm]: [{ [cn]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var bO = [{ [ck]: [X2], [o]: { [cp]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cq]: am, [cw]: {} }, [cj]: o }, { [o]: { [cp]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cq]: am, [cw]: {} }, [cj]: o }];
var bP = [ac];
var bQ = [{ [cl]: y3, [cm]: [{ [cn]: x2 }, false] }];
var bR = [{ [cl]: h2, [cm]: [{ [cn]: v2 }, "beta"] }];
var bS = ["*"];
var bT = [aa];
var bU = [{ [cl]: y3, [cm]: [{ [cn]: "Region" }, false] }];
var bV = [{ [cl]: h2, [cm]: [{ [cn]: "Region" }, "us-east-1"] }];
var bW = [{ [cl]: h2, [cm]: [aS, K] }];
var bX = [{ [cl]: i2, [cm]: [aR, "resourceId[1]"], [co]: L3 }, { [cl]: s2, [cm]: [{ [cl]: h2, [cm]: [aU, I3] }] }];
var bY = [aR, "resourceId[1]"];
var bZ = [{ [cl]: s2, [cm]: [{ [cl]: h2, [cm]: [{ [cl]: i2, [cm]: [aR, "region"] }, I3] }] }];
var ca = [{ [cl]: s2, [cm]: [{ [cl]: d2, [cm]: [{ [cl]: i2, [cm]: [aR, "resourceId[2]"] }] }] }];
var cb = [aR, "resourceId[2]"];
var cc = [{ [cl]: g, [cm]: [{ [cl]: i2, [cm]: [aR, "region"] }], [co]: "bucketPartition" }];
var cd = [{ [cl]: h2, [cm]: [aZ, { [cl]: i2, [cm]: [{ [cn]: "partitionResult" }, j2] }] }];
var ce = [{ [cl]: y3, [cm]: [{ [cl]: i2, [cm]: [aR, "region"] }, true] }];
var cf = [{ [cl]: y3, [cm]: [ba, false] }];
var cg = [{ [cl]: y3, [cm]: [aU, false] }];
var ch = [{ [cl]: y3, [cm]: [{ [cn]: "Region" }, true] }];
var _data = { version: "1.0", parameters: { Bucket: T3, Region: T3, UseFIPS: U2, UseDualStack: U2, Endpoint: T3, ForcePathStyle: U2, Accelerate: U2, UseGlobalEndpoint: U2, UseObjectLambdaEndpoint: V2, Key: T3, Prefix: T3, CopySource: T3, DisableAccessPoints: V2, DisableMultiRegionAccessPoints: U2, UseArnRegion: V2, UseS3ExpressControlEndpoint: V2, DisableS3ExpressSessionAuth: V2 }, rules: [{ [ck]: [{ [cl]: d2, [cm]: bx }], rules: [{ [ck]: [W2, X2], error: "Accelerate cannot be used with FIPS", [cj]: f2 }, { [ck]: [Y2, Z], error: "Cannot set dual-stack in combination with a custom endpoint.", [cj]: f2 }, { [ck]: [Z, X2], error: "A custom endpoint cannot be combined with FIPS", [cj]: f2 }, { [ck]: [Z, W2], error: "A custom endpoint cannot be combined with S3 Accelerate", [cj]: f2 }, { [ck]: [X2, aa, ab], error: "Partition does not support FIPS", [cj]: f2 }, { [ck]: [ac, { [cl]: k2, [cm]: [ad, 0, a3, c3], [co]: l2 }, { [cl]: h2, [cm]: [{ [cn]: l2 }, "--x-s3"] }], rules: [{ [ck]: bA, error: "S3Express does not support Dual-stack.", [cj]: f2 }, { [ck]: bB, error: "S3Express does not support S3 Accelerate.", [cj]: f2 }, { [ck]: bC, rules: [{ [ck]: bD2, rules: [{ [ck]: bE, rules: [{ [ck]: bF, rules: [{ endpoint: { [cp]: n2, [cq]: ai, [cw]: aj }, [cj]: o }], [cj]: p3 }], [cj]: p3 }, { [ck]: bG, rules: [{ endpoint: { [cp]: r3, [cq]: ai, [cw]: aj }, [cj]: o }], [cj]: p3 }, al], [cj]: p3 }, { [ck]: bE, rules: [{ [ck]: bF, rules: [{ endpoint: { [cp]: n2, [cq]: am, [cw]: aj }, [cj]: o }], [cj]: p3 }], [cj]: p3 }, { [ck]: bG, rules: [{ endpoint: { [cp]: r3, [cq]: am, [cw]: aj }, [cj]: o }], [cj]: p3 }, al], [cj]: p3 }, { [ck]: [an, ao], rules: [{ [ck]: [ah, ap], rules: [{ [ck]: bH, endpoint: { [cp]: "https://s3express-control-fips.{Region}.amazonaws.com/{uri_encoded_bucket}", [cq]: ai, [cw]: aj }, [cj]: o }, { endpoint: { [cp]: "https://s3express-control.{Region}.amazonaws.com/{uri_encoded_bucket}", [cq]: ai, [cw]: aj }, [cj]: o }], [cj]: p3 }], [cj]: p3 }, { [ck]: bG, rules: [{ [ck]: bD2, rules: [{ [ck]: bI, rules: bJ, [cj]: p3 }, { [ck]: bK, rules: bJ, [cj]: p3 }, { [ck]: bL, rules: bJ, [cj]: p3 }, { [ck]: bM, rules: bJ, [cj]: p3 }, { [ck]: bN, rules: bJ, [cj]: p3 }, aq], [cj]: p3 }, { [ck]: bI, rules: bO, [cj]: p3 }, { [ck]: bK, rules: bO, [cj]: p3 }, { [ck]: bL, rules: bO, [cj]: p3 }, { [ck]: bM, rules: bO, [cj]: p3 }, { [ck]: bN, rules: bO, [cj]: p3 }, aq], [cj]: p3 }, al], [cj]: p3 }, { [ck]: [ar, an, ao], rules: [{ [ck]: bC, endpoint: { [cp]: t2, [cq]: ai, [cw]: aj }, [cj]: o }, { [ck]: bH, endpoint: { [cp]: "https://s3express-control-fips.{Region}.amazonaws.com", [cq]: ai, [cw]: aj }, [cj]: o }, { endpoint: { [cp]: "https://s3express-control.{Region}.amazonaws.com", [cq]: ai, [cw]: aj }, [cj]: o }], [cj]: p3 }, { [ck]: [ac, { [cl]: k2, [cm]: [ad, 49, 50, c3], [co]: u3 }, { [cl]: k2, [cm]: [ad, 8, 12, c3], [co]: v2 }, { [cl]: k2, [cm]: [ad, 0, 7, c3], [co]: w2 }, { [cl]: k2, [cm]: [ad, 32, 49, c3], [co]: x2 }, { [cl]: g, [cm]: bx, [co]: "regionPartition" }, { [cl]: h2, [cm]: [{ [cn]: w2 }, "--op-s3"] }], rules: [{ [ck]: bQ, rules: [{ [ck]: [{ [cl]: h2, [cm]: [as, "e"] }], rules: [{ [ck]: bR, rules: [at, { [ck]: bC, endpoint: { [cp]: "https://{Bucket}.ec2.{url#authority}", [cq]: au, [cw]: aj }, [cj]: o }], [cj]: p3 }, { endpoint: { [cp]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cq]: au, [cw]: aj }, [cj]: o }], [cj]: p3 }, { [ck]: [{ [cl]: h2, [cm]: [as, "o"] }], rules: [{ [ck]: bR, rules: [at, { [ck]: bC, endpoint: { [cp]: "https://{Bucket}.op-{outpostId}.{url#authority}", [cq]: au, [cw]: aj }, [cj]: o }], [cj]: p3 }, { endpoint: { [cp]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cq]: au, [cw]: aj }, [cj]: o }], [cj]: p3 }, { error: 'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"', [cj]: f2 }], [cj]: p3 }, { error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.", [cj]: f2 }], [cj]: p3 }, { [ck]: bP, rules: [{ [ck]: [Z, { [cl]: s2, [cm]: [{ [cl]: d2, [cm]: [{ [cl]: m2, [cm]: by }] }] }], error: "Custom endpoint `{Endpoint}` was not a valid URI", [cj]: f2 }, { [ck]: [av, ak], rules: [{ [ck]: bT, rules: [{ [ck]: bU, rules: [{ [ck]: [W2, ab], error: "S3 Accelerate cannot be used in this region", [cj]: f2 }, { [ck]: [Y2, X2, ax, ap, ay], endpoint: { [cp]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [Y2, X2, ax, ap, aA, aB], rules: [{ endpoint: aC, [cj]: o }], [cj]: p3 }, { [ck]: [Y2, X2, ax, ap, aA, aE], endpoint: aC, [cj]: o }, { [ck]: [aF, X2, ax, ap, ay], endpoint: { [cp]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aF, X2, ax, ap, aA, aB], rules: [{ endpoint: aG, [cj]: o }], [cj]: p3 }, { [ck]: [aF, X2, ax, ap, aA, aE], endpoint: aG, [cj]: o }, { [ck]: [Y2, aH, W2, ap, ay], endpoint: { [cp]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [Y2, aH, W2, ap, aA, aB], rules: [{ endpoint: aI, [cj]: o }], [cj]: p3 }, { [ck]: [Y2, aH, W2, ap, aA, aE], endpoint: aI, [cj]: o }, { [ck]: [Y2, aH, ax, ap, ay], endpoint: { [cp]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [Y2, aH, ax, ap, aA, aB], rules: [{ endpoint: aJ, [cj]: o }], [cj]: p3 }, { [ck]: [Y2, aH, ax, ap, aA, aE], endpoint: aJ, [cj]: o }, { [ck]: [aF, aH, ax, Z, ae, af, ay], endpoint: { [cp]: C2, [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aF, aH, ax, Z, ae, aK, ay], endpoint: { [cp]: r3, [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aF, aH, ax, Z, ae, af, aA, aB], rules: [{ [ck]: bV, endpoint: aL, [cj]: o }, { endpoint: aL, [cj]: o }], [cj]: p3 }, { [ck]: [aF, aH, ax, Z, ae, aK, aA, aB], rules: [{ [ck]: bV, endpoint: aM, [cj]: o }, aN], [cj]: p3 }, { [ck]: [aF, aH, ax, Z, ae, af, aA, aE], endpoint: aL, [cj]: o }, { [ck]: [aF, aH, ax, Z, ae, aK, aA, aE], endpoint: aM, [cj]: o }, { [ck]: [aF, aH, W2, ap, ay], endpoint: { [cp]: D2, [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aF, aH, W2, ap, aA, aB], rules: [{ [ck]: bV, endpoint: aO, [cj]: o }, { endpoint: aO, [cj]: o }], [cj]: p3 }, { [ck]: [aF, aH, W2, ap, aA, aE], endpoint: aO, [cj]: o }, { [ck]: [aF, aH, ax, ap, ay], endpoint: { [cp]: E2, [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aF, aH, ax, ap, aA, aB], rules: [{ [ck]: bV, endpoint: { [cp]: E2, [cq]: aD2, [cw]: aj }, [cj]: o }, { endpoint: aP, [cj]: o }], [cj]: p3 }, { [ck]: [aF, aH, ax, ap, aA, aE], endpoint: aP, [cj]: o }], [cj]: p3 }, aQ], [cj]: p3 }], [cj]: p3 }, { [ck]: [Z, ae, { [cl]: h2, [cm]: [{ [cl]: i2, [cm]: [ag, "scheme"] }, "http"] }, { [cl]: q2, [cm]: [ad, c3] }, av, aH, aF, ax], rules: [{ [ck]: bT, rules: [{ [ck]: bU, rules: [aN], [cj]: p3 }, aQ], [cj]: p3 }], [cj]: p3 }, { [ck]: [av, { [cl]: F2, [cm]: bz, [co]: G3 }], rules: [{ [ck]: [{ [cl]: i2, [cm]: [aR, "resourceId[0]"], [co]: H }, { [cl]: s2, [cm]: [{ [cl]: h2, [cm]: [aS, I3] }] }], rules: [{ [ck]: [{ [cl]: h2, [cm]: [aT, J2] }], rules: [{ [ck]: bW, rules: [{ [ck]: bX, rules: [aV, aW, { [ck]: bZ, rules: [aX, { [ck]: ca, rules: [aY, { [ck]: cc, rules: [{ [ck]: bT, rules: [{ [ck]: cd, rules: [{ [ck]: ce, rules: [{ [ck]: [{ [cl]: h2, [cm]: [ba, I3] }], error: "Invalid ARN: Missing account id", [cj]: f2 }, { [ck]: cf, rules: [{ [ck]: cg, rules: [{ [ck]: bC, endpoint: { [cp]: M2, [cq]: bb, [cw]: aj }, [cj]: o }, { [ck]: bH, endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bb, [cw]: aj }, [cj]: o }, { endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bb, [cw]: aj }, [cj]: o }], [cj]: p3 }, bc], [cj]: p3 }, bd], [cj]: p3 }, be], [cj]: p3 }, bf], [cj]: p3 }], [cj]: p3 }], [cj]: p3 }, bg], [cj]: p3 }, { error: "Invalid ARN: bucket ARN is missing a region", [cj]: f2 }], [cj]: p3 }, bh], [cj]: p3 }, { error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`", [cj]: f2 }], [cj]: p3 }, { [ck]: bW, rules: [{ [ck]: bX, rules: [{ [ck]: bZ, rules: [{ [ck]: bW, rules: [{ [ck]: bZ, rules: [aX, { [ck]: ca, rules: [aY, { [ck]: cc, rules: [{ [ck]: bT, rules: [{ [ck]: [{ [cl]: h2, [cm]: [aZ, "{partitionResult#name}"] }], rules: [{ [ck]: ce, rules: [{ [ck]: [{ [cl]: h2, [cm]: [aT, B3] }], rules: [{ [ck]: cf, rules: [{ [ck]: cg, rules: [{ [ck]: bB, error: "Access Points do not support S3 Accelerate", [cj]: f2 }, { [ck]: [X2, Y2], endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bi, [cw]: aj }, [cj]: o }, { [ck]: [X2, aF], endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bi, [cw]: aj }, [cj]: o }, { [ck]: [aH, Y2], endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bi, [cw]: aj }, [cj]: o }, { [ck]: [aH, aF, Z, ae], endpoint: { [cp]: M2, [cq]: bi, [cw]: aj }, [cj]: o }, { [ck]: [aH, aF], endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bi, [cw]: aj }, [cj]: o }], [cj]: p3 }, bc], [cj]: p3 }, bd], [cj]: p3 }, { error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}", [cj]: f2 }], [cj]: p3 }, be], [cj]: p3 }, bf], [cj]: p3 }], [cj]: p3 }], [cj]: p3 }, bg], [cj]: p3 }], [cj]: p3 }], [cj]: p3 }, { [ck]: [{ [cl]: y3, [cm]: [aU, c3] }], rules: [{ [ck]: bA, error: "S3 MRAP does not support dual-stack", [cj]: f2 }, { [ck]: bH, error: "S3 MRAP does not support FIPS", [cj]: f2 }, { [ck]: bB, error: "S3 MRAP does not support S3 Accelerate", [cj]: f2 }, { [ck]: [{ [cl]: e2, [cm]: [{ [cn]: "DisableMultiRegionAccessPoints" }, c3] }], error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.", [cj]: f2 }, { [ck]: [{ [cl]: g, [cm]: bx, [co]: N3 }], rules: [{ [ck]: [{ [cl]: h2, [cm]: [{ [cl]: i2, [cm]: [{ [cn]: N3 }, j2] }, { [cl]: i2, [cm]: [aR, "partition"] }] }], rules: [{ endpoint: { [cp]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}", [cq]: { [cs]: [{ [ct]: c3, name: z2, [cu]: B3, [cx]: bS }] }, [cw]: aj }, [cj]: o }], [cj]: p3 }, { error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`", [cj]: f2 }], [cj]: p3 }], [cj]: p3 }, { error: "Invalid Access Point Name", [cj]: f2 }], [cj]: p3 }, bh], [cj]: p3 }, { [ck]: [{ [cl]: h2, [cm]: [aT, A3] }], rules: [{ [ck]: bA, error: "S3 Outposts does not support Dual-stack", [cj]: f2 }, { [ck]: bH, error: "S3 Outposts does not support FIPS", [cj]: f2 }, { [ck]: bB, error: "S3 Outposts does not support S3 Accelerate", [cj]: f2 }, { [ck]: [{ [cl]: d2, [cm]: [{ [cl]: i2, [cm]: [aR, "resourceId[4]"] }] }], error: "Invalid Arn: Outpost Access Point ARN contains sub resources", [cj]: f2 }, { [ck]: [{ [cl]: i2, [cm]: bY, [co]: x2 }], rules: [{ [ck]: bQ, rules: [aY, { [ck]: cc, rules: [{ [ck]: bT, rules: [{ [ck]: cd, rules: [{ [ck]: ce, rules: [{ [ck]: cf, rules: [{ [ck]: [{ [cl]: i2, [cm]: cb, [co]: O3 }], rules: [{ [ck]: [{ [cl]: i2, [cm]: [aR, "resourceId[3]"], [co]: L3 }], rules: [{ [ck]: [{ [cl]: h2, [cm]: [{ [cn]: O3 }, K] }], rules: [{ [ck]: bC, endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}", [cq]: bj, [cw]: aj }, [cj]: o }, { endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bj, [cw]: aj }, [cj]: o }], [cj]: p3 }, { error: "Expected an outpost type `accesspoint`, found {outpostType}", [cj]: f2 }], [cj]: p3 }, { error: "Invalid ARN: expected an access point name", [cj]: f2 }], [cj]: p3 }, { error: "Invalid ARN: Expected a 4-component resource", [cj]: f2 }], [cj]: p3 }, bd], [cj]: p3 }, be], [cj]: p3 }, bf], [cj]: p3 }], [cj]: p3 }], [cj]: p3 }, { error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`", [cj]: f2 }], [cj]: p3 }, { error: "Invalid ARN: The Outpost Id was not set", [cj]: f2 }], [cj]: p3 }, { error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})", [cj]: f2 }], [cj]: p3 }, { error: "Invalid ARN: No ARN type specified", [cj]: f2 }], [cj]: p3 }, { [ck]: [{ [cl]: k2, [cm]: [ad, 0, 4, b], [co]: P3 }, { [cl]: h2, [cm]: [{ [cn]: P3 }, "arn:"] }, { [cl]: s2, [cm]: [{ [cl]: d2, [cm]: [bk] }] }], error: "Invalid ARN: `{Bucket}` was not a valid ARN", [cj]: f2 }, { [ck]: [{ [cl]: e2, [cm]: [aw, c3] }, bk], error: "Path-style addressing cannot be used with ARN buckets", [cj]: f2 }, { [ck]: bF, rules: [{ [ck]: bT, rules: [{ [ck]: [ax], rules: [{ [ck]: [Y2, ap, X2, ay], endpoint: { [cp]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [Y2, ap, X2, aA, aB], rules: [{ endpoint: bl, [cj]: o }], [cj]: p3 }, { [ck]: [Y2, ap, X2, aA, aE], endpoint: bl, [cj]: o }, { [ck]: [aF, ap, X2, ay], endpoint: { [cp]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aF, ap, X2, aA, aB], rules: [{ endpoint: bm, [cj]: o }], [cj]: p3 }, { [ck]: [aF, ap, X2, aA, aE], endpoint: bm, [cj]: o }, { [ck]: [Y2, ap, aH, ay], endpoint: { [cp]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [Y2, ap, aH, aA, aB], rules: [{ endpoint: bn, [cj]: o }], [cj]: p3 }, { [ck]: [Y2, ap, aH, aA, aE], endpoint: bn, [cj]: o }, { [ck]: [aF, Z, ae, aH, ay], endpoint: { [cp]: Q2, [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aF, Z, ae, aH, aA, aB], rules: [{ [ck]: bV, endpoint: bo, [cj]: o }, { endpoint: bo, [cj]: o }], [cj]: p3 }, { [ck]: [aF, Z, ae, aH, aA, aE], endpoint: bo, [cj]: o }, { [ck]: [aF, ap, aH, ay], endpoint: { [cp]: R3, [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aF, ap, aH, aA, aB], rules: [{ [ck]: bV, endpoint: { [cp]: R3, [cq]: aD2, [cw]: aj }, [cj]: o }, { endpoint: bp, [cj]: o }], [cj]: p3 }, { [ck]: [aF, ap, aH, aA, aE], endpoint: bp, [cj]: o }], [cj]: p3 }, { error: "Path-style addressing cannot be used with S3 Accelerate", [cj]: f2 }], [cj]: p3 }], [cj]: p3 }], [cj]: p3 }, { [ck]: [{ [cl]: d2, [cm]: [bq] }, { [cl]: e2, [cm]: [bq, c3] }], rules: [{ [ck]: bT, rules: [{ [ck]: ch, rules: [aV, aW, { [ck]: bC, endpoint: { [cp]: t2, [cq]: br, [cw]: aj }, [cj]: o }, { [ck]: bH, endpoint: { [cp]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}", [cq]: br, [cw]: aj }, [cj]: o }, { endpoint: { [cp]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}", [cq]: br, [cw]: aj }, [cj]: o }], [cj]: p3 }, aQ], [cj]: p3 }], [cj]: p3 }, { [ck]: [ar], rules: [{ [ck]: bT, rules: [{ [ck]: ch, rules: [{ [ck]: [X2, Y2, ap, ay], endpoint: { [cp]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [X2, Y2, ap, aA, aB], rules: [{ endpoint: bs, [cj]: o }], [cj]: p3 }, { [ck]: [X2, Y2, ap, aA, aE], endpoint: bs, [cj]: o }, { [ck]: [X2, aF, ap, ay], endpoint: { [cp]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [X2, aF, ap, aA, aB], rules: [{ endpoint: bt, [cj]: o }], [cj]: p3 }, { [ck]: [X2, aF, ap, aA, aE], endpoint: bt, [cj]: o }, { [ck]: [aH, Y2, ap, ay], endpoint: { [cp]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aH, Y2, ap, aA, aB], rules: [{ endpoint: bu, [cj]: o }], [cj]: p3 }, { [ck]: [aH, Y2, ap, aA, aE], endpoint: bu, [cj]: o }, { [ck]: [aH, aF, Z, ae, ay], endpoint: { [cp]: t2, [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aH, aF, Z, ae, aA, aB], rules: [{ [ck]: bV, endpoint: bv, [cj]: o }, { endpoint: bv, [cj]: o }], [cj]: p3 }, { [ck]: [aH, aF, Z, ae, aA, aE], endpoint: bv, [cj]: o }, { [ck]: [aH, aF, ap, ay], endpoint: { [cp]: S3, [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aH, aF, ap, aA, aB], rules: [{ [ck]: bV, endpoint: { [cp]: S3, [cq]: aD2, [cw]: aj }, [cj]: o }, { endpoint: bw, [cj]: o }], [cj]: p3 }, { [ck]: [aH, aF, ap, aA, aE], endpoint: bw, [cj]: o }], [cj]: p3 }, aQ], [cj]: p3 }], [cj]: p3 }], [cj]: p3 }, { error: "A region must be set when sending requests to S3.", [cj]: f2 }] };
var ruleSet = _data;

// ../../node_modules/@aws-sdk/client-s3/dist-es/endpoint/endpointResolver.js
var cache = new EndpointCache({
  size: 50,
  params: [
    "Accelerate",
    "Bucket",
    "DisableAccessPoints",
    "DisableMultiRegionAccessPoints",
    "DisableS3ExpressSessionAuth",
    "Endpoint",
    "ForcePathStyle",
    "Region",
    "UseArnRegion",
    "UseDualStack",
    "UseFIPS",
    "UseGlobalEndpoint",
    "UseObjectLambdaEndpoint",
    "UseS3ExpressControlEndpoint"
  ]
});
var defaultEndpointResolver = (endpointParams, context = {}) => {
  return cache.get(endpointParams, () => resolveEndpoint2(ruleSet, {
    endpointParams,
    logger: context.logger
  }));
};
customEndpointFunctions.aws = awsEndpointFunctions;

// ../../node_modules/@aws-sdk/client-s3/dist-es/auth/httpAuthSchemeProvider.js
var createEndpointRuleSetHttpAuthSchemeParametersProvider = (defaultHttpAuthSchemeParametersProvider) => async (config4, context, input) => {
  if (!input) {
    throw new Error(`Could not find \`input\` for \`defaultEndpointRuleSetHttpAuthSchemeParametersProvider\``);
  }
  const defaultParameters = await defaultHttpAuthSchemeParametersProvider(config4, context, input);
  const instructionsFn = getSmithyContext(context)?.commandInstance?.constructor?.getEndpointParameterInstructions;
  if (!instructionsFn) {
    throw new Error(`getEndpointParameterInstructions() is not defined on \`${context.commandName}\``);
  }
  const endpointParameters = await resolveParams(input, { getEndpointParameterInstructions: instructionsFn }, config4);
  return Object.assign(defaultParameters, endpointParameters);
};
var _defaultS3HttpAuthSchemeParametersProvider = async (config4, context, input) => {
  return {
    operation: getSmithyContext(context).operation,
    region: await normalizeProvider(config4.region)() || (() => {
      throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
    })()
  };
};
var defaultS3HttpAuthSchemeParametersProvider = createEndpointRuleSetHttpAuthSchemeParametersProvider(_defaultS3HttpAuthSchemeParametersProvider);
function createAwsAuthSigv4HttpAuthOption(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "s3",
      region: authParameters.region
    },
    propertiesExtractor: (config4, context) => ({
      signingProperties: {
        config: config4,
        context
      }
    })
  };
}
function createAwsAuthSigv4aHttpAuthOption(authParameters) {
  return {
    schemeId: "aws.auth#sigv4a",
    signingProperties: {
      name: "s3",
      region: authParameters.region
    },
    propertiesExtractor: (config4, context) => ({
      signingProperties: {
        config: config4,
        context
      }
    })
  };
}
var createEndpointRuleSetHttpAuthSchemeProvider = (defaultEndpointResolver2, defaultHttpAuthSchemeResolver, createHttpAuthOptionFunctions) => {
  const endpointRuleSetHttpAuthSchemeProvider = (authParameters) => {
    const endpoint = defaultEndpointResolver2(authParameters);
    const authSchemes = endpoint.properties?.authSchemes;
    if (!authSchemes) {
      return defaultHttpAuthSchemeResolver(authParameters);
    }
    const options = [];
    for (const scheme of authSchemes) {
      const { name: resolvedName, properties = {}, ...rest } = scheme;
      const name = resolvedName.toLowerCase();
      if (resolvedName !== name) {
        console.warn(`HttpAuthScheme has been normalized with lowercasing: \`${resolvedName}\` to \`${name}\``);
      }
      let schemeId;
      if (name === "sigv4a") {
        schemeId = "aws.auth#sigv4a";
        const sigv4Present = authSchemes.find((s4) => {
          const name2 = s4.name.toLowerCase();
          return name2 !== "sigv4a" && name2.startsWith("sigv4");
        });
        if (!signatureV4CrtContainer.CrtSignerV4 && sigv4Present) {
          continue;
        }
      } else if (name.startsWith("sigv4")) {
        schemeId = "aws.auth#sigv4";
      } else {
        throw new Error(`Unknown HttpAuthScheme found in \`@smithy.rules#endpointRuleSet\`: \`${name}\``);
      }
      const createOption = createHttpAuthOptionFunctions[schemeId];
      if (!createOption) {
        throw new Error(`Could not find HttpAuthOption create function for \`${schemeId}\``);
      }
      const option = createOption(authParameters);
      option.schemeId = schemeId;
      option.signingProperties = { ...option.signingProperties || {}, ...rest, ...properties };
      options.push(option);
    }
    return options;
  };
  return endpointRuleSetHttpAuthSchemeProvider;
};
var _defaultS3HttpAuthSchemeProvider = (authParameters) => {
  const options = [];
  switch (authParameters.operation) {
    default: {
      options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
      options.push(createAwsAuthSigv4aHttpAuthOption(authParameters));
    }
  }
  return options;
};
var defaultS3HttpAuthSchemeProvider = createEndpointRuleSetHttpAuthSchemeProvider(defaultEndpointResolver, _defaultS3HttpAuthSchemeProvider, {
  "aws.auth#sigv4": createAwsAuthSigv4HttpAuthOption,
  "aws.auth#sigv4a": createAwsAuthSigv4aHttpAuthOption
});
var resolveHttpAuthSchemeConfig = (config4) => {
  const config_0 = import_core8.resolveAwsSdkSigV4Config(config4);
  const config_1 = import_core8.resolveAwsSdkSigV4AConfig(config_0);
  return {
    ...config_1
  };
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/commands/CreateSessionCommand.js
init_dist_es25();
init_dist_es24();
init_dist_es14();

// ../../node_modules/@aws-sdk/client-s3/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters = (options) => {
  return {
    ...options,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    forcePathStyle: options.forcePathStyle ?? false,
    useAccelerateEndpoint: options.useAccelerateEndpoint ?? false,
    useGlobalEndpoint: options.useGlobalEndpoint ?? false,
    disableMultiregionAccessPoints: options.disableMultiregionAccessPoints ?? false,
    defaultSigningName: "s3"
  };
};
var commonParams = {
  ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
  UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
  DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
  Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
  DisableS3ExpressSessionAuth: { type: "clientContextParams", name: "disableS3ExpressSessionAuth" },
  UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
  UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
  Endpoint: { type: "builtInParams", name: "endpoint" },
  Region: { type: "builtInParams", name: "region" },
  UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/models/models_0.js
init_dist_es14();

// ../../node_modules/@aws-sdk/client-s3/dist-es/models/S3ServiceException.js
init_dist_es14();
class S3ServiceException extends ServiceException {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, S3ServiceException.prototype);
  }
}

// ../../node_modules/@aws-sdk/client-s3/dist-es/models/models_0.js
class NoSuchUpload extends S3ServiceException {
  name = "NoSuchUpload";
  $fault = "client";
  constructor(opts) {
    super({
      name: "NoSuchUpload",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, NoSuchUpload.prototype);
  }
}
class ObjectNotInActiveTierError extends S3ServiceException {
  name = "ObjectNotInActiveTierError";
  $fault = "client";
  constructor(opts) {
    super({
      name: "ObjectNotInActiveTierError",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, ObjectNotInActiveTierError.prototype);
  }
}

class BucketAlreadyExists extends S3ServiceException {
  name = "BucketAlreadyExists";
  $fault = "client";
  constructor(opts) {
    super({
      name: "BucketAlreadyExists",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, BucketAlreadyExists.prototype);
  }
}

class BucketAlreadyOwnedByYou extends S3ServiceException {
  name = "BucketAlreadyOwnedByYou";
  $fault = "client";
  constructor(opts) {
    super({
      name: "BucketAlreadyOwnedByYou",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, BucketAlreadyOwnedByYou.prototype);
  }
}
class NoSuchBucket extends S3ServiceException {
  name = "NoSuchBucket";
  $fault = "client";
  constructor(opts) {
    super({
      name: "NoSuchBucket",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, NoSuchBucket.prototype);
  }
}
var AnalyticsFilter;
(function(AnalyticsFilter2) {
  AnalyticsFilter2.visit = (value, visitor) => {
    if (value.Prefix !== undefined)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== undefined)
      return visitor.Tag(value.Tag);
    if (value.And !== undefined)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(AnalyticsFilter || (AnalyticsFilter = {}));
var MetricsFilter;
(function(MetricsFilter2) {
  MetricsFilter2.visit = (value, visitor) => {
    if (value.Prefix !== undefined)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== undefined)
      return visitor.Tag(value.Tag);
    if (value.AccessPointArn !== undefined)
      return visitor.AccessPointArn(value.AccessPointArn);
    if (value.And !== undefined)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(MetricsFilter || (MetricsFilter = {}));
class InvalidObjectState extends S3ServiceException {
  name = "InvalidObjectState";
  $fault = "client";
  StorageClass;
  AccessTier;
  constructor(opts) {
    super({
      name: "InvalidObjectState",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidObjectState.prototype);
    this.StorageClass = opts.StorageClass;
    this.AccessTier = opts.AccessTier;
  }
}

class NoSuchKey extends S3ServiceException {
  name = "NoSuchKey";
  $fault = "client";
  constructor(opts) {
    super({
      name: "NoSuchKey",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, NoSuchKey.prototype);
  }
}
class NotFound extends S3ServiceException {
  name = "NotFound";
  $fault = "client";
  constructor(opts) {
    super({
      name: "NotFound",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, NotFound.prototype);
  }
}
var SessionCredentialsFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SecretAccessKey && { SecretAccessKey: SENSITIVE_STRING },
  ...obj.SessionToken && { SessionToken: SENSITIVE_STRING }
});
var CreateSessionOutputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
  ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING },
  ...obj.Credentials && { Credentials: SessionCredentialsFilterSensitiveLog(obj.Credentials) }
});
var CreateSessionRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
  ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }
});

// ../../node_modules/@aws-sdk/client-s3/dist-es/protocols/Aws_restXml.js
var import_core9 = __toESM(require_dist_cjs20(), 1);
var import_core10 = __toESM(require_dist_cjs15(), 1);
init_dist_es();
init_dist_es14();

// ../../node_modules/@aws-sdk/client-s3/dist-es/models/models_1.js
init_dist_es14();
class EncryptionTypeMismatch extends S3ServiceException {
  name = "EncryptionTypeMismatch";
  $fault = "client";
  constructor(opts) {
    super({
      name: "EncryptionTypeMismatch",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, EncryptionTypeMismatch.prototype);
  }
}

class InvalidRequest extends S3ServiceException {
  name = "InvalidRequest";
  $fault = "client";
  constructor(opts) {
    super({
      name: "InvalidRequest",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidRequest.prototype);
  }
}

class InvalidWriteOffset extends S3ServiceException {
  name = "InvalidWriteOffset";
  $fault = "client";
  constructor(opts) {
    super({
      name: "InvalidWriteOffset",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidWriteOffset.prototype);
  }
}

class TooManyParts extends S3ServiceException {
  name = "TooManyParts";
  $fault = "client";
  constructor(opts) {
    super({
      name: "TooManyParts",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, TooManyParts.prototype);
  }
}

class ObjectAlreadyInActiveTierError extends S3ServiceException {
  name = "ObjectAlreadyInActiveTierError";
  $fault = "client";
  constructor(opts) {
    super({
      name: "ObjectAlreadyInActiveTierError",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, ObjectAlreadyInActiveTierError.prototype);
  }
}
var SelectObjectContentEventStream;
(function(SelectObjectContentEventStream2) {
  SelectObjectContentEventStream2.visit = (value, visitor) => {
    if (value.Records !== undefined)
      return visitor.Records(value.Records);
    if (value.Stats !== undefined)
      return visitor.Stats(value.Stats);
    if (value.Progress !== undefined)
      return visitor.Progress(value.Progress);
    if (value.Cont !== undefined)
      return visitor.Cont(value.Cont);
    if (value.End !== undefined)
      return visitor.End(value.End);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(SelectObjectContentEventStream || (SelectObjectContentEventStream = {}));

// ../../node_modules/@aws-sdk/client-s3/dist-es/protocols/Aws_restXml.js
var se_CreateSessionCommand = async (input, context) => {
  const b2 = import_core10.requestBuilder(input, context);
  const headers = map({}, isSerializableHeaderValue, {
    [_xacsm]: input[_SM],
    [_xasse]: input[_SSE],
    [_xasseakki]: input[_SSEKMSKI],
    [_xassec]: input[_SSEKMSEC],
    [_xassebke]: [() => isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()]
  });
  b2.bp("/");
  b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
  const query = map({
    [_s]: [, ""]
  });
  let body;
  b2.m("GET").h(headers).q(query).b(body);
  return b2.build();
};
var de_CreateSessionCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const contents = map({
    $metadata: deserializeMetadata2(output),
    [_SSE]: [, output.headers[_xasse]],
    [_SSEKMSKI]: [, output.headers[_xasseakki]],
    [_SSEKMSEC]: [, output.headers[_xassec]],
    [_BKE]: [() => output.headers[_xassebke] !== undefined, () => parseBoolean(output.headers[_xassebke])]
  });
  const data = expectNonNull(expectObject(await import_core9.parseXmlBody(output.body, context)), "body");
  if (data[_C] != null) {
    contents[_C] = de_SessionCredentials(data[_C], context);
  }
  return contents;
};
var de_CommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await import_core9.parseXmlErrorBody(output.body, context)
  };
  const errorCode = import_core9.loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NoSuchUpload":
    case "com.amazonaws.s3#NoSuchUpload":
      throw await de_NoSuchUploadRes(parsedOutput, context);
    case "ObjectNotInActiveTierError":
    case "com.amazonaws.s3#ObjectNotInActiveTierError":
      throw await de_ObjectNotInActiveTierErrorRes(parsedOutput, context);
    case "BucketAlreadyExists":
    case "com.amazonaws.s3#BucketAlreadyExists":
      throw await de_BucketAlreadyExistsRes(parsedOutput, context);
    case "BucketAlreadyOwnedByYou":
    case "com.amazonaws.s3#BucketAlreadyOwnedByYou":
      throw await de_BucketAlreadyOwnedByYouRes(parsedOutput, context);
    case "NoSuchBucket":
    case "com.amazonaws.s3#NoSuchBucket":
      throw await de_NoSuchBucketRes(parsedOutput, context);
    case "InvalidObjectState":
    case "com.amazonaws.s3#InvalidObjectState":
      throw await de_InvalidObjectStateRes(parsedOutput, context);
    case "NoSuchKey":
    case "com.amazonaws.s3#NoSuchKey":
      throw await de_NoSuchKeyRes(parsedOutput, context);
    case "NotFound":
    case "com.amazonaws.s3#NotFound":
      throw await de_NotFoundRes(parsedOutput, context);
    case "EncryptionTypeMismatch":
    case "com.amazonaws.s3#EncryptionTypeMismatch":
      throw await de_EncryptionTypeMismatchRes(parsedOutput, context);
    case "InvalidRequest":
    case "com.amazonaws.s3#InvalidRequest":
      throw await de_InvalidRequestRes(parsedOutput, context);
    case "InvalidWriteOffset":
    case "com.amazonaws.s3#InvalidWriteOffset":
      throw await de_InvalidWriteOffsetRes(parsedOutput, context);
    case "TooManyParts":
    case "com.amazonaws.s3#TooManyParts":
      throw await de_TooManyPartsRes(parsedOutput, context);
    case "ObjectAlreadyInActiveTierError":
    case "com.amazonaws.s3#ObjectAlreadyInActiveTierError":
      throw await de_ObjectAlreadyInActiveTierErrorRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError2({
        output,
        parsedBody,
        errorCode
      });
  }
};
var throwDefaultError2 = withBaseException(S3ServiceException);
var de_BucketAlreadyExistsRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new BucketAlreadyExists({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_BucketAlreadyOwnedByYouRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new BucketAlreadyOwnedByYou({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_EncryptionTypeMismatchRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new EncryptionTypeMismatch({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_InvalidObjectStateRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  if (data[_AT] != null) {
    contents[_AT] = expectString(data[_AT]);
  }
  if (data[_SC] != null) {
    contents[_SC] = expectString(data[_SC]);
  }
  const exception = new InvalidObjectState({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_InvalidRequestRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new InvalidRequest({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_InvalidWriteOffsetRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new InvalidWriteOffset({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_NoSuchBucketRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new NoSuchBucket({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_NoSuchKeyRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new NoSuchKey({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_NoSuchUploadRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new NoSuchUpload({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_NotFoundRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new NotFound({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_ObjectAlreadyInActiveTierErrorRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new ObjectAlreadyInActiveTierError({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_ObjectNotInActiveTierErrorRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new ObjectNotInActiveTierError({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_TooManyPartsRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new TooManyParts({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_SessionCredentials = (output, context) => {
  const contents = {};
  if (output[_AKI] != null) {
    contents[_AKI] = expectString(output[_AKI]);
  }
  if (output[_SAK] != null) {
    contents[_SAK] = expectString(output[_SAK]);
  }
  if (output[_ST] != null) {
    contents[_ST] = expectString(output[_ST]);
  }
  if (output[_Exp] != null) {
    contents[_Exp] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_Exp]));
  }
  return contents;
};
var deserializeMetadata2 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var _AKI = "AccessKeyId";
var _AT = "AccessTier";
var _BKE = "BucketKeyEnabled";
var _C = "Credentials";
var _Exp = "Expiration";
var _SAK = "SecretAccessKey";
var _SC = "StorageClass";
var _SM = "SessionMode";
var _SSE = "ServerSideEncryption";
var _SSEKMSEC = "SSEKMSEncryptionContext";
var _SSEKMSKI = "SSEKMSKeyId";
var _ST = "SessionToken";
var _s = "session";
var _xacsm = "x-amz-create-session-mode";
var _xasse = "x-amz-server-side-encryption";
var _xasseakki = "x-amz-server-side-encryption-aws-kms-key-id";
var _xassebke = "x-amz-server-side-encryption-bucket-key-enabled";
var _xassec = "x-amz-server-side-encryption-context";

// ../../node_modules/@aws-sdk/client-s3/dist-es/commands/CreateSessionCommand.js
class CreateSessionCommand extends Command.classBuilder().ep({
  ...commonParams,
  DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
  Bucket: { type: "contextParams", name: "Bucket" }
}).m(function(Command2, cs2, config4, o2) {
  return [
    getSerdePlugin(config4, this.serialize, this.deserialize),
    getEndpointPlugin(config4, Command2.getEndpointParameterInstructions()),
    getThrow200ExceptionsPlugin(config4)
  ];
}).s("AmazonS3", "CreateSession", {}).n("S3Client", "CreateSessionCommand").f(CreateSessionRequestFilterSensitiveLog, CreateSessionOutputFilterSensitiveLog).ser(se_CreateSessionCommand).de(de_CreateSessionCommand).build() {
}
// ../../node_modules/@aws-sdk/client-s3/package.json
var package_default = {
  name: "@aws-sdk/client-s3",
  description: "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native",
  version: "3.735.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline client-s3",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo s3",
    test: "yarn g:vitest run",
    "test:browser": "node ./test/browser-build/esbuild && yarn g:vitest run -c vitest.config.browser.ts",
    "test:browser:watch": "node ./test/browser-build/esbuild && yarn g:vitest watch -c vitest.config.browser.ts",
    "test:e2e": "yarn g:vitest run -c vitest.config.e2e.ts && yarn test:browser",
    "test:e2e:watch": "yarn g:vitest watch -c vitest.config.e2e.ts",
    "test:watch": "yarn g:vitest watch"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha1-browser": "5.2.0",
    "@aws-crypto/sha256-browser": "5.2.0",
    "@aws-crypto/sha256-js": "5.2.0",
    "@aws-sdk/core": "3.734.0",
    "@aws-sdk/credential-provider-node": "3.734.0",
    "@aws-sdk/middleware-bucket-endpoint": "3.734.0",
    "@aws-sdk/middleware-expect-continue": "3.734.0",
    "@aws-sdk/middleware-flexible-checksums": "3.735.0",
    "@aws-sdk/middleware-host-header": "3.734.0",
    "@aws-sdk/middleware-location-constraint": "3.734.0",
    "@aws-sdk/middleware-logger": "3.734.0",
    "@aws-sdk/middleware-recursion-detection": "3.734.0",
    "@aws-sdk/middleware-sdk-s3": "3.734.0",
    "@aws-sdk/middleware-ssec": "3.734.0",
    "@aws-sdk/middleware-user-agent": "3.734.0",
    "@aws-sdk/region-config-resolver": "3.734.0",
    "@aws-sdk/signature-v4-multi-region": "3.734.0",
    "@aws-sdk/types": "3.734.0",
    "@aws-sdk/util-endpoints": "3.734.0",
    "@aws-sdk/util-user-agent-browser": "3.734.0",
    "@aws-sdk/util-user-agent-node": "3.734.0",
    "@aws-sdk/xml-builder": "3.734.0",
    "@smithy/config-resolver": "^4.0.1",
    "@smithy/core": "^3.1.1",
    "@smithy/eventstream-serde-browser": "^4.0.1",
    "@smithy/eventstream-serde-config-resolver": "^4.0.1",
    "@smithy/eventstream-serde-node": "^4.0.1",
    "@smithy/fetch-http-handler": "^5.0.1",
    "@smithy/hash-blob-browser": "^4.0.1",
    "@smithy/hash-node": "^4.0.1",
    "@smithy/hash-stream-node": "^4.0.1",
    "@smithy/invalid-dependency": "^4.0.1",
    "@smithy/md5-js": "^4.0.1",
    "@smithy/middleware-content-length": "^4.0.1",
    "@smithy/middleware-endpoint": "^4.0.2",
    "@smithy/middleware-retry": "^4.0.3",
    "@smithy/middleware-serde": "^4.0.1",
    "@smithy/middleware-stack": "^4.0.1",
    "@smithy/node-config-provider": "^4.0.1",
    "@smithy/node-http-handler": "^4.0.2",
    "@smithy/protocol-http": "^5.0.1",
    "@smithy/smithy-client": "^4.1.2",
    "@smithy/types": "^4.1.0",
    "@smithy/url-parser": "^4.0.1",
    "@smithy/util-base64": "^4.0.0",
    "@smithy/util-body-length-browser": "^4.0.0",
    "@smithy/util-body-length-node": "^4.0.0",
    "@smithy/util-defaults-mode-browser": "^4.0.3",
    "@smithy/util-defaults-mode-node": "^4.0.3",
    "@smithy/util-endpoints": "^3.0.1",
    "@smithy/util-middleware": "^4.0.1",
    "@smithy/util-retry": "^4.0.1",
    "@smithy/util-stream": "^4.0.2",
    "@smithy/util-utf8": "^4.0.0",
    "@smithy/util-waiter": "^4.0.2",
    tslib: "^2.6.2"
  },
  devDependencies: {
    "@aws-sdk/signature-v4-crt": "3.734.0",
    "@tsconfig/node18": "18.2.4",
    "@types/node": "^18.19.69",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typescript: "~5.2.2"
  },
  engines: {
    node: ">=18.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-s3"
  }
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.js
var import_core21 = __toESM(require_dist_cjs20(), 1);

// ../../node_modules/@aws-sdk/credential-provider-node/dist-es/defaultProvider.js
init_dist_es29();
var import_property_provider28 = __toESM(require_dist_cjs16(), 1);
init_dist_es21();

// ../../node_modules/@aws-sdk/credential-provider-node/dist-es/remoteProvider.js
var import_property_provider13 = __toESM(require_dist_cjs16(), 1);
var ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
var remoteProvider = async (init2) => {
  const { ENV_CMDS_FULL_URI: ENV_CMDS_FULL_URI2, ENV_CMDS_RELATIVE_URI: ENV_CMDS_RELATIVE_URI2, fromContainerMetadata: fromContainerMetadata3, fromInstanceMetadata: fromInstanceMetadata3 } = await Promise.resolve().then(() => (init_dist_es30(), exports_dist_es2));
  if (process.env[ENV_CMDS_RELATIVE_URI2] || process.env[ENV_CMDS_FULL_URI2]) {
    init2.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata");
    const { fromHttp: fromHttp2 } = await Promise.resolve().then(() => (init_dist_es31(), exports_dist_es3));
    return import_property_provider13.chain(fromHttp2(init2), fromContainerMetadata3(init2));
  }
  if (process.env[ENV_IMDS_DISABLED]) {
    return async () => {
      throw new import_property_provider13.CredentialsProviderError("EC2 Instance Metadata Service access disabled", { logger: init2.logger });
    };
  }
  init2.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata");
  return fromInstanceMetadata3(init2);
};

// ../../node_modules/@aws-sdk/credential-provider-node/dist-es/defaultProvider.js
var multipleCredentialSourceWarningEmitted = false;
var defaultProvider = (init2 = {}) => import_property_provider28.memoize(import_property_provider28.chain(async () => {
  const profile = init2.profile ?? process.env[ENV_PROFILE];
  if (profile) {
    const envStaticCredentialsAreSet = process.env[ENV_KEY] && process.env[ENV_SECRET];
    if (envStaticCredentialsAreSet) {
      if (!multipleCredentialSourceWarningEmitted) {
        const warnFn = init2.logger?.warn && init2.logger?.constructor?.name !== "NoOpLogger" ? init2.logger.warn : console.warn;
        warnFn(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`);
        multipleCredentialSourceWarningEmitted = true;
      }
    }
    throw new import_property_provider28.CredentialsProviderError("AWS_PROFILE is set, skipping fromEnv provider.", {
      logger: init2.logger,
      tryNextLink: true
    });
  }
  init2.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromEnv");
  return fromEnv2(init2)();
}, async () => {
  init2.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromSSO");
  const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init2;
  if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
    throw new import_property_provider28.CredentialsProviderError("Skipping SSO provider in default chain (inputs do not include SSO fields).", { logger: init2.logger });
  }
  const { fromSSO: fromSSO3 } = await Promise.resolve().then(() => (init_dist_es39(), exports_dist_es4));
  return fromSSO3(init2)();
}, async () => {
  init2.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromIni");
  const { fromIni: fromIni3 } = await Promise.resolve().then(() => (init_dist_es42(), exports_dist_es7));
  return fromIni3(init2)();
}, async () => {
  init2.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromProcess");
  const { fromProcess: fromProcess3 } = await Promise.resolve().then(() => (init_dist_es40(), exports_dist_es5));
  return fromProcess3(init2)();
}, async () => {
  init2.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile");
  const { fromTokenFile: fromTokenFile3 } = await Promise.resolve().then(() => (init_dist_es41(), exports_dist_es6));
  return fromTokenFile3(init2)();
}, async () => {
  init2.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::remoteProvider");
  return (await remoteProvider(init2))();
}, async () => {
  throw new import_property_provider28.CredentialsProviderError("Could not load credentials from any providers", {
    tryNextLink: false,
    logger: init2.logger
  });
}), credentialsTreatedAsExpired, credentialsWillNeedRefresh);
var credentialsWillNeedRefresh = (credentials) => credentials?.expiration !== undefined;
var credentialsTreatedAsExpired = (credentials) => credentials?.expiration !== undefined && credentials.expiration.getTime() - Date.now() < 300000;
// ../../node_modules/@aws-sdk/middleware-bucket-endpoint/dist-es/NodeDisableMultiregionAccessPointConfigOptions.js
init_dist_es15();
// ../../node_modules/@aws-sdk/middleware-bucket-endpoint/dist-es/NodeUseArnRegionConfigOptions.js
init_dist_es15();
var NODE_USE_ARN_REGION_ENV_NAME = "AWS_S3_USE_ARN_REGION";
var NODE_USE_ARN_REGION_INI_NAME = "s3_use_arn_region";
var NODE_USE_ARN_REGION_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => booleanSelector(env3, NODE_USE_ARN_REGION_ENV_NAME, SelectorType2.ENV),
  configFileSelector: (profile) => booleanSelector(profile, NODE_USE_ARN_REGION_INI_NAME, SelectorType2.CONFIG),
  default: false
};
// ../../node_modules/@aws-sdk/middleware-bucket-endpoint/dist-es/bucketEndpointMiddleware.js
init_dist_es();
// ../../node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.js
init_dist_es33();
init_dist_es19();

// ../../node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js
var import_util_hex_encoding7 = __toESM(require_dist_cjs13(), 1);

// ../../node_modules/@smithy/eventstream-codec/dist-es/Int64.js
var import_util_hex_encoding6 = __toESM(require_dist_cjs13(), 1);

class Int642 {
  constructor(bytes) {
    this.bytes = bytes;
    if (bytes.byteLength !== 8) {
      throw new Error("Int64 buffers must be exactly 8 bytes");
    }
  }
  static fromNumber(number) {
    if (number > 9223372036854776000 || number < -9223372036854776000) {
      throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
    }
    const bytes = new Uint8Array(8);
    for (let i4 = 7, remaining = Math.abs(Math.round(number));i4 > -1 && remaining > 0; i4--, remaining /= 256) {
      bytes[i4] = remaining;
    }
    if (number < 0) {
      negate2(bytes);
    }
    return new Int642(bytes);
  }
  valueOf() {
    const bytes = this.bytes.slice(0);
    const negative = bytes[0] & 128;
    if (negative) {
      negate2(bytes);
    }
    return parseInt(import_util_hex_encoding6.toHex(bytes), 16) * (negative ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
}
function negate2(bytes) {
  for (let i4 = 0;i4 < 8; i4++) {
    bytes[i4] ^= 255;
  }
  for (let i4 = 7;i4 > -1; i4--) {
    bytes[i4]++;
    if (bytes[i4] !== 0)
      break;
  }
}

// ../../node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js
class HeaderMarshaller {
  constructor(toUtf84, fromUtf86) {
    this.toUtf8 = toUtf84;
    this.fromUtf8 = fromUtf86;
  }
  format(headers) {
    const chunks = [];
    for (const headerName of Object.keys(headers)) {
      const bytes = this.fromUtf8(headerName);
      chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
    }
    const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
    let position = 0;
    for (const chunk of chunks) {
      out.set(chunk, position);
      position += chunk.byteLength;
    }
    return out;
  }
  formatHeaderValue(header) {
    switch (header.type) {
      case "boolean":
        return Uint8Array.from([header.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, header.value]);
      case "short":
        const shortView = new DataView(new ArrayBuffer(3));
        shortView.setUint8(0, 3);
        shortView.setInt16(1, header.value, false);
        return new Uint8Array(shortView.buffer);
      case "integer":
        const intView = new DataView(new ArrayBuffer(5));
        intView.setUint8(0, 4);
        intView.setInt32(1, header.value, false);
        return new Uint8Array(intView.buffer);
      case "long":
        const longBytes = new Uint8Array(9);
        longBytes[0] = 5;
        longBytes.set(header.value.bytes, 1);
        return longBytes;
      case "binary":
        const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
        binView.setUint8(0, 6);
        binView.setUint16(1, header.value.byteLength, false);
        const binBytes = new Uint8Array(binView.buffer);
        binBytes.set(header.value, 3);
        return binBytes;
      case "string":
        const utf8Bytes = this.fromUtf8(header.value);
        const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
        strView.setUint8(0, 7);
        strView.setUint16(1, utf8Bytes.byteLength, false);
        const strBytes = new Uint8Array(strView.buffer);
        strBytes.set(utf8Bytes, 3);
        return strBytes;
      case "timestamp":
        const tsBytes = new Uint8Array(9);
        tsBytes[0] = 8;
        tsBytes.set(Int642.fromNumber(header.value.valueOf()).bytes, 1);
        return tsBytes;
      case "uuid":
        if (!UUID_PATTERN2.test(header.value)) {
          throw new Error(`Invalid UUID received: ${header.value}`);
        }
        const uuidBytes = new Uint8Array(17);
        uuidBytes[0] = 9;
        uuidBytes.set(import_util_hex_encoding7.fromHex(header.value.replace(/\-/g, "")), 1);
        return uuidBytes;
    }
  }
  parse(headers) {
    const out = {};
    let position = 0;
    while (position < headers.byteLength) {
      const nameLength = headers.getUint8(position++);
      const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
      position += nameLength;
      switch (headers.getUint8(position++)) {
        case 0:
          out[name] = {
            type: BOOLEAN_TAG,
            value: true
          };
          break;
        case 1:
          out[name] = {
            type: BOOLEAN_TAG,
            value: false
          };
          break;
        case 2:
          out[name] = {
            type: BYTE_TAG,
            value: headers.getInt8(position++)
          };
          break;
        case 3:
          out[name] = {
            type: SHORT_TAG,
            value: headers.getInt16(position, false)
          };
          position += 2;
          break;
        case 4:
          out[name] = {
            type: INT_TAG,
            value: headers.getInt32(position, false)
          };
          position += 4;
          break;
        case 5:
          out[name] = {
            type: LONG_TAG,
            value: new Int642(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))
          };
          position += 8;
          break;
        case 6:
          const binaryLength = headers.getUint16(position, false);
          position += 2;
          out[name] = {
            type: BINARY_TAG,
            value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)
          };
          position += binaryLength;
          break;
        case 7:
          const stringLength = headers.getUint16(position, false);
          position += 2;
          out[name] = {
            type: STRING_TAG,
            value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))
          };
          position += stringLength;
          break;
        case 8:
          out[name] = {
            type: TIMESTAMP_TAG,
            value: new Date(new Int642(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())
          };
          position += 8;
          break;
        case 9:
          const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
          position += 16;
          out[name] = {
            type: UUID_TAG,
            value: `${import_util_hex_encoding7.toHex(uuidBytes.subarray(0, 4))}-${import_util_hex_encoding7.toHex(uuidBytes.subarray(4, 6))}-${import_util_hex_encoding7.toHex(uuidBytes.subarray(6, 8))}-${import_util_hex_encoding7.toHex(uuidBytes.subarray(8, 10))}-${import_util_hex_encoding7.toHex(uuidBytes.subarray(10))}`
          };
          break;
        default:
          throw new Error(`Unrecognized header type tag`);
      }
    }
    return out;
  }
}
var HEADER_VALUE_TYPE2;
(function(HEADER_VALUE_TYPE3) {
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolTrue"] = 0] = "boolTrue";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolFalse"] = 1] = "boolFalse";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byte"] = 2] = "byte";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["short"] = 3] = "short";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["integer"] = 4] = "integer";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["long"] = 5] = "long";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byteArray"] = 6] = "byteArray";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["string"] = 7] = "string";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["timestamp"] = 8] = "timestamp";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE2 || (HEADER_VALUE_TYPE2 = {}));
var BOOLEAN_TAG = "boolean";
var BYTE_TAG = "byte";
var SHORT_TAG = "short";
var INT_TAG = "integer";
var LONG_TAG = "long";
var BINARY_TAG = "binary";
var STRING_TAG = "string";
var TIMESTAMP_TAG = "timestamp";
var UUID_TAG = "uuid";
var UUID_PATTERN2 = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;

// ../../node_modules/@smithy/eventstream-codec/dist-es/splitMessage.js
var PRELUDE_MEMBER_LENGTH = 4;
var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
var CHECKSUM_LENGTH = 4;
var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
function splitMessage({ byteLength, byteOffset, buffer }) {
  if (byteLength < MINIMUM_MESSAGE_LENGTH) {
    throw new Error("Provided message too short to accommodate event stream message overhead");
  }
  const view = new DataView(buffer, byteOffset, byteLength);
  const messageLength = view.getUint32(0, false);
  if (byteLength !== messageLength) {
    throw new Error("Reported message length does not match received message length");
  }
  const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
  const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
  const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);
  const checksummer = new Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
  if (expectedPreludeChecksum !== checksummer.digest()) {
    throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
  }
  checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
  if (expectedMessageChecksum !== checksummer.digest()) {
    throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
  }
  return {
    headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
    body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))
  };
}

// ../../node_modules/@smithy/eventstream-codec/dist-es/EventStreamCodec.js
class EventStreamCodec {
  constructor(toUtf84, fromUtf86) {
    this.headerMarshaller = new HeaderMarshaller(toUtf84, fromUtf86);
    this.messageBuffer = [];
    this.isEndOfStream = false;
  }
  feed(message) {
    this.messageBuffer.push(this.decode(message));
  }
  endOfStream() {
    this.isEndOfStream = true;
  }
  getMessage() {
    const message = this.messageBuffer.pop();
    const isEndOfStream = this.isEndOfStream;
    return {
      getMessage() {
        return message;
      },
      isEndOfStream() {
        return isEndOfStream;
      }
    };
  }
  getAvailableMessages() {
    const messages = this.messageBuffer;
    this.messageBuffer = [];
    const isEndOfStream = this.isEndOfStream;
    return {
      getMessages() {
        return messages;
      },
      isEndOfStream() {
        return isEndOfStream;
      }
    };
  }
  encode({ headers: rawHeaders, body }) {
    const headers = this.headerMarshaller.format(rawHeaders);
    const length = headers.byteLength + body.byteLength + 16;
    const out = new Uint8Array(length);
    const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    const checksum = new Crc32;
    view.setUint32(0, length, false);
    view.setUint32(4, headers.byteLength, false);
    view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);
    out.set(headers, 12);
    out.set(body, headers.byteLength + 12);
    view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);
    return out;
  }
  decode(message) {
    const { headers, body } = splitMessage(message);
    return { headers: this.headerMarshaller.parse(headers), body };
  }
  formatHeaders(rawHeaders) {
    return this.headerMarshaller.format(rawHeaders);
  }
}
// ../../node_modules/@smithy/eventstream-codec/dist-es/MessageDecoderStream.js
class MessageDecoderStream {
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async* asyncIterator() {
    for await (const bytes of this.options.inputStream) {
      const decoded = this.options.decoder.decode(bytes);
      yield decoded;
    }
  }
}
// ../../node_modules/@smithy/eventstream-codec/dist-es/MessageEncoderStream.js
class MessageEncoderStream {
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async* asyncIterator() {
    for await (const msg of this.options.messageStream) {
      const encoded = this.options.encoder.encode(msg);
      yield encoded;
    }
    if (this.options.includeEndFrame) {
      yield new Uint8Array(0);
    }
  }
}
// ../../node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageDecoderStream.js
class SmithyMessageDecoderStream {
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async* asyncIterator() {
    for await (const message of this.options.messageStream) {
      const deserialized = await this.options.deserializer(message);
      if (deserialized === undefined)
        continue;
      yield deserialized;
    }
  }
}
// ../../node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageEncoderStream.js
class SmithyMessageEncoderStream {
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async* asyncIterator() {
    for await (const chunk of this.options.inputStream) {
      const payloadBuf = this.options.serializer(chunk);
      yield payloadBuf;
    }
  }
}
// ../../node_modules/@smithy/eventstream-serde-universal/dist-es/getChunkedStream.js
function getChunkedStream(source) {
  let currentMessageTotalLength = 0;
  let currentMessagePendingLength = 0;
  let currentMessage = null;
  let messageLengthBuffer = null;
  const allocateMessage = (size) => {
    if (typeof size !== "number") {
      throw new Error("Attempted to allocate an event message where size was not a number: " + size);
    }
    currentMessageTotalLength = size;
    currentMessagePendingLength = 4;
    currentMessage = new Uint8Array(size);
    const currentMessageView = new DataView(currentMessage.buffer);
    currentMessageView.setUint32(0, size, false);
  };
  const iterator = async function* () {
    const sourceIterator = source[Symbol.asyncIterator]();
    while (true) {
      const { value, done } = await sourceIterator.next();
      if (done) {
        if (!currentMessageTotalLength) {
          return;
        } else if (currentMessageTotalLength === currentMessagePendingLength) {
          yield currentMessage;
        } else {
          throw new Error("Truncated event message received.");
        }
        return;
      }
      const chunkLength = value.length;
      let currentOffset = 0;
      while (currentOffset < chunkLength) {
        if (!currentMessage) {
          const bytesRemaining = chunkLength - currentOffset;
          if (!messageLengthBuffer) {
            messageLengthBuffer = new Uint8Array(4);
          }
          const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);
          messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);
          currentMessagePendingLength += numBytesForTotal;
          currentOffset += numBytesForTotal;
          if (currentMessagePendingLength < 4) {
            break;
          }
          allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));
          messageLengthBuffer = null;
        }
        const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);
        currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);
        currentMessagePendingLength += numBytesToWrite;
        currentOffset += numBytesToWrite;
        if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {
          yield currentMessage;
          currentMessage = null;
          currentMessageTotalLength = 0;
          currentMessagePendingLength = 0;
        }
      }
    }
  };
  return {
    [Symbol.asyncIterator]: iterator
  };
}

// ../../node_modules/@smithy/eventstream-serde-universal/dist-es/getUnmarshalledStream.js
function getMessageUnmarshaller(deserializer, toUtf84) {
  return async function(message) {
    const { value: messageType } = message.headers[":message-type"];
    if (messageType === "error") {
      const unmodeledError = new Error(message.headers[":error-message"].value || "UnknownError");
      unmodeledError.name = message.headers[":error-code"].value;
      throw unmodeledError;
    } else if (messageType === "exception") {
      const code = message.headers[":exception-type"].value;
      const exception = { [code]: message };
      const deserializedException = await deserializer(exception);
      if (deserializedException.$unknown) {
        const error = new Error(toUtf84(message.body));
        error.name = code;
        throw error;
      }
      throw deserializedException[code];
    } else if (messageType === "event") {
      const event = {
        [message.headers[":event-type"].value]: message
      };
      const deserialized = await deserializer(event);
      if (deserialized.$unknown)
        return;
      return deserialized;
    } else {
      throw Error(`Unrecognizable event type: ${message.headers[":event-type"].value}`);
    }
  };
}

// ../../node_modules/@smithy/eventstream-serde-universal/dist-es/EventStreamMarshaller.js
class EventStreamMarshaller {
  constructor({ utf8Encoder, utf8Decoder }) {
    this.eventStreamCodec = new EventStreamCodec(utf8Encoder, utf8Decoder);
    this.utfEncoder = utf8Encoder;
  }
  deserialize(body, deserializer) {
    const inputStream = getChunkedStream(body);
    return new SmithyMessageDecoderStream({
      messageStream: new MessageDecoderStream({ inputStream, decoder: this.eventStreamCodec }),
      deserializer: getMessageUnmarshaller(deserializer, this.utfEncoder)
    });
  }
  serialize(inputStream, serializer) {
    return new MessageEncoderStream({
      messageStream: new SmithyMessageEncoderStream({ inputStream, serializer }),
      encoder: this.eventStreamCodec,
      includeEndFrame: true
    });
  }
}
// ../../node_modules/@smithy/eventstream-serde-node/dist-es/EventStreamMarshaller.js
import { Readable as Readable5 } from "stream";

// ../../node_modules/@smithy/eventstream-serde-node/dist-es/utils.js
async function* readabletoIterable(readStream) {
  let streamEnded = false;
  let generationEnded = false;
  const records = new Array;
  readStream.on("error", (err) => {
    if (!streamEnded) {
      streamEnded = true;
    }
    if (err) {
      throw err;
    }
  });
  readStream.on("data", (data) => {
    records.push(data);
  });
  readStream.on("end", () => {
    streamEnded = true;
  });
  while (!generationEnded) {
    const value = await new Promise((resolve2) => setTimeout(() => resolve2(records.shift()), 0));
    if (value) {
      yield value;
    }
    generationEnded = streamEnded && records.length === 0;
  }
}

// ../../node_modules/@smithy/eventstream-serde-node/dist-es/EventStreamMarshaller.js
class EventStreamMarshaller3 {
  constructor({ utf8Encoder, utf8Decoder }) {
    this.universalMarshaller = new EventStreamMarshaller({
      utf8Decoder,
      utf8Encoder
    });
  }
  deserialize(body, deserializer) {
    const bodyIterable = typeof body[Symbol.asyncIterator] === "function" ? body : readabletoIterable(body);
    return this.universalMarshaller.deserialize(bodyIterable, deserializer);
  }
  serialize(input, serializer) {
    return Readable5.from(this.universalMarshaller.serialize(input, serializer));
  }
}
// ../../node_modules/@smithy/eventstream-serde-node/dist-es/provider.js
var eventStreamSerdeProvider = (options) => new EventStreamMarshaller3(options);
// ../../node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.js
init_dist_es34();

// ../../node_modules/@smithy/hash-stream-node/dist-es/HashCalculator.js
init_dist_es3();
import { Writable as Writable3 } from "stream";

class HashCalculator extends Writable3 {
  constructor(hash, options) {
    super(options);
    this.hash = hash;
  }
  _write(chunk, encoding, callback) {
    try {
      this.hash.update(toUint8Array2(chunk));
    } catch (err) {
      return callback(err);
    }
    callback();
  }
}
// ../../node_modules/@smithy/hash-stream-node/dist-es/readableStreamHasher.js
var readableStreamHasher = (hashCtor, readableStream) => {
  if (readableStream.readableFlowing !== null) {
    throw new Error("Unable to calculate hash for flowing readable stream");
  }
  const hash = new hashCtor;
  const hashCalculator = new HashCalculator(hash);
  readableStream.pipe(hashCalculator);
  return new Promise((resolve2, reject) => {
    readableStream.on("error", (err) => {
      hashCalculator.end();
      reject(err);
    });
    hashCalculator.on("error", reject);
    hashCalculator.on("finish", () => {
      hash.digest().then(resolve2).catch(reject);
    });
  });
};
// ../../node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.js
init_dist_es28();
init_dist_es22();
init_dist_es6();
init_dist_es35();
init_dist_es27();

// ../../node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.shared.js
var import_core20 = __toESM(require_dist_cjs20(), 1);
init_dist_es14();
init_dist_es23();
init_dist_es4();
init_dist_es8();
init_dist_es3();
var getRuntimeConfig3 = (config5) => {
  return {
    apiVersion: "2006-03-01",
    base64Decoder: config5?.base64Decoder ?? fromBase643,
    base64Encoder: config5?.base64Encoder ?? toBase643,
    disableHostPrefix: config5?.disableHostPrefix ?? false,
    endpointProvider: config5?.endpointProvider ?? defaultEndpointResolver,
    extensions: config5?.extensions ?? [],
    getAwsChunkedEncodingStream: config5?.getAwsChunkedEncodingStream ?? getAwsChunkedEncodingStream2,
    httpAuthSchemeProvider: config5?.httpAuthSchemeProvider ?? defaultS3HttpAuthSchemeProvider,
    httpAuthSchemes: config5?.httpAuthSchemes ?? [
      {
        schemeId: "aws.auth#sigv4",
        identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
        signer: new import_core20.AwsSdkSigV4Signer
      },
      {
        schemeId: "aws.auth#sigv4a",
        identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4a"),
        signer: new import_core20.AwsSdkSigV4ASigner
      }
    ],
    logger: config5?.logger ?? new NoOpLogger,
    sdkStreamMixin: config5?.sdkStreamMixin ?? sdkStreamMixin3,
    serviceId: config5?.serviceId ?? "S3",
    signerConstructor: config5?.signerConstructor ?? SignatureV4MultiRegion,
    signingEscapePath: config5?.signingEscapePath ?? false,
    urlParser: config5?.urlParser ?? parseUrl,
    useArnRegion: config5?.useArnRegion ?? false,
    utf8Decoder: config5?.utf8Decoder ?? fromUtf84,
    utf8Encoder: config5?.utf8Encoder ?? toUtf82
  };
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.js
init_dist_es14();
init_dist_es36();
init_dist_es14();
var getRuntimeConfig4 = (config5) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config5);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig3(config5);
  import_core21.emitWarningIfUnsupportedVersion(process.version);
  const profileConfig = { profile: config5?.profile };
  return {
    ...clientSharedValues,
    ...config5,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config5?.bodyLengthChecker ?? calculateBodyLength,
    credentialDefaultProvider: config5?.credentialDefaultProvider ?? defaultProvider,
    defaultUserAgentProvider: config5?.defaultUserAgentProvider ?? createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
    disableS3ExpressSessionAuth: config5?.disableS3ExpressSessionAuth ?? loadConfig(NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS, profileConfig),
    eventStreamSerdeProvider: config5?.eventStreamSerdeProvider ?? eventStreamSerdeProvider,
    maxAttempts: config5?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config5),
    md5: config5?.md5 ?? Hash.bind(null, "md5"),
    region: config5?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, { ...NODE_REGION_CONFIG_FILE_OPTIONS, ...profileConfig }),
    requestChecksumCalculation: config5?.requestChecksumCalculation ?? loadConfig(NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS, profileConfig),
    requestHandler: NodeHttpHandler.create(config5?.requestHandler ?? defaultConfigProvider),
    responseChecksumValidation: config5?.responseChecksumValidation ?? loadConfig(NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS, profileConfig),
    retryMode: config5?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }, config5),
    sha1: config5?.sha1 ?? Hash.bind(null, "sha1"),
    sha256: config5?.sha256 ?? Hash.bind(null, "sha256"),
    sigv4aSigningRegionSet: config5?.sigv4aSigningRegionSet ?? loadConfig(import_core21.NODE_SIGV4A_CONFIG_OPTIONS, profileConfig),
    streamCollector: config5?.streamCollector ?? streamCollector,
    streamHasher: config5?.streamHasher ?? readableStreamHasher,
    useArnRegion: config5?.useArnRegion ?? loadConfig(NODE_USE_ARN_REGION_CONFIG_OPTIONS, profileConfig),
    useDualstackEndpoint: config5?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, profileConfig),
    useFipsEndpoint: config5?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, profileConfig),
    userAgentAppId: config5?.userAgentAppId ?? loadConfig(NODE_APP_ID_CONFIG_OPTIONS, profileConfig)
  };
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/runtimeExtensions.js
init_dist_es37();
init_dist_es();
init_dist_es14();

// ../../node_modules/@aws-sdk/client-s3/dist-es/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration2 = (runtimeConfig) => {
  const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
  let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
  let _credentials = runtimeConfig.credentials;
  return {
    setHttpAuthScheme(httpAuthScheme) {
      const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
      if (index === -1) {
        _httpAuthSchemes.push(httpAuthScheme);
      } else {
        _httpAuthSchemes.splice(index, 1, httpAuthScheme);
      }
    },
    httpAuthSchemes() {
      return _httpAuthSchemes;
    },
    setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
      _httpAuthSchemeProvider = httpAuthSchemeProvider;
    },
    httpAuthSchemeProvider() {
      return _httpAuthSchemeProvider;
    },
    setCredentials(credentials) {
      _credentials = credentials;
    },
    credentials() {
      return _credentials;
    }
  };
};
var resolveHttpAuthRuntimeConfig2 = (config5) => {
  return {
    httpAuthSchemes: config5.httpAuthSchemes(),
    httpAuthSchemeProvider: config5.httpAuthSchemeProvider(),
    credentials: config5.credentials()
  };
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/runtimeExtensions.js
var asPartial2 = (t4) => t4;
var resolveRuntimeExtensions2 = (runtimeConfig, extensions4) => {
  const extensionConfiguration = {
    ...asPartial2(getAwsRegionExtensionConfiguration(runtimeConfig)),
    ...asPartial2(getDefaultExtensionConfiguration(runtimeConfig)),
    ...asPartial2(getHttpHandlerExtensionConfiguration(runtimeConfig)),
    ...asPartial2(getHttpAuthExtensionConfiguration2(runtimeConfig))
  };
  extensions4.forEach((extension) => extension.configure(extensionConfiguration));
  return {
    ...runtimeConfig,
    ...resolveAwsRegionExtensionConfiguration(extensionConfiguration),
    ...resolveDefaultRuntimeConfig(extensionConfiguration),
    ...resolveHttpHandlerRuntimeConfig(extensionConfiguration),
    ...resolveHttpAuthRuntimeConfig2(extensionConfiguration)
  };
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/S3Client.js
class S3Client extends Client {
  config;
  constructor(...[configuration]) {
    const _config_0 = getRuntimeConfig4(configuration || {});
    const _config_1 = resolveClientEndpointParameters(_config_0);
    const _config_2 = resolveUserAgentConfig(_config_1);
    const _config_3 = resolveFlexibleChecksumsConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveRegionConfig(_config_4);
    const _config_6 = resolveHostHeaderConfig(_config_5);
    const _config_7 = resolveEndpointConfig(_config_6);
    const _config_8 = resolveEventStreamSerdeConfig(_config_7);
    const _config_9 = resolveHttpAuthSchemeConfig(_config_8);
    const _config_10 = resolveS3Config(_config_9, { session: [() => this, CreateSessionCommand] });
    const _config_11 = resolveRuntimeExtensions2(_config_10, configuration?.extensions || []);
    super(_config_11);
    this.config = _config_11;
    this.middlewareStack.use(getUserAgentPlugin(this.config));
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(import_core22.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
      httpAuthSchemeParametersProvider: defaultS3HttpAuthSchemeParametersProvider,
      identityProviderConfigProvider: async (config5) => new import_core22.DefaultIdentityProviderConfig({
        "aws.auth#sigv4": config5.credentials,
        "aws.auth#sigv4a": config5.credentials
      })
    }));
    this.middlewareStack.use(import_core22.getHttpSigningPlugin(this.config));
    this.middlewareStack.use(getValidateBucketNamePlugin(this.config));
    this.middlewareStack.use(getAddExpectContinuePlugin(this.config));
    this.middlewareStack.use(getRegionRedirectMiddlewarePlugin(this.config));
    this.middlewareStack.use(getS3ExpressPlugin(this.config));
    this.middlewareStack.use(getS3ExpressHttpSigningPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
}

// src/database/common.ts
var import_client12 = __toESM(require_default2(), 1);
var selectPublicUser = import_client12.Prisma.validator()({
  id: true,
  avatar: true,
  displayName: true,
  flags: true,
  username: true
});
var selectPrivateUser = import_client12.Prisma.validator()({
  id: true,
  avatar: true,
  displayName: true,
  flags: true,
  username: true,
  email: true,
  password: true
});
var selectChannelRecipients = import_client12.Prisma.validator()({
  recipients: { select: { id: true, avatar: true, displayName: true, flags: true, username: true } }
});
var omitChannelRecipient = (id) => import_client12.Prisma.validator()({ recipients: { where: { id: { not: BigInt(id) } } } });
var selectMessageAuthor = import_client12.Prisma.validator()({
  author: { select: selectPublicUser }
});
var selectMessageMentions = import_client12.Prisma.validator()({
  mentions: { select: selectPublicUser }
});
var selectMessageEmbeds = import_client12.Prisma.validator()({
  embeds: { select: { description: true, title: true, type: true, url: true, thumbnail: { select: { height: true, url: true, width: true } } } }
});
var selectMessageDefaults = import_client12.Prisma.validator()({
  ...selectMessageAuthor,
  ...selectMessageMentions,
  ...selectMessageEmbeds,
  channelId: true,
  content: true,
  timestamp: true,
  editedTimestamp: true,
  type: true,
  pinned: true,
  id: true,
  attachments: true,
  reactions: true,
  flags: true
});
var selectRelationshipUser = import_client12.Prisma.validator()({
  user: { select: selectPublicUser }
});
var omitMessageAuthorId = import_client12.Prisma.validator()({ authorId: true });
var omitRelationshipUserIds = import_client12.Prisma.validator()({ userId: true, ownerId: true });

// src/database/index.ts
var import_client21 = __toESM(require_default2(), 1);
var import_extension_optimize = __toESM(require_dist4(), 1);

// src/database/assert.ts
var import_client13 = __toESM(require_default2(), 1);
var assertExtension = import_client13.Prisma.defineExtension({
  model: {
    user: {
      async assertUsersExist(methodName, userIds) {
        assertId(methodName, ...userIds);
        const foundCount = await prisma.user.count({ where: { id: { in: userIds.map((x4) => BigInt(x4)) } } });
        assertCondition(methodName, foundCount !== userIds.length, "NULL_USER" /* NULL_USER */, userIds.join(","));
      }
    },
    channel: {
      async assertChannelsExist(methodName, channelIds) {
        assertId(methodName, ...channelIds);
        const foundCount = await prisma.channel.count({ where: { id: { in: channelIds.map((x4) => BigInt(x4)) } } });
        assertCondition(methodName, foundCount !== channelIds.length, "NULL_CHANNEL" /* NULL_CHANNEL */, channelIds.join(","));
      }
    },
    relationship: {
      async assertRelationshipsExist(methodName, relationshipIds) {
        assertId(methodName, ...relationshipIds);
        const foundCount = await prisma.relationship.count({ where: { id: { in: relationshipIds.map((x4) => BigInt(x4)) } } });
        assertCondition(methodName, foundCount !== relationshipIds.length, "NULL_RELATIONSHIP" /* NULL_RELATIONSHIP */, relationshipIds.join(","));
      }
    },
    message: {
      async assertMessagesExist(methodName, messageIds) {
        assertId(methodName, ...messageIds);
        const foundCount = await prisma.message.count({ where: { id: { in: messageIds.map((x4) => BigInt(x4)) } } });
        assertCondition(methodName, foundCount !== messageIds.length, "NULL_MESSAGE" /* NULL_MESSAGE */, messageIds.join(","));
      }
    },
    readState: {
      async assertReadStatesExist(methodName, idPairs) {
        assertId(methodName, ...idPairs.flatMap((x4) => [x4.userId, x4.channelId]));
        const foundCount = await prisma.readState.count({
          where: { channelId: { in: idPairs.map((x4) => BigInt(x4.channelId)) }, userId: { in: idPairs.map((x4) => BigInt(x4.userId)) } }
        });
        assertCondition(methodName, foundCount !== idPairs.length, "NULL_READ_STATE" /* NULL_READ_STATE */, idPairs.map((x4) => `${x4.userId}:${x4.channelId}`).join(","));
      }
    }
  }
});
var assert_default = assertExtension;

// src/database/auth.ts
var import_client14 = __toESM(require_default2(), 1);
var authExtension = import_client14.Prisma.defineExtension({
  name: "auth",
  model: {
    user: {
      async findByCredentials(credentials) {
        const user = await prisma.user.findFirst({
          where: {
            AND: [
              { password: credentials.password },
              {
                OR: [{ email: credentials.email }, { username: credentials.username?.toLowerCase() }]
              }
            ]
          },
          select: selectPrivateUser
        });
        assertObj("findByCredentials", user, "NULL_USER" /* NULL_USER */);
        return user;
      },
      async registerNew(user) {
        const newUser = await prisma.user.create({
          data: {
            id: snowflake.generate(0 /* AUTH */),
            username: user.username.toLowerCase(),
            displayName: !user.displayName ? null : user.displayName,
            password: user.password,
            avatar: null,
            email: user.email,
            flags: 0 /* NONE */,
            system: false
          },
          select: selectPrivateUser
        });
        assertObj("registerNew", newUser, "NULL_USER" /* NULL_USER */);
        return newUser;
      }
    }
  }
});
var auth_default = authExtension;

// src/database/channel.ts
var import_client15 = __toESM(require_default2(), 1);

// src/database/error.ts
function assertId(methodName, ...ids) {
  let lastValidIndex = -1;
  try {
    for (const [i4, id] of ids.entries()) {
      BigInt(id);
      lastValidIndex = i4;
    }
  } catch (e4) {
    throw new DBError(methodName, "INVALID_ID" /* INVALID_ID */, ids[lastValidIndex + 1]);
  }
}
function assertObj(methodName, obj, errorType, cause) {
  if (obj === null || typeof obj !== "object") {
    throw new DBError(methodName, errorType, cause);
  }
}
function assertCondition(methodName, shouldAssert, errorType, cause) {
  if (shouldAssert) {
    throw new DBError(methodName, errorType, cause);
  }
}
async function assertExists(error, methodName, errorType, ids) {
  const normalIds = ids;
  const readStateIds = ids;
  if (errorType === "NULL_USER" /* NULL_USER */) {
    await prisma.user.assertUsersExist(methodName, normalIds);
  } else if (errorType === "NULL_CHANNEL" /* NULL_CHANNEL */) {
    await prisma.channel.assertChannelsExist(methodName, normalIds);
  } else if (errorType === "NULL_MESSAGE" /* NULL_MESSAGE */) {
    await prisma.message.assertMessagesExist(methodName, normalIds);
  } else if (errorType === "NULL_RELATIONSHIP" /* NULL_RELATIONSHIP */) {
    await prisma.relationship.assertRelationshipsExist(methodName, normalIds);
  } else if (errorType === "NULL_READ_STATE" /* NULL_READ_STATE */) {
    await prisma.readState.assertReadStatesExist(methodName, readStateIds);
  }
}

// src/database/channel.ts
var channelExtension = import_client15.Prisma.defineExtension({
  model: {
    channel: {
      async getById(id, args) {
        assertId("getById", id);
        const channel = await prisma.channel.findUnique({ where: { id: BigInt(id) }, ...args });
        assertObj("getById", channel, "NULL_CHANNEL" /* NULL_CHANNEL */, id);
        return channel;
      },
      async getUserChannels(userId, includeDeleted, args) {
        try {
          const dmChannels = await prisma.channel.findMany({
            where: {
              recipients: { some: { id: BigInt(userId) } },
              type: 0 /* DM */,
              tempDeletedByUsers: !includeDeleted ? { none: { id: BigInt(userId) } } : undefined
            },
            ...args,
            omit: args?.select ? undefined : { icon: true, name: true, ownerId: true }
          });
          const groupChannels = await prisma.channel.findMany({
            where: {
              recipients: { some: { id: BigInt(userId) } },
              type: 1 /* GROUP_DM */,
              tempDeletedByUsers: !includeDeleted ? { none: { id: BigInt(userId) } } : undefined
            },
            ...args
          });
          const channels = [...groupChannels, ...dmChannels];
          assertObj("getUserChannels", channels, "NULL_CHANNEL" /* NULL_CHANNEL */);
          return channels;
        } catch (e4) {
          await assertExists(e4, "getUserChannels", "NULL_USER" /* NULL_USER */, [userId]);
          throw e4;
        }
      },
      async createDM(initiatorId, recipients, name, args) {
        try {
          let channel;
          const isGroup = recipients.length > 1;
          const recipientsConnect = [{ id: BigInt(initiatorId) }, ...recipients.map((x4) => ({ id: BigInt(x4) }))];
          const existingChannel = await prisma.channel.findFirst({
            where: { recipients: { every: { OR: [{ id: BigInt(recipients[0]) }, { id: BigInt(initiatorId) }] } }, type: 0 /* DM */ },
            select: { id: true }
          });
          if (!isGroup && existingChannel) {
            channel = await prisma.channel.update({
              where: { id: existingChannel.id },
              data: { tempDeletedByUsers: { disconnect: { id: BigInt(initiatorId) } } },
              ...args,
              omit: { icon: true, name: true, ownerId: true }
            });
          } else if (!isGroup) {
            channel = await prisma.channel.create({
              data: {
                id: snowflake.generate(1 /* CHANNEL */),
                type: 0 /* DM */,
                lastMessageId: null,
                recipients: {
                  connect: recipientsConnect
                }
              },
              ...args,
              omit: { icon: true, name: true, ownerId: true }
            });
          } else if (isGroup) {
            channel = await prisma.channel.create({
              data: {
                id: snowflake.generate(1 /* CHANNEL */),
                type: 1 /* GROUP_DM */,
                name: name ? name : null,
                icon: null,
                lastMessageId: null,
                ownerId: BigInt(initiatorId),
                recipients: {
                  connect: recipientsConnect
                }
              },
              ...args
            });
          }
          assertObj("createDM", channel, "NULL_CHANNEL" /* NULL_CHANNEL */);
          return channel;
        } catch (e4) {
          await assertExists(e4, "createDM", "NULL_USER" /* NULL_USER */, [initiatorId, ...recipients]);
          throw e4;
        }
      },
      async editDM(channelId, name, icon, owner, args) {
        try {
          const updatedChannel = await prisma.channel.update({
            where: { id: BigInt(channelId), type: 1 /* GROUP_DM */ },
            data: { icon, name, owner: owner ? { connect: { id: BigInt(owner) } } : undefined },
            ...args
          });
          assertObj("editDM", updatedChannel, "NULL_CHANNEL" /* NULL_CHANNEL */);
          return updatedChannel;
        } catch (e4) {
          await assertExists(e4, "editDM", "NULL_CHANNEL" /* NULL_CHANNEL */, [channelId]);
          await assertExists(e4, "editDM", "NULL_USER" /* NULL_USER */, [owner]);
          throw e4;
        }
      },
      async addRecipient(channelId, recipientId, args) {
        try {
          const updatedChannel = await prisma.channel.update({
            where: { id: BigInt(channelId), type: 1 /* GROUP_DM */ },
            data: { recipients: { connect: { id: BigInt(recipientId) } } },
            ...args
          });
          assertObj("addRecipient", updatedChannel, "NULL_CHANNEL" /* NULL_CHANNEL */);
          return updatedChannel;
        } catch (e4) {
          await assertExists(e4, "addRecipient", "NULL_CHANNEL" /* NULL_CHANNEL */, [channelId]);
          await assertExists(e4, "addRecipient", "NULL_USER" /* NULL_USER */, [recipientId]);
          throw e4;
        }
      },
      async removeRecipient(channelId, recipientId, args) {
        try {
          const updatedChannel = await prisma.channel.update({
            where: { id: BigInt(channelId), type: 1 /* GROUP_DM */ },
            data: { recipients: { disconnect: { id: BigInt(recipientId) } } },
            ...args
          });
          assertObj("removeRecipient", updatedChannel, "NULL_CHANNEL" /* NULL_CHANNEL */);
          return updatedChannel;
        } catch (e4) {
          await assertExists(e4, "removeRecipient", "NULL_CHANNEL" /* NULL_CHANNEL */, [channelId]);
          await assertExists(e4, "removeRecipient", "NULL_USER" /* NULL_USER */, [recipientId]);
          throw e4;
        }
      },
      async deleteDM(channelId, userId, args) {
        try {
          const channel = await prisma.channel.getById(channelId, { select: { type: true } });
          let editedChannel;
          if (channel.type === 1 /* GROUP_DM */) {
            editedChannel = await prisma.channel.update({
              where: { id: BigInt(channelId) },
              data: { recipients: { disconnect: { id: BigInt(userId) } } },
              ...args
            });
          } else if (channel.type === 0 /* DM */) {
            editedChannel = await prisma.channel.update({
              where: { id: BigInt(channelId) },
              data: { tempDeletedByUsers: { connect: { id: BigInt(userId) } } },
              ...args,
              omit: { icon: true, name: true, ownerId: true }
            });
          }
          assertObj("deleteDM", editedChannel, "NULL_CHANNEL" /* NULL_CHANNEL */);
          return editedChannel;
        } catch (e4) {
          await assertExists(e4, "deleteDM", "NULL_CHANNEL" /* NULL_CHANNEL */, [channelId]);
          await assertExists(e4, "deleteDM", "NULL_USER" /* NULL_USER */, [userId]);
          throw e4;
        }
      }
    }
  }
});
var channel_default = channelExtension;

// src/database/embed.ts
var import_client16 = __toESM(require_default2(), 1);
var embedExtension = import_client16.Prisma.defineExtension({
  model: {
    embed: {
      async createEmbed(title, description, url, timestamp, type, thumbnail) {
        const embed = await prisma.embed.create({
          data: { id: snowflake.generate(9 /* EMBED */), title, description, url, type, timestamp }
        });
        if (thumbnail) {
          await prisma.thumbnail.create({
            data: {
              id: snowflake.generate(10 /* THUMBNAIL */),
              url: thumbnail.url,
              height: thumbnail.height,
              width: thumbnail.width,
              embed: { connect: { id: embed.id } }
            }
          });
        }
        return embed;
      }
    }
  }
});
var embed_default = embedExtension;

// src/database/message.ts
var import_client17 = __toESM(require_default2(), 1);
var messagesExtension = import_client17.Prisma.defineExtension({
  model: {
    message: {
      async getById(channelId, messageId, args) {
        try {
          assertId("getById", channelId, messageId);
          const message = await prisma.message.findUnique({
            where: { channelId: BigInt(channelId), id: BigInt(messageId) },
            ...args
          });
          assertObj("getById", message, "NULL_MESSAGE" /* NULL_MESSAGE */, messageId);
          return message;
        } catch (e4) {
          await assertExists(e4, "getById", "NULL_CHANNEL" /* NULL_CHANNEL */, [channelId]);
          await assertExists(e4, "getById", "NULL_MESSAGE" /* NULL_MESSAGE */, [messageId]);
          throw e4;
        }
      },
      async getMessages(channelId, limit, before, after, args) {
        try {
          const cursor = after ?? before;
          const direction = after ? "forward" : before ? "backward" : "none";
          const messages = await prisma.message.findMany({
            where: { channelId: BigInt(channelId) },
            ...args,
            cursor: cursor ? { id: BigInt(cursor) } : undefined,
            skip: direction === "none" ? undefined : 1,
            take: (direction === "forward" ? 1 : -1) * limit
          });
          assertObj("getMessages", messages, "NULL_MESSAGE" /* NULL_MESSAGE */);
          return messages;
        } catch (e4) {
          await assertExists(e4, "getMessages", "NULL_CHANNEL" /* NULL_CHANNEL */, [channelId]);
          throw e4;
        }
      },
      async createMessage(authorId, channelId, type, content, attachments, embeds, mentions, flags, args) {
        try {
          const createdEmbeds = [];
          if (embeds) {
            for (const embed of embeds) {
              createdEmbeds.push(await prisma.embed.createEmbed(embed.title, embed.description, embed.url, embed.timestamp, embed.type, embed.thumbnail));
            }
          }
          const message = await prisma.message.create({
            data: {
              id: snowflake.generate(2 /* MESSAGE */),
              type,
              channelId: BigInt(channelId),
              content: content ?? "",
              attachments,
              mentions: { connect: mentions?.map((x4) => ({ id: BigInt(x4) })) },
              authorId: BigInt(authorId),
              timestamp: new Date,
              embeds: embeds ? { connect: createdEmbeds.map((x4) => ({ id: x4.id })) } : undefined,
              editedTimestamp: null,
              pinned: false,
              reactions: [],
              flags
            },
            ...args
          });
          await prisma.channel.update({ where: { id: BigInt(channelId) }, data: { lastMessageId: message.id }, select: { id: true } });
          assertObj("createDefaultMessage", message, "NULL_MESSAGE" /* NULL_MESSAGE */);
          return message;
        } catch (e4) {
          await assertExists(e4, "createDefaultMessage", "NULL_CHANNEL" /* NULL_CHANNEL */, [channelId]);
          await assertExists(e4, "createDefaultMessage", "NULL_USER" /* NULL_USER */, [authorId]);
          throw e4;
        }
      },
      async updateMessage(id, content, embeds, args) {
        try {
          const createdEmbeds = [];
          if (embeds) {
            for (const embed of embeds) {
              createdEmbeds.push(await prisma.embed.createEmbed(embed.title, embed.description, embed.url, embed.timestamp, embed.type, embed.thumbnail));
            }
          }
          const message = await prisma.message.update({
            where: { id: BigInt(id) },
            data: {
              content,
              embeds: embeds ? { set: createdEmbeds.map((x4) => ({ id: x4.id })) } : { set: [] },
              editedTimestamp: new Date
            },
            ...args
          });
          assertObj("updateMessage", message, "NULL_MESSAGE" /* NULL_MESSAGE */);
          return message;
        } catch (e4) {
          await assertExists(e4, "updateMessage", "NULL_MESSAGE" /* NULL_MESSAGE */, [id]);
          throw e4;
        }
      }
    }
  }
});
var message_default = messagesExtension;

// src/database/readState.ts
var import_client18 = __toESM(require_default2(), 1);
var import_library = __toESM(require_library(), 1);
var readStateExtension = import_client18.Prisma.defineExtension({
  model: {
    readState: {
      async getByUserAndChannelId(userId, channelId) {
        assertId("getByUserAndChannelId", userId, channelId);
        const readState = await prisma.readState.findUnique({
          where: { channelId_userId: { userId: BigInt(userId), channelId: BigInt(channelId) } }
        });
        assertObj("getByUserAndChannelId", readState, "NULL_READ_STATE" /* NULL_READ_STATE */, `${userId}:${channelId}`);
        return readState;
      },
      async getUserStates(userId) {
        assertId("getUserStates", userId);
        const readStates = await prisma.readState.findMany({ where: { userId: BigInt(userId) } });
        assertObj("getUserStates", readStates, "NULL_READ_STATE" /* NULL_READ_STATE */);
        return readStates;
      },
      async createState(userId, channelId) {
        try {
          const existing = await prisma.readState.findUnique({
            where: { channelId_userId: { userId: BigInt(userId), channelId: BigInt(channelId) } }
          });
          if (existing) {
            return existing;
          }
          const readState = await prisma.readState.create({ data: { userId: BigInt(userId), channelId: BigInt(channelId) } });
          assertObj("createState", readState, "NULL_READ_STATE" /* NULL_READ_STATE */);
          return readState;
        } catch (e4) {
          await assertExists(e4, "createState", "NULL_CHANNEL" /* NULL_CHANNEL */, [channelId]);
          await assertExists(e4, "createState", "NULL_USER" /* NULL_USER */, [userId]);
          throw e4;
        }
      },
      async deleteState(userId, channelId) {
        try {
          const deletedReadState = await prisma.readState.delete({
            where: { channelId_userId: { userId: BigInt(userId), channelId: BigInt(channelId) } }
          });
          assertObj("deleteState", deletedReadState, "NULL_READ_STATE" /* NULL_READ_STATE */);
          return deletedReadState;
        } catch (e4) {
          await assertExists(e4, "createState", "NULL_READ_STATE" /* NULL_READ_STATE */, [{ userId, channelId }]);
          throw e4;
        }
      },
      async updateLastRead(userId, channelId, lastReadMessageId) {
        try {
          const olderExists = await prisma.readState.exists({
            userId: BigInt(userId),
            channelId: BigInt(channelId),
            OR: [{ lastReadMessage: null }, { lastReadMessage: { timestamp: { lt: new Date(snowflake.getTimestamp(lastReadMessageId)) } } }]
          });
          if (!olderExists) {
            return;
          }
          const updatedReadState = await prisma.readState.update({
            where: {
              channelId_userId: { userId: BigInt(userId), channelId: BigInt(channelId) },
              OR: [{ lastReadMessage: null }, { lastReadMessage: { timestamp: { lt: new Date(snowflake.getTimestamp(lastReadMessageId)) } } }]
            },
            data: { lastReadMessage: { connect: { id: BigInt(lastReadMessageId) } } }
          });
          assertObj("updateLastReadMessage", updatedReadState, "NULL_READ_STATE" /* NULL_READ_STATE */);
          return updatedReadState;
        } catch (e4) {
          if (e4 instanceof import_library.PrismaClientKnownRequestError && e4.code === "P2025") {
            consola.info("Rare error due to fast updates, ignoring");
            return;
          }
          await assertExists(e4, "updateLastReadMessage", "NULL_MESSAGE" /* NULL_MESSAGE */, [lastReadMessageId]);
          await assertExists(e4, "updateLastReadMessage", "NULL_READ_STATE" /* NULL_READ_STATE */, [{ userId, channelId }]);
          throw e4;
        }
      },
      async countUnreadMessages(userId, channelId) {
        const readState = await prisma.readState.getByUserAndChannelId(userId, channelId);
        const unreadCount = await prisma.message.count({
          where: { channelId: BigInt(channelId), author: { id: { not: BigInt(userId) } } },
          cursor: readState.lastReadMessageId ? { id: BigInt(readState.lastReadMessageId) } : undefined
        }) - 1;
        return unreadCount < 0 ? 0 : unreadCount;
      }
    }
  }
});
var readState_default = readStateExtension;

// src/database/relationship.ts
var import_client19 = __toESM(require_default2(), 1);
var relationshipExtension = import_client19.Prisma.defineExtension({
  model: {
    relationship: {
      async getByUserId(ownerId, userId, args) {
        assertId("getByUserId", ownerId, userId);
        const relationship = await prisma.relationship.findFirst({
          where: { ownerId: BigInt(ownerId), userId: BigInt(userId) },
          ...args
        });
        assertObj("getById", relationship, "NULL_RELATIONSHIP" /* NULL_RELATIONSHIP */, `${ownerId}, ${userId}`);
        return relationship;
      },
      async getUserRelationships(userId, args) {
        try {
          const relationships = await prisma.relationship.findMany({
            where: { ownerId: BigInt(userId) },
            ...args
          });
          assertObj("getUserRelationships", relationships, "NULL_RELATIONSHIP" /* NULL_RELATIONSHIP */);
          return relationships;
        } catch (e4) {
          await assertExists(e4, "getUserRelationships", "NULL_USER" /* NULL_USER */, [userId]);
          throw e4;
        }
      },
      async deleteByUserId(ownerId, userId) {
        assertId("deleteByUserId", ownerId, userId);
        const relation = await prisma.relationship.findFirst({ where: { userId: BigInt(userId), ownerId: BigInt(ownerId) } });
        assertObj("deleteByUserId", relation, "NULL_RELATIONSHIP" /* NULL_RELATIONSHIP */, `${ownerId}>${userId}`);
        const oppositeRelation = await prisma.relationship.findFirst({
          where: { userId: BigInt(ownerId), ownerId: BigInt(userId) }
        });
        assertObj("deleteByUserId", oppositeRelation, "NULL_RELATIONSHIP" /* NULL_RELATIONSHIP */, `${userId}>${ownerId}`);
        const deleteRelation = prisma.relationship.delete({ where: { id: relation?.id } });
        const deleteOppositeRelation = prisma.relationship.delete({ where: { id: oppositeRelation?.id } });
        await prisma.$transaction([deleteRelation, deleteOppositeRelation]);
      },
      async createRelationship(senderId, recieverId, args) {
        try {
          const incomingExists = await prisma.relationship.exists({
            ownerId: BigInt(senderId),
            userId: BigInt(recieverId),
            type: 3 /* PENDING_INCOMING */
          });
          if (incomingExists) {
            await prisma.relationship.updateMany({
              where: {
                OR: [
                  { ownerId: BigInt(senderId), userId: BigInt(recieverId) },
                  { ownerId: BigInt(recieverId), userId: BigInt(senderId) }
                ]
              },
              data: { type: 1 /* FRIEND */, since: new Date }
            });
            const relationships2 = await prisma.relationship.findMany({
              where: {
                OR: [
                  { ownerId: BigInt(senderId), userId: BigInt(recieverId) },
                  { ownerId: BigInt(recieverId), userId: BigInt(senderId) }
                ]
              },
              ...args
            });
            return relationships2;
          }
          const relationships = await prisma.relationship.createManyAndReturn({
            data: [
              {
                id: snowflake.generate(3 /* RELATIONSHIP */),
                nickname: "",
                type: 3 /* PENDING_INCOMING */,
                ownerId: BigInt(recieverId),
                userId: BigInt(senderId),
                since: null
              },
              {
                id: snowflake.generate(3 /* RELATIONSHIP */),
                nickname: "",
                type: 4 /* PENDING_OUTGOING */,
                ownerId: BigInt(senderId),
                userId: BigInt(recieverId),
                since: null
              }
            ],
            ...args
          });
          assertObj("createRelationship", relationships, "NULL_RELATIONSHIP" /* NULL_RELATIONSHIP */);
          return relationships;
        } catch (e4) {
          await assertExists(e4, "createRelationship", "NULL_USER" /* NULL_USER */, [senderId, recieverId]);
          throw e4;
        }
      }
    }
  }
});
var relationship_default = relationshipExtension;

// src/database/user.ts
var import_client20 = __toESM(require_default2(), 1);
var userExtension = import_client20.Prisma.defineExtension({
  model: {
    user: {
      async getById(id, args) {
        assertId("getById", id);
        const user = await prisma.user.findUnique({ where: { id: BigInt(id) }, ...args });
        assertObj("getById", user, "NULL_USER" /* NULL_USER */, id);
        return user;
      },
      async getByUsername(username, args) {
        const user = await prisma.user.findUnique({ where: { username }, ...args });
        assertObj("getByUsername", user, "NULL_USER" /* NULL_USER */, username);
        return user;
      },
      async edit(id, editedUser, args) {
        assertId("edit", id);
        const updatedUser = await prisma.user.update({ where: { id: BigInt(id) }, data: { ...editedUser }, ...args });
        assertObj("edit", updatedUser, "NULL_USER" /* NULL_USER */, id);
        return updatedUser;
      },
      async hasChannel(userId, channelId) {
        assertId("hasChannel", userId, channelId);
        const hasAccess = await prisma.user.exists({
          id: BigInt(userId),
          OR: [{ includedChannels: { some: { id: BigInt(channelId) } } }, { ownedChannels: { some: { id: BigInt(channelId) } } }]
        });
        return hasAccess;
      }
    }
  }
});
var user_default = userExtension;

// src/database/index.ts
var prismaBase = new import_client21.PrismaClient().$extends(import_extension_optimize.withOptimize({ apiKey: process.env.OPTIMIZE_API_KEY ?? "", enable: false }));
var prisma = prismaBase.$extends({
  model: {
    $allModels: {
      async exists(where) {
        const context = import_client21.Prisma.getExtensionContext(this);
        const result = await context.count({ where });
        return result !== 0;
      }
    }
  }
}).$extends(assert_default).$extends(auth_default).$extends(user_default).$extends(channel_default).$extends(message_default).$extends(relationship_default).$extends(readState_default).$extends(embed_default);

// ../../node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default = crypto;
var isCryptoKey = (key) => key instanceof CryptoKey;

// ../../node_modules/jose/dist/browser/lib/buffer_utils.js
var encoder2 = new TextEncoder;
var decoder = new TextDecoder;
var MAX_INT32 = 2 ** 32;
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i4 = 0;
  for (const buffer of buffers) {
    buf.set(buffer, i4);
    i4 += buffer.length;
  }
  return buf;
}

// ../../node_modules/jose/dist/browser/runtime/base64url.js
var decodeBase642 = (encoded) => {
  const binary = atob(encoded);
  const bytes = new Uint8Array(binary.length);
  for (let i4 = 0;i4 < binary.length; i4++) {
    bytes[i4] = binary.charCodeAt(i4);
  }
  return bytes;
};
var decode2 = (input) => {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return decodeBase642(encoded);
  } catch {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
};

// ../../node_modules/jose/dist/browser/util/errors.js
class JOSEError extends Error {
  constructor(message, options) {
    super(message, options);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    Error.captureStackTrace?.(this, this.constructor);
  }
}
JOSEError.code = "ERR_JOSE_GENERIC";

class JWTClaimValidationFailed extends JOSEError {
  constructor(message, payload, claim = "unspecified", reason = "unspecified") {
    super(message, { cause: { claim, reason, payload } });
    this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
}
JWTClaimValidationFailed.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";

class JWTExpired extends JOSEError {
  constructor(message, payload, claim = "unspecified", reason = "unspecified") {
    super(message, { cause: { claim, reason, payload } });
    this.code = "ERR_JWT_EXPIRED";
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
}
JWTExpired.code = "ERR_JWT_EXPIRED";

class JOSEAlgNotAllowed extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
}
JOSEAlgNotAllowed.code = "ERR_JOSE_ALG_NOT_ALLOWED";

class JOSENotSupported extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
}
JOSENotSupported.code = "ERR_JOSE_NOT_SUPPORTED";

class JWEDecryptionFailed extends JOSEError {
  constructor(message = "decryption operation failed", options) {
    super(message, options);
    this.code = "ERR_JWE_DECRYPTION_FAILED";
  }
}
JWEDecryptionFailed.code = "ERR_JWE_DECRYPTION_FAILED";

class JWEInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWE_INVALID";
  }
}
JWEInvalid.code = "ERR_JWE_INVALID";

class JWSInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_INVALID";
  }
}
JWSInvalid.code = "ERR_JWS_INVALID";

class JWTInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
}
JWTInvalid.code = "ERR_JWT_INVALID";

class JWKInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWK_INVALID";
  }
}
JWKInvalid.code = "ERR_JWK_INVALID";

class JWKSInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_INVALID";
  }
}
JWKSInvalid.code = "ERR_JWKS_INVALID";

class JWKSNoMatchingKey extends JOSEError {
  constructor(message = "no applicable key found in the JSON Web Key Set", options) {
    super(message, options);
    this.code = "ERR_JWKS_NO_MATCHING_KEY";
  }
}
JWKSNoMatchingKey.code = "ERR_JWKS_NO_MATCHING_KEY";

class JWKSMultipleMatchingKeys extends JOSEError {
  constructor(message = "multiple matching keys found in the JSON Web Key Set", options) {
    super(message, options);
    this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
  }
}
JWKSMultipleMatchingKeys.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";

class JWKSTimeout extends JOSEError {
  constructor(message = "request timed out", options) {
    super(message, options);
    this.code = "ERR_JWKS_TIMEOUT";
  }
}
JWKSTimeout.code = "ERR_JWKS_TIMEOUT";

class JWSSignatureVerificationFailed extends JOSEError {
  constructor(message = "signature verification failed", options) {
    super(message, options);
    this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
}
JWSSignatureVerificationFailed.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";

// ../../node_modules/jose/dist/browser/lib/crypto_key.js
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength(hash) {
  return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}

// ../../node_modules/jose/dist/browser/lib/invalid_key_input.js
function message(msg, actual, ...types10) {
  types10 = types10.filter(Boolean);
  if (types10.length > 2) {
    const last = types10.pop();
    msg += `one of type ${types10.join(", ")}, or ${last}.`;
  } else if (types10.length === 2) {
    msg += `one of type ${types10[0]} or ${types10[1]}.`;
  } else {
    msg += `of type ${types10[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor?.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
var invalid_key_input_default = (actual, ...types10) => {
  return message("Key must be ", actual, ...types10);
};
function withAlg(alg, actual, ...types10) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types10);
}

// ../../node_modules/jose/dist/browser/runtime/is_key_like.js
var is_key_like_default = (key) => {
  if (isCryptoKey(key)) {
    return true;
  }
  return key?.[Symbol.toStringTag] === "KeyObject";
};
var types10 = ["CryptoKey"];

// ../../node_modules/jose/dist/browser/lib/is_disjoint.js
var isDisjoint = (...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
};
var is_disjoint_default = isDisjoint;

// ../../node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject2(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}

// ../../node_modules/jose/dist/browser/runtime/check_key_length.js
var check_key_length_default = (alg, key) => {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
};

// ../../node_modules/jose/dist/browser/lib/is_jwk.js
function isJWK(key) {
  return isObject2(key) && typeof key.kty === "string";
}
function isPrivateJWK(key) {
  return key.kty !== "oct" && typeof key.d === "string";
}
function isPublicJWK(key) {
  return key.kty !== "oct" && typeof key.d === "undefined";
}
function isSecretJWK(key) {
  return isJWK(key) && key.kty === "oct" && typeof key.k === "string";
}

// ../../node_modules/jose/dist/browser/runtime/jwk_to_key.js
function subtleMapping(jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "EdDSA":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm, keyUsages };
}
var parse6 = async (jwk) => {
  if (!jwk.alg) {
    throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
  }
  const { algorithm, keyUsages } = subtleMapping(jwk);
  const rest = [
    algorithm,
    jwk.ext ?? false,
    jwk.key_ops ?? keyUsages
  ];
  const keyData = { ...jwk };
  delete keyData.alg;
  delete keyData.use;
  return webcrypto_default.subtle.importKey("jwk", keyData, ...rest);
};
var jwk_to_key_default = parse6;

// ../../node_modules/jose/dist/browser/runtime/normalize_key.js
var exportKeyValue = (k4) => decode2(k4);
var privCache;
var pubCache;
var isKeyObject = (key) => {
  return key?.[Symbol.toStringTag] === "KeyObject";
};
var importAndCache = async (cache3, key, jwk, alg, freeze = false) => {
  let cached = cache3.get(key);
  if (cached?.[alg]) {
    return cached[alg];
  }
  const cryptoKey = await jwk_to_key_default({ ...jwk, alg });
  if (freeze)
    Object.freeze(key);
  if (!cached) {
    cache3.set(key, { [alg]: cryptoKey });
  } else {
    cached[alg] = cryptoKey;
  }
  return cryptoKey;
};
var normalizePublicKey = (key, alg) => {
  if (isKeyObject(key)) {
    let jwk = key.export({ format: "jwk" });
    delete jwk.d;
    delete jwk.dp;
    delete jwk.dq;
    delete jwk.p;
    delete jwk.q;
    delete jwk.qi;
    if (jwk.k) {
      return exportKeyValue(jwk.k);
    }
    pubCache || (pubCache = new WeakMap);
    return importAndCache(pubCache, key, jwk, alg);
  }
  if (isJWK(key)) {
    if (key.k)
      return decode2(key.k);
    pubCache || (pubCache = new WeakMap);
    const cryptoKey = importAndCache(pubCache, key, key, alg, true);
    return cryptoKey;
  }
  return key;
};
var normalizePrivateKey = (key, alg) => {
  if (isKeyObject(key)) {
    let jwk = key.export({ format: "jwk" });
    if (jwk.k) {
      return exportKeyValue(jwk.k);
    }
    privCache || (privCache = new WeakMap);
    return importAndCache(privCache, key, jwk, alg);
  }
  if (isJWK(key)) {
    if (key.k)
      return decode2(key.k);
    privCache || (privCache = new WeakMap);
    const cryptoKey = importAndCache(privCache, key, key, alg, true);
    return cryptoKey;
  }
  return key;
};
var normalize_key_default = { normalizePublicKey, normalizePrivateKey };

// ../../node_modules/jose/dist/browser/key/import.js
async function importJWK(jwk, alg) {
  if (!isObject2(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  alg || (alg = jwk.alg);
  switch (jwk.kty) {
    case "oct":
      if (typeof jwk.k !== "string" || !jwk.k) {
        throw new TypeError('missing "k" (Key Value) Parameter value');
      }
      return decode2(jwk.k);
    case "RSA":
      if (jwk.oth !== undefined) {
        throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
      }
    case "EC":
    case "OKP":
      return jwk_to_key_default({ ...jwk, alg });
    default:
      throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
  }
}

// ../../node_modules/jose/dist/browser/lib/check_key_type.js
var tag = (key) => key?.[Symbol.toStringTag];
var jwkMatchesOp = (alg, key, usage) => {
  if (key.use !== undefined && key.use !== "sig") {
    throw new TypeError("Invalid key for this operation, when present its use must be sig");
  }
  if (key.key_ops !== undefined && key.key_ops.includes?.(usage) !== true) {
    throw new TypeError(`Invalid key for this operation, when present its key_ops must include ${usage}`);
  }
  if (key.alg !== undefined && key.alg !== alg) {
    throw new TypeError(`Invalid key for this operation, when present its alg must be ${alg}`);
  }
  return true;
};
var symmetricTypeCheck = (alg, key, usage, allowJwk) => {
  if (key instanceof Uint8Array)
    return;
  if (allowJwk && isJWK(key)) {
    if (isSecretJWK(key) && jwkMatchesOp(alg, key, usage))
      return;
    throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present`);
  }
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types10, "Uint8Array", allowJwk ? "JSON Web Key" : null));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type "secret"`);
  }
};
var asymmetricTypeCheck = (alg, key, usage, allowJwk) => {
  if (allowJwk && isJWK(key)) {
    switch (usage) {
      case "sign":
        if (isPrivateJWK(key) && jwkMatchesOp(alg, key, usage))
          return;
        throw new TypeError(`JSON Web Key for this operation be a private JWK`);
      case "verify":
        if (isPublicJWK(key) && jwkMatchesOp(alg, key, usage))
          return;
        throw new TypeError(`JSON Web Key for this operation be a public JWK`);
    }
  }
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types10, allowJwk ? "JSON Web Key" : null));
  }
  if (key.type === "secret") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (usage === "sign" && key.type === "public") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type "private"`);
  }
  if (usage === "decrypt" && key.type === "public") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type "private"`);
  }
  if (key.algorithm && usage === "verify" && key.type === "private") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type "public"`);
  }
  if (key.algorithm && usage === "encrypt" && key.type === "private") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type "public"`);
  }
};
function checkKeyType(allowJwk, alg, key, usage) {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(alg, key, usage, allowJwk);
  } else {
    asymmetricTypeCheck(alg, key, usage, allowJwk);
  }
}
var check_key_type_default = checkKeyType.bind(undefined, false);
var checkKeyTypeWithJwk = checkKeyType.bind(undefined, true);

// ../../node_modules/jose/dist/browser/lib/validate_crit.js
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== undefined && protectedHeader?.crit === undefined) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === undefined) {
    return new Set;
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== undefined) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    }
    if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default = validateCrit;

// ../../node_modules/jose/dist/browser/lib/validate_algorithms.js
var validateAlgorithms = (option, algorithms2) => {
  if (algorithms2 !== undefined && (!Array.isArray(algorithms2) || algorithms2.some((s5) => typeof s5 !== "string"))) {
    throw new TypeError(`"${option}" option must be an array of strings`);
  }
  if (!algorithms2) {
    return;
  }
  return new Set(algorithms2);
};
var validate_algorithms_default = validateAlgorithms;

// ../../node_modules/jose/dist/browser/runtime/subtle_dsa.js
function subtleDsa(alg, algorithm) {
  const hash = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}

// ../../node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
async function getCryptoKey(alg, key, usage) {
  if (usage === "sign") {
    key = await normalize_key_default.normalizePrivateKey(key, alg);
  }
  if (usage === "verify") {
    key = await normalize_key_default.normalizePublicKey(key, alg);
  }
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types10));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types10, "Uint8Array", "JSON Web Key"));
}

// ../../node_modules/jose/dist/browser/runtime/verify.js
var verify = async (alg, key, signature, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "verify");
  check_key_length_default(alg, cryptoKey);
  const algorithm = subtleDsa(alg, cryptoKey.algorithm);
  try {
    return await webcrypto_default.subtle.verify(algorithm, cryptoKey, signature, data);
  } catch {
    return false;
  }
};
var verify_default = verify;

// ../../node_modules/jose/dist/browser/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  if (!isObject2(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === undefined && jws.header === undefined) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== undefined && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === undefined) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== undefined && !isObject2(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode2(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions4 = validate_crit_default(JWSInvalid, new Map([["b64", true]]), options?.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions4.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms2 = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms2 && !algorithms2.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
    checkKeyTypeWithJwk(alg, key, "verify");
    if (isJWK(key)) {
      key = await importJWK(key, alg);
    }
  } else {
    checkKeyTypeWithJwk(alg, key, "verify");
  }
  const data = concat(encoder2.encode(jws.protected ?? ""), encoder2.encode("."), typeof jws.payload === "string" ? encoder2.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode2(jws.signature);
  } catch {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed;
  }
  let payload;
  if (b64) {
    try {
      payload = decode2(jws.payload);
    } catch {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder2.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== undefined) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== undefined) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}

// ../../node_modules/jose/dist/browser/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}

// ../../node_modules/jose/dist/browser/lib/epoch.js
var epoch_default = (date) => Math.floor(date.getTime() / 1000);

// ../../node_modules/jose/dist/browser/lib/secs.js
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;
var REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
var secs_default = (str) => {
  const matched = REGEX.exec(str);
  if (!matched || matched[4] && matched[1]) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[2]);
  const unit = matched[3].toLowerCase();
  let numericDate;
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      numericDate = Math.round(value);
      break;
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      numericDate = Math.round(value * minute);
      break;
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      numericDate = Math.round(value * hour);
      break;
    case "day":
    case "days":
    case "d":
      numericDate = Math.round(value * day);
      break;
    case "week":
    case "weeks":
    case "w":
      numericDate = Math.round(value * week);
      break;
    default:
      numericDate = Math.round(value * year);
      break;
  }
  if (matched[1] === "-" || matched[4] === "ago") {
    return -numericDate;
  }
  return numericDate;
};

// ../../node_modules/jose/dist/browser/lib/jwt_claims_set.js
var normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
var checkAudiencePresence = (audPayload, audOption) => {
  if (typeof audPayload === "string") {
    return audOption.includes(audPayload);
  }
  if (Array.isArray(audPayload)) {
    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
  }
  return false;
};
var jwt_claims_set_default = (protectedHeader, encodedPayload, options = {}) => {
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch {
  }
  if (!isObject2(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', payload, "typ", "check_failed");
  }
  const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
  const presenceCheck = [...requiredClaims];
  if (maxTokenAge !== undefined)
    presenceCheck.push("iat");
  if (audience !== undefined)
    presenceCheck.push("aud");
  if (subject !== undefined)
    presenceCheck.push("sub");
  if (issuer !== undefined)
    presenceCheck.push("iss");
  for (const claim of new Set(presenceCheck.reverse())) {
    if (!(claim in payload)) {
      throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, payload, claim, "missing");
    }
  }
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', payload, "iss", "check_failed");
  }
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', payload, "sub", "check_failed");
  }
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', payload, "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs_default(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now = epoch_default(currentDate || new Date);
  if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== "number") {
    throw new JWTClaimValidationFailed('"iat" claim must be a number', payload, "iat", "invalid");
  }
  if (payload.nbf !== undefined) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', payload, "nbf", "invalid");
    }
    if (payload.nbf > now + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', payload, "nbf", "check_failed");
    }
  }
  if (payload.exp !== undefined) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', payload, "exp", "invalid");
    }
    if (payload.exp <= now - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', payload, "exp", "check_failed");
    }
  }
  if (maxTokenAge) {
    const age = now - payload.iat;
    const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
    if (age - tolerance > max) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', payload, "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', payload, "iat", "check_failed");
    }
  }
  return payload;
};

// ../../node_modules/jose/dist/browser/jwt/verify.js
async function jwtVerify(jwt, key, options) {
  const verified = await compactVerify(jwt, key, options);
  if (verified.protectedHeader.crit?.includes("b64") && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
// src/utils/token-factory.ts
var ACCESS_TOKEN_SECRET_ENCODED = new TextEncoder().encode(process.env.ACCESS_TOKEN_SECRET ?? "");
var REFRESH_TOKEN_SECRET_ENCODED = new TextEncoder().encode(process.env.REFRESH_TOKEN_SECRET ?? "");
async function verifyToken(token, secret = ACCESS_TOKEN_SECRET_ENCODED) {
  try {
    if (tokenInvalidator.isInvalid(token)) {
      return { valid: false, payload: null };
    }
    const jwt = await jwtVerify(token, secret);
    if (!("id" in jwt.payload) && !("providerId" in jwt.payload)) {
      return { valid: false, payload: null };
    }
    return { valid: true, payload: jwt.payload };
  } catch (e4) {
    return { valid: false, payload: null };
  }
}

// src/utils/gateway-utils.ts
function dispatchToTopic(topics, t4, d4) {
  const data = { op: 0 /* DISPATCH */, t: t4, d: d4, s: 0 };
  logGatewaySend(topics, data, false);
  if (Array.isArray(topics)) {
    for (const topic of topics) {
      gateway.sendToTopic(topic, data);
    }
  } else {
    gateway.sendToTopic(topics, data);
  }
}
function validateGatewayData(data) {
  if (data && typeof data === "object") {
    return "op" in data;
  }
  return false;
}

// src/gateway/client-session.ts
import { EventEmitter } from "events";
class ClientSession extends EventEmitter {
  data;
  peer;
  sentMessages;
  subscribedTopics;
  hearbeatTimeout;
  sequence;
  constructor(peer) {
    super();
    this.peer = peer;
    this.sentMessages = new Map;
    this.subscribedTopics = new Set;
    this.startHeartbeatTimeout();
  }
  async initialize(data) {
    this.data = data;
    await this.subscribeClientEvents();
    if (!this.hearbeatTimeout) {
      this.startHeartbeatTimeout();
    }
  }
  resetTimeout() {
    clearTimeout(this.hearbeatTimeout);
    this.startHeartbeatTimeout();
  }
  dispose() {
    clearTimeout(this.hearbeatTimeout);
    this.removeAllListeners();
  }
  subscribe(topic) {
    if (!this.isSubscribed(topic)) {
      this.subscribedTopics.add(topic);
    }
  }
  unsubscribe(topic) {
    if (this.isSubscribed(topic)) {
      this.subscribedTopics.delete(topic);
    }
  }
  isSubscribed(topic) {
    return this.subscribedTopics.has(topic);
  }
  increaseSequence() {
    this.sequence = this.sequence !== undefined ? this.sequence + 1 : 0;
    return this.sequence;
  }
  addMessage(data) {
    this.sentMessages.set(data.s, data);
  }
  getMessages() {
    return this.sentMessages;
  }
  getSubscriptions() {
    return this.subscribedTopics;
  }
  async subscribeClientEvents() {
    if (!this.data) {
      throw new Error("Client session was not initialized");
    }
    const userId = this.data.user.id;
    this.subscribe(userId);
    const relationships = idFix(await prisma.relationship.getUserRelationships(userId, { select: { ...selectRelationshipUser, type: true } }));
    const channels = idFix(await prisma.channel.getUserChannels(userId, true, {
      select: { ...merge(selectChannelRecipients, omitChannelRecipient(userId)), id: true }
    }));
    const publicUserIds = [...new Set([...relationships.map((x4) => x4.user.id), ...channels.flatMap((x4) => x4.recipients).map((x4) => x4.id)])];
    const presenceUserIds = [...new Set([...relationships.filter((x4) => x4.type === 1 /* FRIEND */).map((x4) => x4.user.id)])];
    for (const channel of channels) {
      this.subscribe(channel.id);
    }
    for (const userId2 of publicUserIds) {
      this.subscribe(`${userId2}_public`);
    }
    for (const userId2 of presenceUserIds) {
      this.subscribe(`${userId2}_presence`);
    }
  }
  startHeartbeatTimeout() {
    const tolerance = 3000;
    this.hearbeatTimeout = setTimeout(() => {
      this.emit("timeout", this.data);
      this.dispose();
      this.peer.close(4007 /* SESSION_TIMEOUT */, "SESSION_TIMEOUT");
    }, constants.HEARTBEAT_INTERVAL + tolerance);
  }
}

// src/gateway/presence-manager.ts
class PresenceManager {
  presences;
  constructor() {
    this.presences = new Map;
  }
  setClient(user, session, settings) {
    const isOfficialClient = session.data?.browser === "Huginn Client";
    const presence = {
      user: pick(user, ["id", "avatar", "displayName", "flags", "username"]),
      status: settings.status,
      clientStatus: { desktop: isOfficialClient ? settings.status : undefined, web: !isOfficialClient ? settings.status : undefined }
    };
    const existing = this.presences.get(user.id);
    this.presences.set(user.id, existing ? { ...presence, clientStatus: { ...existing.clientStatus, ...presence.clientStatus } } : presence);
    dispatchToTopic(`${user.id}_presence`, "presence_update", presence);
  }
  updateClientUser(user) {
    const existing = this.presences.get(user.id);
    if (existing) {
      this.presences.set(user.id, { ...existing, user: pick(user, ["id", "avatar", "displayName", "flags", "username"]) });
    }
  }
  removeClient(userId) {
    dispatchToTopic(`${userId}_presence`, "presence_update", { user: { id: userId }, status: "offline" });
    this.presences.delete(userId);
  }
  getUserPresences(session) {
    const subscriptions = session.getSubscriptions();
    const presences = [];
    for (const [id, presence] of this.presences) {
      if (subscriptions.has(`${id}_presence`)) {
        presences.push(presence);
      }
    }
    return presences;
  }
  getClient(userId) {
    return this.presences.get(userId);
  }
  sendToUser(userId, userIdToSend, offlineStatus) {
    const presence = offlineStatus ? { user: { id: userIdToSend }, status: "offline" } : this.presences.get(userIdToSend);
    if (presence) {
      dispatchToTopic(userId, "presence_update", presence);
    }
  }
}

// src/gateway/server-gateway.ts
class ServerGateway {
  options;
  clients;
  cancelledClientDisconnects;
  presenceManeger;
  constructor(options) {
    this.options = options;
    this.clients = new Map;
    this.presenceManeger = new PresenceManager;
    this.cancelledClientDisconnects = [];
  }
  open(peer) {
    try {
      logGatewayOpen();
      const client2 = new ClientSession(peer);
      this.clients.set(peer.id, client2);
      const helloData = { op: 10 /* HELLO */, d: { heartbeatInterval: constants.HEARTBEAT_INTERVAL, peerId: peer.id } };
      this.send(peer, helloData);
    } catch (e4) {
      peer.close(4000 /* UNKNOWN */, "UNKNOWN");
    }
  }
  async close(peer, event) {
    this.deleteUninitializedClient(peer.id);
    const client2 = this.getSessionByPeerId(peer.id);
    if (client2?.data) {
      this.presenceManeger.removeClient(client2.data.user.id);
    }
    client2?.dispose();
    if (client2?.data && event.code === 4009 /* INVALID_SESSION */) {
      this.clients.delete(client2.data.sessionId);
    } else if (client2?.data) {
      this.queueClientDisconnect(client2.data.sessionId);
    }
    logGatewayClose(event.code || 0, event.reason || "");
  }
  async message(peer, message2) {
    try {
      const data = message2.json();
      if (!validateGatewayData(data)) {
        peer.close(4002 /* DECODE_ERROR */, "DECODE_ERROR");
        return;
      }
      const session = this.getSessionByPeerId(peer.id);
      logGatewayRecieve(session?.data?.sessionId ?? peer.id, data, this.options.logHeartbeat);
      if (isOpcode(data, 2 /* IDENTIFY */)) {
        await this.handleIdentify(peer, data);
      } else if (isOpcode(data, 6 /* RESUME */)) {
        this.handleResume(peer, data);
      } else if (isOpcode(data, 1 /* HEARTBEAT */)) {
        this.handleHeartbeat(peer, data);
      } else if (!session?.data) {
        peer.close(4003 /* NOT_AUTHENTICATED */, "NOT_AUTHENTICATED");
        return;
      } else {
        peer.close(4001 /* UNKNOWN_OPCODE */, "UNKNOWN_OPCODE");
      }
    } catch (e4) {
      if (e4 instanceof SyntaxError) {
        peer.close(4002 /* DECODE_ERROR */, "DECODE_ERROR");
        return;
      }
      logServerError("/gateway", e4);
      peer.close(4000 /* UNKNOWN */, "UNKNOWN");
    }
  }
  subscribeSessionsToTopic(userId, topic) {
    const sessions = Array.from(this.clients.entries()).filter((x4) => x4[1].data?.user.id === userId).map((x4) => x4[1]);
    for (const session of sessions) {
      session.subscribe(topic);
    }
  }
  unsubscribeSessionsFromTopic(userId, topic) {
    const sessions = Array.from(this.clients.entries()).filter((x4) => x4[1].data?.user.id === userId).map((x4) => x4[1]);
    for (const session of sessions) {
      session.unsubscribe(topic);
    }
  }
  getSessionsCount() {
    return this.clients.size;
  }
  getSessionByPeerId(peerId) {
    for (const [_sessionId, client2] of this.clients) {
      if (client2.peer.id === peerId) {
        return client2;
      }
    }
  }
  getSessionByKey(key) {
    return this.clients.get(key);
  }
  sendToTopic(topic, data) {
    for (const client2 of this.clients.values()) {
      if (client2.isSubscribed(topic)) {
        const newData = { ...data, s: client2.increaseSequence() };
        client2.addMessage(newData);
        client2.peer.send(JSON.stringify(newData));
      }
    }
  }
  handleHeartbeat(peer, data) {
    const client2 = this.getSessionByPeerId(peer.id);
    client2?.resetTimeout();
    const hearbeatAckData = { op: 11 /* HEARTBEAT_ACK */ };
    this.send(peer, hearbeatAckData);
  }
  async handleIdentify(peer, data) {
    const { valid, payload } = await verifyToken(data.d.token);
    if (!valid || !payload) {
      peer.close(4004 /* AUTHENTICATION_FAILED */, "AUTHENTICATION_FAILED");
      return;
    }
    if (this.getSessionByPeerId(peer.id) && !this.clients.get(peer.id)) {
      peer.close(4005 /* ALREADY_AUTHENTICATED */, "ALREADY_AUTHENTICATED");
      return;
    }
    const user = idFix(await prisma.user.getById(payload.id, { select: selectPrivateUser }));
    const sessionId = snowflake.generateString(4 /* GATEWAY */);
    this.deleteUninitializedClient(peer.id);
    const client2 = new ClientSession(peer);
    await client2.initialize({ user, sessionId, ...data.d.properties });
    this.clients.set(sessionId, client2);
    const userRelationships = idFix(await prisma.relationship.getUserRelationships(user.id, { include: selectRelationshipUser, omit: omitRelationshipUserIds }));
    const userChannels = idFix(await prisma.channel.getUserChannels(user.id, false, { include: merge(selectChannelRecipients, omitChannelRecipient(user.id)) }));
    const presences = this.presenceManeger.getUserPresences(client2);
    const dbReadStates = idFix(await prisma.readState.getUserStates(user.id));
    const finalReadStates = [];
    for (const readState of dbReadStates) {
      finalReadStates.push({
        channelId: readState.channelId,
        lastReadMessageId: readState.lastReadMessageId,
        unreadCount: await prisma.readState.countUnreadMessages(readState.userId, readState.channelId)
      });
    }
    const settings = { status: "online" };
    const readyData = {
      op: 0 /* DISPATCH */,
      d: {
        user,
        sessionId,
        privateChannels: userChannels,
        relationships: userRelationships,
        userSettings: settings,
        presences,
        readStates: finalReadStates
      },
      t: "ready",
      s: client2.increaseSequence()
    };
    this.send(peer, readyData);
    this.presenceManeger.setClient(user, client2, settings);
  }
  async handleResume(peer, data) {
    const { valid, payload } = await verifyToken(data.d.token);
    if (!valid || !payload) {
      peer.close(4004 /* AUTHENTICATION_FAILED */, "AUTHENTICATION_FAILED");
      return;
    }
    if (!this.clients.has(data.d.sessionId)) {
      peer.close(4009 /* INVALID_SESSION */, "INVALID_SESSION");
      return;
    }
    const client2 = this.clients.get(data.d.sessionId);
    if (!client2) {
      throw new Error("client was null in handleResume");
    }
    if (client2.sequence === undefined || data.d.seq > client2.sequence) {
      peer.close(4006 /* INVALID_SEQ */, "INVALID_SEQ");
      return;
    }
    const user = idFix(await prisma.user.getById(payload.id, { select: { id: true } }));
    this.deleteUninitializedClient(peer.id);
    client2.peer = peer;
    client2.initialize(client2.data);
    this.cancelledClientDisconnects.push(data.d.sessionId);
    const messageQueue = client2.getMessages();
    for (const [seq, _data3] of messageQueue) {
      if (seq <= data.d.seq) {
        continue;
      }
      this.send(peer, _data3);
    }
    const resumedData = {
      t: "resumed",
      op: 0 /* DISPATCH */,
      d: undefined,
      s: client2.increaseSequence()
    };
    this.send(peer, resumedData);
    this.presenceManeger.setClient(user, client2, { status: "online" });
  }
  deleteUninitializedClient(peerId) {
    const uninitializedClient = this.clients.get(peerId);
    uninitializedClient?.dispose();
    this.clients.delete(peerId);
  }
  queueClientDisconnect(sessionId) {
    setTimeout(() => {
      if (this.cancelledClientDisconnects.includes(sessionId)) {
        this.cancelledClientDisconnects = this.cancelledClientDisconnects.filter((x4) => x4 !== sessionId);
        return;
      }
      this.clients.delete(sessionId);
    }, 1000 * 60);
  }
  send(peer, data) {
    logGatewaySend(peer.id, data, this.options.logHeartbeat);
    peer.send(JSON.stringify(data));
  }
}

// src/utils/token-invalidator.ts
class TokenInvalidator {
  invalidTokens = [];
  invalidate(token) {
    if (!this.invalidTokens.includes(token)) {
      this.invalidTokens.push(token);
    }
  }
  isInvalid(token) {
    return this.invalidTokens.includes(token);
  }
}

// src/setup.ts
var envs = readEnv([
  "ACCESS_TOKEN_SECRET",
  "REFRESH_TOKEN_SECRET",
  "POSTGRESQL_URL",
  "CDN_ROOT",
  "SERVER_HOST",
  "SERVER_PORT",
  "GITHUB_TOKEN",
  { key: "REPO_OWNER", default: "WerdoxDev" },
  { key: "REPO", default: "Huginn" },
  "AWS_REGION",
  "AWS_KEY_ID",
  "AWS_SECRET_KEY",
  "AWS_BUCKET",
  "AWS_VERSIONS_OBJECT_KEY",
  "PASSPHRASE",
  "CERTIFICATE_PATH",
  "PRIVATE_KEY_PATH",
  "GOOGLE_CLIENT_ID",
  "GOOGLE_CLIENT_SECRET",
  "SESSION_PASSWORD",
  "ALLOWED_ORIGINS",
  "REDIRECT_HOST"
]);
var CERT_FILE = envs.CERTIFICATE_PATH && Bun.file(envs.CERTIFICATE_PATH);
var KEY_FILE = envs.PRIVATE_KEY_PATH && Bun.file(envs.PRIVATE_KEY_PATH);
if (!envs.POSTGRESQL_URL) {
  consola.error("Database config is not set correctly!");
  process.exit();
}
var gateway = new ServerGateway({ logHeartbeat: false });
var tokenInvalidator = new TokenInvalidator;
var s32 = new S3Client({
  region: envs.AWS_REGION,
  credentials: { accessKeyId: envs.AWS_KEY_ID ?? "", secretAccessKey: envs.AWS_SECRET_KEY ?? "" }
});

// src/routes/gateway.ts
var ws = bun({
  hooks: {
    open: gateway.open.bind(gateway),
    close: gateway.close.bind(gateway),
    message: gateway.message.bind(gateway)
  }
});

// src/index.ts
var store = new CookieStore_default;
appInstance.notFound((c5) => {
  return notFound(c5);
});
appInstance.onError((error2, c5) => {
  const returnedError = serverOnError(error2, c5);
  if (returnedError) {
    return returnedError;
  }
  return handleServerError(error2, c5);
});
appInstance.all("*", sessionMiddleware({
  store,
  encryptionKey: envs.SESSION_PASSWORD,
  expireAfterSeconds: 900,
  cookieOptions: { sameSite: "Lax", path: "/", httpOnly: true }
}));
appInstance.use("*", createMiddleware(async (c5, next) => {
  await sharedOnRequest(c5);
  await next();
  if (!c5.error) {
    await sharedOnAfterResponse(c5);
  }
}));
await importRoutes();
appInstance.use("*", serveStatic2({ root: "./src/static" }));
console.log("ROUTES", appInstance.routes);
showRoutes(appInstance, { colorize: true, verbose: false });
if (!process.env.test) {
  Bun.serve({
    websocket: ws.websocket,
    fetch(req, server) {
      if (req.headers.get("upgrade") === "websocket") {
        return ws.handleUpgrade(req, server);
      }
      return appInstance.fetch(req, server);
    },
    hostname: envs.SERVER_HOST,
    port: envs.SERVER_PORT
  });
}
